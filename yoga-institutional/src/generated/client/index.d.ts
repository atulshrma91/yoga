
/**
 * Client
**/

import * as runtime from './runtime/index';
declare const prisma: unique symbol
export interface PrismaPromise<A> extends Promise<A> {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model SequelizeData
 * 
 */
export type SequelizeData = {
  name: string
}

/**
 * Model SequelizeMeta
 * 
 */
export type SequelizeMeta = {
  name: string
}

/**
 * Model assets
 * 
 */
export type assets = {
  id: number
  name: string
  description: string
  baseNetworkId: number | null
  type: enum_assets_type
  ticker: string
  fireblocksTicker: string | null
  enabled: boolean
  createdAt: Date
  updatedAt: Date
}

/**
 * Model baseNetworks
 * 
 */
export type baseNetworks = {
  id: number
  name: string
  addressUrl: string
  feeAssetId: number | null
  txUrl: string
  enabled: boolean
  baseBps: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model quotes
 * 
 */
export type quotes = {
  id: string
  quoteStatusId: number
  sourceAssetId: number
  targetAssetId: number
  side: enum_quotes_side
  userId: string
  vendorId: number | null
  extraData: Prisma.JsonValue | null
  error: Prisma.JsonValue | null
  createdAt: Date
  updatedAt: Date
  fxRequestID: string | null
  buyPrice: string
  sellPrice: string
  quantity: string
}

/**
 * Model transactionStatusTypes
 * 
 */
export type transactionStatusTypes = {
  id: number
  name: string
  description: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model transactionTypes
 * 
 */
export type transactionTypes = {
  id: number
  name: string
  description: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model transactions
 * 
 */
export type transactions = {
  id: string
  custodyVendorId: number
  custodyVendorRef: string
  transactionTypeId: number
  amountAsset: string
  amountUSD: string
  assetId: number
  transactionStatusTypeId: number
  onChainTxId: string | null
  sourceVaultId: string | null
  targetVaultId: string | null
  targetWithdrawalAddressId: string | null
  sourceExternalAddress: string | null
  createdByUserId: string | null
  subjectId: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model users
 * 
 */
export type users = {
  id: string
  organizationId: number
  userTypeId: number
  primaryEmail: string
  firstName: string
  lastName: string | null
  createdAt: Date
  updatedAt: Date
  publicKey: string | null
  apiKey: string | null
}

/**
 * Model vendorTypes
 * 
 */
export type vendorTypes = {
  id: number
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model vendors
 * 
 */
export type vendors = {
  id: number
  name: string
  identifier: string
  vendorTypeId: number
  quoteEngineBaseBps: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model custodyEngineEventTypes
 * 
 */
export type custodyEngineEventTypes = {
  id: number
  name: string
  description: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model custodyEngineEvents
 * 
 */
export type custodyEngineEvents = {
  id: string
  organizationId: number
  custodyEngineEventTypeId: number
  event: Prisma.JsonValue
  createdAt: Date
  updatedAt: Date
}

/**
 * Model custodyVendorVaultAssets
 * 
 */
export type custodyVendorVaultAssets = {
  id: number
  vendorId: number
  vendorRef: string
  balance: string
  vaultAssetId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model depositAddressStatusTypes
 * 
 */
export type depositAddressStatusTypes = {
  id: number
  name: string
  description: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model depositAddresses
 * 
 */
export type depositAddresses = {
  id: string
  vaultAssetId: number
  address: string
  depositAddressStatusId: number | null
  vendorId: number | null
  vendorRef: string
  subjectId: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model institutionalProducts
 * 
 */
export type institutionalProducts = {
  id: string
  name: string
  enabled: boolean
  createdAt: Date
  updatedAt: Date
}

/**
 * Model orders
 * 
 */
export type orders = {
  id: string
  quoteId: string
  orderStatus: string | null
  userAcceptedPrice: string
  userAcceptedQuantity: string
  userAcceptedSide: enum_orders_userAcceptedSide
  userAcceptedTradePair: Prisma.JsonValue
  userAcceptedTimestamp: Date
  orderType: enum_orders_orderType | null
  orderTimeInForce: string | null
  vendorQuoteId: string | null
  vendorQuantityRequested: string | null
  vendorPriceRequested: string | null
  orderQuantityExecuted: string | null
  orderPriceExecuted: string | null
  orderTimestampExecuted: Date | null
  orderVendorStatus: string | null
  allowedSlippage: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model organizationStatusTypes
 * 
 */
export type organizationStatusTypes = {
  id: number
  name: string
  description: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model organizations
 * 
 */
export type organizations = {
  id: number
  name: string
  primaryEmail: string
  pricingPlanId: number
  statusId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model pricingPlanProfiles
 * 
 */
export type pricingPlanProfiles = {
  id: number
  name: string
  quoteEngineRps: number
  custodyEngineRps: number
  numberOfUsers: number
  sla: number
  rbac: boolean
  quoteEngineClaims: Prisma.JsonValue
  createdAt: Date
  updatedAt: Date
}

/**
 * Model pricingPlanSupportsAssets
 * 
 */
export type pricingPlanSupportsAssets = {
  id: number
  vendorSupportsAssetId: number
  pricingPlanId: number
  enabled: boolean
  buyBps: number
  sellBps: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model pricingPlans
 * 
 */
export type pricingPlans = {
  id: number
  price: number
  active: boolean
  pricingPlanProfileId: number
  createdAt: Date
  updatedAt: Date
}

/**
 * Model quoteStatuses
 * 
 */
export type quoteStatuses = {
  id: number
  name: string
  description: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model tokenPairs
 * 
 */
export type tokenPairs = {
  id: number
  baseToken: string
  quoteToken: string
  createdAt: Date
  updatedAt: Date
  vendorId: number
}

/**
 * Model tokenPairsInfo
 * 
 */
export type tokenPairsInfo = {
  id: number
  tokenPairId: number
  fxRequestID: string
  quantity: Prisma.JsonValue
  createdAt: Date
  updatedAt: Date
}

/**
 * Model transactionPolicies
 * 
 */
export type transactionPolicies = {
  id: string
  userId: string
  transactionTypeId: number
  sourceVaultId: string
  targetVaultId: string | null
  targetWithdrawalAddressId: string | null
  toOneTimeAddresses: boolean | null
  greaterThanUSD: string
  assetId: number
  action: enum_transactionPolicies_action
  createdAt: Date
  updatedAt: Date
}

/**
 * Model userTypes
 * 
 */
export type userTypes = {
  id: number
  name: string
  description: string
  claims: Prisma.JsonValue
  isServiceAccount: boolean
  createdAt: Date
  updatedAt: Date
}

/**
 * Model vaultAssets
 * 
 */
export type vaultAssets = {
  id: number
  vaultId: string
  assetId: number
  balance: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model vaultStatusTypes
 * 
 */
export type vaultStatusTypes = {
  id: number
  name: string
  description: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model vaults
 * 
 */
export type vaults = {
  id: string
  createdByUserId: string
  vaultStatusId: number | null
  vaultName: string | null
  subjectId: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model vendorSupportsAssets
 * 
 */
export type vendorSupportsAssets = {
  id: number
  assetId: number
  vendorId: number
  enabled: boolean | null
  createdAt: Date
  updatedAt: Date
  theirId: string | null
}

/**
 * Model webhookRequests
 * 
 */
export type webhookRequests = {
  id: string
  webhookId: string
  institutionalProductId: string | null
  httpStatusCode: number
  requestPayload: Prisma.JsonValue
  responsePayload: Prisma.JsonValue | null
  custodyEngineEventId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model webhookStatusTypes
 * 
 */
export type webhookStatusTypes = {
  id: number
  name: string
  description: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model webhooks
 * 
 */
export type webhooks = {
  id: string
  organizationId: number
  webhookStatusTypeId: number
  url: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model withdrawalAddresses
 * 
 */
export type withdrawalAddresses = {
  id: string
  organizationId: number
  assetId: number
  nickname: string | null
  address: string
  subjectId: string
  createdAt: Date
  updatedAt: Date
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const enum_assets_type: {
  crypto: 'crypto',
  fiat: 'fiat'
};

export type enum_assets_type = (typeof enum_assets_type)[keyof typeof enum_assets_type]


export const enum_orders_orderType: {
  GTC: 'GTC',
  GTX: 'GTX',
  FOK: 'FOK',
  LIMIT: 'LIMIT',
  MARKET: 'MARKET'
};

export type enum_orders_orderType = (typeof enum_orders_orderType)[keyof typeof enum_orders_orderType]


export const enum_orders_userAcceptedSide: {
  BUY: 'BUY',
  SELL: 'SELL',
  INFO: 'INFO',
  SWAP: 'SWAP'
};

export type enum_orders_userAcceptedSide = (typeof enum_orders_userAcceptedSide)[keyof typeof enum_orders_userAcceptedSide]


export const enum_quotes_side: {
  BUY: 'BUY',
  SELL: 'SELL',
  INFO: 'INFO',
  SWAP: 'SWAP'
};

export type enum_quotes_side = (typeof enum_quotes_side)[keyof typeof enum_quotes_side]


export const enum_transactionPolicies_action: {
  allow: 'allow',
  deny: 'deny'
};

export type enum_transactionPolicies_action = (typeof enum_transactionPolicies_action)[keyof typeof enum_transactionPolicies_action]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more SequelizeData
 * const sequelizeData = await prisma.sequelizeData.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more SequelizeData
   * const sequelizeData = await prisma.sequelizeData.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Prisma.TransactionClient) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.sequelizeData`: Exposes CRUD operations for the **SequelizeData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SequelizeData
    * const sequelizeData = await prisma.sequelizeData.findMany()
    * ```
    */
  get sequelizeData(): Prisma.SequelizeDataDelegate<GlobalReject>;

  /**
   * `prisma.sequelizeMeta`: Exposes CRUD operations for the **SequelizeMeta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SequelizeMetas
    * const sequelizeMetas = await prisma.sequelizeMeta.findMany()
    * ```
    */
  get sequelizeMeta(): Prisma.SequelizeMetaDelegate<GlobalReject>;

  /**
   * `prisma.assets`: Exposes CRUD operations for the **assets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assets
    * const assets = await prisma.assets.findMany()
    * ```
    */
  get assets(): Prisma.assetsDelegate<GlobalReject>;

  /**
   * `prisma.baseNetworks`: Exposes CRUD operations for the **baseNetworks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BaseNetworks
    * const baseNetworks = await prisma.baseNetworks.findMany()
    * ```
    */
  get baseNetworks(): Prisma.baseNetworksDelegate<GlobalReject>;

  /**
   * `prisma.quotes`: Exposes CRUD operations for the **quotes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quotes
    * const quotes = await prisma.quotes.findMany()
    * ```
    */
  get quotes(): Prisma.quotesDelegate<GlobalReject>;

  /**
   * `prisma.transactionStatusTypes`: Exposes CRUD operations for the **transactionStatusTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionStatusTypes
    * const transactionStatusTypes = await prisma.transactionStatusTypes.findMany()
    * ```
    */
  get transactionStatusTypes(): Prisma.transactionStatusTypesDelegate<GlobalReject>;

  /**
   * `prisma.transactionTypes`: Exposes CRUD operations for the **transactionTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionTypes
    * const transactionTypes = await prisma.transactionTypes.findMany()
    * ```
    */
  get transactionTypes(): Prisma.transactionTypesDelegate<GlobalReject>;

  /**
   * `prisma.transactions`: Exposes CRUD operations for the **transactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transactions.findMany()
    * ```
    */
  get transactions(): Prisma.transactionsDelegate<GlobalReject>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<GlobalReject>;

  /**
   * `prisma.vendorTypes`: Exposes CRUD operations for the **vendorTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorTypes
    * const vendorTypes = await prisma.vendorTypes.findMany()
    * ```
    */
  get vendorTypes(): Prisma.vendorTypesDelegate<GlobalReject>;

  /**
   * `prisma.vendors`: Exposes CRUD operations for the **vendors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendors
    * const vendors = await prisma.vendors.findMany()
    * ```
    */
  get vendors(): Prisma.vendorsDelegate<GlobalReject>;

  /**
   * `prisma.custodyEngineEventTypes`: Exposes CRUD operations for the **custodyEngineEventTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustodyEngineEventTypes
    * const custodyEngineEventTypes = await prisma.custodyEngineEventTypes.findMany()
    * ```
    */
  get custodyEngineEventTypes(): Prisma.custodyEngineEventTypesDelegate<GlobalReject>;

  /**
   * `prisma.custodyEngineEvents`: Exposes CRUD operations for the **custodyEngineEvents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustodyEngineEvents
    * const custodyEngineEvents = await prisma.custodyEngineEvents.findMany()
    * ```
    */
  get custodyEngineEvents(): Prisma.custodyEngineEventsDelegate<GlobalReject>;

  /**
   * `prisma.custodyVendorVaultAssets`: Exposes CRUD operations for the **custodyVendorVaultAssets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustodyVendorVaultAssets
    * const custodyVendorVaultAssets = await prisma.custodyVendorVaultAssets.findMany()
    * ```
    */
  get custodyVendorVaultAssets(): Prisma.custodyVendorVaultAssetsDelegate<GlobalReject>;

  /**
   * `prisma.depositAddressStatusTypes`: Exposes CRUD operations for the **depositAddressStatusTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DepositAddressStatusTypes
    * const depositAddressStatusTypes = await prisma.depositAddressStatusTypes.findMany()
    * ```
    */
  get depositAddressStatusTypes(): Prisma.depositAddressStatusTypesDelegate<GlobalReject>;

  /**
   * `prisma.depositAddresses`: Exposes CRUD operations for the **depositAddresses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DepositAddresses
    * const depositAddresses = await prisma.depositAddresses.findMany()
    * ```
    */
  get depositAddresses(): Prisma.depositAddressesDelegate<GlobalReject>;

  /**
   * `prisma.institutionalProducts`: Exposes CRUD operations for the **institutionalProducts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InstitutionalProducts
    * const institutionalProducts = await prisma.institutionalProducts.findMany()
    * ```
    */
  get institutionalProducts(): Prisma.institutionalProductsDelegate<GlobalReject>;

  /**
   * `prisma.orders`: Exposes CRUD operations for the **orders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.orders.findMany()
    * ```
    */
  get orders(): Prisma.ordersDelegate<GlobalReject>;

  /**
   * `prisma.organizationStatusTypes`: Exposes CRUD operations for the **organizationStatusTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganizationStatusTypes
    * const organizationStatusTypes = await prisma.organizationStatusTypes.findMany()
    * ```
    */
  get organizationStatusTypes(): Prisma.organizationStatusTypesDelegate<GlobalReject>;

  /**
   * `prisma.organizations`: Exposes CRUD operations for the **organizations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organizations.findMany()
    * ```
    */
  get organizations(): Prisma.organizationsDelegate<GlobalReject>;

  /**
   * `prisma.pricingPlanProfiles`: Exposes CRUD operations for the **pricingPlanProfiles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PricingPlanProfiles
    * const pricingPlanProfiles = await prisma.pricingPlanProfiles.findMany()
    * ```
    */
  get pricingPlanProfiles(): Prisma.pricingPlanProfilesDelegate<GlobalReject>;

  /**
   * `prisma.pricingPlanSupportsAssets`: Exposes CRUD operations for the **pricingPlanSupportsAssets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PricingPlanSupportsAssets
    * const pricingPlanSupportsAssets = await prisma.pricingPlanSupportsAssets.findMany()
    * ```
    */
  get pricingPlanSupportsAssets(): Prisma.pricingPlanSupportsAssetsDelegate<GlobalReject>;

  /**
   * `prisma.pricingPlans`: Exposes CRUD operations for the **pricingPlans** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PricingPlans
    * const pricingPlans = await prisma.pricingPlans.findMany()
    * ```
    */
  get pricingPlans(): Prisma.pricingPlansDelegate<GlobalReject>;

  /**
   * `prisma.quoteStatuses`: Exposes CRUD operations for the **quoteStatuses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuoteStatuses
    * const quoteStatuses = await prisma.quoteStatuses.findMany()
    * ```
    */
  get quoteStatuses(): Prisma.quoteStatusesDelegate<GlobalReject>;

  /**
   * `prisma.tokenPairs`: Exposes CRUD operations for the **tokenPairs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TokenPairs
    * const tokenPairs = await prisma.tokenPairs.findMany()
    * ```
    */
  get tokenPairs(): Prisma.tokenPairsDelegate<GlobalReject>;

  /**
   * `prisma.tokenPairsInfo`: Exposes CRUD operations for the **tokenPairsInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TokenPairsInfos
    * const tokenPairsInfos = await prisma.tokenPairsInfo.findMany()
    * ```
    */
  get tokenPairsInfo(): Prisma.tokenPairsInfoDelegate<GlobalReject>;

  /**
   * `prisma.transactionPolicies`: Exposes CRUD operations for the **transactionPolicies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionPolicies
    * const transactionPolicies = await prisma.transactionPolicies.findMany()
    * ```
    */
  get transactionPolicies(): Prisma.transactionPoliciesDelegate<GlobalReject>;

  /**
   * `prisma.userTypes`: Exposes CRUD operations for the **userTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTypes
    * const userTypes = await prisma.userTypes.findMany()
    * ```
    */
  get userTypes(): Prisma.userTypesDelegate<GlobalReject>;

  /**
   * `prisma.vaultAssets`: Exposes CRUD operations for the **vaultAssets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VaultAssets
    * const vaultAssets = await prisma.vaultAssets.findMany()
    * ```
    */
  get vaultAssets(): Prisma.vaultAssetsDelegate<GlobalReject>;

  /**
   * `prisma.vaultStatusTypes`: Exposes CRUD operations for the **vaultStatusTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VaultStatusTypes
    * const vaultStatusTypes = await prisma.vaultStatusTypes.findMany()
    * ```
    */
  get vaultStatusTypes(): Prisma.vaultStatusTypesDelegate<GlobalReject>;

  /**
   * `prisma.vaults`: Exposes CRUD operations for the **vaults** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vaults
    * const vaults = await prisma.vaults.findMany()
    * ```
    */
  get vaults(): Prisma.vaultsDelegate<GlobalReject>;

  /**
   * `prisma.vendorSupportsAssets`: Exposes CRUD operations for the **vendorSupportsAssets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorSupportsAssets
    * const vendorSupportsAssets = await prisma.vendorSupportsAssets.findMany()
    * ```
    */
  get vendorSupportsAssets(): Prisma.vendorSupportsAssetsDelegate<GlobalReject>;

  /**
   * `prisma.webhookRequests`: Exposes CRUD operations for the **webhookRequests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookRequests
    * const webhookRequests = await prisma.webhookRequests.findMany()
    * ```
    */
  get webhookRequests(): Prisma.webhookRequestsDelegate<GlobalReject>;

  /**
   * `prisma.webhookStatusTypes`: Exposes CRUD operations for the **webhookStatusTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookStatusTypes
    * const webhookStatusTypes = await prisma.webhookStatusTypes.findMany()
    * ```
    */
  get webhookStatusTypes(): Prisma.webhookStatusTypesDelegate<GlobalReject>;

  /**
   * `prisma.webhooks`: Exposes CRUD operations for the **webhooks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Webhooks
    * const webhooks = await prisma.webhooks.findMany()
    * ```
    */
  get webhooks(): Prisma.webhooksDelegate<GlobalReject>;

  /**
   * `prisma.withdrawalAddresses`: Exposes CRUD operations for the **withdrawalAddresses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WithdrawalAddresses
    * const withdrawalAddresses = await prisma.withdrawalAddresses.findMany()
    * ```
    */
  get withdrawalAddresses(): Prisma.withdrawalAddressesDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.9.0
   * Query Engine version: ceb5c99003b99c9ee2c1d2e618e359c14aef2ea5
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    SequelizeData: 'SequelizeData',
    SequelizeMeta: 'SequelizeMeta',
    assets: 'assets',
    baseNetworks: 'baseNetworks',
    quotes: 'quotes',
    transactionStatusTypes: 'transactionStatusTypes',
    transactionTypes: 'transactionTypes',
    transactions: 'transactions',
    users: 'users',
    vendorTypes: 'vendorTypes',
    vendors: 'vendors',
    custodyEngineEventTypes: 'custodyEngineEventTypes',
    custodyEngineEvents: 'custodyEngineEvents',
    custodyVendorVaultAssets: 'custodyVendorVaultAssets',
    depositAddressStatusTypes: 'depositAddressStatusTypes',
    depositAddresses: 'depositAddresses',
    institutionalProducts: 'institutionalProducts',
    orders: 'orders',
    organizationStatusTypes: 'organizationStatusTypes',
    organizations: 'organizations',
    pricingPlanProfiles: 'pricingPlanProfiles',
    pricingPlanSupportsAssets: 'pricingPlanSupportsAssets',
    pricingPlans: 'pricingPlans',
    quoteStatuses: 'quoteStatuses',
    tokenPairs: 'tokenPairs',
    tokenPairsInfo: 'tokenPairsInfo',
    transactionPolicies: 'transactionPolicies',
    userTypes: 'userTypes',
    vaultAssets: 'vaultAssets',
    vaultStatusTypes: 'vaultStatusTypes',
    vaults: 'vaults',
    vendorSupportsAssets: 'vendorSupportsAssets',
    webhookRequests: 'webhookRequests',
    webhookStatusTypes: 'webhookStatusTypes',
    webhooks: 'webhooks',
    withdrawalAddresses: 'withdrawalAddresses'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AssetsCountOutputType
   */


  export type AssetsCountOutputType = {
    quotes_quotes_sourceAssetIdToassets: number
    quotes_quotes_targetAssetIdToassets: number
    transactionPolicies: number
    transactions: number
    vaultAssets: number
    vendorSupportsAssets: number
    withdrawalAddresses: number
  }

  export type AssetsCountOutputTypeSelect = {
    quotes_quotes_sourceAssetIdToassets?: boolean
    quotes_quotes_targetAssetIdToassets?: boolean
    transactionPolicies?: boolean
    transactions?: boolean
    vaultAssets?: boolean
    vendorSupportsAssets?: boolean
    withdrawalAddresses?: boolean
  }

  export type AssetsCountOutputTypeGetPayload<S extends boolean | null | undefined | AssetsCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AssetsCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (AssetsCountOutputTypeArgs)
    ? AssetsCountOutputType 
    : S extends { select: any } & (AssetsCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof AssetsCountOutputType ? AssetsCountOutputType[P] : never
  } 
      : AssetsCountOutputType




  // Custom InputTypes

  /**
   * AssetsCountOutputType without action
   */
  export type AssetsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AssetsCountOutputType
     */
    select?: AssetsCountOutputTypeSelect | null
  }



  /**
   * Count Type BaseNetworksCountOutputType
   */


  export type BaseNetworksCountOutputType = {
    assets: number
  }

  export type BaseNetworksCountOutputTypeSelect = {
    assets?: boolean
  }

  export type BaseNetworksCountOutputTypeGetPayload<S extends boolean | null | undefined | BaseNetworksCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BaseNetworksCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BaseNetworksCountOutputTypeArgs)
    ? BaseNetworksCountOutputType 
    : S extends { select: any } & (BaseNetworksCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BaseNetworksCountOutputType ? BaseNetworksCountOutputType[P] : never
  } 
      : BaseNetworksCountOutputType




  // Custom InputTypes

  /**
   * BaseNetworksCountOutputType without action
   */
  export type BaseNetworksCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BaseNetworksCountOutputType
     */
    select?: BaseNetworksCountOutputTypeSelect | null
  }



  /**
   * Count Type QuotesCountOutputType
   */


  export type QuotesCountOutputType = {
    orders: number
  }

  export type QuotesCountOutputTypeSelect = {
    orders?: boolean
  }

  export type QuotesCountOutputTypeGetPayload<S extends boolean | null | undefined | QuotesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuotesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (QuotesCountOutputTypeArgs)
    ? QuotesCountOutputType 
    : S extends { select: any } & (QuotesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof QuotesCountOutputType ? QuotesCountOutputType[P] : never
  } 
      : QuotesCountOutputType




  // Custom InputTypes

  /**
   * QuotesCountOutputType without action
   */
  export type QuotesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the QuotesCountOutputType
     */
    select?: QuotesCountOutputTypeSelect | null
  }



  /**
   * Count Type TransactionStatusTypesCountOutputType
   */


  export type TransactionStatusTypesCountOutputType = {
    transactions: number
  }

  export type TransactionStatusTypesCountOutputTypeSelect = {
    transactions?: boolean
  }

  export type TransactionStatusTypesCountOutputTypeGetPayload<S extends boolean | null | undefined | TransactionStatusTypesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TransactionStatusTypesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TransactionStatusTypesCountOutputTypeArgs)
    ? TransactionStatusTypesCountOutputType 
    : S extends { select: any } & (TransactionStatusTypesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TransactionStatusTypesCountOutputType ? TransactionStatusTypesCountOutputType[P] : never
  } 
      : TransactionStatusTypesCountOutputType




  // Custom InputTypes

  /**
   * TransactionStatusTypesCountOutputType without action
   */
  export type TransactionStatusTypesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TransactionStatusTypesCountOutputType
     */
    select?: TransactionStatusTypesCountOutputTypeSelect | null
  }



  /**
   * Count Type TransactionTypesCountOutputType
   */


  export type TransactionTypesCountOutputType = {
    transactionPolicies: number
    transactions: number
  }

  export type TransactionTypesCountOutputTypeSelect = {
    transactionPolicies?: boolean
    transactions?: boolean
  }

  export type TransactionTypesCountOutputTypeGetPayload<S extends boolean | null | undefined | TransactionTypesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TransactionTypesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TransactionTypesCountOutputTypeArgs)
    ? TransactionTypesCountOutputType 
    : S extends { select: any } & (TransactionTypesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TransactionTypesCountOutputType ? TransactionTypesCountOutputType[P] : never
  } 
      : TransactionTypesCountOutputType




  // Custom InputTypes

  /**
   * TransactionTypesCountOutputType without action
   */
  export type TransactionTypesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TransactionTypesCountOutputType
     */
    select?: TransactionTypesCountOutputTypeSelect | null
  }



  /**
   * Count Type UsersCountOutputType
   */


  export type UsersCountOutputType = {
    transactionPolicies: number
    transactions: number
    vaults: number
  }

  export type UsersCountOutputTypeSelect = {
    transactionPolicies?: boolean
    transactions?: boolean
    vaults?: boolean
  }

  export type UsersCountOutputTypeGetPayload<S extends boolean | null | undefined | UsersCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UsersCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UsersCountOutputTypeArgs)
    ? UsersCountOutputType 
    : S extends { select: any } & (UsersCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UsersCountOutputType ? UsersCountOutputType[P] : never
  } 
      : UsersCountOutputType




  // Custom InputTypes

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect | null
  }



  /**
   * Count Type VendorTypesCountOutputType
   */


  export type VendorTypesCountOutputType = {
    vendors: number
  }

  export type VendorTypesCountOutputTypeSelect = {
    vendors?: boolean
  }

  export type VendorTypesCountOutputTypeGetPayload<S extends boolean | null | undefined | VendorTypesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? VendorTypesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (VendorTypesCountOutputTypeArgs)
    ? VendorTypesCountOutputType 
    : S extends { select: any } & (VendorTypesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof VendorTypesCountOutputType ? VendorTypesCountOutputType[P] : never
  } 
      : VendorTypesCountOutputType




  // Custom InputTypes

  /**
   * VendorTypesCountOutputType without action
   */
  export type VendorTypesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the VendorTypesCountOutputType
     */
    select?: VendorTypesCountOutputTypeSelect | null
  }



  /**
   * Count Type VendorsCountOutputType
   */


  export type VendorsCountOutputType = {
    custodyVendorVaultAssets: number
    depositAddresses: number
    quotes: number
    tokenPairs: number
    transactions: number
    vendorSupportsAssets: number
  }

  export type VendorsCountOutputTypeSelect = {
    custodyVendorVaultAssets?: boolean
    depositAddresses?: boolean
    quotes?: boolean
    tokenPairs?: boolean
    transactions?: boolean
    vendorSupportsAssets?: boolean
  }

  export type VendorsCountOutputTypeGetPayload<S extends boolean | null | undefined | VendorsCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? VendorsCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (VendorsCountOutputTypeArgs)
    ? VendorsCountOutputType 
    : S extends { select: any } & (VendorsCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof VendorsCountOutputType ? VendorsCountOutputType[P] : never
  } 
      : VendorsCountOutputType




  // Custom InputTypes

  /**
   * VendorsCountOutputType without action
   */
  export type VendorsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the VendorsCountOutputType
     */
    select?: VendorsCountOutputTypeSelect | null
  }



  /**
   * Count Type CustodyEngineEventTypesCountOutputType
   */


  export type CustodyEngineEventTypesCountOutputType = {
    custodyEngineEvents: number
  }

  export type CustodyEngineEventTypesCountOutputTypeSelect = {
    custodyEngineEvents?: boolean
  }

  export type CustodyEngineEventTypesCountOutputTypeGetPayload<S extends boolean | null | undefined | CustodyEngineEventTypesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CustodyEngineEventTypesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CustodyEngineEventTypesCountOutputTypeArgs)
    ? CustodyEngineEventTypesCountOutputType 
    : S extends { select: any } & (CustodyEngineEventTypesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CustodyEngineEventTypesCountOutputType ? CustodyEngineEventTypesCountOutputType[P] : never
  } 
      : CustodyEngineEventTypesCountOutputType




  // Custom InputTypes

  /**
   * CustodyEngineEventTypesCountOutputType without action
   */
  export type CustodyEngineEventTypesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CustodyEngineEventTypesCountOutputType
     */
    select?: CustodyEngineEventTypesCountOutputTypeSelect | null
  }



  /**
   * Count Type CustodyEngineEventsCountOutputType
   */


  export type CustodyEngineEventsCountOutputType = {
    webhookRequests: number
  }

  export type CustodyEngineEventsCountOutputTypeSelect = {
    webhookRequests?: boolean
  }

  export type CustodyEngineEventsCountOutputTypeGetPayload<S extends boolean | null | undefined | CustodyEngineEventsCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CustodyEngineEventsCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CustodyEngineEventsCountOutputTypeArgs)
    ? CustodyEngineEventsCountOutputType 
    : S extends { select: any } & (CustodyEngineEventsCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CustodyEngineEventsCountOutputType ? CustodyEngineEventsCountOutputType[P] : never
  } 
      : CustodyEngineEventsCountOutputType




  // Custom InputTypes

  /**
   * CustodyEngineEventsCountOutputType without action
   */
  export type CustodyEngineEventsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CustodyEngineEventsCountOutputType
     */
    select?: CustodyEngineEventsCountOutputTypeSelect | null
  }



  /**
   * Count Type InstitutionalProductsCountOutputType
   */


  export type InstitutionalProductsCountOutputType = {
    webhookRequests: number
  }

  export type InstitutionalProductsCountOutputTypeSelect = {
    webhookRequests?: boolean
  }

  export type InstitutionalProductsCountOutputTypeGetPayload<S extends boolean | null | undefined | InstitutionalProductsCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? InstitutionalProductsCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (InstitutionalProductsCountOutputTypeArgs)
    ? InstitutionalProductsCountOutputType 
    : S extends { select: any } & (InstitutionalProductsCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof InstitutionalProductsCountOutputType ? InstitutionalProductsCountOutputType[P] : never
  } 
      : InstitutionalProductsCountOutputType




  // Custom InputTypes

  /**
   * InstitutionalProductsCountOutputType without action
   */
  export type InstitutionalProductsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the InstitutionalProductsCountOutputType
     */
    select?: InstitutionalProductsCountOutputTypeSelect | null
  }



  /**
   * Count Type OrganizationStatusTypesCountOutputType
   */


  export type OrganizationStatusTypesCountOutputType = {
    organizations: number
  }

  export type OrganizationStatusTypesCountOutputTypeSelect = {
    organizations?: boolean
  }

  export type OrganizationStatusTypesCountOutputTypeGetPayload<S extends boolean | null | undefined | OrganizationStatusTypesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OrganizationStatusTypesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (OrganizationStatusTypesCountOutputTypeArgs)
    ? OrganizationStatusTypesCountOutputType 
    : S extends { select: any } & (OrganizationStatusTypesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof OrganizationStatusTypesCountOutputType ? OrganizationStatusTypesCountOutputType[P] : never
  } 
      : OrganizationStatusTypesCountOutputType




  // Custom InputTypes

  /**
   * OrganizationStatusTypesCountOutputType without action
   */
  export type OrganizationStatusTypesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OrganizationStatusTypesCountOutputType
     */
    select?: OrganizationStatusTypesCountOutputTypeSelect | null
  }



  /**
   * Count Type OrganizationsCountOutputType
   */


  export type OrganizationsCountOutputType = {
    custodyEngineEvents: number
    users: number
    webhooks: number
    withdrawalAddresses: number
  }

  export type OrganizationsCountOutputTypeSelect = {
    custodyEngineEvents?: boolean
    users?: boolean
    webhooks?: boolean
    withdrawalAddresses?: boolean
  }

  export type OrganizationsCountOutputTypeGetPayload<S extends boolean | null | undefined | OrganizationsCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OrganizationsCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (OrganizationsCountOutputTypeArgs)
    ? OrganizationsCountOutputType 
    : S extends { select: any } & (OrganizationsCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof OrganizationsCountOutputType ? OrganizationsCountOutputType[P] : never
  } 
      : OrganizationsCountOutputType




  // Custom InputTypes

  /**
   * OrganizationsCountOutputType without action
   */
  export type OrganizationsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OrganizationsCountOutputType
     */
    select?: OrganizationsCountOutputTypeSelect | null
  }



  /**
   * Count Type PricingPlanProfilesCountOutputType
   */


  export type PricingPlanProfilesCountOutputType = {
    pricingPlans: number
  }

  export type PricingPlanProfilesCountOutputTypeSelect = {
    pricingPlans?: boolean
  }

  export type PricingPlanProfilesCountOutputTypeGetPayload<S extends boolean | null | undefined | PricingPlanProfilesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PricingPlanProfilesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PricingPlanProfilesCountOutputTypeArgs)
    ? PricingPlanProfilesCountOutputType 
    : S extends { select: any } & (PricingPlanProfilesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PricingPlanProfilesCountOutputType ? PricingPlanProfilesCountOutputType[P] : never
  } 
      : PricingPlanProfilesCountOutputType




  // Custom InputTypes

  /**
   * PricingPlanProfilesCountOutputType without action
   */
  export type PricingPlanProfilesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PricingPlanProfilesCountOutputType
     */
    select?: PricingPlanProfilesCountOutputTypeSelect | null
  }



  /**
   * Count Type PricingPlansCountOutputType
   */


  export type PricingPlansCountOutputType = {
    organizations: number
    pricingPlanSupportsAssets: number
  }

  export type PricingPlansCountOutputTypeSelect = {
    organizations?: boolean
    pricingPlanSupportsAssets?: boolean
  }

  export type PricingPlansCountOutputTypeGetPayload<S extends boolean | null | undefined | PricingPlansCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PricingPlansCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PricingPlansCountOutputTypeArgs)
    ? PricingPlansCountOutputType 
    : S extends { select: any } & (PricingPlansCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PricingPlansCountOutputType ? PricingPlansCountOutputType[P] : never
  } 
      : PricingPlansCountOutputType




  // Custom InputTypes

  /**
   * PricingPlansCountOutputType without action
   */
  export type PricingPlansCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PricingPlansCountOutputType
     */
    select?: PricingPlansCountOutputTypeSelect | null
  }



  /**
   * Count Type QuoteStatusesCountOutputType
   */


  export type QuoteStatusesCountOutputType = {
    quotes: number
  }

  export type QuoteStatusesCountOutputTypeSelect = {
    quotes?: boolean
  }

  export type QuoteStatusesCountOutputTypeGetPayload<S extends boolean | null | undefined | QuoteStatusesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? QuoteStatusesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (QuoteStatusesCountOutputTypeArgs)
    ? QuoteStatusesCountOutputType 
    : S extends { select: any } & (QuoteStatusesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof QuoteStatusesCountOutputType ? QuoteStatusesCountOutputType[P] : never
  } 
      : QuoteStatusesCountOutputType




  // Custom InputTypes

  /**
   * QuoteStatusesCountOutputType without action
   */
  export type QuoteStatusesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the QuoteStatusesCountOutputType
     */
    select?: QuoteStatusesCountOutputTypeSelect | null
  }



  /**
   * Count Type TokenPairsCountOutputType
   */


  export type TokenPairsCountOutputType = {
    tokenPairsInfo: number
  }

  export type TokenPairsCountOutputTypeSelect = {
    tokenPairsInfo?: boolean
  }

  export type TokenPairsCountOutputTypeGetPayload<S extends boolean | null | undefined | TokenPairsCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TokenPairsCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TokenPairsCountOutputTypeArgs)
    ? TokenPairsCountOutputType 
    : S extends { select: any } & (TokenPairsCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TokenPairsCountOutputType ? TokenPairsCountOutputType[P] : never
  } 
      : TokenPairsCountOutputType




  // Custom InputTypes

  /**
   * TokenPairsCountOutputType without action
   */
  export type TokenPairsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TokenPairsCountOutputType
     */
    select?: TokenPairsCountOutputTypeSelect | null
  }



  /**
   * Count Type TokenPairsInfoCountOutputType
   */


  export type TokenPairsInfoCountOutputType = {
    quotes: number
  }

  export type TokenPairsInfoCountOutputTypeSelect = {
    quotes?: boolean
  }

  export type TokenPairsInfoCountOutputTypeGetPayload<S extends boolean | null | undefined | TokenPairsInfoCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TokenPairsInfoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TokenPairsInfoCountOutputTypeArgs)
    ? TokenPairsInfoCountOutputType 
    : S extends { select: any } & (TokenPairsInfoCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TokenPairsInfoCountOutputType ? TokenPairsInfoCountOutputType[P] : never
  } 
      : TokenPairsInfoCountOutputType




  // Custom InputTypes

  /**
   * TokenPairsInfoCountOutputType without action
   */
  export type TokenPairsInfoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TokenPairsInfoCountOutputType
     */
    select?: TokenPairsInfoCountOutputTypeSelect | null
  }



  /**
   * Count Type UserTypesCountOutputType
   */


  export type UserTypesCountOutputType = {
    users: number
  }

  export type UserTypesCountOutputTypeSelect = {
    users?: boolean
  }

  export type UserTypesCountOutputTypeGetPayload<S extends boolean | null | undefined | UserTypesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserTypesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserTypesCountOutputTypeArgs)
    ? UserTypesCountOutputType 
    : S extends { select: any } & (UserTypesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserTypesCountOutputType ? UserTypesCountOutputType[P] : never
  } 
      : UserTypesCountOutputType




  // Custom InputTypes

  /**
   * UserTypesCountOutputType without action
   */
  export type UserTypesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserTypesCountOutputType
     */
    select?: UserTypesCountOutputTypeSelect | null
  }



  /**
   * Count Type VaultAssetsCountOutputType
   */


  export type VaultAssetsCountOutputType = {
    custodyVendorVaultAssets: number
    depositAddresses: number
  }

  export type VaultAssetsCountOutputTypeSelect = {
    custodyVendorVaultAssets?: boolean
    depositAddresses?: boolean
  }

  export type VaultAssetsCountOutputTypeGetPayload<S extends boolean | null | undefined | VaultAssetsCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? VaultAssetsCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (VaultAssetsCountOutputTypeArgs)
    ? VaultAssetsCountOutputType 
    : S extends { select: any } & (VaultAssetsCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof VaultAssetsCountOutputType ? VaultAssetsCountOutputType[P] : never
  } 
      : VaultAssetsCountOutputType




  // Custom InputTypes

  /**
   * VaultAssetsCountOutputType without action
   */
  export type VaultAssetsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the VaultAssetsCountOutputType
     */
    select?: VaultAssetsCountOutputTypeSelect | null
  }



  /**
   * Count Type VaultStatusTypesCountOutputType
   */


  export type VaultStatusTypesCountOutputType = {
    vaults: number
  }

  export type VaultStatusTypesCountOutputTypeSelect = {
    vaults?: boolean
  }

  export type VaultStatusTypesCountOutputTypeGetPayload<S extends boolean | null | undefined | VaultStatusTypesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? VaultStatusTypesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (VaultStatusTypesCountOutputTypeArgs)
    ? VaultStatusTypesCountOutputType 
    : S extends { select: any } & (VaultStatusTypesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof VaultStatusTypesCountOutputType ? VaultStatusTypesCountOutputType[P] : never
  } 
      : VaultStatusTypesCountOutputType




  // Custom InputTypes

  /**
   * VaultStatusTypesCountOutputType without action
   */
  export type VaultStatusTypesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the VaultStatusTypesCountOutputType
     */
    select?: VaultStatusTypesCountOutputTypeSelect | null
  }



  /**
   * Count Type VaultsCountOutputType
   */


  export type VaultsCountOutputType = {
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults: number
    transactionPolicies_transactionPolicies_targetVaultIdTovaults: number
    transactions_transactions_sourceVaultIdTovaults: number
    transactions_transactions_targetVaultIdTovaults: number
    vaultAssets: number
  }

  export type VaultsCountOutputTypeSelect = {
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: boolean
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: boolean
    transactions_transactions_sourceVaultIdTovaults?: boolean
    transactions_transactions_targetVaultIdTovaults?: boolean
    vaultAssets?: boolean
  }

  export type VaultsCountOutputTypeGetPayload<S extends boolean | null | undefined | VaultsCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? VaultsCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (VaultsCountOutputTypeArgs)
    ? VaultsCountOutputType 
    : S extends { select: any } & (VaultsCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof VaultsCountOutputType ? VaultsCountOutputType[P] : never
  } 
      : VaultsCountOutputType




  // Custom InputTypes

  /**
   * VaultsCountOutputType without action
   */
  export type VaultsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the VaultsCountOutputType
     */
    select?: VaultsCountOutputTypeSelect | null
  }



  /**
   * Count Type VendorSupportsAssetsCountOutputType
   */


  export type VendorSupportsAssetsCountOutputType = {
    pricingPlanSupportsAssets: number
  }

  export type VendorSupportsAssetsCountOutputTypeSelect = {
    pricingPlanSupportsAssets?: boolean
  }

  export type VendorSupportsAssetsCountOutputTypeGetPayload<S extends boolean | null | undefined | VendorSupportsAssetsCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? VendorSupportsAssetsCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (VendorSupportsAssetsCountOutputTypeArgs)
    ? VendorSupportsAssetsCountOutputType 
    : S extends { select: any } & (VendorSupportsAssetsCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof VendorSupportsAssetsCountOutputType ? VendorSupportsAssetsCountOutputType[P] : never
  } 
      : VendorSupportsAssetsCountOutputType




  // Custom InputTypes

  /**
   * VendorSupportsAssetsCountOutputType without action
   */
  export type VendorSupportsAssetsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the VendorSupportsAssetsCountOutputType
     */
    select?: VendorSupportsAssetsCountOutputTypeSelect | null
  }



  /**
   * Count Type WebhookStatusTypesCountOutputType
   */


  export type WebhookStatusTypesCountOutputType = {
    webhooks: number
  }

  export type WebhookStatusTypesCountOutputTypeSelect = {
    webhooks?: boolean
  }

  export type WebhookStatusTypesCountOutputTypeGetPayload<S extends boolean | null | undefined | WebhookStatusTypesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WebhookStatusTypesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (WebhookStatusTypesCountOutputTypeArgs)
    ? WebhookStatusTypesCountOutputType 
    : S extends { select: any } & (WebhookStatusTypesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof WebhookStatusTypesCountOutputType ? WebhookStatusTypesCountOutputType[P] : never
  } 
      : WebhookStatusTypesCountOutputType




  // Custom InputTypes

  /**
   * WebhookStatusTypesCountOutputType without action
   */
  export type WebhookStatusTypesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WebhookStatusTypesCountOutputType
     */
    select?: WebhookStatusTypesCountOutputTypeSelect | null
  }



  /**
   * Count Type WebhooksCountOutputType
   */


  export type WebhooksCountOutputType = {
    webhookRequests: number
  }

  export type WebhooksCountOutputTypeSelect = {
    webhookRequests?: boolean
  }

  export type WebhooksCountOutputTypeGetPayload<S extends boolean | null | undefined | WebhooksCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WebhooksCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (WebhooksCountOutputTypeArgs)
    ? WebhooksCountOutputType 
    : S extends { select: any } & (WebhooksCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof WebhooksCountOutputType ? WebhooksCountOutputType[P] : never
  } 
      : WebhooksCountOutputType




  // Custom InputTypes

  /**
   * WebhooksCountOutputType without action
   */
  export type WebhooksCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WebhooksCountOutputType
     */
    select?: WebhooksCountOutputTypeSelect | null
  }



  /**
   * Count Type WithdrawalAddressesCountOutputType
   */


  export type WithdrawalAddressesCountOutputType = {
    transactionPolicies: number
    transactions: number
  }

  export type WithdrawalAddressesCountOutputTypeSelect = {
    transactionPolicies?: boolean
    transactions?: boolean
  }

  export type WithdrawalAddressesCountOutputTypeGetPayload<S extends boolean | null | undefined | WithdrawalAddressesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WithdrawalAddressesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (WithdrawalAddressesCountOutputTypeArgs)
    ? WithdrawalAddressesCountOutputType 
    : S extends { select: any } & (WithdrawalAddressesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof WithdrawalAddressesCountOutputType ? WithdrawalAddressesCountOutputType[P] : never
  } 
      : WithdrawalAddressesCountOutputType




  // Custom InputTypes

  /**
   * WithdrawalAddressesCountOutputType without action
   */
  export type WithdrawalAddressesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WithdrawalAddressesCountOutputType
     */
    select?: WithdrawalAddressesCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model SequelizeData
   */


  export type AggregateSequelizeData = {
    _count: SequelizeDataCountAggregateOutputType | null
    _min: SequelizeDataMinAggregateOutputType | null
    _max: SequelizeDataMaxAggregateOutputType | null
  }

  export type SequelizeDataMinAggregateOutputType = {
    name: string | null
  }

  export type SequelizeDataMaxAggregateOutputType = {
    name: string | null
  }

  export type SequelizeDataCountAggregateOutputType = {
    name: number
    _all: number
  }


  export type SequelizeDataMinAggregateInputType = {
    name?: true
  }

  export type SequelizeDataMaxAggregateInputType = {
    name?: true
  }

  export type SequelizeDataCountAggregateInputType = {
    name?: true
    _all?: true
  }

  export type SequelizeDataAggregateArgs = {
    /**
     * Filter which SequelizeData to aggregate.
     */
    where?: SequelizeDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SequelizeData to fetch.
     */
    orderBy?: Enumerable<SequelizeDataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SequelizeDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SequelizeData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SequelizeData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SequelizeData
    **/
    _count?: true | SequelizeDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SequelizeDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SequelizeDataMaxAggregateInputType
  }

  export type GetSequelizeDataAggregateType<T extends SequelizeDataAggregateArgs> = {
        [P in keyof T & keyof AggregateSequelizeData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSequelizeData[P]>
      : GetScalarType<T[P], AggregateSequelizeData[P]>
  }




  export type SequelizeDataGroupByArgs = {
    where?: SequelizeDataWhereInput
    orderBy?: Enumerable<SequelizeDataOrderByWithAggregationInput>
    by: SequelizeDataScalarFieldEnum[]
    having?: SequelizeDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SequelizeDataCountAggregateInputType | true
    _min?: SequelizeDataMinAggregateInputType
    _max?: SequelizeDataMaxAggregateInputType
  }


  export type SequelizeDataGroupByOutputType = {
    name: string
    _count: SequelizeDataCountAggregateOutputType | null
    _min: SequelizeDataMinAggregateOutputType | null
    _max: SequelizeDataMaxAggregateOutputType | null
  }

  type GetSequelizeDataGroupByPayload<T extends SequelizeDataGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SequelizeDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SequelizeDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SequelizeDataGroupByOutputType[P]>
            : GetScalarType<T[P], SequelizeDataGroupByOutputType[P]>
        }
      >
    >


  export type SequelizeDataSelect = {
    name?: boolean
  }


  export type SequelizeDataGetPayload<S extends boolean | null | undefined | SequelizeDataArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SequelizeData :
    S extends undefined ? never :
    S extends { include: any } & (SequelizeDataArgs | SequelizeDataFindManyArgs)
    ? SequelizeData 
    : S extends { select: any } & (SequelizeDataArgs | SequelizeDataFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SequelizeData ? SequelizeData[P] : never
  } 
      : SequelizeData


  type SequelizeDataCountArgs = 
    Omit<SequelizeDataFindManyArgs, 'select' | 'include'> & {
      select?: SequelizeDataCountAggregateInputType | true
    }

  export interface SequelizeDataDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SequelizeData that matches the filter.
     * @param {SequelizeDataFindUniqueArgs} args - Arguments to find a SequelizeData
     * @example
     * // Get one SequelizeData
     * const sequelizeData = await prisma.sequelizeData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SequelizeDataFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SequelizeDataFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SequelizeData'> extends True ? Prisma__SequelizeDataClient<SequelizeDataGetPayload<T>> : Prisma__SequelizeDataClient<SequelizeDataGetPayload<T> | null, null>

    /**
     * Find one SequelizeData that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SequelizeDataFindUniqueOrThrowArgs} args - Arguments to find a SequelizeData
     * @example
     * // Get one SequelizeData
     * const sequelizeData = await prisma.sequelizeData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SequelizeDataFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SequelizeDataFindUniqueOrThrowArgs>
    ): Prisma__SequelizeDataClient<SequelizeDataGetPayload<T>>

    /**
     * Find the first SequelizeData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeDataFindFirstArgs} args - Arguments to find a SequelizeData
     * @example
     * // Get one SequelizeData
     * const sequelizeData = await prisma.sequelizeData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SequelizeDataFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SequelizeDataFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SequelizeData'> extends True ? Prisma__SequelizeDataClient<SequelizeDataGetPayload<T>> : Prisma__SequelizeDataClient<SequelizeDataGetPayload<T> | null, null>

    /**
     * Find the first SequelizeData that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeDataFindFirstOrThrowArgs} args - Arguments to find a SequelizeData
     * @example
     * // Get one SequelizeData
     * const sequelizeData = await prisma.sequelizeData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SequelizeDataFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SequelizeDataFindFirstOrThrowArgs>
    ): Prisma__SequelizeDataClient<SequelizeDataGetPayload<T>>

    /**
     * Find zero or more SequelizeData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeDataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SequelizeData
     * const sequelizeData = await prisma.sequelizeData.findMany()
     * 
     * // Get first 10 SequelizeData
     * const sequelizeData = await prisma.sequelizeData.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const sequelizeDataWithNameOnly = await prisma.sequelizeData.findMany({ select: { name: true } })
     * 
    **/
    findMany<T extends SequelizeDataFindManyArgs>(
      args?: SelectSubset<T, SequelizeDataFindManyArgs>
    ): PrismaPromise<Array<SequelizeDataGetPayload<T>>>

    /**
     * Create a SequelizeData.
     * @param {SequelizeDataCreateArgs} args - Arguments to create a SequelizeData.
     * @example
     * // Create one SequelizeData
     * const SequelizeData = await prisma.sequelizeData.create({
     *   data: {
     *     // ... data to create a SequelizeData
     *   }
     * })
     * 
    **/
    create<T extends SequelizeDataCreateArgs>(
      args: SelectSubset<T, SequelizeDataCreateArgs>
    ): Prisma__SequelizeDataClient<SequelizeDataGetPayload<T>>

    /**
     * Create many SequelizeData.
     *     @param {SequelizeDataCreateManyArgs} args - Arguments to create many SequelizeData.
     *     @example
     *     // Create many SequelizeData
     *     const sequelizeData = await prisma.sequelizeData.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SequelizeDataCreateManyArgs>(
      args?: SelectSubset<T, SequelizeDataCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SequelizeData.
     * @param {SequelizeDataDeleteArgs} args - Arguments to delete one SequelizeData.
     * @example
     * // Delete one SequelizeData
     * const SequelizeData = await prisma.sequelizeData.delete({
     *   where: {
     *     // ... filter to delete one SequelizeData
     *   }
     * })
     * 
    **/
    delete<T extends SequelizeDataDeleteArgs>(
      args: SelectSubset<T, SequelizeDataDeleteArgs>
    ): Prisma__SequelizeDataClient<SequelizeDataGetPayload<T>>

    /**
     * Update one SequelizeData.
     * @param {SequelizeDataUpdateArgs} args - Arguments to update one SequelizeData.
     * @example
     * // Update one SequelizeData
     * const sequelizeData = await prisma.sequelizeData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SequelizeDataUpdateArgs>(
      args: SelectSubset<T, SequelizeDataUpdateArgs>
    ): Prisma__SequelizeDataClient<SequelizeDataGetPayload<T>>

    /**
     * Delete zero or more SequelizeData.
     * @param {SequelizeDataDeleteManyArgs} args - Arguments to filter SequelizeData to delete.
     * @example
     * // Delete a few SequelizeData
     * const { count } = await prisma.sequelizeData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SequelizeDataDeleteManyArgs>(
      args?: SelectSubset<T, SequelizeDataDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SequelizeData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SequelizeData
     * const sequelizeData = await prisma.sequelizeData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SequelizeDataUpdateManyArgs>(
      args: SelectSubset<T, SequelizeDataUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SequelizeData.
     * @param {SequelizeDataUpsertArgs} args - Arguments to update or create a SequelizeData.
     * @example
     * // Update or create a SequelizeData
     * const sequelizeData = await prisma.sequelizeData.upsert({
     *   create: {
     *     // ... data to create a SequelizeData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SequelizeData we want to update
     *   }
     * })
    **/
    upsert<T extends SequelizeDataUpsertArgs>(
      args: SelectSubset<T, SequelizeDataUpsertArgs>
    ): Prisma__SequelizeDataClient<SequelizeDataGetPayload<T>>

    /**
     * Count the number of SequelizeData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeDataCountArgs} args - Arguments to filter SequelizeData to count.
     * @example
     * // Count the number of SequelizeData
     * const count = await prisma.sequelizeData.count({
     *   where: {
     *     // ... the filter for the SequelizeData we want to count
     *   }
     * })
    **/
    count<T extends SequelizeDataCountArgs>(
      args?: Subset<T, SequelizeDataCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SequelizeDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SequelizeData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SequelizeDataAggregateArgs>(args: Subset<T, SequelizeDataAggregateArgs>): PrismaPromise<GetSequelizeDataAggregateType<T>>

    /**
     * Group by SequelizeData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SequelizeDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SequelizeDataGroupByArgs['orderBy'] }
        : { orderBy?: SequelizeDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SequelizeDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSequelizeDataGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SequelizeData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SequelizeDataClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SequelizeData base type for findUnique actions
   */
  export type SequelizeDataFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SequelizeData
     */
    select?: SequelizeDataSelect | null
    /**
     * Filter, which SequelizeData to fetch.
     */
    where: SequelizeDataWhereUniqueInput
  }

  /**
   * SequelizeData findUnique
   */
  export interface SequelizeDataFindUniqueArgs extends SequelizeDataFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SequelizeData findUniqueOrThrow
   */
  export type SequelizeDataFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SequelizeData
     */
    select?: SequelizeDataSelect | null
    /**
     * Filter, which SequelizeData to fetch.
     */
    where: SequelizeDataWhereUniqueInput
  }


  /**
   * SequelizeData base type for findFirst actions
   */
  export type SequelizeDataFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SequelizeData
     */
    select?: SequelizeDataSelect | null
    /**
     * Filter, which SequelizeData to fetch.
     */
    where?: SequelizeDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SequelizeData to fetch.
     */
    orderBy?: Enumerable<SequelizeDataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SequelizeData.
     */
    cursor?: SequelizeDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SequelizeData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SequelizeData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SequelizeData.
     */
    distinct?: Enumerable<SequelizeDataScalarFieldEnum>
  }

  /**
   * SequelizeData findFirst
   */
  export interface SequelizeDataFindFirstArgs extends SequelizeDataFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SequelizeData findFirstOrThrow
   */
  export type SequelizeDataFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SequelizeData
     */
    select?: SequelizeDataSelect | null
    /**
     * Filter, which SequelizeData to fetch.
     */
    where?: SequelizeDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SequelizeData to fetch.
     */
    orderBy?: Enumerable<SequelizeDataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SequelizeData.
     */
    cursor?: SequelizeDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SequelizeData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SequelizeData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SequelizeData.
     */
    distinct?: Enumerable<SequelizeDataScalarFieldEnum>
  }


  /**
   * SequelizeData findMany
   */
  export type SequelizeDataFindManyArgs = {
    /**
     * Select specific fields to fetch from the SequelizeData
     */
    select?: SequelizeDataSelect | null
    /**
     * Filter, which SequelizeData to fetch.
     */
    where?: SequelizeDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SequelizeData to fetch.
     */
    orderBy?: Enumerable<SequelizeDataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SequelizeData.
     */
    cursor?: SequelizeDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SequelizeData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SequelizeData.
     */
    skip?: number
    distinct?: Enumerable<SequelizeDataScalarFieldEnum>
  }


  /**
   * SequelizeData create
   */
  export type SequelizeDataCreateArgs = {
    /**
     * Select specific fields to fetch from the SequelizeData
     */
    select?: SequelizeDataSelect | null
    /**
     * The data needed to create a SequelizeData.
     */
    data: XOR<SequelizeDataCreateInput, SequelizeDataUncheckedCreateInput>
  }


  /**
   * SequelizeData createMany
   */
  export type SequelizeDataCreateManyArgs = {
    /**
     * The data used to create many SequelizeData.
     */
    data: Enumerable<SequelizeDataCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SequelizeData update
   */
  export type SequelizeDataUpdateArgs = {
    /**
     * Select specific fields to fetch from the SequelizeData
     */
    select?: SequelizeDataSelect | null
    /**
     * The data needed to update a SequelizeData.
     */
    data: XOR<SequelizeDataUpdateInput, SequelizeDataUncheckedUpdateInput>
    /**
     * Choose, which SequelizeData to update.
     */
    where: SequelizeDataWhereUniqueInput
  }


  /**
   * SequelizeData updateMany
   */
  export type SequelizeDataUpdateManyArgs = {
    /**
     * The data used to update SequelizeData.
     */
    data: XOR<SequelizeDataUpdateManyMutationInput, SequelizeDataUncheckedUpdateManyInput>
    /**
     * Filter which SequelizeData to update
     */
    where?: SequelizeDataWhereInput
  }


  /**
   * SequelizeData upsert
   */
  export type SequelizeDataUpsertArgs = {
    /**
     * Select specific fields to fetch from the SequelizeData
     */
    select?: SequelizeDataSelect | null
    /**
     * The filter to search for the SequelizeData to update in case it exists.
     */
    where: SequelizeDataWhereUniqueInput
    /**
     * In case the SequelizeData found by the `where` argument doesn't exist, create a new SequelizeData with this data.
     */
    create: XOR<SequelizeDataCreateInput, SequelizeDataUncheckedCreateInput>
    /**
     * In case the SequelizeData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SequelizeDataUpdateInput, SequelizeDataUncheckedUpdateInput>
  }


  /**
   * SequelizeData delete
   */
  export type SequelizeDataDeleteArgs = {
    /**
     * Select specific fields to fetch from the SequelizeData
     */
    select?: SequelizeDataSelect | null
    /**
     * Filter which SequelizeData to delete.
     */
    where: SequelizeDataWhereUniqueInput
  }


  /**
   * SequelizeData deleteMany
   */
  export type SequelizeDataDeleteManyArgs = {
    /**
     * Filter which SequelizeData to delete
     */
    where?: SequelizeDataWhereInput
  }


  /**
   * SequelizeData without action
   */
  export type SequelizeDataArgs = {
    /**
     * Select specific fields to fetch from the SequelizeData
     */
    select?: SequelizeDataSelect | null
  }



  /**
   * Model SequelizeMeta
   */


  export type AggregateSequelizeMeta = {
    _count: SequelizeMetaCountAggregateOutputType | null
    _min: SequelizeMetaMinAggregateOutputType | null
    _max: SequelizeMetaMaxAggregateOutputType | null
  }

  export type SequelizeMetaMinAggregateOutputType = {
    name: string | null
  }

  export type SequelizeMetaMaxAggregateOutputType = {
    name: string | null
  }

  export type SequelizeMetaCountAggregateOutputType = {
    name: number
    _all: number
  }


  export type SequelizeMetaMinAggregateInputType = {
    name?: true
  }

  export type SequelizeMetaMaxAggregateInputType = {
    name?: true
  }

  export type SequelizeMetaCountAggregateInputType = {
    name?: true
    _all?: true
  }

  export type SequelizeMetaAggregateArgs = {
    /**
     * Filter which SequelizeMeta to aggregate.
     */
    where?: SequelizeMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SequelizeMetas to fetch.
     */
    orderBy?: Enumerable<SequelizeMetaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SequelizeMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SequelizeMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SequelizeMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SequelizeMetas
    **/
    _count?: true | SequelizeMetaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SequelizeMetaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SequelizeMetaMaxAggregateInputType
  }

  export type GetSequelizeMetaAggregateType<T extends SequelizeMetaAggregateArgs> = {
        [P in keyof T & keyof AggregateSequelizeMeta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSequelizeMeta[P]>
      : GetScalarType<T[P], AggregateSequelizeMeta[P]>
  }




  export type SequelizeMetaGroupByArgs = {
    where?: SequelizeMetaWhereInput
    orderBy?: Enumerable<SequelizeMetaOrderByWithAggregationInput>
    by: SequelizeMetaScalarFieldEnum[]
    having?: SequelizeMetaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SequelizeMetaCountAggregateInputType | true
    _min?: SequelizeMetaMinAggregateInputType
    _max?: SequelizeMetaMaxAggregateInputType
  }


  export type SequelizeMetaGroupByOutputType = {
    name: string
    _count: SequelizeMetaCountAggregateOutputType | null
    _min: SequelizeMetaMinAggregateOutputType | null
    _max: SequelizeMetaMaxAggregateOutputType | null
  }

  type GetSequelizeMetaGroupByPayload<T extends SequelizeMetaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SequelizeMetaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SequelizeMetaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SequelizeMetaGroupByOutputType[P]>
            : GetScalarType<T[P], SequelizeMetaGroupByOutputType[P]>
        }
      >
    >


  export type SequelizeMetaSelect = {
    name?: boolean
  }


  export type SequelizeMetaGetPayload<S extends boolean | null | undefined | SequelizeMetaArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SequelizeMeta :
    S extends undefined ? never :
    S extends { include: any } & (SequelizeMetaArgs | SequelizeMetaFindManyArgs)
    ? SequelizeMeta 
    : S extends { select: any } & (SequelizeMetaArgs | SequelizeMetaFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SequelizeMeta ? SequelizeMeta[P] : never
  } 
      : SequelizeMeta


  type SequelizeMetaCountArgs = 
    Omit<SequelizeMetaFindManyArgs, 'select' | 'include'> & {
      select?: SequelizeMetaCountAggregateInputType | true
    }

  export interface SequelizeMetaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SequelizeMeta that matches the filter.
     * @param {SequelizeMetaFindUniqueArgs} args - Arguments to find a SequelizeMeta
     * @example
     * // Get one SequelizeMeta
     * const sequelizeMeta = await prisma.sequelizeMeta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SequelizeMetaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SequelizeMetaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SequelizeMeta'> extends True ? Prisma__SequelizeMetaClient<SequelizeMetaGetPayload<T>> : Prisma__SequelizeMetaClient<SequelizeMetaGetPayload<T> | null, null>

    /**
     * Find one SequelizeMeta that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SequelizeMetaFindUniqueOrThrowArgs} args - Arguments to find a SequelizeMeta
     * @example
     * // Get one SequelizeMeta
     * const sequelizeMeta = await prisma.sequelizeMeta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SequelizeMetaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SequelizeMetaFindUniqueOrThrowArgs>
    ): Prisma__SequelizeMetaClient<SequelizeMetaGetPayload<T>>

    /**
     * Find the first SequelizeMeta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeMetaFindFirstArgs} args - Arguments to find a SequelizeMeta
     * @example
     * // Get one SequelizeMeta
     * const sequelizeMeta = await prisma.sequelizeMeta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SequelizeMetaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SequelizeMetaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SequelizeMeta'> extends True ? Prisma__SequelizeMetaClient<SequelizeMetaGetPayload<T>> : Prisma__SequelizeMetaClient<SequelizeMetaGetPayload<T> | null, null>

    /**
     * Find the first SequelizeMeta that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeMetaFindFirstOrThrowArgs} args - Arguments to find a SequelizeMeta
     * @example
     * // Get one SequelizeMeta
     * const sequelizeMeta = await prisma.sequelizeMeta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SequelizeMetaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SequelizeMetaFindFirstOrThrowArgs>
    ): Prisma__SequelizeMetaClient<SequelizeMetaGetPayload<T>>

    /**
     * Find zero or more SequelizeMetas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeMetaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SequelizeMetas
     * const sequelizeMetas = await prisma.sequelizeMeta.findMany()
     * 
     * // Get first 10 SequelizeMetas
     * const sequelizeMetas = await prisma.sequelizeMeta.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const sequelizeMetaWithNameOnly = await prisma.sequelizeMeta.findMany({ select: { name: true } })
     * 
    **/
    findMany<T extends SequelizeMetaFindManyArgs>(
      args?: SelectSubset<T, SequelizeMetaFindManyArgs>
    ): PrismaPromise<Array<SequelizeMetaGetPayload<T>>>

    /**
     * Create a SequelizeMeta.
     * @param {SequelizeMetaCreateArgs} args - Arguments to create a SequelizeMeta.
     * @example
     * // Create one SequelizeMeta
     * const SequelizeMeta = await prisma.sequelizeMeta.create({
     *   data: {
     *     // ... data to create a SequelizeMeta
     *   }
     * })
     * 
    **/
    create<T extends SequelizeMetaCreateArgs>(
      args: SelectSubset<T, SequelizeMetaCreateArgs>
    ): Prisma__SequelizeMetaClient<SequelizeMetaGetPayload<T>>

    /**
     * Create many SequelizeMetas.
     *     @param {SequelizeMetaCreateManyArgs} args - Arguments to create many SequelizeMetas.
     *     @example
     *     // Create many SequelizeMetas
     *     const sequelizeMeta = await prisma.sequelizeMeta.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SequelizeMetaCreateManyArgs>(
      args?: SelectSubset<T, SequelizeMetaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SequelizeMeta.
     * @param {SequelizeMetaDeleteArgs} args - Arguments to delete one SequelizeMeta.
     * @example
     * // Delete one SequelizeMeta
     * const SequelizeMeta = await prisma.sequelizeMeta.delete({
     *   where: {
     *     // ... filter to delete one SequelizeMeta
     *   }
     * })
     * 
    **/
    delete<T extends SequelizeMetaDeleteArgs>(
      args: SelectSubset<T, SequelizeMetaDeleteArgs>
    ): Prisma__SequelizeMetaClient<SequelizeMetaGetPayload<T>>

    /**
     * Update one SequelizeMeta.
     * @param {SequelizeMetaUpdateArgs} args - Arguments to update one SequelizeMeta.
     * @example
     * // Update one SequelizeMeta
     * const sequelizeMeta = await prisma.sequelizeMeta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SequelizeMetaUpdateArgs>(
      args: SelectSubset<T, SequelizeMetaUpdateArgs>
    ): Prisma__SequelizeMetaClient<SequelizeMetaGetPayload<T>>

    /**
     * Delete zero or more SequelizeMetas.
     * @param {SequelizeMetaDeleteManyArgs} args - Arguments to filter SequelizeMetas to delete.
     * @example
     * // Delete a few SequelizeMetas
     * const { count } = await prisma.sequelizeMeta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SequelizeMetaDeleteManyArgs>(
      args?: SelectSubset<T, SequelizeMetaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SequelizeMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeMetaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SequelizeMetas
     * const sequelizeMeta = await prisma.sequelizeMeta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SequelizeMetaUpdateManyArgs>(
      args: SelectSubset<T, SequelizeMetaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SequelizeMeta.
     * @param {SequelizeMetaUpsertArgs} args - Arguments to update or create a SequelizeMeta.
     * @example
     * // Update or create a SequelizeMeta
     * const sequelizeMeta = await prisma.sequelizeMeta.upsert({
     *   create: {
     *     // ... data to create a SequelizeMeta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SequelizeMeta we want to update
     *   }
     * })
    **/
    upsert<T extends SequelizeMetaUpsertArgs>(
      args: SelectSubset<T, SequelizeMetaUpsertArgs>
    ): Prisma__SequelizeMetaClient<SequelizeMetaGetPayload<T>>

    /**
     * Count the number of SequelizeMetas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeMetaCountArgs} args - Arguments to filter SequelizeMetas to count.
     * @example
     * // Count the number of SequelizeMetas
     * const count = await prisma.sequelizeMeta.count({
     *   where: {
     *     // ... the filter for the SequelizeMetas we want to count
     *   }
     * })
    **/
    count<T extends SequelizeMetaCountArgs>(
      args?: Subset<T, SequelizeMetaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SequelizeMetaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SequelizeMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeMetaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SequelizeMetaAggregateArgs>(args: Subset<T, SequelizeMetaAggregateArgs>): PrismaPromise<GetSequelizeMetaAggregateType<T>>

    /**
     * Group by SequelizeMeta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SequelizeMetaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SequelizeMetaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SequelizeMetaGroupByArgs['orderBy'] }
        : { orderBy?: SequelizeMetaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SequelizeMetaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSequelizeMetaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SequelizeMeta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SequelizeMetaClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SequelizeMeta base type for findUnique actions
   */
  export type SequelizeMetaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
     */
    select?: SequelizeMetaSelect | null
    /**
     * Filter, which SequelizeMeta to fetch.
     */
    where: SequelizeMetaWhereUniqueInput
  }

  /**
   * SequelizeMeta findUnique
   */
  export interface SequelizeMetaFindUniqueArgs extends SequelizeMetaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SequelizeMeta findUniqueOrThrow
   */
  export type SequelizeMetaFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
     */
    select?: SequelizeMetaSelect | null
    /**
     * Filter, which SequelizeMeta to fetch.
     */
    where: SequelizeMetaWhereUniqueInput
  }


  /**
   * SequelizeMeta base type for findFirst actions
   */
  export type SequelizeMetaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
     */
    select?: SequelizeMetaSelect | null
    /**
     * Filter, which SequelizeMeta to fetch.
     */
    where?: SequelizeMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SequelizeMetas to fetch.
     */
    orderBy?: Enumerable<SequelizeMetaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SequelizeMetas.
     */
    cursor?: SequelizeMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SequelizeMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SequelizeMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SequelizeMetas.
     */
    distinct?: Enumerable<SequelizeMetaScalarFieldEnum>
  }

  /**
   * SequelizeMeta findFirst
   */
  export interface SequelizeMetaFindFirstArgs extends SequelizeMetaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SequelizeMeta findFirstOrThrow
   */
  export type SequelizeMetaFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
     */
    select?: SequelizeMetaSelect | null
    /**
     * Filter, which SequelizeMeta to fetch.
     */
    where?: SequelizeMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SequelizeMetas to fetch.
     */
    orderBy?: Enumerable<SequelizeMetaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SequelizeMetas.
     */
    cursor?: SequelizeMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SequelizeMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SequelizeMetas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SequelizeMetas.
     */
    distinct?: Enumerable<SequelizeMetaScalarFieldEnum>
  }


  /**
   * SequelizeMeta findMany
   */
  export type SequelizeMetaFindManyArgs = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
     */
    select?: SequelizeMetaSelect | null
    /**
     * Filter, which SequelizeMetas to fetch.
     */
    where?: SequelizeMetaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SequelizeMetas to fetch.
     */
    orderBy?: Enumerable<SequelizeMetaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SequelizeMetas.
     */
    cursor?: SequelizeMetaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SequelizeMetas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SequelizeMetas.
     */
    skip?: number
    distinct?: Enumerable<SequelizeMetaScalarFieldEnum>
  }


  /**
   * SequelizeMeta create
   */
  export type SequelizeMetaCreateArgs = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
     */
    select?: SequelizeMetaSelect | null
    /**
     * The data needed to create a SequelizeMeta.
     */
    data: XOR<SequelizeMetaCreateInput, SequelizeMetaUncheckedCreateInput>
  }


  /**
   * SequelizeMeta createMany
   */
  export type SequelizeMetaCreateManyArgs = {
    /**
     * The data used to create many SequelizeMetas.
     */
    data: Enumerable<SequelizeMetaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SequelizeMeta update
   */
  export type SequelizeMetaUpdateArgs = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
     */
    select?: SequelizeMetaSelect | null
    /**
     * The data needed to update a SequelizeMeta.
     */
    data: XOR<SequelizeMetaUpdateInput, SequelizeMetaUncheckedUpdateInput>
    /**
     * Choose, which SequelizeMeta to update.
     */
    where: SequelizeMetaWhereUniqueInput
  }


  /**
   * SequelizeMeta updateMany
   */
  export type SequelizeMetaUpdateManyArgs = {
    /**
     * The data used to update SequelizeMetas.
     */
    data: XOR<SequelizeMetaUpdateManyMutationInput, SequelizeMetaUncheckedUpdateManyInput>
    /**
     * Filter which SequelizeMetas to update
     */
    where?: SequelizeMetaWhereInput
  }


  /**
   * SequelizeMeta upsert
   */
  export type SequelizeMetaUpsertArgs = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
     */
    select?: SequelizeMetaSelect | null
    /**
     * The filter to search for the SequelizeMeta to update in case it exists.
     */
    where: SequelizeMetaWhereUniqueInput
    /**
     * In case the SequelizeMeta found by the `where` argument doesn't exist, create a new SequelizeMeta with this data.
     */
    create: XOR<SequelizeMetaCreateInput, SequelizeMetaUncheckedCreateInput>
    /**
     * In case the SequelizeMeta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SequelizeMetaUpdateInput, SequelizeMetaUncheckedUpdateInput>
  }


  /**
   * SequelizeMeta delete
   */
  export type SequelizeMetaDeleteArgs = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
     */
    select?: SequelizeMetaSelect | null
    /**
     * Filter which SequelizeMeta to delete.
     */
    where: SequelizeMetaWhereUniqueInput
  }


  /**
   * SequelizeMeta deleteMany
   */
  export type SequelizeMetaDeleteManyArgs = {
    /**
     * Filter which SequelizeMetas to delete
     */
    where?: SequelizeMetaWhereInput
  }


  /**
   * SequelizeMeta without action
   */
  export type SequelizeMetaArgs = {
    /**
     * Select specific fields to fetch from the SequelizeMeta
     */
    select?: SequelizeMetaSelect | null
  }



  /**
   * Model assets
   */


  export type AggregateAssets = {
    _count: AssetsCountAggregateOutputType | null
    _avg: AssetsAvgAggregateOutputType | null
    _sum: AssetsSumAggregateOutputType | null
    _min: AssetsMinAggregateOutputType | null
    _max: AssetsMaxAggregateOutputType | null
  }

  export type AssetsAvgAggregateOutputType = {
    id: number | null
    baseNetworkId: number | null
  }

  export type AssetsSumAggregateOutputType = {
    id: number | null
    baseNetworkId: number | null
  }

  export type AssetsMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    baseNetworkId: number | null
    type: enum_assets_type | null
    ticker: string | null
    fireblocksTicker: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssetsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    baseNetworkId: number | null
    type: enum_assets_type | null
    ticker: string | null
    fireblocksTicker: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssetsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    baseNetworkId: number
    type: number
    ticker: number
    fireblocksTicker: number
    enabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AssetsAvgAggregateInputType = {
    id?: true
    baseNetworkId?: true
  }

  export type AssetsSumAggregateInputType = {
    id?: true
    baseNetworkId?: true
  }

  export type AssetsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    baseNetworkId?: true
    type?: true
    ticker?: true
    fireblocksTicker?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssetsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    baseNetworkId?: true
    type?: true
    ticker?: true
    fireblocksTicker?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssetsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    baseNetworkId?: true
    type?: true
    ticker?: true
    fireblocksTicker?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AssetsAggregateArgs = {
    /**
     * Filter which assets to aggregate.
     */
    where?: assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assets to fetch.
     */
    orderBy?: Enumerable<assetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned assets
    **/
    _count?: true | AssetsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetsMaxAggregateInputType
  }

  export type GetAssetsAggregateType<T extends AssetsAggregateArgs> = {
        [P in keyof T & keyof AggregateAssets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssets[P]>
      : GetScalarType<T[P], AggregateAssets[P]>
  }




  export type AssetsGroupByArgs = {
    where?: assetsWhereInput
    orderBy?: Enumerable<assetsOrderByWithAggregationInput>
    by: AssetsScalarFieldEnum[]
    having?: assetsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetsCountAggregateInputType | true
    _avg?: AssetsAvgAggregateInputType
    _sum?: AssetsSumAggregateInputType
    _min?: AssetsMinAggregateInputType
    _max?: AssetsMaxAggregateInputType
  }


  export type AssetsGroupByOutputType = {
    id: number
    name: string
    description: string
    baseNetworkId: number | null
    type: enum_assets_type
    ticker: string
    fireblocksTicker: string | null
    enabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: AssetsCountAggregateOutputType | null
    _avg: AssetsAvgAggregateOutputType | null
    _sum: AssetsSumAggregateOutputType | null
    _min: AssetsMinAggregateOutputType | null
    _max: AssetsMaxAggregateOutputType | null
  }

  type GetAssetsGroupByPayload<T extends AssetsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AssetsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetsGroupByOutputType[P]>
            : GetScalarType<T[P], AssetsGroupByOutputType[P]>
        }
      >
    >


  export type assetsSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    baseNetworkId?: boolean
    type?: boolean
    ticker?: boolean
    fireblocksTicker?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    baseNetworks?: boolean | baseNetworksArgs
    quotes_quotes_sourceAssetIdToassets?: boolean | assets$quotes_quotes_sourceAssetIdToassetsArgs
    quotes_quotes_targetAssetIdToassets?: boolean | assets$quotes_quotes_targetAssetIdToassetsArgs
    transactionPolicies?: boolean | assets$transactionPoliciesArgs
    transactions?: boolean | assets$transactionsArgs
    vaultAssets?: boolean | assets$vaultAssetsArgs
    vendorSupportsAssets?: boolean | assets$vendorSupportsAssetsArgs
    withdrawalAddresses?: boolean | assets$withdrawalAddressesArgs
    _count?: boolean | AssetsCountOutputTypeArgs
  }


  export type assetsInclude = {
    baseNetworks?: boolean | baseNetworksArgs
    quotes_quotes_sourceAssetIdToassets?: boolean | assets$quotes_quotes_sourceAssetIdToassetsArgs
    quotes_quotes_targetAssetIdToassets?: boolean | assets$quotes_quotes_targetAssetIdToassetsArgs
    transactionPolicies?: boolean | assets$transactionPoliciesArgs
    transactions?: boolean | assets$transactionsArgs
    vaultAssets?: boolean | assets$vaultAssetsArgs
    vendorSupportsAssets?: boolean | assets$vendorSupportsAssetsArgs
    withdrawalAddresses?: boolean | assets$withdrawalAddressesArgs
    _count?: boolean | AssetsCountOutputTypeArgs
  }

  export type assetsGetPayload<S extends boolean | null | undefined | assetsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? assets :
    S extends undefined ? never :
    S extends { include: any } & (assetsArgs | assetsFindManyArgs)
    ? assets  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'baseNetworks' ? baseNetworksGetPayload<S['include'][P]> | null :
        P extends 'quotes_quotes_sourceAssetIdToassets' ? Array < quotesGetPayload<S['include'][P]>>  :
        P extends 'quotes_quotes_targetAssetIdToassets' ? Array < quotesGetPayload<S['include'][P]>>  :
        P extends 'transactionPolicies' ? Array < transactionPoliciesGetPayload<S['include'][P]>>  :
        P extends 'transactions' ? Array < transactionsGetPayload<S['include'][P]>>  :
        P extends 'vaultAssets' ? Array < vaultAssetsGetPayload<S['include'][P]>>  :
        P extends 'vendorSupportsAssets' ? Array < vendorSupportsAssetsGetPayload<S['include'][P]>>  :
        P extends 'withdrawalAddresses' ? Array < withdrawalAddressesGetPayload<S['include'][P]>>  :
        P extends '_count' ? AssetsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (assetsArgs | assetsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'baseNetworks' ? baseNetworksGetPayload<S['select'][P]> | null :
        P extends 'quotes_quotes_sourceAssetIdToassets' ? Array < quotesGetPayload<S['select'][P]>>  :
        P extends 'quotes_quotes_targetAssetIdToassets' ? Array < quotesGetPayload<S['select'][P]>>  :
        P extends 'transactionPolicies' ? Array < transactionPoliciesGetPayload<S['select'][P]>>  :
        P extends 'transactions' ? Array < transactionsGetPayload<S['select'][P]>>  :
        P extends 'vaultAssets' ? Array < vaultAssetsGetPayload<S['select'][P]>>  :
        P extends 'vendorSupportsAssets' ? Array < vendorSupportsAssetsGetPayload<S['select'][P]>>  :
        P extends 'withdrawalAddresses' ? Array < withdrawalAddressesGetPayload<S['select'][P]>>  :
        P extends '_count' ? AssetsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof assets ? assets[P] : never
  } 
      : assets


  type assetsCountArgs = 
    Omit<assetsFindManyArgs, 'select' | 'include'> & {
      select?: AssetsCountAggregateInputType | true
    }

  export interface assetsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Assets that matches the filter.
     * @param {assetsFindUniqueArgs} args - Arguments to find a Assets
     * @example
     * // Get one Assets
     * const assets = await prisma.assets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends assetsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, assetsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'assets'> extends True ? Prisma__assetsClient<assetsGetPayload<T>> : Prisma__assetsClient<assetsGetPayload<T> | null, null>

    /**
     * Find one Assets that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {assetsFindUniqueOrThrowArgs} args - Arguments to find a Assets
     * @example
     * // Get one Assets
     * const assets = await prisma.assets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends assetsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, assetsFindUniqueOrThrowArgs>
    ): Prisma__assetsClient<assetsGetPayload<T>>

    /**
     * Find the first Assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assetsFindFirstArgs} args - Arguments to find a Assets
     * @example
     * // Get one Assets
     * const assets = await prisma.assets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends assetsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, assetsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'assets'> extends True ? Prisma__assetsClient<assetsGetPayload<T>> : Prisma__assetsClient<assetsGetPayload<T> | null, null>

    /**
     * Find the first Assets that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assetsFindFirstOrThrowArgs} args - Arguments to find a Assets
     * @example
     * // Get one Assets
     * const assets = await prisma.assets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends assetsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, assetsFindFirstOrThrowArgs>
    ): Prisma__assetsClient<assetsGetPayload<T>>

    /**
     * Find zero or more Assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assetsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assets
     * const assets = await prisma.assets.findMany()
     * 
     * // Get first 10 Assets
     * const assets = await prisma.assets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetsWithIdOnly = await prisma.assets.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends assetsFindManyArgs>(
      args?: SelectSubset<T, assetsFindManyArgs>
    ): PrismaPromise<Array<assetsGetPayload<T>>>

    /**
     * Create a Assets.
     * @param {assetsCreateArgs} args - Arguments to create a Assets.
     * @example
     * // Create one Assets
     * const Assets = await prisma.assets.create({
     *   data: {
     *     // ... data to create a Assets
     *   }
     * })
     * 
    **/
    create<T extends assetsCreateArgs>(
      args: SelectSubset<T, assetsCreateArgs>
    ): Prisma__assetsClient<assetsGetPayload<T>>

    /**
     * Create many Assets.
     *     @param {assetsCreateManyArgs} args - Arguments to create many Assets.
     *     @example
     *     // Create many Assets
     *     const assets = await prisma.assets.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends assetsCreateManyArgs>(
      args?: SelectSubset<T, assetsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Assets.
     * @param {assetsDeleteArgs} args - Arguments to delete one Assets.
     * @example
     * // Delete one Assets
     * const Assets = await prisma.assets.delete({
     *   where: {
     *     // ... filter to delete one Assets
     *   }
     * })
     * 
    **/
    delete<T extends assetsDeleteArgs>(
      args: SelectSubset<T, assetsDeleteArgs>
    ): Prisma__assetsClient<assetsGetPayload<T>>

    /**
     * Update one Assets.
     * @param {assetsUpdateArgs} args - Arguments to update one Assets.
     * @example
     * // Update one Assets
     * const assets = await prisma.assets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends assetsUpdateArgs>(
      args: SelectSubset<T, assetsUpdateArgs>
    ): Prisma__assetsClient<assetsGetPayload<T>>

    /**
     * Delete zero or more Assets.
     * @param {assetsDeleteManyArgs} args - Arguments to filter Assets to delete.
     * @example
     * // Delete a few Assets
     * const { count } = await prisma.assets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends assetsDeleteManyArgs>(
      args?: SelectSubset<T, assetsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assetsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assets
     * const assets = await prisma.assets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends assetsUpdateManyArgs>(
      args: SelectSubset<T, assetsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Assets.
     * @param {assetsUpsertArgs} args - Arguments to update or create a Assets.
     * @example
     * // Update or create a Assets
     * const assets = await prisma.assets.upsert({
     *   create: {
     *     // ... data to create a Assets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assets we want to update
     *   }
     * })
    **/
    upsert<T extends assetsUpsertArgs>(
      args: SelectSubset<T, assetsUpsertArgs>
    ): Prisma__assetsClient<assetsGetPayload<T>>

    /**
     * Count the number of Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assetsCountArgs} args - Arguments to filter Assets to count.
     * @example
     * // Count the number of Assets
     * const count = await prisma.assets.count({
     *   where: {
     *     // ... the filter for the Assets we want to count
     *   }
     * })
    **/
    count<T extends assetsCountArgs>(
      args?: Subset<T, assetsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetsAggregateArgs>(args: Subset<T, AssetsAggregateArgs>): PrismaPromise<GetAssetsAggregateType<T>>

    /**
     * Group by Assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetsGroupByArgs['orderBy'] }
        : { orderBy?: AssetsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for assets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__assetsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    baseNetworks<T extends baseNetworksArgs= {}>(args?: Subset<T, baseNetworksArgs>): Prisma__baseNetworksClient<baseNetworksGetPayload<T> | Null>;

    quotes_quotes_sourceAssetIdToassets<T extends assets$quotes_quotes_sourceAssetIdToassetsArgs= {}>(args?: Subset<T, assets$quotes_quotes_sourceAssetIdToassetsArgs>): PrismaPromise<Array<quotesGetPayload<T>>| Null>;

    quotes_quotes_targetAssetIdToassets<T extends assets$quotes_quotes_targetAssetIdToassetsArgs= {}>(args?: Subset<T, assets$quotes_quotes_targetAssetIdToassetsArgs>): PrismaPromise<Array<quotesGetPayload<T>>| Null>;

    transactionPolicies<T extends assets$transactionPoliciesArgs= {}>(args?: Subset<T, assets$transactionPoliciesArgs>): PrismaPromise<Array<transactionPoliciesGetPayload<T>>| Null>;

    transactions<T extends assets$transactionsArgs= {}>(args?: Subset<T, assets$transactionsArgs>): PrismaPromise<Array<transactionsGetPayload<T>>| Null>;

    vaultAssets<T extends assets$vaultAssetsArgs= {}>(args?: Subset<T, assets$vaultAssetsArgs>): PrismaPromise<Array<vaultAssetsGetPayload<T>>| Null>;

    vendorSupportsAssets<T extends assets$vendorSupportsAssetsArgs= {}>(args?: Subset<T, assets$vendorSupportsAssetsArgs>): PrismaPromise<Array<vendorSupportsAssetsGetPayload<T>>| Null>;

    withdrawalAddresses<T extends assets$withdrawalAddressesArgs= {}>(args?: Subset<T, assets$withdrawalAddressesArgs>): PrismaPromise<Array<withdrawalAddressesGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * assets base type for findUnique actions
   */
  export type assetsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the assets
     */
    select?: assetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: assetsInclude | null
    /**
     * Filter, which assets to fetch.
     */
    where: assetsWhereUniqueInput
  }

  /**
   * assets findUnique
   */
  export interface assetsFindUniqueArgs extends assetsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * assets findUniqueOrThrow
   */
  export type assetsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the assets
     */
    select?: assetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: assetsInclude | null
    /**
     * Filter, which assets to fetch.
     */
    where: assetsWhereUniqueInput
  }


  /**
   * assets base type for findFirst actions
   */
  export type assetsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the assets
     */
    select?: assetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: assetsInclude | null
    /**
     * Filter, which assets to fetch.
     */
    where?: assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assets to fetch.
     */
    orderBy?: Enumerable<assetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for assets.
     */
    cursor?: assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of assets.
     */
    distinct?: Enumerable<AssetsScalarFieldEnum>
  }

  /**
   * assets findFirst
   */
  export interface assetsFindFirstArgs extends assetsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * assets findFirstOrThrow
   */
  export type assetsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the assets
     */
    select?: assetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: assetsInclude | null
    /**
     * Filter, which assets to fetch.
     */
    where?: assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assets to fetch.
     */
    orderBy?: Enumerable<assetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for assets.
     */
    cursor?: assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of assets.
     */
    distinct?: Enumerable<AssetsScalarFieldEnum>
  }


  /**
   * assets findMany
   */
  export type assetsFindManyArgs = {
    /**
     * Select specific fields to fetch from the assets
     */
    select?: assetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: assetsInclude | null
    /**
     * Filter, which assets to fetch.
     */
    where?: assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assets to fetch.
     */
    orderBy?: Enumerable<assetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing assets.
     */
    cursor?: assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assets.
     */
    skip?: number
    distinct?: Enumerable<AssetsScalarFieldEnum>
  }


  /**
   * assets create
   */
  export type assetsCreateArgs = {
    /**
     * Select specific fields to fetch from the assets
     */
    select?: assetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: assetsInclude | null
    /**
     * The data needed to create a assets.
     */
    data: XOR<assetsCreateInput, assetsUncheckedCreateInput>
  }


  /**
   * assets createMany
   */
  export type assetsCreateManyArgs = {
    /**
     * The data used to create many assets.
     */
    data: Enumerable<assetsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * assets update
   */
  export type assetsUpdateArgs = {
    /**
     * Select specific fields to fetch from the assets
     */
    select?: assetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: assetsInclude | null
    /**
     * The data needed to update a assets.
     */
    data: XOR<assetsUpdateInput, assetsUncheckedUpdateInput>
    /**
     * Choose, which assets to update.
     */
    where: assetsWhereUniqueInput
  }


  /**
   * assets updateMany
   */
  export type assetsUpdateManyArgs = {
    /**
     * The data used to update assets.
     */
    data: XOR<assetsUpdateManyMutationInput, assetsUncheckedUpdateManyInput>
    /**
     * Filter which assets to update
     */
    where?: assetsWhereInput
  }


  /**
   * assets upsert
   */
  export type assetsUpsertArgs = {
    /**
     * Select specific fields to fetch from the assets
     */
    select?: assetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: assetsInclude | null
    /**
     * The filter to search for the assets to update in case it exists.
     */
    where: assetsWhereUniqueInput
    /**
     * In case the assets found by the `where` argument doesn't exist, create a new assets with this data.
     */
    create: XOR<assetsCreateInput, assetsUncheckedCreateInput>
    /**
     * In case the assets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<assetsUpdateInput, assetsUncheckedUpdateInput>
  }


  /**
   * assets delete
   */
  export type assetsDeleteArgs = {
    /**
     * Select specific fields to fetch from the assets
     */
    select?: assetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: assetsInclude | null
    /**
     * Filter which assets to delete.
     */
    where: assetsWhereUniqueInput
  }


  /**
   * assets deleteMany
   */
  export type assetsDeleteManyArgs = {
    /**
     * Filter which assets to delete
     */
    where?: assetsWhereInput
  }


  /**
   * assets.quotes_quotes_sourceAssetIdToassets
   */
  export type assets$quotes_quotes_sourceAssetIdToassetsArgs = {
    /**
     * Select specific fields to fetch from the quotes
     */
    select?: quotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: quotesInclude | null
    where?: quotesWhereInput
    orderBy?: Enumerable<quotesOrderByWithRelationInput>
    cursor?: quotesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QuotesScalarFieldEnum>
  }


  /**
   * assets.quotes_quotes_targetAssetIdToassets
   */
  export type assets$quotes_quotes_targetAssetIdToassetsArgs = {
    /**
     * Select specific fields to fetch from the quotes
     */
    select?: quotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: quotesInclude | null
    where?: quotesWhereInput
    orderBy?: Enumerable<quotesOrderByWithRelationInput>
    cursor?: quotesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QuotesScalarFieldEnum>
  }


  /**
   * assets.transactionPolicies
   */
  export type assets$transactionPoliciesArgs = {
    /**
     * Select specific fields to fetch from the transactionPolicies
     */
    select?: transactionPoliciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionPoliciesInclude | null
    where?: transactionPoliciesWhereInput
    orderBy?: Enumerable<transactionPoliciesOrderByWithRelationInput>
    cursor?: transactionPoliciesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TransactionPoliciesScalarFieldEnum>
  }


  /**
   * assets.transactions
   */
  export type assets$transactionsArgs = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionsInclude | null
    where?: transactionsWhereInput
    orderBy?: Enumerable<transactionsOrderByWithRelationInput>
    cursor?: transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TransactionsScalarFieldEnum>
  }


  /**
   * assets.vaultAssets
   */
  export type assets$vaultAssetsArgs = {
    /**
     * Select specific fields to fetch from the vaultAssets
     */
    select?: vaultAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultAssetsInclude | null
    where?: vaultAssetsWhereInput
    orderBy?: Enumerable<vaultAssetsOrderByWithRelationInput>
    cursor?: vaultAssetsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VaultAssetsScalarFieldEnum>
  }


  /**
   * assets.vendorSupportsAssets
   */
  export type assets$vendorSupportsAssetsArgs = {
    /**
     * Select specific fields to fetch from the vendorSupportsAssets
     */
    select?: vendorSupportsAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorSupportsAssetsInclude | null
    where?: vendorSupportsAssetsWhereInput
    orderBy?: Enumerable<vendorSupportsAssetsOrderByWithRelationInput>
    cursor?: vendorSupportsAssetsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VendorSupportsAssetsScalarFieldEnum>
  }


  /**
   * assets.withdrawalAddresses
   */
  export type assets$withdrawalAddressesArgs = {
    /**
     * Select specific fields to fetch from the withdrawalAddresses
     */
    select?: withdrawalAddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: withdrawalAddressesInclude | null
    where?: withdrawalAddressesWhereInput
    orderBy?: Enumerable<withdrawalAddressesOrderByWithRelationInput>
    cursor?: withdrawalAddressesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WithdrawalAddressesScalarFieldEnum>
  }


  /**
   * assets without action
   */
  export type assetsArgs = {
    /**
     * Select specific fields to fetch from the assets
     */
    select?: assetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: assetsInclude | null
  }



  /**
   * Model baseNetworks
   */


  export type AggregateBaseNetworks = {
    _count: BaseNetworksCountAggregateOutputType | null
    _avg: BaseNetworksAvgAggregateOutputType | null
    _sum: BaseNetworksSumAggregateOutputType | null
    _min: BaseNetworksMinAggregateOutputType | null
    _max: BaseNetworksMaxAggregateOutputType | null
  }

  export type BaseNetworksAvgAggregateOutputType = {
    id: number | null
    feeAssetId: number | null
    baseBps: number | null
  }

  export type BaseNetworksSumAggregateOutputType = {
    id: number | null
    feeAssetId: number | null
    baseBps: number | null
  }

  export type BaseNetworksMinAggregateOutputType = {
    id: number | null
    name: string | null
    addressUrl: string | null
    feeAssetId: number | null
    txUrl: string | null
    enabled: boolean | null
    baseBps: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BaseNetworksMaxAggregateOutputType = {
    id: number | null
    name: string | null
    addressUrl: string | null
    feeAssetId: number | null
    txUrl: string | null
    enabled: boolean | null
    baseBps: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BaseNetworksCountAggregateOutputType = {
    id: number
    name: number
    addressUrl: number
    feeAssetId: number
    txUrl: number
    enabled: number
    baseBps: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BaseNetworksAvgAggregateInputType = {
    id?: true
    feeAssetId?: true
    baseBps?: true
  }

  export type BaseNetworksSumAggregateInputType = {
    id?: true
    feeAssetId?: true
    baseBps?: true
  }

  export type BaseNetworksMinAggregateInputType = {
    id?: true
    name?: true
    addressUrl?: true
    feeAssetId?: true
    txUrl?: true
    enabled?: true
    baseBps?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BaseNetworksMaxAggregateInputType = {
    id?: true
    name?: true
    addressUrl?: true
    feeAssetId?: true
    txUrl?: true
    enabled?: true
    baseBps?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BaseNetworksCountAggregateInputType = {
    id?: true
    name?: true
    addressUrl?: true
    feeAssetId?: true
    txUrl?: true
    enabled?: true
    baseBps?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BaseNetworksAggregateArgs = {
    /**
     * Filter which baseNetworks to aggregate.
     */
    where?: baseNetworksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of baseNetworks to fetch.
     */
    orderBy?: Enumerable<baseNetworksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: baseNetworksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` baseNetworks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` baseNetworks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned baseNetworks
    **/
    _count?: true | BaseNetworksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BaseNetworksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BaseNetworksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BaseNetworksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BaseNetworksMaxAggregateInputType
  }

  export type GetBaseNetworksAggregateType<T extends BaseNetworksAggregateArgs> = {
        [P in keyof T & keyof AggregateBaseNetworks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBaseNetworks[P]>
      : GetScalarType<T[P], AggregateBaseNetworks[P]>
  }




  export type BaseNetworksGroupByArgs = {
    where?: baseNetworksWhereInput
    orderBy?: Enumerable<baseNetworksOrderByWithAggregationInput>
    by: BaseNetworksScalarFieldEnum[]
    having?: baseNetworksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BaseNetworksCountAggregateInputType | true
    _avg?: BaseNetworksAvgAggregateInputType
    _sum?: BaseNetworksSumAggregateInputType
    _min?: BaseNetworksMinAggregateInputType
    _max?: BaseNetworksMaxAggregateInputType
  }


  export type BaseNetworksGroupByOutputType = {
    id: number
    name: string
    addressUrl: string
    feeAssetId: number | null
    txUrl: string
    enabled: boolean
    baseBps: number
    createdAt: Date
    updatedAt: Date
    _count: BaseNetworksCountAggregateOutputType | null
    _avg: BaseNetworksAvgAggregateOutputType | null
    _sum: BaseNetworksSumAggregateOutputType | null
    _min: BaseNetworksMinAggregateOutputType | null
    _max: BaseNetworksMaxAggregateOutputType | null
  }

  type GetBaseNetworksGroupByPayload<T extends BaseNetworksGroupByArgs> = PrismaPromise<
    Array<
      PickArray<BaseNetworksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BaseNetworksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BaseNetworksGroupByOutputType[P]>
            : GetScalarType<T[P], BaseNetworksGroupByOutputType[P]>
        }
      >
    >


  export type baseNetworksSelect = {
    id?: boolean
    name?: boolean
    addressUrl?: boolean
    feeAssetId?: boolean
    txUrl?: boolean
    enabled?: boolean
    baseBps?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assets?: boolean | baseNetworks$assetsArgs
    _count?: boolean | BaseNetworksCountOutputTypeArgs
  }


  export type baseNetworksInclude = {
    assets?: boolean | baseNetworks$assetsArgs
    _count?: boolean | BaseNetworksCountOutputTypeArgs
  }

  export type baseNetworksGetPayload<S extends boolean | null | undefined | baseNetworksArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? baseNetworks :
    S extends undefined ? never :
    S extends { include: any } & (baseNetworksArgs | baseNetworksFindManyArgs)
    ? baseNetworks  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'assets' ? Array < assetsGetPayload<S['include'][P]>>  :
        P extends '_count' ? BaseNetworksCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (baseNetworksArgs | baseNetworksFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'assets' ? Array < assetsGetPayload<S['select'][P]>>  :
        P extends '_count' ? BaseNetworksCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof baseNetworks ? baseNetworks[P] : never
  } 
      : baseNetworks


  type baseNetworksCountArgs = 
    Omit<baseNetworksFindManyArgs, 'select' | 'include'> & {
      select?: BaseNetworksCountAggregateInputType | true
    }

  export interface baseNetworksDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BaseNetworks that matches the filter.
     * @param {baseNetworksFindUniqueArgs} args - Arguments to find a BaseNetworks
     * @example
     * // Get one BaseNetworks
     * const baseNetworks = await prisma.baseNetworks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends baseNetworksFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, baseNetworksFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'baseNetworks'> extends True ? Prisma__baseNetworksClient<baseNetworksGetPayload<T>> : Prisma__baseNetworksClient<baseNetworksGetPayload<T> | null, null>

    /**
     * Find one BaseNetworks that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {baseNetworksFindUniqueOrThrowArgs} args - Arguments to find a BaseNetworks
     * @example
     * // Get one BaseNetworks
     * const baseNetworks = await prisma.baseNetworks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends baseNetworksFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, baseNetworksFindUniqueOrThrowArgs>
    ): Prisma__baseNetworksClient<baseNetworksGetPayload<T>>

    /**
     * Find the first BaseNetworks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {baseNetworksFindFirstArgs} args - Arguments to find a BaseNetworks
     * @example
     * // Get one BaseNetworks
     * const baseNetworks = await prisma.baseNetworks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends baseNetworksFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, baseNetworksFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'baseNetworks'> extends True ? Prisma__baseNetworksClient<baseNetworksGetPayload<T>> : Prisma__baseNetworksClient<baseNetworksGetPayload<T> | null, null>

    /**
     * Find the first BaseNetworks that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {baseNetworksFindFirstOrThrowArgs} args - Arguments to find a BaseNetworks
     * @example
     * // Get one BaseNetworks
     * const baseNetworks = await prisma.baseNetworks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends baseNetworksFindFirstOrThrowArgs>(
      args?: SelectSubset<T, baseNetworksFindFirstOrThrowArgs>
    ): Prisma__baseNetworksClient<baseNetworksGetPayload<T>>

    /**
     * Find zero or more BaseNetworks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {baseNetworksFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BaseNetworks
     * const baseNetworks = await prisma.baseNetworks.findMany()
     * 
     * // Get first 10 BaseNetworks
     * const baseNetworks = await prisma.baseNetworks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const baseNetworksWithIdOnly = await prisma.baseNetworks.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends baseNetworksFindManyArgs>(
      args?: SelectSubset<T, baseNetworksFindManyArgs>
    ): PrismaPromise<Array<baseNetworksGetPayload<T>>>

    /**
     * Create a BaseNetworks.
     * @param {baseNetworksCreateArgs} args - Arguments to create a BaseNetworks.
     * @example
     * // Create one BaseNetworks
     * const BaseNetworks = await prisma.baseNetworks.create({
     *   data: {
     *     // ... data to create a BaseNetworks
     *   }
     * })
     * 
    **/
    create<T extends baseNetworksCreateArgs>(
      args: SelectSubset<T, baseNetworksCreateArgs>
    ): Prisma__baseNetworksClient<baseNetworksGetPayload<T>>

    /**
     * Create many BaseNetworks.
     *     @param {baseNetworksCreateManyArgs} args - Arguments to create many BaseNetworks.
     *     @example
     *     // Create many BaseNetworks
     *     const baseNetworks = await prisma.baseNetworks.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends baseNetworksCreateManyArgs>(
      args?: SelectSubset<T, baseNetworksCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a BaseNetworks.
     * @param {baseNetworksDeleteArgs} args - Arguments to delete one BaseNetworks.
     * @example
     * // Delete one BaseNetworks
     * const BaseNetworks = await prisma.baseNetworks.delete({
     *   where: {
     *     // ... filter to delete one BaseNetworks
     *   }
     * })
     * 
    **/
    delete<T extends baseNetworksDeleteArgs>(
      args: SelectSubset<T, baseNetworksDeleteArgs>
    ): Prisma__baseNetworksClient<baseNetworksGetPayload<T>>

    /**
     * Update one BaseNetworks.
     * @param {baseNetworksUpdateArgs} args - Arguments to update one BaseNetworks.
     * @example
     * // Update one BaseNetworks
     * const baseNetworks = await prisma.baseNetworks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends baseNetworksUpdateArgs>(
      args: SelectSubset<T, baseNetworksUpdateArgs>
    ): Prisma__baseNetworksClient<baseNetworksGetPayload<T>>

    /**
     * Delete zero or more BaseNetworks.
     * @param {baseNetworksDeleteManyArgs} args - Arguments to filter BaseNetworks to delete.
     * @example
     * // Delete a few BaseNetworks
     * const { count } = await prisma.baseNetworks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends baseNetworksDeleteManyArgs>(
      args?: SelectSubset<T, baseNetworksDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more BaseNetworks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {baseNetworksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BaseNetworks
     * const baseNetworks = await prisma.baseNetworks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends baseNetworksUpdateManyArgs>(
      args: SelectSubset<T, baseNetworksUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one BaseNetworks.
     * @param {baseNetworksUpsertArgs} args - Arguments to update or create a BaseNetworks.
     * @example
     * // Update or create a BaseNetworks
     * const baseNetworks = await prisma.baseNetworks.upsert({
     *   create: {
     *     // ... data to create a BaseNetworks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BaseNetworks we want to update
     *   }
     * })
    **/
    upsert<T extends baseNetworksUpsertArgs>(
      args: SelectSubset<T, baseNetworksUpsertArgs>
    ): Prisma__baseNetworksClient<baseNetworksGetPayload<T>>

    /**
     * Count the number of BaseNetworks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {baseNetworksCountArgs} args - Arguments to filter BaseNetworks to count.
     * @example
     * // Count the number of BaseNetworks
     * const count = await prisma.baseNetworks.count({
     *   where: {
     *     // ... the filter for the BaseNetworks we want to count
     *   }
     * })
    **/
    count<T extends baseNetworksCountArgs>(
      args?: Subset<T, baseNetworksCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BaseNetworksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BaseNetworks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseNetworksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BaseNetworksAggregateArgs>(args: Subset<T, BaseNetworksAggregateArgs>): PrismaPromise<GetBaseNetworksAggregateType<T>>

    /**
     * Group by BaseNetworks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BaseNetworksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BaseNetworksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BaseNetworksGroupByArgs['orderBy'] }
        : { orderBy?: BaseNetworksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BaseNetworksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBaseNetworksGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for baseNetworks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__baseNetworksClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    assets<T extends baseNetworks$assetsArgs= {}>(args?: Subset<T, baseNetworks$assetsArgs>): PrismaPromise<Array<assetsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * baseNetworks base type for findUnique actions
   */
  export type baseNetworksFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the baseNetworks
     */
    select?: baseNetworksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: baseNetworksInclude | null
    /**
     * Filter, which baseNetworks to fetch.
     */
    where: baseNetworksWhereUniqueInput
  }

  /**
   * baseNetworks findUnique
   */
  export interface baseNetworksFindUniqueArgs extends baseNetworksFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * baseNetworks findUniqueOrThrow
   */
  export type baseNetworksFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the baseNetworks
     */
    select?: baseNetworksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: baseNetworksInclude | null
    /**
     * Filter, which baseNetworks to fetch.
     */
    where: baseNetworksWhereUniqueInput
  }


  /**
   * baseNetworks base type for findFirst actions
   */
  export type baseNetworksFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the baseNetworks
     */
    select?: baseNetworksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: baseNetworksInclude | null
    /**
     * Filter, which baseNetworks to fetch.
     */
    where?: baseNetworksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of baseNetworks to fetch.
     */
    orderBy?: Enumerable<baseNetworksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for baseNetworks.
     */
    cursor?: baseNetworksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` baseNetworks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` baseNetworks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of baseNetworks.
     */
    distinct?: Enumerable<BaseNetworksScalarFieldEnum>
  }

  /**
   * baseNetworks findFirst
   */
  export interface baseNetworksFindFirstArgs extends baseNetworksFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * baseNetworks findFirstOrThrow
   */
  export type baseNetworksFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the baseNetworks
     */
    select?: baseNetworksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: baseNetworksInclude | null
    /**
     * Filter, which baseNetworks to fetch.
     */
    where?: baseNetworksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of baseNetworks to fetch.
     */
    orderBy?: Enumerable<baseNetworksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for baseNetworks.
     */
    cursor?: baseNetworksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` baseNetworks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` baseNetworks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of baseNetworks.
     */
    distinct?: Enumerable<BaseNetworksScalarFieldEnum>
  }


  /**
   * baseNetworks findMany
   */
  export type baseNetworksFindManyArgs = {
    /**
     * Select specific fields to fetch from the baseNetworks
     */
    select?: baseNetworksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: baseNetworksInclude | null
    /**
     * Filter, which baseNetworks to fetch.
     */
    where?: baseNetworksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of baseNetworks to fetch.
     */
    orderBy?: Enumerable<baseNetworksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing baseNetworks.
     */
    cursor?: baseNetworksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` baseNetworks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` baseNetworks.
     */
    skip?: number
    distinct?: Enumerable<BaseNetworksScalarFieldEnum>
  }


  /**
   * baseNetworks create
   */
  export type baseNetworksCreateArgs = {
    /**
     * Select specific fields to fetch from the baseNetworks
     */
    select?: baseNetworksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: baseNetworksInclude | null
    /**
     * The data needed to create a baseNetworks.
     */
    data: XOR<baseNetworksCreateInput, baseNetworksUncheckedCreateInput>
  }


  /**
   * baseNetworks createMany
   */
  export type baseNetworksCreateManyArgs = {
    /**
     * The data used to create many baseNetworks.
     */
    data: Enumerable<baseNetworksCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * baseNetworks update
   */
  export type baseNetworksUpdateArgs = {
    /**
     * Select specific fields to fetch from the baseNetworks
     */
    select?: baseNetworksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: baseNetworksInclude | null
    /**
     * The data needed to update a baseNetworks.
     */
    data: XOR<baseNetworksUpdateInput, baseNetworksUncheckedUpdateInput>
    /**
     * Choose, which baseNetworks to update.
     */
    where: baseNetworksWhereUniqueInput
  }


  /**
   * baseNetworks updateMany
   */
  export type baseNetworksUpdateManyArgs = {
    /**
     * The data used to update baseNetworks.
     */
    data: XOR<baseNetworksUpdateManyMutationInput, baseNetworksUncheckedUpdateManyInput>
    /**
     * Filter which baseNetworks to update
     */
    where?: baseNetworksWhereInput
  }


  /**
   * baseNetworks upsert
   */
  export type baseNetworksUpsertArgs = {
    /**
     * Select specific fields to fetch from the baseNetworks
     */
    select?: baseNetworksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: baseNetworksInclude | null
    /**
     * The filter to search for the baseNetworks to update in case it exists.
     */
    where: baseNetworksWhereUniqueInput
    /**
     * In case the baseNetworks found by the `where` argument doesn't exist, create a new baseNetworks with this data.
     */
    create: XOR<baseNetworksCreateInput, baseNetworksUncheckedCreateInput>
    /**
     * In case the baseNetworks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<baseNetworksUpdateInput, baseNetworksUncheckedUpdateInput>
  }


  /**
   * baseNetworks delete
   */
  export type baseNetworksDeleteArgs = {
    /**
     * Select specific fields to fetch from the baseNetworks
     */
    select?: baseNetworksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: baseNetworksInclude | null
    /**
     * Filter which baseNetworks to delete.
     */
    where: baseNetworksWhereUniqueInput
  }


  /**
   * baseNetworks deleteMany
   */
  export type baseNetworksDeleteManyArgs = {
    /**
     * Filter which baseNetworks to delete
     */
    where?: baseNetworksWhereInput
  }


  /**
   * baseNetworks.assets
   */
  export type baseNetworks$assetsArgs = {
    /**
     * Select specific fields to fetch from the assets
     */
    select?: assetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: assetsInclude | null
    where?: assetsWhereInput
    orderBy?: Enumerable<assetsOrderByWithRelationInput>
    cursor?: assetsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AssetsScalarFieldEnum>
  }


  /**
   * baseNetworks without action
   */
  export type baseNetworksArgs = {
    /**
     * Select specific fields to fetch from the baseNetworks
     */
    select?: baseNetworksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: baseNetworksInclude | null
  }



  /**
   * Model quotes
   */


  export type AggregateQuotes = {
    _count: QuotesCountAggregateOutputType | null
    _avg: QuotesAvgAggregateOutputType | null
    _sum: QuotesSumAggregateOutputType | null
    _min: QuotesMinAggregateOutputType | null
    _max: QuotesMaxAggregateOutputType | null
  }

  export type QuotesAvgAggregateOutputType = {
    quoteStatusId: number | null
    sourceAssetId: number | null
    targetAssetId: number | null
    vendorId: number | null
  }

  export type QuotesSumAggregateOutputType = {
    quoteStatusId: number | null
    sourceAssetId: number | null
    targetAssetId: number | null
    vendorId: number | null
  }

  export type QuotesMinAggregateOutputType = {
    id: string | null
    quoteStatusId: number | null
    sourceAssetId: number | null
    targetAssetId: number | null
    side: enum_quotes_side | null
    userId: string | null
    vendorId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    fxRequestID: string | null
    buyPrice: string | null
    sellPrice: string | null
    quantity: string | null
  }

  export type QuotesMaxAggregateOutputType = {
    id: string | null
    quoteStatusId: number | null
    sourceAssetId: number | null
    targetAssetId: number | null
    side: enum_quotes_side | null
    userId: string | null
    vendorId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    fxRequestID: string | null
    buyPrice: string | null
    sellPrice: string | null
    quantity: string | null
  }

  export type QuotesCountAggregateOutputType = {
    id: number
    quoteStatusId: number
    sourceAssetId: number
    targetAssetId: number
    side: number
    userId: number
    vendorId: number
    extraData: number
    error: number
    createdAt: number
    updatedAt: number
    fxRequestID: number
    buyPrice: number
    sellPrice: number
    quantity: number
    _all: number
  }


  export type QuotesAvgAggregateInputType = {
    quoteStatusId?: true
    sourceAssetId?: true
    targetAssetId?: true
    vendorId?: true
  }

  export type QuotesSumAggregateInputType = {
    quoteStatusId?: true
    sourceAssetId?: true
    targetAssetId?: true
    vendorId?: true
  }

  export type QuotesMinAggregateInputType = {
    id?: true
    quoteStatusId?: true
    sourceAssetId?: true
    targetAssetId?: true
    side?: true
    userId?: true
    vendorId?: true
    createdAt?: true
    updatedAt?: true
    fxRequestID?: true
    buyPrice?: true
    sellPrice?: true
    quantity?: true
  }

  export type QuotesMaxAggregateInputType = {
    id?: true
    quoteStatusId?: true
    sourceAssetId?: true
    targetAssetId?: true
    side?: true
    userId?: true
    vendorId?: true
    createdAt?: true
    updatedAt?: true
    fxRequestID?: true
    buyPrice?: true
    sellPrice?: true
    quantity?: true
  }

  export type QuotesCountAggregateInputType = {
    id?: true
    quoteStatusId?: true
    sourceAssetId?: true
    targetAssetId?: true
    side?: true
    userId?: true
    vendorId?: true
    extraData?: true
    error?: true
    createdAt?: true
    updatedAt?: true
    fxRequestID?: true
    buyPrice?: true
    sellPrice?: true
    quantity?: true
    _all?: true
  }

  export type QuotesAggregateArgs = {
    /**
     * Filter which quotes to aggregate.
     */
    where?: quotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quotes to fetch.
     */
    orderBy?: Enumerable<quotesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: quotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned quotes
    **/
    _count?: true | QuotesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuotesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuotesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuotesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuotesMaxAggregateInputType
  }

  export type GetQuotesAggregateType<T extends QuotesAggregateArgs> = {
        [P in keyof T & keyof AggregateQuotes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuotes[P]>
      : GetScalarType<T[P], AggregateQuotes[P]>
  }




  export type QuotesGroupByArgs = {
    where?: quotesWhereInput
    orderBy?: Enumerable<quotesOrderByWithAggregationInput>
    by: QuotesScalarFieldEnum[]
    having?: quotesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuotesCountAggregateInputType | true
    _avg?: QuotesAvgAggregateInputType
    _sum?: QuotesSumAggregateInputType
    _min?: QuotesMinAggregateInputType
    _max?: QuotesMaxAggregateInputType
  }


  export type QuotesGroupByOutputType = {
    id: string
    quoteStatusId: number
    sourceAssetId: number
    targetAssetId: number
    side: enum_quotes_side
    userId: string
    vendorId: number | null
    extraData: JsonValue | null
    error: JsonValue | null
    createdAt: Date
    updatedAt: Date
    fxRequestID: string | null
    buyPrice: string
    sellPrice: string
    quantity: string
    _count: QuotesCountAggregateOutputType | null
    _avg: QuotesAvgAggregateOutputType | null
    _sum: QuotesSumAggregateOutputType | null
    _min: QuotesMinAggregateOutputType | null
    _max: QuotesMaxAggregateOutputType | null
  }

  type GetQuotesGroupByPayload<T extends QuotesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<QuotesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuotesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuotesGroupByOutputType[P]>
            : GetScalarType<T[P], QuotesGroupByOutputType[P]>
        }
      >
    >


  export type quotesSelect = {
    id?: boolean
    quoteStatusId?: boolean
    sourceAssetId?: boolean
    targetAssetId?: boolean
    side?: boolean
    userId?: boolean
    vendorId?: boolean
    extraData?: boolean
    error?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fxRequestID?: boolean
    buyPrice?: boolean
    sellPrice?: boolean
    quantity?: boolean
    orders?: boolean | quotes$ordersArgs
    tokenPairsInfo?: boolean | tokenPairsInfoArgs
    quoteStatuses?: boolean | quoteStatusesArgs
    assets_quotes_sourceAssetIdToassets?: boolean | assetsArgs
    assets_quotes_targetAssetIdToassets?: boolean | assetsArgs
    vendors?: boolean | vendorsArgs
    _count?: boolean | QuotesCountOutputTypeArgs
  }


  export type quotesInclude = {
    orders?: boolean | quotes$ordersArgs
    tokenPairsInfo?: boolean | tokenPairsInfoArgs
    quoteStatuses?: boolean | quoteStatusesArgs
    assets_quotes_sourceAssetIdToassets?: boolean | assetsArgs
    assets_quotes_targetAssetIdToassets?: boolean | assetsArgs
    vendors?: boolean | vendorsArgs
    _count?: boolean | QuotesCountOutputTypeArgs
  }

  export type quotesGetPayload<S extends boolean | null | undefined | quotesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? quotes :
    S extends undefined ? never :
    S extends { include: any } & (quotesArgs | quotesFindManyArgs)
    ? quotes  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'orders' ? Array < ordersGetPayload<S['include'][P]>>  :
        P extends 'tokenPairsInfo' ? tokenPairsInfoGetPayload<S['include'][P]> | null :
        P extends 'quoteStatuses' ? quoteStatusesGetPayload<S['include'][P]> :
        P extends 'assets_quotes_sourceAssetIdToassets' ? assetsGetPayload<S['include'][P]> :
        P extends 'assets_quotes_targetAssetIdToassets' ? assetsGetPayload<S['include'][P]> :
        P extends 'vendors' ? vendorsGetPayload<S['include'][P]> | null :
        P extends '_count' ? QuotesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (quotesArgs | quotesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'orders' ? Array < ordersGetPayload<S['select'][P]>>  :
        P extends 'tokenPairsInfo' ? tokenPairsInfoGetPayload<S['select'][P]> | null :
        P extends 'quoteStatuses' ? quoteStatusesGetPayload<S['select'][P]> :
        P extends 'assets_quotes_sourceAssetIdToassets' ? assetsGetPayload<S['select'][P]> :
        P extends 'assets_quotes_targetAssetIdToassets' ? assetsGetPayload<S['select'][P]> :
        P extends 'vendors' ? vendorsGetPayload<S['select'][P]> | null :
        P extends '_count' ? QuotesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof quotes ? quotes[P] : never
  } 
      : quotes


  type quotesCountArgs = 
    Omit<quotesFindManyArgs, 'select' | 'include'> & {
      select?: QuotesCountAggregateInputType | true
    }

  export interface quotesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Quotes that matches the filter.
     * @param {quotesFindUniqueArgs} args - Arguments to find a Quotes
     * @example
     * // Get one Quotes
     * const quotes = await prisma.quotes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends quotesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, quotesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'quotes'> extends True ? Prisma__quotesClient<quotesGetPayload<T>> : Prisma__quotesClient<quotesGetPayload<T> | null, null>

    /**
     * Find one Quotes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {quotesFindUniqueOrThrowArgs} args - Arguments to find a Quotes
     * @example
     * // Get one Quotes
     * const quotes = await prisma.quotes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends quotesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, quotesFindUniqueOrThrowArgs>
    ): Prisma__quotesClient<quotesGetPayload<T>>

    /**
     * Find the first Quotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quotesFindFirstArgs} args - Arguments to find a Quotes
     * @example
     * // Get one Quotes
     * const quotes = await prisma.quotes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends quotesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, quotesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'quotes'> extends True ? Prisma__quotesClient<quotesGetPayload<T>> : Prisma__quotesClient<quotesGetPayload<T> | null, null>

    /**
     * Find the first Quotes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quotesFindFirstOrThrowArgs} args - Arguments to find a Quotes
     * @example
     * // Get one Quotes
     * const quotes = await prisma.quotes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends quotesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, quotesFindFirstOrThrowArgs>
    ): Prisma__quotesClient<quotesGetPayload<T>>

    /**
     * Find zero or more Quotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quotesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quotes
     * const quotes = await prisma.quotes.findMany()
     * 
     * // Get first 10 Quotes
     * const quotes = await prisma.quotes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quotesWithIdOnly = await prisma.quotes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends quotesFindManyArgs>(
      args?: SelectSubset<T, quotesFindManyArgs>
    ): PrismaPromise<Array<quotesGetPayload<T>>>

    /**
     * Create a Quotes.
     * @param {quotesCreateArgs} args - Arguments to create a Quotes.
     * @example
     * // Create one Quotes
     * const Quotes = await prisma.quotes.create({
     *   data: {
     *     // ... data to create a Quotes
     *   }
     * })
     * 
    **/
    create<T extends quotesCreateArgs>(
      args: SelectSubset<T, quotesCreateArgs>
    ): Prisma__quotesClient<quotesGetPayload<T>>

    /**
     * Create many Quotes.
     *     @param {quotesCreateManyArgs} args - Arguments to create many Quotes.
     *     @example
     *     // Create many Quotes
     *     const quotes = await prisma.quotes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends quotesCreateManyArgs>(
      args?: SelectSubset<T, quotesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Quotes.
     * @param {quotesDeleteArgs} args - Arguments to delete one Quotes.
     * @example
     * // Delete one Quotes
     * const Quotes = await prisma.quotes.delete({
     *   where: {
     *     // ... filter to delete one Quotes
     *   }
     * })
     * 
    **/
    delete<T extends quotesDeleteArgs>(
      args: SelectSubset<T, quotesDeleteArgs>
    ): Prisma__quotesClient<quotesGetPayload<T>>

    /**
     * Update one Quotes.
     * @param {quotesUpdateArgs} args - Arguments to update one Quotes.
     * @example
     * // Update one Quotes
     * const quotes = await prisma.quotes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends quotesUpdateArgs>(
      args: SelectSubset<T, quotesUpdateArgs>
    ): Prisma__quotesClient<quotesGetPayload<T>>

    /**
     * Delete zero or more Quotes.
     * @param {quotesDeleteManyArgs} args - Arguments to filter Quotes to delete.
     * @example
     * // Delete a few Quotes
     * const { count } = await prisma.quotes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends quotesDeleteManyArgs>(
      args?: SelectSubset<T, quotesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quotesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quotes
     * const quotes = await prisma.quotes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends quotesUpdateManyArgs>(
      args: SelectSubset<T, quotesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Quotes.
     * @param {quotesUpsertArgs} args - Arguments to update or create a Quotes.
     * @example
     * // Update or create a Quotes
     * const quotes = await prisma.quotes.upsert({
     *   create: {
     *     // ... data to create a Quotes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quotes we want to update
     *   }
     * })
    **/
    upsert<T extends quotesUpsertArgs>(
      args: SelectSubset<T, quotesUpsertArgs>
    ): Prisma__quotesClient<quotesGetPayload<T>>

    /**
     * Count the number of Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quotesCountArgs} args - Arguments to filter Quotes to count.
     * @example
     * // Count the number of Quotes
     * const count = await prisma.quotes.count({
     *   where: {
     *     // ... the filter for the Quotes we want to count
     *   }
     * })
    **/
    count<T extends quotesCountArgs>(
      args?: Subset<T, quotesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuotesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuotesAggregateArgs>(args: Subset<T, QuotesAggregateArgs>): PrismaPromise<GetQuotesAggregateType<T>>

    /**
     * Group by Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuotesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuotesGroupByArgs['orderBy'] }
        : { orderBy?: QuotesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuotesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuotesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for quotes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__quotesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    orders<T extends quotes$ordersArgs= {}>(args?: Subset<T, quotes$ordersArgs>): PrismaPromise<Array<ordersGetPayload<T>>| Null>;

    tokenPairsInfo<T extends tokenPairsInfoArgs= {}>(args?: Subset<T, tokenPairsInfoArgs>): Prisma__tokenPairsInfoClient<tokenPairsInfoGetPayload<T> | Null>;

    quoteStatuses<T extends quoteStatusesArgs= {}>(args?: Subset<T, quoteStatusesArgs>): Prisma__quoteStatusesClient<quoteStatusesGetPayload<T> | Null>;

    assets_quotes_sourceAssetIdToassets<T extends assetsArgs= {}>(args?: Subset<T, assetsArgs>): Prisma__assetsClient<assetsGetPayload<T> | Null>;

    assets_quotes_targetAssetIdToassets<T extends assetsArgs= {}>(args?: Subset<T, assetsArgs>): Prisma__assetsClient<assetsGetPayload<T> | Null>;

    vendors<T extends vendorsArgs= {}>(args?: Subset<T, vendorsArgs>): Prisma__vendorsClient<vendorsGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * quotes base type for findUnique actions
   */
  export type quotesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the quotes
     */
    select?: quotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: quotesInclude | null
    /**
     * Filter, which quotes to fetch.
     */
    where: quotesWhereUniqueInput
  }

  /**
   * quotes findUnique
   */
  export interface quotesFindUniqueArgs extends quotesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * quotes findUniqueOrThrow
   */
  export type quotesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the quotes
     */
    select?: quotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: quotesInclude | null
    /**
     * Filter, which quotes to fetch.
     */
    where: quotesWhereUniqueInput
  }


  /**
   * quotes base type for findFirst actions
   */
  export type quotesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the quotes
     */
    select?: quotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: quotesInclude | null
    /**
     * Filter, which quotes to fetch.
     */
    where?: quotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quotes to fetch.
     */
    orderBy?: Enumerable<quotesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quotes.
     */
    cursor?: quotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quotes.
     */
    distinct?: Enumerable<QuotesScalarFieldEnum>
  }

  /**
   * quotes findFirst
   */
  export interface quotesFindFirstArgs extends quotesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * quotes findFirstOrThrow
   */
  export type quotesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the quotes
     */
    select?: quotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: quotesInclude | null
    /**
     * Filter, which quotes to fetch.
     */
    where?: quotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quotes to fetch.
     */
    orderBy?: Enumerable<quotesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quotes.
     */
    cursor?: quotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quotes.
     */
    distinct?: Enumerable<QuotesScalarFieldEnum>
  }


  /**
   * quotes findMany
   */
  export type quotesFindManyArgs = {
    /**
     * Select specific fields to fetch from the quotes
     */
    select?: quotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: quotesInclude | null
    /**
     * Filter, which quotes to fetch.
     */
    where?: quotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quotes to fetch.
     */
    orderBy?: Enumerable<quotesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing quotes.
     */
    cursor?: quotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quotes.
     */
    skip?: number
    distinct?: Enumerable<QuotesScalarFieldEnum>
  }


  /**
   * quotes create
   */
  export type quotesCreateArgs = {
    /**
     * Select specific fields to fetch from the quotes
     */
    select?: quotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: quotesInclude | null
    /**
     * The data needed to create a quotes.
     */
    data: XOR<quotesCreateInput, quotesUncheckedCreateInput>
  }


  /**
   * quotes createMany
   */
  export type quotesCreateManyArgs = {
    /**
     * The data used to create many quotes.
     */
    data: Enumerable<quotesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * quotes update
   */
  export type quotesUpdateArgs = {
    /**
     * Select specific fields to fetch from the quotes
     */
    select?: quotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: quotesInclude | null
    /**
     * The data needed to update a quotes.
     */
    data: XOR<quotesUpdateInput, quotesUncheckedUpdateInput>
    /**
     * Choose, which quotes to update.
     */
    where: quotesWhereUniqueInput
  }


  /**
   * quotes updateMany
   */
  export type quotesUpdateManyArgs = {
    /**
     * The data used to update quotes.
     */
    data: XOR<quotesUpdateManyMutationInput, quotesUncheckedUpdateManyInput>
    /**
     * Filter which quotes to update
     */
    where?: quotesWhereInput
  }


  /**
   * quotes upsert
   */
  export type quotesUpsertArgs = {
    /**
     * Select specific fields to fetch from the quotes
     */
    select?: quotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: quotesInclude | null
    /**
     * The filter to search for the quotes to update in case it exists.
     */
    where: quotesWhereUniqueInput
    /**
     * In case the quotes found by the `where` argument doesn't exist, create a new quotes with this data.
     */
    create: XOR<quotesCreateInput, quotesUncheckedCreateInput>
    /**
     * In case the quotes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<quotesUpdateInput, quotesUncheckedUpdateInput>
  }


  /**
   * quotes delete
   */
  export type quotesDeleteArgs = {
    /**
     * Select specific fields to fetch from the quotes
     */
    select?: quotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: quotesInclude | null
    /**
     * Filter which quotes to delete.
     */
    where: quotesWhereUniqueInput
  }


  /**
   * quotes deleteMany
   */
  export type quotesDeleteManyArgs = {
    /**
     * Filter which quotes to delete
     */
    where?: quotesWhereInput
  }


  /**
   * quotes.orders
   */
  export type quotes$ordersArgs = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ordersInclude | null
    where?: ordersWhereInput
    orderBy?: Enumerable<ordersOrderByWithRelationInput>
    cursor?: ordersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OrdersScalarFieldEnum>
  }


  /**
   * quotes without action
   */
  export type quotesArgs = {
    /**
     * Select specific fields to fetch from the quotes
     */
    select?: quotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: quotesInclude | null
  }



  /**
   * Model transactionStatusTypes
   */


  export type AggregateTransactionStatusTypes = {
    _count: TransactionStatusTypesCountAggregateOutputType | null
    _avg: TransactionStatusTypesAvgAggregateOutputType | null
    _sum: TransactionStatusTypesSumAggregateOutputType | null
    _min: TransactionStatusTypesMinAggregateOutputType | null
    _max: TransactionStatusTypesMaxAggregateOutputType | null
  }

  export type TransactionStatusTypesAvgAggregateOutputType = {
    id: number | null
  }

  export type TransactionStatusTypesSumAggregateOutputType = {
    id: number | null
  }

  export type TransactionStatusTypesMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionStatusTypesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionStatusTypesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionStatusTypesAvgAggregateInputType = {
    id?: true
  }

  export type TransactionStatusTypesSumAggregateInputType = {
    id?: true
  }

  export type TransactionStatusTypesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionStatusTypesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionStatusTypesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionStatusTypesAggregateArgs = {
    /**
     * Filter which transactionStatusTypes to aggregate.
     */
    where?: transactionStatusTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactionStatusTypes to fetch.
     */
    orderBy?: Enumerable<transactionStatusTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transactionStatusTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactionStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactionStatusTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transactionStatusTypes
    **/
    _count?: true | TransactionStatusTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionStatusTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionStatusTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionStatusTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionStatusTypesMaxAggregateInputType
  }

  export type GetTransactionStatusTypesAggregateType<T extends TransactionStatusTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionStatusTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionStatusTypes[P]>
      : GetScalarType<T[P], AggregateTransactionStatusTypes[P]>
  }




  export type TransactionStatusTypesGroupByArgs = {
    where?: transactionStatusTypesWhereInput
    orderBy?: Enumerable<transactionStatusTypesOrderByWithAggregationInput>
    by: TransactionStatusTypesScalarFieldEnum[]
    having?: transactionStatusTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionStatusTypesCountAggregateInputType | true
    _avg?: TransactionStatusTypesAvgAggregateInputType
    _sum?: TransactionStatusTypesSumAggregateInputType
    _min?: TransactionStatusTypesMinAggregateInputType
    _max?: TransactionStatusTypesMaxAggregateInputType
  }


  export type TransactionStatusTypesGroupByOutputType = {
    id: number
    name: string
    description: string
    createdAt: Date
    updatedAt: Date
    _count: TransactionStatusTypesCountAggregateOutputType | null
    _avg: TransactionStatusTypesAvgAggregateOutputType | null
    _sum: TransactionStatusTypesSumAggregateOutputType | null
    _min: TransactionStatusTypesMinAggregateOutputType | null
    _max: TransactionStatusTypesMaxAggregateOutputType | null
  }

  type GetTransactionStatusTypesGroupByPayload<T extends TransactionStatusTypesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TransactionStatusTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionStatusTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionStatusTypesGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionStatusTypesGroupByOutputType[P]>
        }
      >
    >


  export type transactionStatusTypesSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactions?: boolean | transactionStatusTypes$transactionsArgs
    _count?: boolean | TransactionStatusTypesCountOutputTypeArgs
  }


  export type transactionStatusTypesInclude = {
    transactions?: boolean | transactionStatusTypes$transactionsArgs
    _count?: boolean | TransactionStatusTypesCountOutputTypeArgs
  }

  export type transactionStatusTypesGetPayload<S extends boolean | null | undefined | transactionStatusTypesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? transactionStatusTypes :
    S extends undefined ? never :
    S extends { include: any } & (transactionStatusTypesArgs | transactionStatusTypesFindManyArgs)
    ? transactionStatusTypes  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'transactions' ? Array < transactionsGetPayload<S['include'][P]>>  :
        P extends '_count' ? TransactionStatusTypesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (transactionStatusTypesArgs | transactionStatusTypesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'transactions' ? Array < transactionsGetPayload<S['select'][P]>>  :
        P extends '_count' ? TransactionStatusTypesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof transactionStatusTypes ? transactionStatusTypes[P] : never
  } 
      : transactionStatusTypes


  type transactionStatusTypesCountArgs = 
    Omit<transactionStatusTypesFindManyArgs, 'select' | 'include'> & {
      select?: TransactionStatusTypesCountAggregateInputType | true
    }

  export interface transactionStatusTypesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TransactionStatusTypes that matches the filter.
     * @param {transactionStatusTypesFindUniqueArgs} args - Arguments to find a TransactionStatusTypes
     * @example
     * // Get one TransactionStatusTypes
     * const transactionStatusTypes = await prisma.transactionStatusTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends transactionStatusTypesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, transactionStatusTypesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'transactionStatusTypes'> extends True ? Prisma__transactionStatusTypesClient<transactionStatusTypesGetPayload<T>> : Prisma__transactionStatusTypesClient<transactionStatusTypesGetPayload<T> | null, null>

    /**
     * Find one TransactionStatusTypes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {transactionStatusTypesFindUniqueOrThrowArgs} args - Arguments to find a TransactionStatusTypes
     * @example
     * // Get one TransactionStatusTypes
     * const transactionStatusTypes = await prisma.transactionStatusTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends transactionStatusTypesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, transactionStatusTypesFindUniqueOrThrowArgs>
    ): Prisma__transactionStatusTypesClient<transactionStatusTypesGetPayload<T>>

    /**
     * Find the first TransactionStatusTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionStatusTypesFindFirstArgs} args - Arguments to find a TransactionStatusTypes
     * @example
     * // Get one TransactionStatusTypes
     * const transactionStatusTypes = await prisma.transactionStatusTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends transactionStatusTypesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, transactionStatusTypesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'transactionStatusTypes'> extends True ? Prisma__transactionStatusTypesClient<transactionStatusTypesGetPayload<T>> : Prisma__transactionStatusTypesClient<transactionStatusTypesGetPayload<T> | null, null>

    /**
     * Find the first TransactionStatusTypes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionStatusTypesFindFirstOrThrowArgs} args - Arguments to find a TransactionStatusTypes
     * @example
     * // Get one TransactionStatusTypes
     * const transactionStatusTypes = await prisma.transactionStatusTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends transactionStatusTypesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, transactionStatusTypesFindFirstOrThrowArgs>
    ): Prisma__transactionStatusTypesClient<transactionStatusTypesGetPayload<T>>

    /**
     * Find zero or more TransactionStatusTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionStatusTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionStatusTypes
     * const transactionStatusTypes = await prisma.transactionStatusTypes.findMany()
     * 
     * // Get first 10 TransactionStatusTypes
     * const transactionStatusTypes = await prisma.transactionStatusTypes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionStatusTypesWithIdOnly = await prisma.transactionStatusTypes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends transactionStatusTypesFindManyArgs>(
      args?: SelectSubset<T, transactionStatusTypesFindManyArgs>
    ): PrismaPromise<Array<transactionStatusTypesGetPayload<T>>>

    /**
     * Create a TransactionStatusTypes.
     * @param {transactionStatusTypesCreateArgs} args - Arguments to create a TransactionStatusTypes.
     * @example
     * // Create one TransactionStatusTypes
     * const TransactionStatusTypes = await prisma.transactionStatusTypes.create({
     *   data: {
     *     // ... data to create a TransactionStatusTypes
     *   }
     * })
     * 
    **/
    create<T extends transactionStatusTypesCreateArgs>(
      args: SelectSubset<T, transactionStatusTypesCreateArgs>
    ): Prisma__transactionStatusTypesClient<transactionStatusTypesGetPayload<T>>

    /**
     * Create many TransactionStatusTypes.
     *     @param {transactionStatusTypesCreateManyArgs} args - Arguments to create many TransactionStatusTypes.
     *     @example
     *     // Create many TransactionStatusTypes
     *     const transactionStatusTypes = await prisma.transactionStatusTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends transactionStatusTypesCreateManyArgs>(
      args?: SelectSubset<T, transactionStatusTypesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TransactionStatusTypes.
     * @param {transactionStatusTypesDeleteArgs} args - Arguments to delete one TransactionStatusTypes.
     * @example
     * // Delete one TransactionStatusTypes
     * const TransactionStatusTypes = await prisma.transactionStatusTypes.delete({
     *   where: {
     *     // ... filter to delete one TransactionStatusTypes
     *   }
     * })
     * 
    **/
    delete<T extends transactionStatusTypesDeleteArgs>(
      args: SelectSubset<T, transactionStatusTypesDeleteArgs>
    ): Prisma__transactionStatusTypesClient<transactionStatusTypesGetPayload<T>>

    /**
     * Update one TransactionStatusTypes.
     * @param {transactionStatusTypesUpdateArgs} args - Arguments to update one TransactionStatusTypes.
     * @example
     * // Update one TransactionStatusTypes
     * const transactionStatusTypes = await prisma.transactionStatusTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends transactionStatusTypesUpdateArgs>(
      args: SelectSubset<T, transactionStatusTypesUpdateArgs>
    ): Prisma__transactionStatusTypesClient<transactionStatusTypesGetPayload<T>>

    /**
     * Delete zero or more TransactionStatusTypes.
     * @param {transactionStatusTypesDeleteManyArgs} args - Arguments to filter TransactionStatusTypes to delete.
     * @example
     * // Delete a few TransactionStatusTypes
     * const { count } = await prisma.transactionStatusTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends transactionStatusTypesDeleteManyArgs>(
      args?: SelectSubset<T, transactionStatusTypesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionStatusTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionStatusTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionStatusTypes
     * const transactionStatusTypes = await prisma.transactionStatusTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends transactionStatusTypesUpdateManyArgs>(
      args: SelectSubset<T, transactionStatusTypesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TransactionStatusTypes.
     * @param {transactionStatusTypesUpsertArgs} args - Arguments to update or create a TransactionStatusTypes.
     * @example
     * // Update or create a TransactionStatusTypes
     * const transactionStatusTypes = await prisma.transactionStatusTypes.upsert({
     *   create: {
     *     // ... data to create a TransactionStatusTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionStatusTypes we want to update
     *   }
     * })
    **/
    upsert<T extends transactionStatusTypesUpsertArgs>(
      args: SelectSubset<T, transactionStatusTypesUpsertArgs>
    ): Prisma__transactionStatusTypesClient<transactionStatusTypesGetPayload<T>>

    /**
     * Count the number of TransactionStatusTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionStatusTypesCountArgs} args - Arguments to filter TransactionStatusTypes to count.
     * @example
     * // Count the number of TransactionStatusTypes
     * const count = await prisma.transactionStatusTypes.count({
     *   where: {
     *     // ... the filter for the TransactionStatusTypes we want to count
     *   }
     * })
    **/
    count<T extends transactionStatusTypesCountArgs>(
      args?: Subset<T, transactionStatusTypesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionStatusTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionStatusTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionStatusTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionStatusTypesAggregateArgs>(args: Subset<T, TransactionStatusTypesAggregateArgs>): PrismaPromise<GetTransactionStatusTypesAggregateType<T>>

    /**
     * Group by TransactionStatusTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionStatusTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionStatusTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionStatusTypesGroupByArgs['orderBy'] }
        : { orderBy?: TransactionStatusTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionStatusTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionStatusTypesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for transactionStatusTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__transactionStatusTypesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    transactions<T extends transactionStatusTypes$transactionsArgs= {}>(args?: Subset<T, transactionStatusTypes$transactionsArgs>): PrismaPromise<Array<transactionsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * transactionStatusTypes base type for findUnique actions
   */
  export type transactionStatusTypesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the transactionStatusTypes
     */
    select?: transactionStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionStatusTypesInclude | null
    /**
     * Filter, which transactionStatusTypes to fetch.
     */
    where: transactionStatusTypesWhereUniqueInput
  }

  /**
   * transactionStatusTypes findUnique
   */
  export interface transactionStatusTypesFindUniqueArgs extends transactionStatusTypesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * transactionStatusTypes findUniqueOrThrow
   */
  export type transactionStatusTypesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the transactionStatusTypes
     */
    select?: transactionStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionStatusTypesInclude | null
    /**
     * Filter, which transactionStatusTypes to fetch.
     */
    where: transactionStatusTypesWhereUniqueInput
  }


  /**
   * transactionStatusTypes base type for findFirst actions
   */
  export type transactionStatusTypesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the transactionStatusTypes
     */
    select?: transactionStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionStatusTypesInclude | null
    /**
     * Filter, which transactionStatusTypes to fetch.
     */
    where?: transactionStatusTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactionStatusTypes to fetch.
     */
    orderBy?: Enumerable<transactionStatusTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactionStatusTypes.
     */
    cursor?: transactionStatusTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactionStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactionStatusTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactionStatusTypes.
     */
    distinct?: Enumerable<TransactionStatusTypesScalarFieldEnum>
  }

  /**
   * transactionStatusTypes findFirst
   */
  export interface transactionStatusTypesFindFirstArgs extends transactionStatusTypesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * transactionStatusTypes findFirstOrThrow
   */
  export type transactionStatusTypesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the transactionStatusTypes
     */
    select?: transactionStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionStatusTypesInclude | null
    /**
     * Filter, which transactionStatusTypes to fetch.
     */
    where?: transactionStatusTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactionStatusTypes to fetch.
     */
    orderBy?: Enumerable<transactionStatusTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactionStatusTypes.
     */
    cursor?: transactionStatusTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactionStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactionStatusTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactionStatusTypes.
     */
    distinct?: Enumerable<TransactionStatusTypesScalarFieldEnum>
  }


  /**
   * transactionStatusTypes findMany
   */
  export type transactionStatusTypesFindManyArgs = {
    /**
     * Select specific fields to fetch from the transactionStatusTypes
     */
    select?: transactionStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionStatusTypesInclude | null
    /**
     * Filter, which transactionStatusTypes to fetch.
     */
    where?: transactionStatusTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactionStatusTypes to fetch.
     */
    orderBy?: Enumerable<transactionStatusTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transactionStatusTypes.
     */
    cursor?: transactionStatusTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactionStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactionStatusTypes.
     */
    skip?: number
    distinct?: Enumerable<TransactionStatusTypesScalarFieldEnum>
  }


  /**
   * transactionStatusTypes create
   */
  export type transactionStatusTypesCreateArgs = {
    /**
     * Select specific fields to fetch from the transactionStatusTypes
     */
    select?: transactionStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionStatusTypesInclude | null
    /**
     * The data needed to create a transactionStatusTypes.
     */
    data: XOR<transactionStatusTypesCreateInput, transactionStatusTypesUncheckedCreateInput>
  }


  /**
   * transactionStatusTypes createMany
   */
  export type transactionStatusTypesCreateManyArgs = {
    /**
     * The data used to create many transactionStatusTypes.
     */
    data: Enumerable<transactionStatusTypesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * transactionStatusTypes update
   */
  export type transactionStatusTypesUpdateArgs = {
    /**
     * Select specific fields to fetch from the transactionStatusTypes
     */
    select?: transactionStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionStatusTypesInclude | null
    /**
     * The data needed to update a transactionStatusTypes.
     */
    data: XOR<transactionStatusTypesUpdateInput, transactionStatusTypesUncheckedUpdateInput>
    /**
     * Choose, which transactionStatusTypes to update.
     */
    where: transactionStatusTypesWhereUniqueInput
  }


  /**
   * transactionStatusTypes updateMany
   */
  export type transactionStatusTypesUpdateManyArgs = {
    /**
     * The data used to update transactionStatusTypes.
     */
    data: XOR<transactionStatusTypesUpdateManyMutationInput, transactionStatusTypesUncheckedUpdateManyInput>
    /**
     * Filter which transactionStatusTypes to update
     */
    where?: transactionStatusTypesWhereInput
  }


  /**
   * transactionStatusTypes upsert
   */
  export type transactionStatusTypesUpsertArgs = {
    /**
     * Select specific fields to fetch from the transactionStatusTypes
     */
    select?: transactionStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionStatusTypesInclude | null
    /**
     * The filter to search for the transactionStatusTypes to update in case it exists.
     */
    where: transactionStatusTypesWhereUniqueInput
    /**
     * In case the transactionStatusTypes found by the `where` argument doesn't exist, create a new transactionStatusTypes with this data.
     */
    create: XOR<transactionStatusTypesCreateInput, transactionStatusTypesUncheckedCreateInput>
    /**
     * In case the transactionStatusTypes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transactionStatusTypesUpdateInput, transactionStatusTypesUncheckedUpdateInput>
  }


  /**
   * transactionStatusTypes delete
   */
  export type transactionStatusTypesDeleteArgs = {
    /**
     * Select specific fields to fetch from the transactionStatusTypes
     */
    select?: transactionStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionStatusTypesInclude | null
    /**
     * Filter which transactionStatusTypes to delete.
     */
    where: transactionStatusTypesWhereUniqueInput
  }


  /**
   * transactionStatusTypes deleteMany
   */
  export type transactionStatusTypesDeleteManyArgs = {
    /**
     * Filter which transactionStatusTypes to delete
     */
    where?: transactionStatusTypesWhereInput
  }


  /**
   * transactionStatusTypes.transactions
   */
  export type transactionStatusTypes$transactionsArgs = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionsInclude | null
    where?: transactionsWhereInput
    orderBy?: Enumerable<transactionsOrderByWithRelationInput>
    cursor?: transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TransactionsScalarFieldEnum>
  }


  /**
   * transactionStatusTypes without action
   */
  export type transactionStatusTypesArgs = {
    /**
     * Select specific fields to fetch from the transactionStatusTypes
     */
    select?: transactionStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionStatusTypesInclude | null
  }



  /**
   * Model transactionTypes
   */


  export type AggregateTransactionTypes = {
    _count: TransactionTypesCountAggregateOutputType | null
    _avg: TransactionTypesAvgAggregateOutputType | null
    _sum: TransactionTypesSumAggregateOutputType | null
    _min: TransactionTypesMinAggregateOutputType | null
    _max: TransactionTypesMaxAggregateOutputType | null
  }

  export type TransactionTypesAvgAggregateOutputType = {
    id: number | null
  }

  export type TransactionTypesSumAggregateOutputType = {
    id: number | null
  }

  export type TransactionTypesMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionTypesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionTypesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionTypesAvgAggregateInputType = {
    id?: true
  }

  export type TransactionTypesSumAggregateInputType = {
    id?: true
  }

  export type TransactionTypesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionTypesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionTypesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionTypesAggregateArgs = {
    /**
     * Filter which transactionTypes to aggregate.
     */
    where?: transactionTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactionTypes to fetch.
     */
    orderBy?: Enumerable<transactionTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transactionTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactionTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transactionTypes
    **/
    _count?: true | TransactionTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionTypesMaxAggregateInputType
  }

  export type GetTransactionTypesAggregateType<T extends TransactionTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionTypes[P]>
      : GetScalarType<T[P], AggregateTransactionTypes[P]>
  }




  export type TransactionTypesGroupByArgs = {
    where?: transactionTypesWhereInput
    orderBy?: Enumerable<transactionTypesOrderByWithAggregationInput>
    by: TransactionTypesScalarFieldEnum[]
    having?: transactionTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionTypesCountAggregateInputType | true
    _avg?: TransactionTypesAvgAggregateInputType
    _sum?: TransactionTypesSumAggregateInputType
    _min?: TransactionTypesMinAggregateInputType
    _max?: TransactionTypesMaxAggregateInputType
  }


  export type TransactionTypesGroupByOutputType = {
    id: number
    name: string
    description: string
    createdAt: Date
    updatedAt: Date
    _count: TransactionTypesCountAggregateOutputType | null
    _avg: TransactionTypesAvgAggregateOutputType | null
    _sum: TransactionTypesSumAggregateOutputType | null
    _min: TransactionTypesMinAggregateOutputType | null
    _max: TransactionTypesMaxAggregateOutputType | null
  }

  type GetTransactionTypesGroupByPayload<T extends TransactionTypesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TransactionTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionTypesGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionTypesGroupByOutputType[P]>
        }
      >
    >


  export type transactionTypesSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactionPolicies?: boolean | transactionTypes$transactionPoliciesArgs
    transactions?: boolean | transactionTypes$transactionsArgs
    _count?: boolean | TransactionTypesCountOutputTypeArgs
  }


  export type transactionTypesInclude = {
    transactionPolicies?: boolean | transactionTypes$transactionPoliciesArgs
    transactions?: boolean | transactionTypes$transactionsArgs
    _count?: boolean | TransactionTypesCountOutputTypeArgs
  }

  export type transactionTypesGetPayload<S extends boolean | null | undefined | transactionTypesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? transactionTypes :
    S extends undefined ? never :
    S extends { include: any } & (transactionTypesArgs | transactionTypesFindManyArgs)
    ? transactionTypes  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'transactionPolicies' ? Array < transactionPoliciesGetPayload<S['include'][P]>>  :
        P extends 'transactions' ? Array < transactionsGetPayload<S['include'][P]>>  :
        P extends '_count' ? TransactionTypesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (transactionTypesArgs | transactionTypesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'transactionPolicies' ? Array < transactionPoliciesGetPayload<S['select'][P]>>  :
        P extends 'transactions' ? Array < transactionsGetPayload<S['select'][P]>>  :
        P extends '_count' ? TransactionTypesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof transactionTypes ? transactionTypes[P] : never
  } 
      : transactionTypes


  type transactionTypesCountArgs = 
    Omit<transactionTypesFindManyArgs, 'select' | 'include'> & {
      select?: TransactionTypesCountAggregateInputType | true
    }

  export interface transactionTypesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TransactionTypes that matches the filter.
     * @param {transactionTypesFindUniqueArgs} args - Arguments to find a TransactionTypes
     * @example
     * // Get one TransactionTypes
     * const transactionTypes = await prisma.transactionTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends transactionTypesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, transactionTypesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'transactionTypes'> extends True ? Prisma__transactionTypesClient<transactionTypesGetPayload<T>> : Prisma__transactionTypesClient<transactionTypesGetPayload<T> | null, null>

    /**
     * Find one TransactionTypes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {transactionTypesFindUniqueOrThrowArgs} args - Arguments to find a TransactionTypes
     * @example
     * // Get one TransactionTypes
     * const transactionTypes = await prisma.transactionTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends transactionTypesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, transactionTypesFindUniqueOrThrowArgs>
    ): Prisma__transactionTypesClient<transactionTypesGetPayload<T>>

    /**
     * Find the first TransactionTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionTypesFindFirstArgs} args - Arguments to find a TransactionTypes
     * @example
     * // Get one TransactionTypes
     * const transactionTypes = await prisma.transactionTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends transactionTypesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, transactionTypesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'transactionTypes'> extends True ? Prisma__transactionTypesClient<transactionTypesGetPayload<T>> : Prisma__transactionTypesClient<transactionTypesGetPayload<T> | null, null>

    /**
     * Find the first TransactionTypes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionTypesFindFirstOrThrowArgs} args - Arguments to find a TransactionTypes
     * @example
     * // Get one TransactionTypes
     * const transactionTypes = await prisma.transactionTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends transactionTypesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, transactionTypesFindFirstOrThrowArgs>
    ): Prisma__transactionTypesClient<transactionTypesGetPayload<T>>

    /**
     * Find zero or more TransactionTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionTypes
     * const transactionTypes = await prisma.transactionTypes.findMany()
     * 
     * // Get first 10 TransactionTypes
     * const transactionTypes = await prisma.transactionTypes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionTypesWithIdOnly = await prisma.transactionTypes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends transactionTypesFindManyArgs>(
      args?: SelectSubset<T, transactionTypesFindManyArgs>
    ): PrismaPromise<Array<transactionTypesGetPayload<T>>>

    /**
     * Create a TransactionTypes.
     * @param {transactionTypesCreateArgs} args - Arguments to create a TransactionTypes.
     * @example
     * // Create one TransactionTypes
     * const TransactionTypes = await prisma.transactionTypes.create({
     *   data: {
     *     // ... data to create a TransactionTypes
     *   }
     * })
     * 
    **/
    create<T extends transactionTypesCreateArgs>(
      args: SelectSubset<T, transactionTypesCreateArgs>
    ): Prisma__transactionTypesClient<transactionTypesGetPayload<T>>

    /**
     * Create many TransactionTypes.
     *     @param {transactionTypesCreateManyArgs} args - Arguments to create many TransactionTypes.
     *     @example
     *     // Create many TransactionTypes
     *     const transactionTypes = await prisma.transactionTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends transactionTypesCreateManyArgs>(
      args?: SelectSubset<T, transactionTypesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TransactionTypes.
     * @param {transactionTypesDeleteArgs} args - Arguments to delete one TransactionTypes.
     * @example
     * // Delete one TransactionTypes
     * const TransactionTypes = await prisma.transactionTypes.delete({
     *   where: {
     *     // ... filter to delete one TransactionTypes
     *   }
     * })
     * 
    **/
    delete<T extends transactionTypesDeleteArgs>(
      args: SelectSubset<T, transactionTypesDeleteArgs>
    ): Prisma__transactionTypesClient<transactionTypesGetPayload<T>>

    /**
     * Update one TransactionTypes.
     * @param {transactionTypesUpdateArgs} args - Arguments to update one TransactionTypes.
     * @example
     * // Update one TransactionTypes
     * const transactionTypes = await prisma.transactionTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends transactionTypesUpdateArgs>(
      args: SelectSubset<T, transactionTypesUpdateArgs>
    ): Prisma__transactionTypesClient<transactionTypesGetPayload<T>>

    /**
     * Delete zero or more TransactionTypes.
     * @param {transactionTypesDeleteManyArgs} args - Arguments to filter TransactionTypes to delete.
     * @example
     * // Delete a few TransactionTypes
     * const { count } = await prisma.transactionTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends transactionTypesDeleteManyArgs>(
      args?: SelectSubset<T, transactionTypesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionTypes
     * const transactionTypes = await prisma.transactionTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends transactionTypesUpdateManyArgs>(
      args: SelectSubset<T, transactionTypesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TransactionTypes.
     * @param {transactionTypesUpsertArgs} args - Arguments to update or create a TransactionTypes.
     * @example
     * // Update or create a TransactionTypes
     * const transactionTypes = await prisma.transactionTypes.upsert({
     *   create: {
     *     // ... data to create a TransactionTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionTypes we want to update
     *   }
     * })
    **/
    upsert<T extends transactionTypesUpsertArgs>(
      args: SelectSubset<T, transactionTypesUpsertArgs>
    ): Prisma__transactionTypesClient<transactionTypesGetPayload<T>>

    /**
     * Count the number of TransactionTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionTypesCountArgs} args - Arguments to filter TransactionTypes to count.
     * @example
     * // Count the number of TransactionTypes
     * const count = await prisma.transactionTypes.count({
     *   where: {
     *     // ... the filter for the TransactionTypes we want to count
     *   }
     * })
    **/
    count<T extends transactionTypesCountArgs>(
      args?: Subset<T, transactionTypesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionTypesAggregateArgs>(args: Subset<T, TransactionTypesAggregateArgs>): PrismaPromise<GetTransactionTypesAggregateType<T>>

    /**
     * Group by TransactionTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionTypesGroupByArgs['orderBy'] }
        : { orderBy?: TransactionTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionTypesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for transactionTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__transactionTypesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    transactionPolicies<T extends transactionTypes$transactionPoliciesArgs= {}>(args?: Subset<T, transactionTypes$transactionPoliciesArgs>): PrismaPromise<Array<transactionPoliciesGetPayload<T>>| Null>;

    transactions<T extends transactionTypes$transactionsArgs= {}>(args?: Subset<T, transactionTypes$transactionsArgs>): PrismaPromise<Array<transactionsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * transactionTypes base type for findUnique actions
   */
  export type transactionTypesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the transactionTypes
     */
    select?: transactionTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionTypesInclude | null
    /**
     * Filter, which transactionTypes to fetch.
     */
    where: transactionTypesWhereUniqueInput
  }

  /**
   * transactionTypes findUnique
   */
  export interface transactionTypesFindUniqueArgs extends transactionTypesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * transactionTypes findUniqueOrThrow
   */
  export type transactionTypesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the transactionTypes
     */
    select?: transactionTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionTypesInclude | null
    /**
     * Filter, which transactionTypes to fetch.
     */
    where: transactionTypesWhereUniqueInput
  }


  /**
   * transactionTypes base type for findFirst actions
   */
  export type transactionTypesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the transactionTypes
     */
    select?: transactionTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionTypesInclude | null
    /**
     * Filter, which transactionTypes to fetch.
     */
    where?: transactionTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactionTypes to fetch.
     */
    orderBy?: Enumerable<transactionTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactionTypes.
     */
    cursor?: transactionTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactionTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactionTypes.
     */
    distinct?: Enumerable<TransactionTypesScalarFieldEnum>
  }

  /**
   * transactionTypes findFirst
   */
  export interface transactionTypesFindFirstArgs extends transactionTypesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * transactionTypes findFirstOrThrow
   */
  export type transactionTypesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the transactionTypes
     */
    select?: transactionTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionTypesInclude | null
    /**
     * Filter, which transactionTypes to fetch.
     */
    where?: transactionTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactionTypes to fetch.
     */
    orderBy?: Enumerable<transactionTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactionTypes.
     */
    cursor?: transactionTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactionTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactionTypes.
     */
    distinct?: Enumerable<TransactionTypesScalarFieldEnum>
  }


  /**
   * transactionTypes findMany
   */
  export type transactionTypesFindManyArgs = {
    /**
     * Select specific fields to fetch from the transactionTypes
     */
    select?: transactionTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionTypesInclude | null
    /**
     * Filter, which transactionTypes to fetch.
     */
    where?: transactionTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactionTypes to fetch.
     */
    orderBy?: Enumerable<transactionTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transactionTypes.
     */
    cursor?: transactionTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactionTypes.
     */
    skip?: number
    distinct?: Enumerable<TransactionTypesScalarFieldEnum>
  }


  /**
   * transactionTypes create
   */
  export type transactionTypesCreateArgs = {
    /**
     * Select specific fields to fetch from the transactionTypes
     */
    select?: transactionTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionTypesInclude | null
    /**
     * The data needed to create a transactionTypes.
     */
    data: XOR<transactionTypesCreateInput, transactionTypesUncheckedCreateInput>
  }


  /**
   * transactionTypes createMany
   */
  export type transactionTypesCreateManyArgs = {
    /**
     * The data used to create many transactionTypes.
     */
    data: Enumerable<transactionTypesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * transactionTypes update
   */
  export type transactionTypesUpdateArgs = {
    /**
     * Select specific fields to fetch from the transactionTypes
     */
    select?: transactionTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionTypesInclude | null
    /**
     * The data needed to update a transactionTypes.
     */
    data: XOR<transactionTypesUpdateInput, transactionTypesUncheckedUpdateInput>
    /**
     * Choose, which transactionTypes to update.
     */
    where: transactionTypesWhereUniqueInput
  }


  /**
   * transactionTypes updateMany
   */
  export type transactionTypesUpdateManyArgs = {
    /**
     * The data used to update transactionTypes.
     */
    data: XOR<transactionTypesUpdateManyMutationInput, transactionTypesUncheckedUpdateManyInput>
    /**
     * Filter which transactionTypes to update
     */
    where?: transactionTypesWhereInput
  }


  /**
   * transactionTypes upsert
   */
  export type transactionTypesUpsertArgs = {
    /**
     * Select specific fields to fetch from the transactionTypes
     */
    select?: transactionTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionTypesInclude | null
    /**
     * The filter to search for the transactionTypes to update in case it exists.
     */
    where: transactionTypesWhereUniqueInput
    /**
     * In case the transactionTypes found by the `where` argument doesn't exist, create a new transactionTypes with this data.
     */
    create: XOR<transactionTypesCreateInput, transactionTypesUncheckedCreateInput>
    /**
     * In case the transactionTypes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transactionTypesUpdateInput, transactionTypesUncheckedUpdateInput>
  }


  /**
   * transactionTypes delete
   */
  export type transactionTypesDeleteArgs = {
    /**
     * Select specific fields to fetch from the transactionTypes
     */
    select?: transactionTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionTypesInclude | null
    /**
     * Filter which transactionTypes to delete.
     */
    where: transactionTypesWhereUniqueInput
  }


  /**
   * transactionTypes deleteMany
   */
  export type transactionTypesDeleteManyArgs = {
    /**
     * Filter which transactionTypes to delete
     */
    where?: transactionTypesWhereInput
  }


  /**
   * transactionTypes.transactionPolicies
   */
  export type transactionTypes$transactionPoliciesArgs = {
    /**
     * Select specific fields to fetch from the transactionPolicies
     */
    select?: transactionPoliciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionPoliciesInclude | null
    where?: transactionPoliciesWhereInput
    orderBy?: Enumerable<transactionPoliciesOrderByWithRelationInput>
    cursor?: transactionPoliciesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TransactionPoliciesScalarFieldEnum>
  }


  /**
   * transactionTypes.transactions
   */
  export type transactionTypes$transactionsArgs = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionsInclude | null
    where?: transactionsWhereInput
    orderBy?: Enumerable<transactionsOrderByWithRelationInput>
    cursor?: transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TransactionsScalarFieldEnum>
  }


  /**
   * transactionTypes without action
   */
  export type transactionTypesArgs = {
    /**
     * Select specific fields to fetch from the transactionTypes
     */
    select?: transactionTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionTypesInclude | null
  }



  /**
   * Model transactions
   */


  export type AggregateTransactions = {
    _count: TransactionsCountAggregateOutputType | null
    _avg: TransactionsAvgAggregateOutputType | null
    _sum: TransactionsSumAggregateOutputType | null
    _min: TransactionsMinAggregateOutputType | null
    _max: TransactionsMaxAggregateOutputType | null
  }

  export type TransactionsAvgAggregateOutputType = {
    custodyVendorId: number | null
    transactionTypeId: number | null
    assetId: number | null
    transactionStatusTypeId: number | null
  }

  export type TransactionsSumAggregateOutputType = {
    custodyVendorId: number | null
    transactionTypeId: number | null
    assetId: number | null
    transactionStatusTypeId: number | null
  }

  export type TransactionsMinAggregateOutputType = {
    id: string | null
    custodyVendorId: number | null
    custodyVendorRef: string | null
    transactionTypeId: number | null
    amountAsset: string | null
    amountUSD: string | null
    assetId: number | null
    transactionStatusTypeId: number | null
    onChainTxId: string | null
    sourceVaultId: string | null
    targetVaultId: string | null
    targetWithdrawalAddressId: string | null
    sourceExternalAddress: string | null
    createdByUserId: string | null
    subjectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionsMaxAggregateOutputType = {
    id: string | null
    custodyVendorId: number | null
    custodyVendorRef: string | null
    transactionTypeId: number | null
    amountAsset: string | null
    amountUSD: string | null
    assetId: number | null
    transactionStatusTypeId: number | null
    onChainTxId: string | null
    sourceVaultId: string | null
    targetVaultId: string | null
    targetWithdrawalAddressId: string | null
    sourceExternalAddress: string | null
    createdByUserId: string | null
    subjectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionsCountAggregateOutputType = {
    id: number
    custodyVendorId: number
    custodyVendorRef: number
    transactionTypeId: number
    amountAsset: number
    amountUSD: number
    assetId: number
    transactionStatusTypeId: number
    onChainTxId: number
    sourceVaultId: number
    targetVaultId: number
    targetWithdrawalAddressId: number
    sourceExternalAddress: number
    createdByUserId: number
    subjectId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionsAvgAggregateInputType = {
    custodyVendorId?: true
    transactionTypeId?: true
    assetId?: true
    transactionStatusTypeId?: true
  }

  export type TransactionsSumAggregateInputType = {
    custodyVendorId?: true
    transactionTypeId?: true
    assetId?: true
    transactionStatusTypeId?: true
  }

  export type TransactionsMinAggregateInputType = {
    id?: true
    custodyVendorId?: true
    custodyVendorRef?: true
    transactionTypeId?: true
    amountAsset?: true
    amountUSD?: true
    assetId?: true
    transactionStatusTypeId?: true
    onChainTxId?: true
    sourceVaultId?: true
    targetVaultId?: true
    targetWithdrawalAddressId?: true
    sourceExternalAddress?: true
    createdByUserId?: true
    subjectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionsMaxAggregateInputType = {
    id?: true
    custodyVendorId?: true
    custodyVendorRef?: true
    transactionTypeId?: true
    amountAsset?: true
    amountUSD?: true
    assetId?: true
    transactionStatusTypeId?: true
    onChainTxId?: true
    sourceVaultId?: true
    targetVaultId?: true
    targetWithdrawalAddressId?: true
    sourceExternalAddress?: true
    createdByUserId?: true
    subjectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionsCountAggregateInputType = {
    id?: true
    custodyVendorId?: true
    custodyVendorRef?: true
    transactionTypeId?: true
    amountAsset?: true
    amountUSD?: true
    assetId?: true
    transactionStatusTypeId?: true
    onChainTxId?: true
    sourceVaultId?: true
    targetVaultId?: true
    targetWithdrawalAddressId?: true
    sourceExternalAddress?: true
    createdByUserId?: true
    subjectId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionsAggregateArgs = {
    /**
     * Filter which transactions to aggregate.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: Enumerable<transactionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transactions
    **/
    _count?: true | TransactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionsMaxAggregateInputType
  }

  export type GetTransactionsAggregateType<T extends TransactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactions[P]>
      : GetScalarType<T[P], AggregateTransactions[P]>
  }




  export type TransactionsGroupByArgs = {
    where?: transactionsWhereInput
    orderBy?: Enumerable<transactionsOrderByWithAggregationInput>
    by: TransactionsScalarFieldEnum[]
    having?: transactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionsCountAggregateInputType | true
    _avg?: TransactionsAvgAggregateInputType
    _sum?: TransactionsSumAggregateInputType
    _min?: TransactionsMinAggregateInputType
    _max?: TransactionsMaxAggregateInputType
  }


  export type TransactionsGroupByOutputType = {
    id: string
    custodyVendorId: number
    custodyVendorRef: string
    transactionTypeId: number
    amountAsset: string
    amountUSD: string
    assetId: number
    transactionStatusTypeId: number
    onChainTxId: string | null
    sourceVaultId: string | null
    targetVaultId: string | null
    targetWithdrawalAddressId: string | null
    sourceExternalAddress: string | null
    createdByUserId: string | null
    subjectId: string
    createdAt: Date
    updatedAt: Date
    _count: TransactionsCountAggregateOutputType | null
    _avg: TransactionsAvgAggregateOutputType | null
    _sum: TransactionsSumAggregateOutputType | null
    _min: TransactionsMinAggregateOutputType | null
    _max: TransactionsMaxAggregateOutputType | null
  }

  type GetTransactionsGroupByPayload<T extends TransactionsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TransactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionsGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionsGroupByOutputType[P]>
        }
      >
    >


  export type transactionsSelect = {
    id?: boolean
    custodyVendorId?: boolean
    custodyVendorRef?: boolean
    transactionTypeId?: boolean
    amountAsset?: boolean
    amountUSD?: boolean
    assetId?: boolean
    transactionStatusTypeId?: boolean
    onChainTxId?: boolean
    sourceVaultId?: boolean
    targetVaultId?: boolean
    targetWithdrawalAddressId?: boolean
    sourceExternalAddress?: boolean
    createdByUserId?: boolean
    subjectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assets?: boolean | assetsArgs
    users?: boolean | usersArgs
    vendors?: boolean | vendorsArgs
    vaults_transactions_sourceVaultIdTovaults?: boolean | vaultsArgs
    vaults_transactions_targetVaultIdTovaults?: boolean | vaultsArgs
    withdrawalAddresses?: boolean | withdrawalAddressesArgs
    transactionStatusTypes?: boolean | transactionStatusTypesArgs
    transactionTypes?: boolean | transactionTypesArgs
  }


  export type transactionsInclude = {
    assets?: boolean | assetsArgs
    users?: boolean | usersArgs
    vendors?: boolean | vendorsArgs
    vaults_transactions_sourceVaultIdTovaults?: boolean | vaultsArgs
    vaults_transactions_targetVaultIdTovaults?: boolean | vaultsArgs
    withdrawalAddresses?: boolean | withdrawalAddressesArgs
    transactionStatusTypes?: boolean | transactionStatusTypesArgs
    transactionTypes?: boolean | transactionTypesArgs
  }

  export type transactionsGetPayload<S extends boolean | null | undefined | transactionsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? transactions :
    S extends undefined ? never :
    S extends { include: any } & (transactionsArgs | transactionsFindManyArgs)
    ? transactions  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'assets' ? assetsGetPayload<S['include'][P]> :
        P extends 'users' ? usersGetPayload<S['include'][P]> | null :
        P extends 'vendors' ? vendorsGetPayload<S['include'][P]> :
        P extends 'vaults_transactions_sourceVaultIdTovaults' ? vaultsGetPayload<S['include'][P]> | null :
        P extends 'vaults_transactions_targetVaultIdTovaults' ? vaultsGetPayload<S['include'][P]> | null :
        P extends 'withdrawalAddresses' ? withdrawalAddressesGetPayload<S['include'][P]> | null :
        P extends 'transactionStatusTypes' ? transactionStatusTypesGetPayload<S['include'][P]> :
        P extends 'transactionTypes' ? transactionTypesGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (transactionsArgs | transactionsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'assets' ? assetsGetPayload<S['select'][P]> :
        P extends 'users' ? usersGetPayload<S['select'][P]> | null :
        P extends 'vendors' ? vendorsGetPayload<S['select'][P]> :
        P extends 'vaults_transactions_sourceVaultIdTovaults' ? vaultsGetPayload<S['select'][P]> | null :
        P extends 'vaults_transactions_targetVaultIdTovaults' ? vaultsGetPayload<S['select'][P]> | null :
        P extends 'withdrawalAddresses' ? withdrawalAddressesGetPayload<S['select'][P]> | null :
        P extends 'transactionStatusTypes' ? transactionStatusTypesGetPayload<S['select'][P]> :
        P extends 'transactionTypes' ? transactionTypesGetPayload<S['select'][P]> :  P extends keyof transactions ? transactions[P] : never
  } 
      : transactions


  type transactionsCountArgs = 
    Omit<transactionsFindManyArgs, 'select' | 'include'> & {
      select?: TransactionsCountAggregateInputType | true
    }

  export interface transactionsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Transactions that matches the filter.
     * @param {transactionsFindUniqueArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends transactionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, transactionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'transactions'> extends True ? Prisma__transactionsClient<transactionsGetPayload<T>> : Prisma__transactionsClient<transactionsGetPayload<T> | null, null>

    /**
     * Find one Transactions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {transactionsFindUniqueOrThrowArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends transactionsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, transactionsFindUniqueOrThrowArgs>
    ): Prisma__transactionsClient<transactionsGetPayload<T>>

    /**
     * Find the first Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsFindFirstArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends transactionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, transactionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'transactions'> extends True ? Prisma__transactionsClient<transactionsGetPayload<T>> : Prisma__transactionsClient<transactionsGetPayload<T> | null, null>

    /**
     * Find the first Transactions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsFindFirstOrThrowArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends transactionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, transactionsFindFirstOrThrowArgs>
    ): Prisma__transactionsClient<transactionsGetPayload<T>>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transactions.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionsWithIdOnly = await prisma.transactions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends transactionsFindManyArgs>(
      args?: SelectSubset<T, transactionsFindManyArgs>
    ): PrismaPromise<Array<transactionsGetPayload<T>>>

    /**
     * Create a Transactions.
     * @param {transactionsCreateArgs} args - Arguments to create a Transactions.
     * @example
     * // Create one Transactions
     * const Transactions = await prisma.transactions.create({
     *   data: {
     *     // ... data to create a Transactions
     *   }
     * })
     * 
    **/
    create<T extends transactionsCreateArgs>(
      args: SelectSubset<T, transactionsCreateArgs>
    ): Prisma__transactionsClient<transactionsGetPayload<T>>

    /**
     * Create many Transactions.
     *     @param {transactionsCreateManyArgs} args - Arguments to create many Transactions.
     *     @example
     *     // Create many Transactions
     *     const transactions = await prisma.transactions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends transactionsCreateManyArgs>(
      args?: SelectSubset<T, transactionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Transactions.
     * @param {transactionsDeleteArgs} args - Arguments to delete one Transactions.
     * @example
     * // Delete one Transactions
     * const Transactions = await prisma.transactions.delete({
     *   where: {
     *     // ... filter to delete one Transactions
     *   }
     * })
     * 
    **/
    delete<T extends transactionsDeleteArgs>(
      args: SelectSubset<T, transactionsDeleteArgs>
    ): Prisma__transactionsClient<transactionsGetPayload<T>>

    /**
     * Update one Transactions.
     * @param {transactionsUpdateArgs} args - Arguments to update one Transactions.
     * @example
     * // Update one Transactions
     * const transactions = await prisma.transactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends transactionsUpdateArgs>(
      args: SelectSubset<T, transactionsUpdateArgs>
    ): Prisma__transactionsClient<transactionsGetPayload<T>>

    /**
     * Delete zero or more Transactions.
     * @param {transactionsDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends transactionsDeleteManyArgs>(
      args?: SelectSubset<T, transactionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transactions = await prisma.transactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends transactionsUpdateManyArgs>(
      args: SelectSubset<T, transactionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Transactions.
     * @param {transactionsUpsertArgs} args - Arguments to update or create a Transactions.
     * @example
     * // Update or create a Transactions
     * const transactions = await prisma.transactions.upsert({
     *   create: {
     *     // ... data to create a Transactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transactions we want to update
     *   }
     * })
    **/
    upsert<T extends transactionsUpsertArgs>(
      args: SelectSubset<T, transactionsUpsertArgs>
    ): Prisma__transactionsClient<transactionsGetPayload<T>>

    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transactions.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends transactionsCountArgs>(
      args?: Subset<T, transactionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionsAggregateArgs>(args: Subset<T, TransactionsAggregateArgs>): PrismaPromise<GetTransactionsAggregateType<T>>

    /**
     * Group by Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionsGroupByArgs['orderBy'] }
        : { orderBy?: TransactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for transactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__transactionsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    assets<T extends assetsArgs= {}>(args?: Subset<T, assetsArgs>): Prisma__assetsClient<assetsGetPayload<T> | Null>;

    users<T extends usersArgs= {}>(args?: Subset<T, usersArgs>): Prisma__usersClient<usersGetPayload<T> | Null>;

    vendors<T extends vendorsArgs= {}>(args?: Subset<T, vendorsArgs>): Prisma__vendorsClient<vendorsGetPayload<T> | Null>;

    vaults_transactions_sourceVaultIdTovaults<T extends vaultsArgs= {}>(args?: Subset<T, vaultsArgs>): Prisma__vaultsClient<vaultsGetPayload<T> | Null>;

    vaults_transactions_targetVaultIdTovaults<T extends vaultsArgs= {}>(args?: Subset<T, vaultsArgs>): Prisma__vaultsClient<vaultsGetPayload<T> | Null>;

    withdrawalAddresses<T extends withdrawalAddressesArgs= {}>(args?: Subset<T, withdrawalAddressesArgs>): Prisma__withdrawalAddressesClient<withdrawalAddressesGetPayload<T> | Null>;

    transactionStatusTypes<T extends transactionStatusTypesArgs= {}>(args?: Subset<T, transactionStatusTypesArgs>): Prisma__transactionStatusTypesClient<transactionStatusTypesGetPayload<T> | Null>;

    transactionTypes<T extends transactionTypesArgs= {}>(args?: Subset<T, transactionTypesArgs>): Prisma__transactionTypesClient<transactionTypesGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * transactions base type for findUnique actions
   */
  export type transactionsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionsInclude | null
    /**
     * Filter, which transactions to fetch.
     */
    where: transactionsWhereUniqueInput
  }

  /**
   * transactions findUnique
   */
  export interface transactionsFindUniqueArgs extends transactionsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * transactions findUniqueOrThrow
   */
  export type transactionsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionsInclude | null
    /**
     * Filter, which transactions to fetch.
     */
    where: transactionsWhereUniqueInput
  }


  /**
   * transactions base type for findFirst actions
   */
  export type transactionsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionsInclude | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: Enumerable<transactionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactions.
     */
    distinct?: Enumerable<TransactionsScalarFieldEnum>
  }

  /**
   * transactions findFirst
   */
  export interface transactionsFindFirstArgs extends transactionsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * transactions findFirstOrThrow
   */
  export type transactionsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionsInclude | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: Enumerable<transactionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactions.
     */
    distinct?: Enumerable<TransactionsScalarFieldEnum>
  }


  /**
   * transactions findMany
   */
  export type transactionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionsInclude | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: Enumerable<transactionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transactions.
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    distinct?: Enumerable<TransactionsScalarFieldEnum>
  }


  /**
   * transactions create
   */
  export type transactionsCreateArgs = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionsInclude | null
    /**
     * The data needed to create a transactions.
     */
    data: XOR<transactionsCreateInput, transactionsUncheckedCreateInput>
  }


  /**
   * transactions createMany
   */
  export type transactionsCreateManyArgs = {
    /**
     * The data used to create many transactions.
     */
    data: Enumerable<transactionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * transactions update
   */
  export type transactionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionsInclude | null
    /**
     * The data needed to update a transactions.
     */
    data: XOR<transactionsUpdateInput, transactionsUncheckedUpdateInput>
    /**
     * Choose, which transactions to update.
     */
    where: transactionsWhereUniqueInput
  }


  /**
   * transactions updateMany
   */
  export type transactionsUpdateManyArgs = {
    /**
     * The data used to update transactions.
     */
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyInput>
    /**
     * Filter which transactions to update
     */
    where?: transactionsWhereInput
  }


  /**
   * transactions upsert
   */
  export type transactionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionsInclude | null
    /**
     * The filter to search for the transactions to update in case it exists.
     */
    where: transactionsWhereUniqueInput
    /**
     * In case the transactions found by the `where` argument doesn't exist, create a new transactions with this data.
     */
    create: XOR<transactionsCreateInput, transactionsUncheckedCreateInput>
    /**
     * In case the transactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transactionsUpdateInput, transactionsUncheckedUpdateInput>
  }


  /**
   * transactions delete
   */
  export type transactionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionsInclude | null
    /**
     * Filter which transactions to delete.
     */
    where: transactionsWhereUniqueInput
  }


  /**
   * transactions deleteMany
   */
  export type transactionsDeleteManyArgs = {
    /**
     * Filter which transactions to delete
     */
    where?: transactionsWhereInput
  }


  /**
   * transactions without action
   */
  export type transactionsArgs = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionsInclude | null
  }



  /**
   * Model users
   */


  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    organizationId: number | null
    userTypeId: number | null
  }

  export type UsersSumAggregateOutputType = {
    organizationId: number | null
    userTypeId: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    organizationId: number | null
    userTypeId: number | null
    primaryEmail: string | null
    firstName: string | null
    lastName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    publicKey: string | null
    apiKey: string | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    organizationId: number | null
    userTypeId: number | null
    primaryEmail: string | null
    firstName: string | null
    lastName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    publicKey: string | null
    apiKey: string | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    organizationId: number
    userTypeId: number
    primaryEmail: number
    firstName: number
    lastName: number
    createdAt: number
    updatedAt: number
    publicKey: number
    apiKey: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    organizationId?: true
    userTypeId?: true
  }

  export type UsersSumAggregateInputType = {
    organizationId?: true
    userTypeId?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    organizationId?: true
    userTypeId?: true
    primaryEmail?: true
    firstName?: true
    lastName?: true
    createdAt?: true
    updatedAt?: true
    publicKey?: true
    apiKey?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    organizationId?: true
    userTypeId?: true
    primaryEmail?: true
    firstName?: true
    lastName?: true
    createdAt?: true
    updatedAt?: true
    publicKey?: true
    apiKey?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    organizationId?: true
    userTypeId?: true
    primaryEmail?: true
    firstName?: true
    lastName?: true
    createdAt?: true
    updatedAt?: true
    publicKey?: true
    apiKey?: true
    _all?: true
  }

  export type UsersAggregateArgs = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs = {
    where?: usersWhereInput
    orderBy?: Enumerable<usersOrderByWithAggregationInput>
    by: UsersScalarFieldEnum[]
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }


  export type UsersGroupByOutputType = {
    id: string
    organizationId: number
    userTypeId: number
    primaryEmail: string
    firstName: string
    lastName: string | null
    createdAt: Date
    updatedAt: Date
    publicKey: string | null
    apiKey: string | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect = {
    id?: boolean
    organizationId?: boolean
    userTypeId?: boolean
    primaryEmail?: boolean
    firstName?: boolean
    lastName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publicKey?: boolean
    apiKey?: boolean
    transactionPolicies?: boolean | users$transactionPoliciesArgs
    transactions?: boolean | users$transactionsArgs
    organizations?: boolean | organizationsArgs
    userTypes?: boolean | userTypesArgs
    vaults?: boolean | users$vaultsArgs
    _count?: boolean | UsersCountOutputTypeArgs
  }


  export type usersInclude = {
    transactionPolicies?: boolean | users$transactionPoliciesArgs
    transactions?: boolean | users$transactionsArgs
    organizations?: boolean | organizationsArgs
    userTypes?: boolean | userTypesArgs
    vaults?: boolean | users$vaultsArgs
    _count?: boolean | UsersCountOutputTypeArgs
  }

  export type usersGetPayload<S extends boolean | null | undefined | usersArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? users :
    S extends undefined ? never :
    S extends { include: any } & (usersArgs | usersFindManyArgs)
    ? users  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'transactionPolicies' ? Array < transactionPoliciesGetPayload<S['include'][P]>>  :
        P extends 'transactions' ? Array < transactionsGetPayload<S['include'][P]>>  :
        P extends 'organizations' ? organizationsGetPayload<S['include'][P]> :
        P extends 'userTypes' ? userTypesGetPayload<S['include'][P]> :
        P extends 'vaults' ? Array < vaultsGetPayload<S['include'][P]>>  :
        P extends '_count' ? UsersCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (usersArgs | usersFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'transactionPolicies' ? Array < transactionPoliciesGetPayload<S['select'][P]>>  :
        P extends 'transactions' ? Array < transactionsGetPayload<S['select'][P]>>  :
        P extends 'organizations' ? organizationsGetPayload<S['select'][P]> :
        P extends 'userTypes' ? userTypesGetPayload<S['select'][P]> :
        P extends 'vaults' ? Array < vaultsGetPayload<S['select'][P]>>  :
        P extends '_count' ? UsersCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof users ? users[P] : never
  } 
      : users


  type usersCountArgs = 
    Omit<usersFindManyArgs, 'select' | 'include'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, usersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'users'> extends True ? Prisma__usersClient<usersGetPayload<T>> : Prisma__usersClient<usersGetPayload<T> | null, null>

    /**
     * Find one Users that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, usersFindUniqueOrThrowArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, usersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'users'> extends True ? Prisma__usersClient<usersGetPayload<T>> : Prisma__usersClient<usersGetPayload<T> | null, null>

    /**
     * Find the first Users that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, usersFindFirstOrThrowArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends usersFindManyArgs>(
      args?: SelectSubset<T, usersFindManyArgs>
    ): PrismaPromise<Array<usersGetPayload<T>>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends usersCreateArgs>(
      args: SelectSubset<T, usersCreateArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Create many Users.
     *     @param {usersCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const users = await prisma.users.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usersCreateManyArgs>(
      args?: SelectSubset<T, usersCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends usersDeleteArgs>(
      args: SelectSubset<T, usersDeleteArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usersUpdateArgs>(
      args: SelectSubset<T, usersUpdateArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usersDeleteManyArgs>(
      args?: SelectSubset<T, usersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usersUpdateManyArgs>(
      args: SelectSubset<T, usersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends usersUpsertArgs>(
      args: SelectSubset<T, usersUpsertArgs>
    ): Prisma__usersClient<usersGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__usersClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    transactionPolicies<T extends users$transactionPoliciesArgs= {}>(args?: Subset<T, users$transactionPoliciesArgs>): PrismaPromise<Array<transactionPoliciesGetPayload<T>>| Null>;

    transactions<T extends users$transactionsArgs= {}>(args?: Subset<T, users$transactionsArgs>): PrismaPromise<Array<transactionsGetPayload<T>>| Null>;

    organizations<T extends organizationsArgs= {}>(args?: Subset<T, organizationsArgs>): Prisma__organizationsClient<organizationsGetPayload<T> | Null>;

    userTypes<T extends userTypesArgs= {}>(args?: Subset<T, userTypesArgs>): Prisma__userTypesClient<userTypesGetPayload<T> | Null>;

    vaults<T extends users$vaultsArgs= {}>(args?: Subset<T, users$vaultsArgs>): PrismaPromise<Array<vaultsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * users base type for findUnique actions
   */
  export type usersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUnique
   */
  export interface usersFindUniqueArgs extends usersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users base type for findFirst actions
   */
  export type usersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: Enumerable<UsersScalarFieldEnum>
  }

  /**
   * users findFirst
   */
  export interface usersFindFirstArgs extends usersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * users findMany
   */
  export type usersFindManyArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * users create
   */
  export type usersCreateArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }


  /**
   * users createMany
   */
  export type usersCreateManyArgs = {
    /**
     * The data used to create many users.
     */
    data: Enumerable<usersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * users update
   */
  export type usersUpdateArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users updateMany
   */
  export type usersUpdateManyArgs = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }


  /**
   * users upsert
   */
  export type usersUpsertArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }


  /**
   * users delete
   */
  export type usersDeleteArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }


  /**
   * users.transactionPolicies
   */
  export type users$transactionPoliciesArgs = {
    /**
     * Select specific fields to fetch from the transactionPolicies
     */
    select?: transactionPoliciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionPoliciesInclude | null
    where?: transactionPoliciesWhereInput
    orderBy?: Enumerable<transactionPoliciesOrderByWithRelationInput>
    cursor?: transactionPoliciesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TransactionPoliciesScalarFieldEnum>
  }


  /**
   * users.transactions
   */
  export type users$transactionsArgs = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionsInclude | null
    where?: transactionsWhereInput
    orderBy?: Enumerable<transactionsOrderByWithRelationInput>
    cursor?: transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TransactionsScalarFieldEnum>
  }


  /**
   * users.vaults
   */
  export type users$vaultsArgs = {
    /**
     * Select specific fields to fetch from the vaults
     */
    select?: vaultsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultsInclude | null
    where?: vaultsWhereInput
    orderBy?: Enumerable<vaultsOrderByWithRelationInput>
    cursor?: vaultsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VaultsScalarFieldEnum>
  }


  /**
   * users without action
   */
  export type usersArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
  }



  /**
   * Model vendorTypes
   */


  export type AggregateVendorTypes = {
    _count: VendorTypesCountAggregateOutputType | null
    _avg: VendorTypesAvgAggregateOutputType | null
    _sum: VendorTypesSumAggregateOutputType | null
    _min: VendorTypesMinAggregateOutputType | null
    _max: VendorTypesMaxAggregateOutputType | null
  }

  export type VendorTypesAvgAggregateOutputType = {
    id: number | null
  }

  export type VendorTypesSumAggregateOutputType = {
    id: number | null
  }

  export type VendorTypesMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorTypesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorTypesCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VendorTypesAvgAggregateInputType = {
    id?: true
  }

  export type VendorTypesSumAggregateInputType = {
    id?: true
  }

  export type VendorTypesMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorTypesMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorTypesCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VendorTypesAggregateArgs = {
    /**
     * Filter which vendorTypes to aggregate.
     */
    where?: vendorTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vendorTypes to fetch.
     */
    orderBy?: Enumerable<vendorTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vendorTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vendorTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vendorTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vendorTypes
    **/
    _count?: true | VendorTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorTypesMaxAggregateInputType
  }

  export type GetVendorTypesAggregateType<T extends VendorTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorTypes[P]>
      : GetScalarType<T[P], AggregateVendorTypes[P]>
  }




  export type VendorTypesGroupByArgs = {
    where?: vendorTypesWhereInput
    orderBy?: Enumerable<vendorTypesOrderByWithAggregationInput>
    by: VendorTypesScalarFieldEnum[]
    having?: vendorTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorTypesCountAggregateInputType | true
    _avg?: VendorTypesAvgAggregateInputType
    _sum?: VendorTypesSumAggregateInputType
    _min?: VendorTypesMinAggregateInputType
    _max?: VendorTypesMaxAggregateInputType
  }


  export type VendorTypesGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: VendorTypesCountAggregateOutputType | null
    _avg: VendorTypesAvgAggregateOutputType | null
    _sum: VendorTypesSumAggregateOutputType | null
    _min: VendorTypesMinAggregateOutputType | null
    _max: VendorTypesMaxAggregateOutputType | null
  }

  type GetVendorTypesGroupByPayload<T extends VendorTypesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VendorTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorTypesGroupByOutputType[P]>
            : GetScalarType<T[P], VendorTypesGroupByOutputType[P]>
        }
      >
    >


  export type vendorTypesSelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendors?: boolean | vendorTypes$vendorsArgs
    _count?: boolean | VendorTypesCountOutputTypeArgs
  }


  export type vendorTypesInclude = {
    vendors?: boolean | vendorTypes$vendorsArgs
    _count?: boolean | VendorTypesCountOutputTypeArgs
  }

  export type vendorTypesGetPayload<S extends boolean | null | undefined | vendorTypesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? vendorTypes :
    S extends undefined ? never :
    S extends { include: any } & (vendorTypesArgs | vendorTypesFindManyArgs)
    ? vendorTypes  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'vendors' ? Array < vendorsGetPayload<S['include'][P]>>  :
        P extends '_count' ? VendorTypesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (vendorTypesArgs | vendorTypesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'vendors' ? Array < vendorsGetPayload<S['select'][P]>>  :
        P extends '_count' ? VendorTypesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof vendorTypes ? vendorTypes[P] : never
  } 
      : vendorTypes


  type vendorTypesCountArgs = 
    Omit<vendorTypesFindManyArgs, 'select' | 'include'> & {
      select?: VendorTypesCountAggregateInputType | true
    }

  export interface vendorTypesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one VendorTypes that matches the filter.
     * @param {vendorTypesFindUniqueArgs} args - Arguments to find a VendorTypes
     * @example
     * // Get one VendorTypes
     * const vendorTypes = await prisma.vendorTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends vendorTypesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, vendorTypesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'vendorTypes'> extends True ? Prisma__vendorTypesClient<vendorTypesGetPayload<T>> : Prisma__vendorTypesClient<vendorTypesGetPayload<T> | null, null>

    /**
     * Find one VendorTypes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {vendorTypesFindUniqueOrThrowArgs} args - Arguments to find a VendorTypes
     * @example
     * // Get one VendorTypes
     * const vendorTypes = await prisma.vendorTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends vendorTypesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, vendorTypesFindUniqueOrThrowArgs>
    ): Prisma__vendorTypesClient<vendorTypesGetPayload<T>>

    /**
     * Find the first VendorTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vendorTypesFindFirstArgs} args - Arguments to find a VendorTypes
     * @example
     * // Get one VendorTypes
     * const vendorTypes = await prisma.vendorTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends vendorTypesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, vendorTypesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'vendorTypes'> extends True ? Prisma__vendorTypesClient<vendorTypesGetPayload<T>> : Prisma__vendorTypesClient<vendorTypesGetPayload<T> | null, null>

    /**
     * Find the first VendorTypes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vendorTypesFindFirstOrThrowArgs} args - Arguments to find a VendorTypes
     * @example
     * // Get one VendorTypes
     * const vendorTypes = await prisma.vendorTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends vendorTypesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, vendorTypesFindFirstOrThrowArgs>
    ): Prisma__vendorTypesClient<vendorTypesGetPayload<T>>

    /**
     * Find zero or more VendorTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vendorTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorTypes
     * const vendorTypes = await prisma.vendorTypes.findMany()
     * 
     * // Get first 10 VendorTypes
     * const vendorTypes = await prisma.vendorTypes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorTypesWithIdOnly = await prisma.vendorTypes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends vendorTypesFindManyArgs>(
      args?: SelectSubset<T, vendorTypesFindManyArgs>
    ): PrismaPromise<Array<vendorTypesGetPayload<T>>>

    /**
     * Create a VendorTypes.
     * @param {vendorTypesCreateArgs} args - Arguments to create a VendorTypes.
     * @example
     * // Create one VendorTypes
     * const VendorTypes = await prisma.vendorTypes.create({
     *   data: {
     *     // ... data to create a VendorTypes
     *   }
     * })
     * 
    **/
    create<T extends vendorTypesCreateArgs>(
      args: SelectSubset<T, vendorTypesCreateArgs>
    ): Prisma__vendorTypesClient<vendorTypesGetPayload<T>>

    /**
     * Create many VendorTypes.
     *     @param {vendorTypesCreateManyArgs} args - Arguments to create many VendorTypes.
     *     @example
     *     // Create many VendorTypes
     *     const vendorTypes = await prisma.vendorTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends vendorTypesCreateManyArgs>(
      args?: SelectSubset<T, vendorTypesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a VendorTypes.
     * @param {vendorTypesDeleteArgs} args - Arguments to delete one VendorTypes.
     * @example
     * // Delete one VendorTypes
     * const VendorTypes = await prisma.vendorTypes.delete({
     *   where: {
     *     // ... filter to delete one VendorTypes
     *   }
     * })
     * 
    **/
    delete<T extends vendorTypesDeleteArgs>(
      args: SelectSubset<T, vendorTypesDeleteArgs>
    ): Prisma__vendorTypesClient<vendorTypesGetPayload<T>>

    /**
     * Update one VendorTypes.
     * @param {vendorTypesUpdateArgs} args - Arguments to update one VendorTypes.
     * @example
     * // Update one VendorTypes
     * const vendorTypes = await prisma.vendorTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends vendorTypesUpdateArgs>(
      args: SelectSubset<T, vendorTypesUpdateArgs>
    ): Prisma__vendorTypesClient<vendorTypesGetPayload<T>>

    /**
     * Delete zero or more VendorTypes.
     * @param {vendorTypesDeleteManyArgs} args - Arguments to filter VendorTypes to delete.
     * @example
     * // Delete a few VendorTypes
     * const { count } = await prisma.vendorTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends vendorTypesDeleteManyArgs>(
      args?: SelectSubset<T, vendorTypesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vendorTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorTypes
     * const vendorTypes = await prisma.vendorTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends vendorTypesUpdateManyArgs>(
      args: SelectSubset<T, vendorTypesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one VendorTypes.
     * @param {vendorTypesUpsertArgs} args - Arguments to update or create a VendorTypes.
     * @example
     * // Update or create a VendorTypes
     * const vendorTypes = await prisma.vendorTypes.upsert({
     *   create: {
     *     // ... data to create a VendorTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorTypes we want to update
     *   }
     * })
    **/
    upsert<T extends vendorTypesUpsertArgs>(
      args: SelectSubset<T, vendorTypesUpsertArgs>
    ): Prisma__vendorTypesClient<vendorTypesGetPayload<T>>

    /**
     * Count the number of VendorTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vendorTypesCountArgs} args - Arguments to filter VendorTypes to count.
     * @example
     * // Count the number of VendorTypes
     * const count = await prisma.vendorTypes.count({
     *   where: {
     *     // ... the filter for the VendorTypes we want to count
     *   }
     * })
    **/
    count<T extends vendorTypesCountArgs>(
      args?: Subset<T, vendorTypesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorTypesAggregateArgs>(args: Subset<T, VendorTypesAggregateArgs>): PrismaPromise<GetVendorTypesAggregateType<T>>

    /**
     * Group by VendorTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorTypesGroupByArgs['orderBy'] }
        : { orderBy?: VendorTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorTypesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for vendorTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__vendorTypesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    vendors<T extends vendorTypes$vendorsArgs= {}>(args?: Subset<T, vendorTypes$vendorsArgs>): PrismaPromise<Array<vendorsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * vendorTypes base type for findUnique actions
   */
  export type vendorTypesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the vendorTypes
     */
    select?: vendorTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorTypesInclude | null
    /**
     * Filter, which vendorTypes to fetch.
     */
    where: vendorTypesWhereUniqueInput
  }

  /**
   * vendorTypes findUnique
   */
  export interface vendorTypesFindUniqueArgs extends vendorTypesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * vendorTypes findUniqueOrThrow
   */
  export type vendorTypesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the vendorTypes
     */
    select?: vendorTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorTypesInclude | null
    /**
     * Filter, which vendorTypes to fetch.
     */
    where: vendorTypesWhereUniqueInput
  }


  /**
   * vendorTypes base type for findFirst actions
   */
  export type vendorTypesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the vendorTypes
     */
    select?: vendorTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorTypesInclude | null
    /**
     * Filter, which vendorTypes to fetch.
     */
    where?: vendorTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vendorTypes to fetch.
     */
    orderBy?: Enumerable<vendorTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vendorTypes.
     */
    cursor?: vendorTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vendorTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vendorTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vendorTypes.
     */
    distinct?: Enumerable<VendorTypesScalarFieldEnum>
  }

  /**
   * vendorTypes findFirst
   */
  export interface vendorTypesFindFirstArgs extends vendorTypesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * vendorTypes findFirstOrThrow
   */
  export type vendorTypesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the vendorTypes
     */
    select?: vendorTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorTypesInclude | null
    /**
     * Filter, which vendorTypes to fetch.
     */
    where?: vendorTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vendorTypes to fetch.
     */
    orderBy?: Enumerable<vendorTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vendorTypes.
     */
    cursor?: vendorTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vendorTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vendorTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vendorTypes.
     */
    distinct?: Enumerable<VendorTypesScalarFieldEnum>
  }


  /**
   * vendorTypes findMany
   */
  export type vendorTypesFindManyArgs = {
    /**
     * Select specific fields to fetch from the vendorTypes
     */
    select?: vendorTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorTypesInclude | null
    /**
     * Filter, which vendorTypes to fetch.
     */
    where?: vendorTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vendorTypes to fetch.
     */
    orderBy?: Enumerable<vendorTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vendorTypes.
     */
    cursor?: vendorTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vendorTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vendorTypes.
     */
    skip?: number
    distinct?: Enumerable<VendorTypesScalarFieldEnum>
  }


  /**
   * vendorTypes create
   */
  export type vendorTypesCreateArgs = {
    /**
     * Select specific fields to fetch from the vendorTypes
     */
    select?: vendorTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorTypesInclude | null
    /**
     * The data needed to create a vendorTypes.
     */
    data: XOR<vendorTypesCreateInput, vendorTypesUncheckedCreateInput>
  }


  /**
   * vendorTypes createMany
   */
  export type vendorTypesCreateManyArgs = {
    /**
     * The data used to create many vendorTypes.
     */
    data: Enumerable<vendorTypesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * vendorTypes update
   */
  export type vendorTypesUpdateArgs = {
    /**
     * Select specific fields to fetch from the vendorTypes
     */
    select?: vendorTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorTypesInclude | null
    /**
     * The data needed to update a vendorTypes.
     */
    data: XOR<vendorTypesUpdateInput, vendorTypesUncheckedUpdateInput>
    /**
     * Choose, which vendorTypes to update.
     */
    where: vendorTypesWhereUniqueInput
  }


  /**
   * vendorTypes updateMany
   */
  export type vendorTypesUpdateManyArgs = {
    /**
     * The data used to update vendorTypes.
     */
    data: XOR<vendorTypesUpdateManyMutationInput, vendorTypesUncheckedUpdateManyInput>
    /**
     * Filter which vendorTypes to update
     */
    where?: vendorTypesWhereInput
  }


  /**
   * vendorTypes upsert
   */
  export type vendorTypesUpsertArgs = {
    /**
     * Select specific fields to fetch from the vendorTypes
     */
    select?: vendorTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorTypesInclude | null
    /**
     * The filter to search for the vendorTypes to update in case it exists.
     */
    where: vendorTypesWhereUniqueInput
    /**
     * In case the vendorTypes found by the `where` argument doesn't exist, create a new vendorTypes with this data.
     */
    create: XOR<vendorTypesCreateInput, vendorTypesUncheckedCreateInput>
    /**
     * In case the vendorTypes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vendorTypesUpdateInput, vendorTypesUncheckedUpdateInput>
  }


  /**
   * vendorTypes delete
   */
  export type vendorTypesDeleteArgs = {
    /**
     * Select specific fields to fetch from the vendorTypes
     */
    select?: vendorTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorTypesInclude | null
    /**
     * Filter which vendorTypes to delete.
     */
    where: vendorTypesWhereUniqueInput
  }


  /**
   * vendorTypes deleteMany
   */
  export type vendorTypesDeleteManyArgs = {
    /**
     * Filter which vendorTypes to delete
     */
    where?: vendorTypesWhereInput
  }


  /**
   * vendorTypes.vendors
   */
  export type vendorTypes$vendorsArgs = {
    /**
     * Select specific fields to fetch from the vendors
     */
    select?: vendorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorsInclude | null
    where?: vendorsWhereInput
    orderBy?: Enumerable<vendorsOrderByWithRelationInput>
    cursor?: vendorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VendorsScalarFieldEnum>
  }


  /**
   * vendorTypes without action
   */
  export type vendorTypesArgs = {
    /**
     * Select specific fields to fetch from the vendorTypes
     */
    select?: vendorTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorTypesInclude | null
  }



  /**
   * Model vendors
   */


  export type AggregateVendors = {
    _count: VendorsCountAggregateOutputType | null
    _avg: VendorsAvgAggregateOutputType | null
    _sum: VendorsSumAggregateOutputType | null
    _min: VendorsMinAggregateOutputType | null
    _max: VendorsMaxAggregateOutputType | null
  }

  export type VendorsAvgAggregateOutputType = {
    id: number | null
    vendorTypeId: number | null
    quoteEngineBaseBps: number | null
  }

  export type VendorsSumAggregateOutputType = {
    id: number | null
    vendorTypeId: number | null
    quoteEngineBaseBps: number | null
  }

  export type VendorsMinAggregateOutputType = {
    id: number | null
    name: string | null
    identifier: string | null
    vendorTypeId: number | null
    quoteEngineBaseBps: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    identifier: string | null
    vendorTypeId: number | null
    quoteEngineBaseBps: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorsCountAggregateOutputType = {
    id: number
    name: number
    identifier: number
    vendorTypeId: number
    quoteEngineBaseBps: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VendorsAvgAggregateInputType = {
    id?: true
    vendorTypeId?: true
    quoteEngineBaseBps?: true
  }

  export type VendorsSumAggregateInputType = {
    id?: true
    vendorTypeId?: true
    quoteEngineBaseBps?: true
  }

  export type VendorsMinAggregateInputType = {
    id?: true
    name?: true
    identifier?: true
    vendorTypeId?: true
    quoteEngineBaseBps?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorsMaxAggregateInputType = {
    id?: true
    name?: true
    identifier?: true
    vendorTypeId?: true
    quoteEngineBaseBps?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorsCountAggregateInputType = {
    id?: true
    name?: true
    identifier?: true
    vendorTypeId?: true
    quoteEngineBaseBps?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VendorsAggregateArgs = {
    /**
     * Filter which vendors to aggregate.
     */
    where?: vendorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vendors to fetch.
     */
    orderBy?: Enumerable<vendorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vendorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vendors
    **/
    _count?: true | VendorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorsMaxAggregateInputType
  }

  export type GetVendorsAggregateType<T extends VendorsAggregateArgs> = {
        [P in keyof T & keyof AggregateVendors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendors[P]>
      : GetScalarType<T[P], AggregateVendors[P]>
  }




  export type VendorsGroupByArgs = {
    where?: vendorsWhereInput
    orderBy?: Enumerable<vendorsOrderByWithAggregationInput>
    by: VendorsScalarFieldEnum[]
    having?: vendorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorsCountAggregateInputType | true
    _avg?: VendorsAvgAggregateInputType
    _sum?: VendorsSumAggregateInputType
    _min?: VendorsMinAggregateInputType
    _max?: VendorsMaxAggregateInputType
  }


  export type VendorsGroupByOutputType = {
    id: number
    name: string
    identifier: string
    vendorTypeId: number
    quoteEngineBaseBps: number
    createdAt: Date
    updatedAt: Date
    _count: VendorsCountAggregateOutputType | null
    _avg: VendorsAvgAggregateOutputType | null
    _sum: VendorsSumAggregateOutputType | null
    _min: VendorsMinAggregateOutputType | null
    _max: VendorsMaxAggregateOutputType | null
  }

  type GetVendorsGroupByPayload<T extends VendorsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VendorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorsGroupByOutputType[P]>
            : GetScalarType<T[P], VendorsGroupByOutputType[P]>
        }
      >
    >


  export type vendorsSelect = {
    id?: boolean
    name?: boolean
    identifier?: boolean
    vendorTypeId?: boolean
    quoteEngineBaseBps?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    custodyVendorVaultAssets?: boolean | vendors$custodyVendorVaultAssetsArgs
    depositAddresses?: boolean | vendors$depositAddressesArgs
    quotes?: boolean | vendors$quotesArgs
    tokenPairs?: boolean | vendors$tokenPairsArgs
    transactions?: boolean | vendors$transactionsArgs
    vendorSupportsAssets?: boolean | vendors$vendorSupportsAssetsArgs
    vendorTypes?: boolean | vendorTypesArgs
    _count?: boolean | VendorsCountOutputTypeArgs
  }


  export type vendorsInclude = {
    custodyVendorVaultAssets?: boolean | vendors$custodyVendorVaultAssetsArgs
    depositAddresses?: boolean | vendors$depositAddressesArgs
    quotes?: boolean | vendors$quotesArgs
    tokenPairs?: boolean | vendors$tokenPairsArgs
    transactions?: boolean | vendors$transactionsArgs
    vendorSupportsAssets?: boolean | vendors$vendorSupportsAssetsArgs
    vendorTypes?: boolean | vendorTypesArgs
    _count?: boolean | VendorsCountOutputTypeArgs
  }

  export type vendorsGetPayload<S extends boolean | null | undefined | vendorsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? vendors :
    S extends undefined ? never :
    S extends { include: any } & (vendorsArgs | vendorsFindManyArgs)
    ? vendors  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'custodyVendorVaultAssets' ? Array < custodyVendorVaultAssetsGetPayload<S['include'][P]>>  :
        P extends 'depositAddresses' ? Array < depositAddressesGetPayload<S['include'][P]>>  :
        P extends 'quotes' ? Array < quotesGetPayload<S['include'][P]>>  :
        P extends 'tokenPairs' ? Array < tokenPairsGetPayload<S['include'][P]>>  :
        P extends 'transactions' ? Array < transactionsGetPayload<S['include'][P]>>  :
        P extends 'vendorSupportsAssets' ? Array < vendorSupportsAssetsGetPayload<S['include'][P]>>  :
        P extends 'vendorTypes' ? vendorTypesGetPayload<S['include'][P]> :
        P extends '_count' ? VendorsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (vendorsArgs | vendorsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'custodyVendorVaultAssets' ? Array < custodyVendorVaultAssetsGetPayload<S['select'][P]>>  :
        P extends 'depositAddresses' ? Array < depositAddressesGetPayload<S['select'][P]>>  :
        P extends 'quotes' ? Array < quotesGetPayload<S['select'][P]>>  :
        P extends 'tokenPairs' ? Array < tokenPairsGetPayload<S['select'][P]>>  :
        P extends 'transactions' ? Array < transactionsGetPayload<S['select'][P]>>  :
        P extends 'vendorSupportsAssets' ? Array < vendorSupportsAssetsGetPayload<S['select'][P]>>  :
        P extends 'vendorTypes' ? vendorTypesGetPayload<S['select'][P]> :
        P extends '_count' ? VendorsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof vendors ? vendors[P] : never
  } 
      : vendors


  type vendorsCountArgs = 
    Omit<vendorsFindManyArgs, 'select' | 'include'> & {
      select?: VendorsCountAggregateInputType | true
    }

  export interface vendorsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Vendors that matches the filter.
     * @param {vendorsFindUniqueArgs} args - Arguments to find a Vendors
     * @example
     * // Get one Vendors
     * const vendors = await prisma.vendors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends vendorsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, vendorsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'vendors'> extends True ? Prisma__vendorsClient<vendorsGetPayload<T>> : Prisma__vendorsClient<vendorsGetPayload<T> | null, null>

    /**
     * Find one Vendors that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {vendorsFindUniqueOrThrowArgs} args - Arguments to find a Vendors
     * @example
     * // Get one Vendors
     * const vendors = await prisma.vendors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends vendorsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, vendorsFindUniqueOrThrowArgs>
    ): Prisma__vendorsClient<vendorsGetPayload<T>>

    /**
     * Find the first Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vendorsFindFirstArgs} args - Arguments to find a Vendors
     * @example
     * // Get one Vendors
     * const vendors = await prisma.vendors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends vendorsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, vendorsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'vendors'> extends True ? Prisma__vendorsClient<vendorsGetPayload<T>> : Prisma__vendorsClient<vendorsGetPayload<T> | null, null>

    /**
     * Find the first Vendors that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vendorsFindFirstOrThrowArgs} args - Arguments to find a Vendors
     * @example
     * // Get one Vendors
     * const vendors = await prisma.vendors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends vendorsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, vendorsFindFirstOrThrowArgs>
    ): Prisma__vendorsClient<vendorsGetPayload<T>>

    /**
     * Find zero or more Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vendorsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendors
     * const vendors = await prisma.vendors.findMany()
     * 
     * // Get first 10 Vendors
     * const vendors = await prisma.vendors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorsWithIdOnly = await prisma.vendors.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends vendorsFindManyArgs>(
      args?: SelectSubset<T, vendorsFindManyArgs>
    ): PrismaPromise<Array<vendorsGetPayload<T>>>

    /**
     * Create a Vendors.
     * @param {vendorsCreateArgs} args - Arguments to create a Vendors.
     * @example
     * // Create one Vendors
     * const Vendors = await prisma.vendors.create({
     *   data: {
     *     // ... data to create a Vendors
     *   }
     * })
     * 
    **/
    create<T extends vendorsCreateArgs>(
      args: SelectSubset<T, vendorsCreateArgs>
    ): Prisma__vendorsClient<vendorsGetPayload<T>>

    /**
     * Create many Vendors.
     *     @param {vendorsCreateManyArgs} args - Arguments to create many Vendors.
     *     @example
     *     // Create many Vendors
     *     const vendors = await prisma.vendors.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends vendorsCreateManyArgs>(
      args?: SelectSubset<T, vendorsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Vendors.
     * @param {vendorsDeleteArgs} args - Arguments to delete one Vendors.
     * @example
     * // Delete one Vendors
     * const Vendors = await prisma.vendors.delete({
     *   where: {
     *     // ... filter to delete one Vendors
     *   }
     * })
     * 
    **/
    delete<T extends vendorsDeleteArgs>(
      args: SelectSubset<T, vendorsDeleteArgs>
    ): Prisma__vendorsClient<vendorsGetPayload<T>>

    /**
     * Update one Vendors.
     * @param {vendorsUpdateArgs} args - Arguments to update one Vendors.
     * @example
     * // Update one Vendors
     * const vendors = await prisma.vendors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends vendorsUpdateArgs>(
      args: SelectSubset<T, vendorsUpdateArgs>
    ): Prisma__vendorsClient<vendorsGetPayload<T>>

    /**
     * Delete zero or more Vendors.
     * @param {vendorsDeleteManyArgs} args - Arguments to filter Vendors to delete.
     * @example
     * // Delete a few Vendors
     * const { count } = await prisma.vendors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends vendorsDeleteManyArgs>(
      args?: SelectSubset<T, vendorsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vendorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendors
     * const vendors = await prisma.vendors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends vendorsUpdateManyArgs>(
      args: SelectSubset<T, vendorsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Vendors.
     * @param {vendorsUpsertArgs} args - Arguments to update or create a Vendors.
     * @example
     * // Update or create a Vendors
     * const vendors = await prisma.vendors.upsert({
     *   create: {
     *     // ... data to create a Vendors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendors we want to update
     *   }
     * })
    **/
    upsert<T extends vendorsUpsertArgs>(
      args: SelectSubset<T, vendorsUpsertArgs>
    ): Prisma__vendorsClient<vendorsGetPayload<T>>

    /**
     * Count the number of Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vendorsCountArgs} args - Arguments to filter Vendors to count.
     * @example
     * // Count the number of Vendors
     * const count = await prisma.vendors.count({
     *   where: {
     *     // ... the filter for the Vendors we want to count
     *   }
     * })
    **/
    count<T extends vendorsCountArgs>(
      args?: Subset<T, vendorsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorsAggregateArgs>(args: Subset<T, VendorsAggregateArgs>): PrismaPromise<GetVendorsAggregateType<T>>

    /**
     * Group by Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorsGroupByArgs['orderBy'] }
        : { orderBy?: VendorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for vendors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__vendorsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    custodyVendorVaultAssets<T extends vendors$custodyVendorVaultAssetsArgs= {}>(args?: Subset<T, vendors$custodyVendorVaultAssetsArgs>): PrismaPromise<Array<custodyVendorVaultAssetsGetPayload<T>>| Null>;

    depositAddresses<T extends vendors$depositAddressesArgs= {}>(args?: Subset<T, vendors$depositAddressesArgs>): PrismaPromise<Array<depositAddressesGetPayload<T>>| Null>;

    quotes<T extends vendors$quotesArgs= {}>(args?: Subset<T, vendors$quotesArgs>): PrismaPromise<Array<quotesGetPayload<T>>| Null>;

    tokenPairs<T extends vendors$tokenPairsArgs= {}>(args?: Subset<T, vendors$tokenPairsArgs>): PrismaPromise<Array<tokenPairsGetPayload<T>>| Null>;

    transactions<T extends vendors$transactionsArgs= {}>(args?: Subset<T, vendors$transactionsArgs>): PrismaPromise<Array<transactionsGetPayload<T>>| Null>;

    vendorSupportsAssets<T extends vendors$vendorSupportsAssetsArgs= {}>(args?: Subset<T, vendors$vendorSupportsAssetsArgs>): PrismaPromise<Array<vendorSupportsAssetsGetPayload<T>>| Null>;

    vendorTypes<T extends vendorTypesArgs= {}>(args?: Subset<T, vendorTypesArgs>): Prisma__vendorTypesClient<vendorTypesGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * vendors base type for findUnique actions
   */
  export type vendorsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the vendors
     */
    select?: vendorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorsInclude | null
    /**
     * Filter, which vendors to fetch.
     */
    where: vendorsWhereUniqueInput
  }

  /**
   * vendors findUnique
   */
  export interface vendorsFindUniqueArgs extends vendorsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * vendors findUniqueOrThrow
   */
  export type vendorsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the vendors
     */
    select?: vendorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorsInclude | null
    /**
     * Filter, which vendors to fetch.
     */
    where: vendorsWhereUniqueInput
  }


  /**
   * vendors base type for findFirst actions
   */
  export type vendorsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the vendors
     */
    select?: vendorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorsInclude | null
    /**
     * Filter, which vendors to fetch.
     */
    where?: vendorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vendors to fetch.
     */
    orderBy?: Enumerable<vendorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vendors.
     */
    cursor?: vendorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vendors.
     */
    distinct?: Enumerable<VendorsScalarFieldEnum>
  }

  /**
   * vendors findFirst
   */
  export interface vendorsFindFirstArgs extends vendorsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * vendors findFirstOrThrow
   */
  export type vendorsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the vendors
     */
    select?: vendorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorsInclude | null
    /**
     * Filter, which vendors to fetch.
     */
    where?: vendorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vendors to fetch.
     */
    orderBy?: Enumerable<vendorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vendors.
     */
    cursor?: vendorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vendors.
     */
    distinct?: Enumerable<VendorsScalarFieldEnum>
  }


  /**
   * vendors findMany
   */
  export type vendorsFindManyArgs = {
    /**
     * Select specific fields to fetch from the vendors
     */
    select?: vendorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorsInclude | null
    /**
     * Filter, which vendors to fetch.
     */
    where?: vendorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vendors to fetch.
     */
    orderBy?: Enumerable<vendorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vendors.
     */
    cursor?: vendorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vendors.
     */
    skip?: number
    distinct?: Enumerable<VendorsScalarFieldEnum>
  }


  /**
   * vendors create
   */
  export type vendorsCreateArgs = {
    /**
     * Select specific fields to fetch from the vendors
     */
    select?: vendorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorsInclude | null
    /**
     * The data needed to create a vendors.
     */
    data: XOR<vendorsCreateInput, vendorsUncheckedCreateInput>
  }


  /**
   * vendors createMany
   */
  export type vendorsCreateManyArgs = {
    /**
     * The data used to create many vendors.
     */
    data: Enumerable<vendorsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * vendors update
   */
  export type vendorsUpdateArgs = {
    /**
     * Select specific fields to fetch from the vendors
     */
    select?: vendorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorsInclude | null
    /**
     * The data needed to update a vendors.
     */
    data: XOR<vendorsUpdateInput, vendorsUncheckedUpdateInput>
    /**
     * Choose, which vendors to update.
     */
    where: vendorsWhereUniqueInput
  }


  /**
   * vendors updateMany
   */
  export type vendorsUpdateManyArgs = {
    /**
     * The data used to update vendors.
     */
    data: XOR<vendorsUpdateManyMutationInput, vendorsUncheckedUpdateManyInput>
    /**
     * Filter which vendors to update
     */
    where?: vendorsWhereInput
  }


  /**
   * vendors upsert
   */
  export type vendorsUpsertArgs = {
    /**
     * Select specific fields to fetch from the vendors
     */
    select?: vendorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorsInclude | null
    /**
     * The filter to search for the vendors to update in case it exists.
     */
    where: vendorsWhereUniqueInput
    /**
     * In case the vendors found by the `where` argument doesn't exist, create a new vendors with this data.
     */
    create: XOR<vendorsCreateInput, vendorsUncheckedCreateInput>
    /**
     * In case the vendors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vendorsUpdateInput, vendorsUncheckedUpdateInput>
  }


  /**
   * vendors delete
   */
  export type vendorsDeleteArgs = {
    /**
     * Select specific fields to fetch from the vendors
     */
    select?: vendorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorsInclude | null
    /**
     * Filter which vendors to delete.
     */
    where: vendorsWhereUniqueInput
  }


  /**
   * vendors deleteMany
   */
  export type vendorsDeleteManyArgs = {
    /**
     * Filter which vendors to delete
     */
    where?: vendorsWhereInput
  }


  /**
   * vendors.custodyVendorVaultAssets
   */
  export type vendors$custodyVendorVaultAssetsArgs = {
    /**
     * Select specific fields to fetch from the custodyVendorVaultAssets
     */
    select?: custodyVendorVaultAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyVendorVaultAssetsInclude | null
    where?: custodyVendorVaultAssetsWhereInput
    orderBy?: Enumerable<custodyVendorVaultAssetsOrderByWithRelationInput>
    cursor?: custodyVendorVaultAssetsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CustodyVendorVaultAssetsScalarFieldEnum>
  }


  /**
   * vendors.depositAddresses
   */
  export type vendors$depositAddressesArgs = {
    /**
     * Select specific fields to fetch from the depositAddresses
     */
    select?: depositAddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: depositAddressesInclude | null
    where?: depositAddressesWhereInput
    orderBy?: Enumerable<depositAddressesOrderByWithRelationInput>
    cursor?: depositAddressesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DepositAddressesScalarFieldEnum>
  }


  /**
   * vendors.quotes
   */
  export type vendors$quotesArgs = {
    /**
     * Select specific fields to fetch from the quotes
     */
    select?: quotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: quotesInclude | null
    where?: quotesWhereInput
    orderBy?: Enumerable<quotesOrderByWithRelationInput>
    cursor?: quotesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QuotesScalarFieldEnum>
  }


  /**
   * vendors.tokenPairs
   */
  export type vendors$tokenPairsArgs = {
    /**
     * Select specific fields to fetch from the tokenPairs
     */
    select?: tokenPairsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tokenPairsInclude | null
    where?: tokenPairsWhereInput
    orderBy?: Enumerable<tokenPairsOrderByWithRelationInput>
    cursor?: tokenPairsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TokenPairsScalarFieldEnum>
  }


  /**
   * vendors.transactions
   */
  export type vendors$transactionsArgs = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionsInclude | null
    where?: transactionsWhereInput
    orderBy?: Enumerable<transactionsOrderByWithRelationInput>
    cursor?: transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TransactionsScalarFieldEnum>
  }


  /**
   * vendors.vendorSupportsAssets
   */
  export type vendors$vendorSupportsAssetsArgs = {
    /**
     * Select specific fields to fetch from the vendorSupportsAssets
     */
    select?: vendorSupportsAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorSupportsAssetsInclude | null
    where?: vendorSupportsAssetsWhereInput
    orderBy?: Enumerable<vendorSupportsAssetsOrderByWithRelationInput>
    cursor?: vendorSupportsAssetsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VendorSupportsAssetsScalarFieldEnum>
  }


  /**
   * vendors without action
   */
  export type vendorsArgs = {
    /**
     * Select specific fields to fetch from the vendors
     */
    select?: vendorsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorsInclude | null
  }



  /**
   * Model custodyEngineEventTypes
   */


  export type AggregateCustodyEngineEventTypes = {
    _count: CustodyEngineEventTypesCountAggregateOutputType | null
    _avg: CustodyEngineEventTypesAvgAggregateOutputType | null
    _sum: CustodyEngineEventTypesSumAggregateOutputType | null
    _min: CustodyEngineEventTypesMinAggregateOutputType | null
    _max: CustodyEngineEventTypesMaxAggregateOutputType | null
  }

  export type CustodyEngineEventTypesAvgAggregateOutputType = {
    id: number | null
  }

  export type CustodyEngineEventTypesSumAggregateOutputType = {
    id: number | null
  }

  export type CustodyEngineEventTypesMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustodyEngineEventTypesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustodyEngineEventTypesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustodyEngineEventTypesAvgAggregateInputType = {
    id?: true
  }

  export type CustodyEngineEventTypesSumAggregateInputType = {
    id?: true
  }

  export type CustodyEngineEventTypesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustodyEngineEventTypesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustodyEngineEventTypesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustodyEngineEventTypesAggregateArgs = {
    /**
     * Filter which custodyEngineEventTypes to aggregate.
     */
    where?: custodyEngineEventTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of custodyEngineEventTypes to fetch.
     */
    orderBy?: Enumerable<custodyEngineEventTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: custodyEngineEventTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` custodyEngineEventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` custodyEngineEventTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned custodyEngineEventTypes
    **/
    _count?: true | CustodyEngineEventTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustodyEngineEventTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustodyEngineEventTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustodyEngineEventTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustodyEngineEventTypesMaxAggregateInputType
  }

  export type GetCustodyEngineEventTypesAggregateType<T extends CustodyEngineEventTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateCustodyEngineEventTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustodyEngineEventTypes[P]>
      : GetScalarType<T[P], AggregateCustodyEngineEventTypes[P]>
  }




  export type CustodyEngineEventTypesGroupByArgs = {
    where?: custodyEngineEventTypesWhereInput
    orderBy?: Enumerable<custodyEngineEventTypesOrderByWithAggregationInput>
    by: CustodyEngineEventTypesScalarFieldEnum[]
    having?: custodyEngineEventTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustodyEngineEventTypesCountAggregateInputType | true
    _avg?: CustodyEngineEventTypesAvgAggregateInputType
    _sum?: CustodyEngineEventTypesSumAggregateInputType
    _min?: CustodyEngineEventTypesMinAggregateInputType
    _max?: CustodyEngineEventTypesMaxAggregateInputType
  }


  export type CustodyEngineEventTypesGroupByOutputType = {
    id: number
    name: string
    description: string
    createdAt: Date
    updatedAt: Date
    _count: CustodyEngineEventTypesCountAggregateOutputType | null
    _avg: CustodyEngineEventTypesAvgAggregateOutputType | null
    _sum: CustodyEngineEventTypesSumAggregateOutputType | null
    _min: CustodyEngineEventTypesMinAggregateOutputType | null
    _max: CustodyEngineEventTypesMaxAggregateOutputType | null
  }

  type GetCustodyEngineEventTypesGroupByPayload<T extends CustodyEngineEventTypesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CustodyEngineEventTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustodyEngineEventTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustodyEngineEventTypesGroupByOutputType[P]>
            : GetScalarType<T[P], CustodyEngineEventTypesGroupByOutputType[P]>
        }
      >
    >


  export type custodyEngineEventTypesSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    custodyEngineEvents?: boolean | custodyEngineEventTypes$custodyEngineEventsArgs
    _count?: boolean | CustodyEngineEventTypesCountOutputTypeArgs
  }


  export type custodyEngineEventTypesInclude = {
    custodyEngineEvents?: boolean | custodyEngineEventTypes$custodyEngineEventsArgs
    _count?: boolean | CustodyEngineEventTypesCountOutputTypeArgs
  }

  export type custodyEngineEventTypesGetPayload<S extends boolean | null | undefined | custodyEngineEventTypesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? custodyEngineEventTypes :
    S extends undefined ? never :
    S extends { include: any } & (custodyEngineEventTypesArgs | custodyEngineEventTypesFindManyArgs)
    ? custodyEngineEventTypes  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'custodyEngineEvents' ? Array < custodyEngineEventsGetPayload<S['include'][P]>>  :
        P extends '_count' ? CustodyEngineEventTypesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (custodyEngineEventTypesArgs | custodyEngineEventTypesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'custodyEngineEvents' ? Array < custodyEngineEventsGetPayload<S['select'][P]>>  :
        P extends '_count' ? CustodyEngineEventTypesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof custodyEngineEventTypes ? custodyEngineEventTypes[P] : never
  } 
      : custodyEngineEventTypes


  type custodyEngineEventTypesCountArgs = 
    Omit<custodyEngineEventTypesFindManyArgs, 'select' | 'include'> & {
      select?: CustodyEngineEventTypesCountAggregateInputType | true
    }

  export interface custodyEngineEventTypesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one CustodyEngineEventTypes that matches the filter.
     * @param {custodyEngineEventTypesFindUniqueArgs} args - Arguments to find a CustodyEngineEventTypes
     * @example
     * // Get one CustodyEngineEventTypes
     * const custodyEngineEventTypes = await prisma.custodyEngineEventTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends custodyEngineEventTypesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, custodyEngineEventTypesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'custodyEngineEventTypes'> extends True ? Prisma__custodyEngineEventTypesClient<custodyEngineEventTypesGetPayload<T>> : Prisma__custodyEngineEventTypesClient<custodyEngineEventTypesGetPayload<T> | null, null>

    /**
     * Find one CustodyEngineEventTypes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {custodyEngineEventTypesFindUniqueOrThrowArgs} args - Arguments to find a CustodyEngineEventTypes
     * @example
     * // Get one CustodyEngineEventTypes
     * const custodyEngineEventTypes = await prisma.custodyEngineEventTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends custodyEngineEventTypesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, custodyEngineEventTypesFindUniqueOrThrowArgs>
    ): Prisma__custodyEngineEventTypesClient<custodyEngineEventTypesGetPayload<T>>

    /**
     * Find the first CustodyEngineEventTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {custodyEngineEventTypesFindFirstArgs} args - Arguments to find a CustodyEngineEventTypes
     * @example
     * // Get one CustodyEngineEventTypes
     * const custodyEngineEventTypes = await prisma.custodyEngineEventTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends custodyEngineEventTypesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, custodyEngineEventTypesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'custodyEngineEventTypes'> extends True ? Prisma__custodyEngineEventTypesClient<custodyEngineEventTypesGetPayload<T>> : Prisma__custodyEngineEventTypesClient<custodyEngineEventTypesGetPayload<T> | null, null>

    /**
     * Find the first CustodyEngineEventTypes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {custodyEngineEventTypesFindFirstOrThrowArgs} args - Arguments to find a CustodyEngineEventTypes
     * @example
     * // Get one CustodyEngineEventTypes
     * const custodyEngineEventTypes = await prisma.custodyEngineEventTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends custodyEngineEventTypesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, custodyEngineEventTypesFindFirstOrThrowArgs>
    ): Prisma__custodyEngineEventTypesClient<custodyEngineEventTypesGetPayload<T>>

    /**
     * Find zero or more CustodyEngineEventTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {custodyEngineEventTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustodyEngineEventTypes
     * const custodyEngineEventTypes = await prisma.custodyEngineEventTypes.findMany()
     * 
     * // Get first 10 CustodyEngineEventTypes
     * const custodyEngineEventTypes = await prisma.custodyEngineEventTypes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const custodyEngineEventTypesWithIdOnly = await prisma.custodyEngineEventTypes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends custodyEngineEventTypesFindManyArgs>(
      args?: SelectSubset<T, custodyEngineEventTypesFindManyArgs>
    ): PrismaPromise<Array<custodyEngineEventTypesGetPayload<T>>>

    /**
     * Create a CustodyEngineEventTypes.
     * @param {custodyEngineEventTypesCreateArgs} args - Arguments to create a CustodyEngineEventTypes.
     * @example
     * // Create one CustodyEngineEventTypes
     * const CustodyEngineEventTypes = await prisma.custodyEngineEventTypes.create({
     *   data: {
     *     // ... data to create a CustodyEngineEventTypes
     *   }
     * })
     * 
    **/
    create<T extends custodyEngineEventTypesCreateArgs>(
      args: SelectSubset<T, custodyEngineEventTypesCreateArgs>
    ): Prisma__custodyEngineEventTypesClient<custodyEngineEventTypesGetPayload<T>>

    /**
     * Create many CustodyEngineEventTypes.
     *     @param {custodyEngineEventTypesCreateManyArgs} args - Arguments to create many CustodyEngineEventTypes.
     *     @example
     *     // Create many CustodyEngineEventTypes
     *     const custodyEngineEventTypes = await prisma.custodyEngineEventTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends custodyEngineEventTypesCreateManyArgs>(
      args?: SelectSubset<T, custodyEngineEventTypesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CustodyEngineEventTypes.
     * @param {custodyEngineEventTypesDeleteArgs} args - Arguments to delete one CustodyEngineEventTypes.
     * @example
     * // Delete one CustodyEngineEventTypes
     * const CustodyEngineEventTypes = await prisma.custodyEngineEventTypes.delete({
     *   where: {
     *     // ... filter to delete one CustodyEngineEventTypes
     *   }
     * })
     * 
    **/
    delete<T extends custodyEngineEventTypesDeleteArgs>(
      args: SelectSubset<T, custodyEngineEventTypesDeleteArgs>
    ): Prisma__custodyEngineEventTypesClient<custodyEngineEventTypesGetPayload<T>>

    /**
     * Update one CustodyEngineEventTypes.
     * @param {custodyEngineEventTypesUpdateArgs} args - Arguments to update one CustodyEngineEventTypes.
     * @example
     * // Update one CustodyEngineEventTypes
     * const custodyEngineEventTypes = await prisma.custodyEngineEventTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends custodyEngineEventTypesUpdateArgs>(
      args: SelectSubset<T, custodyEngineEventTypesUpdateArgs>
    ): Prisma__custodyEngineEventTypesClient<custodyEngineEventTypesGetPayload<T>>

    /**
     * Delete zero or more CustodyEngineEventTypes.
     * @param {custodyEngineEventTypesDeleteManyArgs} args - Arguments to filter CustodyEngineEventTypes to delete.
     * @example
     * // Delete a few CustodyEngineEventTypes
     * const { count } = await prisma.custodyEngineEventTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends custodyEngineEventTypesDeleteManyArgs>(
      args?: SelectSubset<T, custodyEngineEventTypesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustodyEngineEventTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {custodyEngineEventTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustodyEngineEventTypes
     * const custodyEngineEventTypes = await prisma.custodyEngineEventTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends custodyEngineEventTypesUpdateManyArgs>(
      args: SelectSubset<T, custodyEngineEventTypesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CustodyEngineEventTypes.
     * @param {custodyEngineEventTypesUpsertArgs} args - Arguments to update or create a CustodyEngineEventTypes.
     * @example
     * // Update or create a CustodyEngineEventTypes
     * const custodyEngineEventTypes = await prisma.custodyEngineEventTypes.upsert({
     *   create: {
     *     // ... data to create a CustodyEngineEventTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustodyEngineEventTypes we want to update
     *   }
     * })
    **/
    upsert<T extends custodyEngineEventTypesUpsertArgs>(
      args: SelectSubset<T, custodyEngineEventTypesUpsertArgs>
    ): Prisma__custodyEngineEventTypesClient<custodyEngineEventTypesGetPayload<T>>

    /**
     * Count the number of CustodyEngineEventTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {custodyEngineEventTypesCountArgs} args - Arguments to filter CustodyEngineEventTypes to count.
     * @example
     * // Count the number of CustodyEngineEventTypes
     * const count = await prisma.custodyEngineEventTypes.count({
     *   where: {
     *     // ... the filter for the CustodyEngineEventTypes we want to count
     *   }
     * })
    **/
    count<T extends custodyEngineEventTypesCountArgs>(
      args?: Subset<T, custodyEngineEventTypesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustodyEngineEventTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustodyEngineEventTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustodyEngineEventTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustodyEngineEventTypesAggregateArgs>(args: Subset<T, CustodyEngineEventTypesAggregateArgs>): PrismaPromise<GetCustodyEngineEventTypesAggregateType<T>>

    /**
     * Group by CustodyEngineEventTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustodyEngineEventTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustodyEngineEventTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustodyEngineEventTypesGroupByArgs['orderBy'] }
        : { orderBy?: CustodyEngineEventTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustodyEngineEventTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustodyEngineEventTypesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for custodyEngineEventTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__custodyEngineEventTypesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    custodyEngineEvents<T extends custodyEngineEventTypes$custodyEngineEventsArgs= {}>(args?: Subset<T, custodyEngineEventTypes$custodyEngineEventsArgs>): PrismaPromise<Array<custodyEngineEventsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * custodyEngineEventTypes base type for findUnique actions
   */
  export type custodyEngineEventTypesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the custodyEngineEventTypes
     */
    select?: custodyEngineEventTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyEngineEventTypesInclude | null
    /**
     * Filter, which custodyEngineEventTypes to fetch.
     */
    where: custodyEngineEventTypesWhereUniqueInput
  }

  /**
   * custodyEngineEventTypes findUnique
   */
  export interface custodyEngineEventTypesFindUniqueArgs extends custodyEngineEventTypesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * custodyEngineEventTypes findUniqueOrThrow
   */
  export type custodyEngineEventTypesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the custodyEngineEventTypes
     */
    select?: custodyEngineEventTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyEngineEventTypesInclude | null
    /**
     * Filter, which custodyEngineEventTypes to fetch.
     */
    where: custodyEngineEventTypesWhereUniqueInput
  }


  /**
   * custodyEngineEventTypes base type for findFirst actions
   */
  export type custodyEngineEventTypesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the custodyEngineEventTypes
     */
    select?: custodyEngineEventTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyEngineEventTypesInclude | null
    /**
     * Filter, which custodyEngineEventTypes to fetch.
     */
    where?: custodyEngineEventTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of custodyEngineEventTypes to fetch.
     */
    orderBy?: Enumerable<custodyEngineEventTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for custodyEngineEventTypes.
     */
    cursor?: custodyEngineEventTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` custodyEngineEventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` custodyEngineEventTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of custodyEngineEventTypes.
     */
    distinct?: Enumerable<CustodyEngineEventTypesScalarFieldEnum>
  }

  /**
   * custodyEngineEventTypes findFirst
   */
  export interface custodyEngineEventTypesFindFirstArgs extends custodyEngineEventTypesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * custodyEngineEventTypes findFirstOrThrow
   */
  export type custodyEngineEventTypesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the custodyEngineEventTypes
     */
    select?: custodyEngineEventTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyEngineEventTypesInclude | null
    /**
     * Filter, which custodyEngineEventTypes to fetch.
     */
    where?: custodyEngineEventTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of custodyEngineEventTypes to fetch.
     */
    orderBy?: Enumerable<custodyEngineEventTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for custodyEngineEventTypes.
     */
    cursor?: custodyEngineEventTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` custodyEngineEventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` custodyEngineEventTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of custodyEngineEventTypes.
     */
    distinct?: Enumerable<CustodyEngineEventTypesScalarFieldEnum>
  }


  /**
   * custodyEngineEventTypes findMany
   */
  export type custodyEngineEventTypesFindManyArgs = {
    /**
     * Select specific fields to fetch from the custodyEngineEventTypes
     */
    select?: custodyEngineEventTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyEngineEventTypesInclude | null
    /**
     * Filter, which custodyEngineEventTypes to fetch.
     */
    where?: custodyEngineEventTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of custodyEngineEventTypes to fetch.
     */
    orderBy?: Enumerable<custodyEngineEventTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing custodyEngineEventTypes.
     */
    cursor?: custodyEngineEventTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` custodyEngineEventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` custodyEngineEventTypes.
     */
    skip?: number
    distinct?: Enumerable<CustodyEngineEventTypesScalarFieldEnum>
  }


  /**
   * custodyEngineEventTypes create
   */
  export type custodyEngineEventTypesCreateArgs = {
    /**
     * Select specific fields to fetch from the custodyEngineEventTypes
     */
    select?: custodyEngineEventTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyEngineEventTypesInclude | null
    /**
     * The data needed to create a custodyEngineEventTypes.
     */
    data: XOR<custodyEngineEventTypesCreateInput, custodyEngineEventTypesUncheckedCreateInput>
  }


  /**
   * custodyEngineEventTypes createMany
   */
  export type custodyEngineEventTypesCreateManyArgs = {
    /**
     * The data used to create many custodyEngineEventTypes.
     */
    data: Enumerable<custodyEngineEventTypesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * custodyEngineEventTypes update
   */
  export type custodyEngineEventTypesUpdateArgs = {
    /**
     * Select specific fields to fetch from the custodyEngineEventTypes
     */
    select?: custodyEngineEventTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyEngineEventTypesInclude | null
    /**
     * The data needed to update a custodyEngineEventTypes.
     */
    data: XOR<custodyEngineEventTypesUpdateInput, custodyEngineEventTypesUncheckedUpdateInput>
    /**
     * Choose, which custodyEngineEventTypes to update.
     */
    where: custodyEngineEventTypesWhereUniqueInput
  }


  /**
   * custodyEngineEventTypes updateMany
   */
  export type custodyEngineEventTypesUpdateManyArgs = {
    /**
     * The data used to update custodyEngineEventTypes.
     */
    data: XOR<custodyEngineEventTypesUpdateManyMutationInput, custodyEngineEventTypesUncheckedUpdateManyInput>
    /**
     * Filter which custodyEngineEventTypes to update
     */
    where?: custodyEngineEventTypesWhereInput
  }


  /**
   * custodyEngineEventTypes upsert
   */
  export type custodyEngineEventTypesUpsertArgs = {
    /**
     * Select specific fields to fetch from the custodyEngineEventTypes
     */
    select?: custodyEngineEventTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyEngineEventTypesInclude | null
    /**
     * The filter to search for the custodyEngineEventTypes to update in case it exists.
     */
    where: custodyEngineEventTypesWhereUniqueInput
    /**
     * In case the custodyEngineEventTypes found by the `where` argument doesn't exist, create a new custodyEngineEventTypes with this data.
     */
    create: XOR<custodyEngineEventTypesCreateInput, custodyEngineEventTypesUncheckedCreateInput>
    /**
     * In case the custodyEngineEventTypes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<custodyEngineEventTypesUpdateInput, custodyEngineEventTypesUncheckedUpdateInput>
  }


  /**
   * custodyEngineEventTypes delete
   */
  export type custodyEngineEventTypesDeleteArgs = {
    /**
     * Select specific fields to fetch from the custodyEngineEventTypes
     */
    select?: custodyEngineEventTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyEngineEventTypesInclude | null
    /**
     * Filter which custodyEngineEventTypes to delete.
     */
    where: custodyEngineEventTypesWhereUniqueInput
  }


  /**
   * custodyEngineEventTypes deleteMany
   */
  export type custodyEngineEventTypesDeleteManyArgs = {
    /**
     * Filter which custodyEngineEventTypes to delete
     */
    where?: custodyEngineEventTypesWhereInput
  }


  /**
   * custodyEngineEventTypes.custodyEngineEvents
   */
  export type custodyEngineEventTypes$custodyEngineEventsArgs = {
    /**
     * Select specific fields to fetch from the custodyEngineEvents
     */
    select?: custodyEngineEventsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyEngineEventsInclude | null
    where?: custodyEngineEventsWhereInput
    orderBy?: Enumerable<custodyEngineEventsOrderByWithRelationInput>
    cursor?: custodyEngineEventsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CustodyEngineEventsScalarFieldEnum>
  }


  /**
   * custodyEngineEventTypes without action
   */
  export type custodyEngineEventTypesArgs = {
    /**
     * Select specific fields to fetch from the custodyEngineEventTypes
     */
    select?: custodyEngineEventTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyEngineEventTypesInclude | null
  }



  /**
   * Model custodyEngineEvents
   */


  export type AggregateCustodyEngineEvents = {
    _count: CustodyEngineEventsCountAggregateOutputType | null
    _avg: CustodyEngineEventsAvgAggregateOutputType | null
    _sum: CustodyEngineEventsSumAggregateOutputType | null
    _min: CustodyEngineEventsMinAggregateOutputType | null
    _max: CustodyEngineEventsMaxAggregateOutputType | null
  }

  export type CustodyEngineEventsAvgAggregateOutputType = {
    organizationId: number | null
    custodyEngineEventTypeId: number | null
  }

  export type CustodyEngineEventsSumAggregateOutputType = {
    organizationId: number | null
    custodyEngineEventTypeId: number | null
  }

  export type CustodyEngineEventsMinAggregateOutputType = {
    id: string | null
    organizationId: number | null
    custodyEngineEventTypeId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustodyEngineEventsMaxAggregateOutputType = {
    id: string | null
    organizationId: number | null
    custodyEngineEventTypeId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustodyEngineEventsCountAggregateOutputType = {
    id: number
    organizationId: number
    custodyEngineEventTypeId: number
    event: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustodyEngineEventsAvgAggregateInputType = {
    organizationId?: true
    custodyEngineEventTypeId?: true
  }

  export type CustodyEngineEventsSumAggregateInputType = {
    organizationId?: true
    custodyEngineEventTypeId?: true
  }

  export type CustodyEngineEventsMinAggregateInputType = {
    id?: true
    organizationId?: true
    custodyEngineEventTypeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustodyEngineEventsMaxAggregateInputType = {
    id?: true
    organizationId?: true
    custodyEngineEventTypeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustodyEngineEventsCountAggregateInputType = {
    id?: true
    organizationId?: true
    custodyEngineEventTypeId?: true
    event?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustodyEngineEventsAggregateArgs = {
    /**
     * Filter which custodyEngineEvents to aggregate.
     */
    where?: custodyEngineEventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of custodyEngineEvents to fetch.
     */
    orderBy?: Enumerable<custodyEngineEventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: custodyEngineEventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` custodyEngineEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` custodyEngineEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned custodyEngineEvents
    **/
    _count?: true | CustodyEngineEventsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustodyEngineEventsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustodyEngineEventsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustodyEngineEventsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustodyEngineEventsMaxAggregateInputType
  }

  export type GetCustodyEngineEventsAggregateType<T extends CustodyEngineEventsAggregateArgs> = {
        [P in keyof T & keyof AggregateCustodyEngineEvents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustodyEngineEvents[P]>
      : GetScalarType<T[P], AggregateCustodyEngineEvents[P]>
  }




  export type CustodyEngineEventsGroupByArgs = {
    where?: custodyEngineEventsWhereInput
    orderBy?: Enumerable<custodyEngineEventsOrderByWithAggregationInput>
    by: CustodyEngineEventsScalarFieldEnum[]
    having?: custodyEngineEventsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustodyEngineEventsCountAggregateInputType | true
    _avg?: CustodyEngineEventsAvgAggregateInputType
    _sum?: CustodyEngineEventsSumAggregateInputType
    _min?: CustodyEngineEventsMinAggregateInputType
    _max?: CustodyEngineEventsMaxAggregateInputType
  }


  export type CustodyEngineEventsGroupByOutputType = {
    id: string
    organizationId: number
    custodyEngineEventTypeId: number
    event: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: CustodyEngineEventsCountAggregateOutputType | null
    _avg: CustodyEngineEventsAvgAggregateOutputType | null
    _sum: CustodyEngineEventsSumAggregateOutputType | null
    _min: CustodyEngineEventsMinAggregateOutputType | null
    _max: CustodyEngineEventsMaxAggregateOutputType | null
  }

  type GetCustodyEngineEventsGroupByPayload<T extends CustodyEngineEventsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CustodyEngineEventsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustodyEngineEventsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustodyEngineEventsGroupByOutputType[P]>
            : GetScalarType<T[P], CustodyEngineEventsGroupByOutputType[P]>
        }
      >
    >


  export type custodyEngineEventsSelect = {
    id?: boolean
    organizationId?: boolean
    custodyEngineEventTypeId?: boolean
    event?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    custodyEngineEventTypes?: boolean | custodyEngineEventTypesArgs
    organizations?: boolean | organizationsArgs
    webhookRequests?: boolean | custodyEngineEvents$webhookRequestsArgs
    _count?: boolean | CustodyEngineEventsCountOutputTypeArgs
  }


  export type custodyEngineEventsInclude = {
    custodyEngineEventTypes?: boolean | custodyEngineEventTypesArgs
    organizations?: boolean | organizationsArgs
    webhookRequests?: boolean | custodyEngineEvents$webhookRequestsArgs
    _count?: boolean | CustodyEngineEventsCountOutputTypeArgs
  }

  export type custodyEngineEventsGetPayload<S extends boolean | null | undefined | custodyEngineEventsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? custodyEngineEvents :
    S extends undefined ? never :
    S extends { include: any } & (custodyEngineEventsArgs | custodyEngineEventsFindManyArgs)
    ? custodyEngineEvents  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'custodyEngineEventTypes' ? custodyEngineEventTypesGetPayload<S['include'][P]> :
        P extends 'organizations' ? organizationsGetPayload<S['include'][P]> :
        P extends 'webhookRequests' ? Array < webhookRequestsGetPayload<S['include'][P]>>  :
        P extends '_count' ? CustodyEngineEventsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (custodyEngineEventsArgs | custodyEngineEventsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'custodyEngineEventTypes' ? custodyEngineEventTypesGetPayload<S['select'][P]> :
        P extends 'organizations' ? organizationsGetPayload<S['select'][P]> :
        P extends 'webhookRequests' ? Array < webhookRequestsGetPayload<S['select'][P]>>  :
        P extends '_count' ? CustodyEngineEventsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof custodyEngineEvents ? custodyEngineEvents[P] : never
  } 
      : custodyEngineEvents


  type custodyEngineEventsCountArgs = 
    Omit<custodyEngineEventsFindManyArgs, 'select' | 'include'> & {
      select?: CustodyEngineEventsCountAggregateInputType | true
    }

  export interface custodyEngineEventsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one CustodyEngineEvents that matches the filter.
     * @param {custodyEngineEventsFindUniqueArgs} args - Arguments to find a CustodyEngineEvents
     * @example
     * // Get one CustodyEngineEvents
     * const custodyEngineEvents = await prisma.custodyEngineEvents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends custodyEngineEventsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, custodyEngineEventsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'custodyEngineEvents'> extends True ? Prisma__custodyEngineEventsClient<custodyEngineEventsGetPayload<T>> : Prisma__custodyEngineEventsClient<custodyEngineEventsGetPayload<T> | null, null>

    /**
     * Find one CustodyEngineEvents that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {custodyEngineEventsFindUniqueOrThrowArgs} args - Arguments to find a CustodyEngineEvents
     * @example
     * // Get one CustodyEngineEvents
     * const custodyEngineEvents = await prisma.custodyEngineEvents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends custodyEngineEventsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, custodyEngineEventsFindUniqueOrThrowArgs>
    ): Prisma__custodyEngineEventsClient<custodyEngineEventsGetPayload<T>>

    /**
     * Find the first CustodyEngineEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {custodyEngineEventsFindFirstArgs} args - Arguments to find a CustodyEngineEvents
     * @example
     * // Get one CustodyEngineEvents
     * const custodyEngineEvents = await prisma.custodyEngineEvents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends custodyEngineEventsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, custodyEngineEventsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'custodyEngineEvents'> extends True ? Prisma__custodyEngineEventsClient<custodyEngineEventsGetPayload<T>> : Prisma__custodyEngineEventsClient<custodyEngineEventsGetPayload<T> | null, null>

    /**
     * Find the first CustodyEngineEvents that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {custodyEngineEventsFindFirstOrThrowArgs} args - Arguments to find a CustodyEngineEvents
     * @example
     * // Get one CustodyEngineEvents
     * const custodyEngineEvents = await prisma.custodyEngineEvents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends custodyEngineEventsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, custodyEngineEventsFindFirstOrThrowArgs>
    ): Prisma__custodyEngineEventsClient<custodyEngineEventsGetPayload<T>>

    /**
     * Find zero or more CustodyEngineEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {custodyEngineEventsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustodyEngineEvents
     * const custodyEngineEvents = await prisma.custodyEngineEvents.findMany()
     * 
     * // Get first 10 CustodyEngineEvents
     * const custodyEngineEvents = await prisma.custodyEngineEvents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const custodyEngineEventsWithIdOnly = await prisma.custodyEngineEvents.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends custodyEngineEventsFindManyArgs>(
      args?: SelectSubset<T, custodyEngineEventsFindManyArgs>
    ): PrismaPromise<Array<custodyEngineEventsGetPayload<T>>>

    /**
     * Create a CustodyEngineEvents.
     * @param {custodyEngineEventsCreateArgs} args - Arguments to create a CustodyEngineEvents.
     * @example
     * // Create one CustodyEngineEvents
     * const CustodyEngineEvents = await prisma.custodyEngineEvents.create({
     *   data: {
     *     // ... data to create a CustodyEngineEvents
     *   }
     * })
     * 
    **/
    create<T extends custodyEngineEventsCreateArgs>(
      args: SelectSubset<T, custodyEngineEventsCreateArgs>
    ): Prisma__custodyEngineEventsClient<custodyEngineEventsGetPayload<T>>

    /**
     * Create many CustodyEngineEvents.
     *     @param {custodyEngineEventsCreateManyArgs} args - Arguments to create many CustodyEngineEvents.
     *     @example
     *     // Create many CustodyEngineEvents
     *     const custodyEngineEvents = await prisma.custodyEngineEvents.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends custodyEngineEventsCreateManyArgs>(
      args?: SelectSubset<T, custodyEngineEventsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CustodyEngineEvents.
     * @param {custodyEngineEventsDeleteArgs} args - Arguments to delete one CustodyEngineEvents.
     * @example
     * // Delete one CustodyEngineEvents
     * const CustodyEngineEvents = await prisma.custodyEngineEvents.delete({
     *   where: {
     *     // ... filter to delete one CustodyEngineEvents
     *   }
     * })
     * 
    **/
    delete<T extends custodyEngineEventsDeleteArgs>(
      args: SelectSubset<T, custodyEngineEventsDeleteArgs>
    ): Prisma__custodyEngineEventsClient<custodyEngineEventsGetPayload<T>>

    /**
     * Update one CustodyEngineEvents.
     * @param {custodyEngineEventsUpdateArgs} args - Arguments to update one CustodyEngineEvents.
     * @example
     * // Update one CustodyEngineEvents
     * const custodyEngineEvents = await prisma.custodyEngineEvents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends custodyEngineEventsUpdateArgs>(
      args: SelectSubset<T, custodyEngineEventsUpdateArgs>
    ): Prisma__custodyEngineEventsClient<custodyEngineEventsGetPayload<T>>

    /**
     * Delete zero or more CustodyEngineEvents.
     * @param {custodyEngineEventsDeleteManyArgs} args - Arguments to filter CustodyEngineEvents to delete.
     * @example
     * // Delete a few CustodyEngineEvents
     * const { count } = await prisma.custodyEngineEvents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends custodyEngineEventsDeleteManyArgs>(
      args?: SelectSubset<T, custodyEngineEventsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustodyEngineEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {custodyEngineEventsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustodyEngineEvents
     * const custodyEngineEvents = await prisma.custodyEngineEvents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends custodyEngineEventsUpdateManyArgs>(
      args: SelectSubset<T, custodyEngineEventsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CustodyEngineEvents.
     * @param {custodyEngineEventsUpsertArgs} args - Arguments to update or create a CustodyEngineEvents.
     * @example
     * // Update or create a CustodyEngineEvents
     * const custodyEngineEvents = await prisma.custodyEngineEvents.upsert({
     *   create: {
     *     // ... data to create a CustodyEngineEvents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustodyEngineEvents we want to update
     *   }
     * })
    **/
    upsert<T extends custodyEngineEventsUpsertArgs>(
      args: SelectSubset<T, custodyEngineEventsUpsertArgs>
    ): Prisma__custodyEngineEventsClient<custodyEngineEventsGetPayload<T>>

    /**
     * Count the number of CustodyEngineEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {custodyEngineEventsCountArgs} args - Arguments to filter CustodyEngineEvents to count.
     * @example
     * // Count the number of CustodyEngineEvents
     * const count = await prisma.custodyEngineEvents.count({
     *   where: {
     *     // ... the filter for the CustodyEngineEvents we want to count
     *   }
     * })
    **/
    count<T extends custodyEngineEventsCountArgs>(
      args?: Subset<T, custodyEngineEventsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustodyEngineEventsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustodyEngineEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustodyEngineEventsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustodyEngineEventsAggregateArgs>(args: Subset<T, CustodyEngineEventsAggregateArgs>): PrismaPromise<GetCustodyEngineEventsAggregateType<T>>

    /**
     * Group by CustodyEngineEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustodyEngineEventsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustodyEngineEventsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustodyEngineEventsGroupByArgs['orderBy'] }
        : { orderBy?: CustodyEngineEventsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustodyEngineEventsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustodyEngineEventsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for custodyEngineEvents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__custodyEngineEventsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    custodyEngineEventTypes<T extends custodyEngineEventTypesArgs= {}>(args?: Subset<T, custodyEngineEventTypesArgs>): Prisma__custodyEngineEventTypesClient<custodyEngineEventTypesGetPayload<T> | Null>;

    organizations<T extends organizationsArgs= {}>(args?: Subset<T, organizationsArgs>): Prisma__organizationsClient<organizationsGetPayload<T> | Null>;

    webhookRequests<T extends custodyEngineEvents$webhookRequestsArgs= {}>(args?: Subset<T, custodyEngineEvents$webhookRequestsArgs>): PrismaPromise<Array<webhookRequestsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * custodyEngineEvents base type for findUnique actions
   */
  export type custodyEngineEventsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the custodyEngineEvents
     */
    select?: custodyEngineEventsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyEngineEventsInclude | null
    /**
     * Filter, which custodyEngineEvents to fetch.
     */
    where: custodyEngineEventsWhereUniqueInput
  }

  /**
   * custodyEngineEvents findUnique
   */
  export interface custodyEngineEventsFindUniqueArgs extends custodyEngineEventsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * custodyEngineEvents findUniqueOrThrow
   */
  export type custodyEngineEventsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the custodyEngineEvents
     */
    select?: custodyEngineEventsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyEngineEventsInclude | null
    /**
     * Filter, which custodyEngineEvents to fetch.
     */
    where: custodyEngineEventsWhereUniqueInput
  }


  /**
   * custodyEngineEvents base type for findFirst actions
   */
  export type custodyEngineEventsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the custodyEngineEvents
     */
    select?: custodyEngineEventsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyEngineEventsInclude | null
    /**
     * Filter, which custodyEngineEvents to fetch.
     */
    where?: custodyEngineEventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of custodyEngineEvents to fetch.
     */
    orderBy?: Enumerable<custodyEngineEventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for custodyEngineEvents.
     */
    cursor?: custodyEngineEventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` custodyEngineEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` custodyEngineEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of custodyEngineEvents.
     */
    distinct?: Enumerable<CustodyEngineEventsScalarFieldEnum>
  }

  /**
   * custodyEngineEvents findFirst
   */
  export interface custodyEngineEventsFindFirstArgs extends custodyEngineEventsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * custodyEngineEvents findFirstOrThrow
   */
  export type custodyEngineEventsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the custodyEngineEvents
     */
    select?: custodyEngineEventsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyEngineEventsInclude | null
    /**
     * Filter, which custodyEngineEvents to fetch.
     */
    where?: custodyEngineEventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of custodyEngineEvents to fetch.
     */
    orderBy?: Enumerable<custodyEngineEventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for custodyEngineEvents.
     */
    cursor?: custodyEngineEventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` custodyEngineEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` custodyEngineEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of custodyEngineEvents.
     */
    distinct?: Enumerable<CustodyEngineEventsScalarFieldEnum>
  }


  /**
   * custodyEngineEvents findMany
   */
  export type custodyEngineEventsFindManyArgs = {
    /**
     * Select specific fields to fetch from the custodyEngineEvents
     */
    select?: custodyEngineEventsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyEngineEventsInclude | null
    /**
     * Filter, which custodyEngineEvents to fetch.
     */
    where?: custodyEngineEventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of custodyEngineEvents to fetch.
     */
    orderBy?: Enumerable<custodyEngineEventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing custodyEngineEvents.
     */
    cursor?: custodyEngineEventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` custodyEngineEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` custodyEngineEvents.
     */
    skip?: number
    distinct?: Enumerable<CustodyEngineEventsScalarFieldEnum>
  }


  /**
   * custodyEngineEvents create
   */
  export type custodyEngineEventsCreateArgs = {
    /**
     * Select specific fields to fetch from the custodyEngineEvents
     */
    select?: custodyEngineEventsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyEngineEventsInclude | null
    /**
     * The data needed to create a custodyEngineEvents.
     */
    data: XOR<custodyEngineEventsCreateInput, custodyEngineEventsUncheckedCreateInput>
  }


  /**
   * custodyEngineEvents createMany
   */
  export type custodyEngineEventsCreateManyArgs = {
    /**
     * The data used to create many custodyEngineEvents.
     */
    data: Enumerable<custodyEngineEventsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * custodyEngineEvents update
   */
  export type custodyEngineEventsUpdateArgs = {
    /**
     * Select specific fields to fetch from the custodyEngineEvents
     */
    select?: custodyEngineEventsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyEngineEventsInclude | null
    /**
     * The data needed to update a custodyEngineEvents.
     */
    data: XOR<custodyEngineEventsUpdateInput, custodyEngineEventsUncheckedUpdateInput>
    /**
     * Choose, which custodyEngineEvents to update.
     */
    where: custodyEngineEventsWhereUniqueInput
  }


  /**
   * custodyEngineEvents updateMany
   */
  export type custodyEngineEventsUpdateManyArgs = {
    /**
     * The data used to update custodyEngineEvents.
     */
    data: XOR<custodyEngineEventsUpdateManyMutationInput, custodyEngineEventsUncheckedUpdateManyInput>
    /**
     * Filter which custodyEngineEvents to update
     */
    where?: custodyEngineEventsWhereInput
  }


  /**
   * custodyEngineEvents upsert
   */
  export type custodyEngineEventsUpsertArgs = {
    /**
     * Select specific fields to fetch from the custodyEngineEvents
     */
    select?: custodyEngineEventsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyEngineEventsInclude | null
    /**
     * The filter to search for the custodyEngineEvents to update in case it exists.
     */
    where: custodyEngineEventsWhereUniqueInput
    /**
     * In case the custodyEngineEvents found by the `where` argument doesn't exist, create a new custodyEngineEvents with this data.
     */
    create: XOR<custodyEngineEventsCreateInput, custodyEngineEventsUncheckedCreateInput>
    /**
     * In case the custodyEngineEvents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<custodyEngineEventsUpdateInput, custodyEngineEventsUncheckedUpdateInput>
  }


  /**
   * custodyEngineEvents delete
   */
  export type custodyEngineEventsDeleteArgs = {
    /**
     * Select specific fields to fetch from the custodyEngineEvents
     */
    select?: custodyEngineEventsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyEngineEventsInclude | null
    /**
     * Filter which custodyEngineEvents to delete.
     */
    where: custodyEngineEventsWhereUniqueInput
  }


  /**
   * custodyEngineEvents deleteMany
   */
  export type custodyEngineEventsDeleteManyArgs = {
    /**
     * Filter which custodyEngineEvents to delete
     */
    where?: custodyEngineEventsWhereInput
  }


  /**
   * custodyEngineEvents.webhookRequests
   */
  export type custodyEngineEvents$webhookRequestsArgs = {
    /**
     * Select specific fields to fetch from the webhookRequests
     */
    select?: webhookRequestsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhookRequestsInclude | null
    where?: webhookRequestsWhereInput
    orderBy?: Enumerable<webhookRequestsOrderByWithRelationInput>
    cursor?: webhookRequestsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WebhookRequestsScalarFieldEnum>
  }


  /**
   * custodyEngineEvents without action
   */
  export type custodyEngineEventsArgs = {
    /**
     * Select specific fields to fetch from the custodyEngineEvents
     */
    select?: custodyEngineEventsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyEngineEventsInclude | null
  }



  /**
   * Model custodyVendorVaultAssets
   */


  export type AggregateCustodyVendorVaultAssets = {
    _count: CustodyVendorVaultAssetsCountAggregateOutputType | null
    _avg: CustodyVendorVaultAssetsAvgAggregateOutputType | null
    _sum: CustodyVendorVaultAssetsSumAggregateOutputType | null
    _min: CustodyVendorVaultAssetsMinAggregateOutputType | null
    _max: CustodyVendorVaultAssetsMaxAggregateOutputType | null
  }

  export type CustodyVendorVaultAssetsAvgAggregateOutputType = {
    id: number | null
    vendorId: number | null
    vaultAssetId: number | null
  }

  export type CustodyVendorVaultAssetsSumAggregateOutputType = {
    id: number | null
    vendorId: number | null
    vaultAssetId: number | null
  }

  export type CustodyVendorVaultAssetsMinAggregateOutputType = {
    id: number | null
    vendorId: number | null
    vendorRef: string | null
    balance: string | null
    vaultAssetId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustodyVendorVaultAssetsMaxAggregateOutputType = {
    id: number | null
    vendorId: number | null
    vendorRef: string | null
    balance: string | null
    vaultAssetId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustodyVendorVaultAssetsCountAggregateOutputType = {
    id: number
    vendorId: number
    vendorRef: number
    balance: number
    vaultAssetId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustodyVendorVaultAssetsAvgAggregateInputType = {
    id?: true
    vendorId?: true
    vaultAssetId?: true
  }

  export type CustodyVendorVaultAssetsSumAggregateInputType = {
    id?: true
    vendorId?: true
    vaultAssetId?: true
  }

  export type CustodyVendorVaultAssetsMinAggregateInputType = {
    id?: true
    vendorId?: true
    vendorRef?: true
    balance?: true
    vaultAssetId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustodyVendorVaultAssetsMaxAggregateInputType = {
    id?: true
    vendorId?: true
    vendorRef?: true
    balance?: true
    vaultAssetId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustodyVendorVaultAssetsCountAggregateInputType = {
    id?: true
    vendorId?: true
    vendorRef?: true
    balance?: true
    vaultAssetId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustodyVendorVaultAssetsAggregateArgs = {
    /**
     * Filter which custodyVendorVaultAssets to aggregate.
     */
    where?: custodyVendorVaultAssetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of custodyVendorVaultAssets to fetch.
     */
    orderBy?: Enumerable<custodyVendorVaultAssetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: custodyVendorVaultAssetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` custodyVendorVaultAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` custodyVendorVaultAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned custodyVendorVaultAssets
    **/
    _count?: true | CustodyVendorVaultAssetsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustodyVendorVaultAssetsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustodyVendorVaultAssetsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustodyVendorVaultAssetsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustodyVendorVaultAssetsMaxAggregateInputType
  }

  export type GetCustodyVendorVaultAssetsAggregateType<T extends CustodyVendorVaultAssetsAggregateArgs> = {
        [P in keyof T & keyof AggregateCustodyVendorVaultAssets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustodyVendorVaultAssets[P]>
      : GetScalarType<T[P], AggregateCustodyVendorVaultAssets[P]>
  }




  export type CustodyVendorVaultAssetsGroupByArgs = {
    where?: custodyVendorVaultAssetsWhereInput
    orderBy?: Enumerable<custodyVendorVaultAssetsOrderByWithAggregationInput>
    by: CustodyVendorVaultAssetsScalarFieldEnum[]
    having?: custodyVendorVaultAssetsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustodyVendorVaultAssetsCountAggregateInputType | true
    _avg?: CustodyVendorVaultAssetsAvgAggregateInputType
    _sum?: CustodyVendorVaultAssetsSumAggregateInputType
    _min?: CustodyVendorVaultAssetsMinAggregateInputType
    _max?: CustodyVendorVaultAssetsMaxAggregateInputType
  }


  export type CustodyVendorVaultAssetsGroupByOutputType = {
    id: number
    vendorId: number
    vendorRef: string
    balance: string
    vaultAssetId: number
    createdAt: Date
    updatedAt: Date
    _count: CustodyVendorVaultAssetsCountAggregateOutputType | null
    _avg: CustodyVendorVaultAssetsAvgAggregateOutputType | null
    _sum: CustodyVendorVaultAssetsSumAggregateOutputType | null
    _min: CustodyVendorVaultAssetsMinAggregateOutputType | null
    _max: CustodyVendorVaultAssetsMaxAggregateOutputType | null
  }

  type GetCustodyVendorVaultAssetsGroupByPayload<T extends CustodyVendorVaultAssetsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CustodyVendorVaultAssetsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustodyVendorVaultAssetsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustodyVendorVaultAssetsGroupByOutputType[P]>
            : GetScalarType<T[P], CustodyVendorVaultAssetsGroupByOutputType[P]>
        }
      >
    >


  export type custodyVendorVaultAssetsSelect = {
    id?: boolean
    vendorId?: boolean
    vendorRef?: boolean
    balance?: boolean
    vaultAssetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vaultAssets?: boolean | vaultAssetsArgs
    vendors?: boolean | vendorsArgs
  }


  export type custodyVendorVaultAssetsInclude = {
    vaultAssets?: boolean | vaultAssetsArgs
    vendors?: boolean | vendorsArgs
  }

  export type custodyVendorVaultAssetsGetPayload<S extends boolean | null | undefined | custodyVendorVaultAssetsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? custodyVendorVaultAssets :
    S extends undefined ? never :
    S extends { include: any } & (custodyVendorVaultAssetsArgs | custodyVendorVaultAssetsFindManyArgs)
    ? custodyVendorVaultAssets  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'vaultAssets' ? vaultAssetsGetPayload<S['include'][P]> :
        P extends 'vendors' ? vendorsGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (custodyVendorVaultAssetsArgs | custodyVendorVaultAssetsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'vaultAssets' ? vaultAssetsGetPayload<S['select'][P]> :
        P extends 'vendors' ? vendorsGetPayload<S['select'][P]> :  P extends keyof custodyVendorVaultAssets ? custodyVendorVaultAssets[P] : never
  } 
      : custodyVendorVaultAssets


  type custodyVendorVaultAssetsCountArgs = 
    Omit<custodyVendorVaultAssetsFindManyArgs, 'select' | 'include'> & {
      select?: CustodyVendorVaultAssetsCountAggregateInputType | true
    }

  export interface custodyVendorVaultAssetsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one CustodyVendorVaultAssets that matches the filter.
     * @param {custodyVendorVaultAssetsFindUniqueArgs} args - Arguments to find a CustodyVendorVaultAssets
     * @example
     * // Get one CustodyVendorVaultAssets
     * const custodyVendorVaultAssets = await prisma.custodyVendorVaultAssets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends custodyVendorVaultAssetsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, custodyVendorVaultAssetsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'custodyVendorVaultAssets'> extends True ? Prisma__custodyVendorVaultAssetsClient<custodyVendorVaultAssetsGetPayload<T>> : Prisma__custodyVendorVaultAssetsClient<custodyVendorVaultAssetsGetPayload<T> | null, null>

    /**
     * Find one CustodyVendorVaultAssets that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {custodyVendorVaultAssetsFindUniqueOrThrowArgs} args - Arguments to find a CustodyVendorVaultAssets
     * @example
     * // Get one CustodyVendorVaultAssets
     * const custodyVendorVaultAssets = await prisma.custodyVendorVaultAssets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends custodyVendorVaultAssetsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, custodyVendorVaultAssetsFindUniqueOrThrowArgs>
    ): Prisma__custodyVendorVaultAssetsClient<custodyVendorVaultAssetsGetPayload<T>>

    /**
     * Find the first CustodyVendorVaultAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {custodyVendorVaultAssetsFindFirstArgs} args - Arguments to find a CustodyVendorVaultAssets
     * @example
     * // Get one CustodyVendorVaultAssets
     * const custodyVendorVaultAssets = await prisma.custodyVendorVaultAssets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends custodyVendorVaultAssetsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, custodyVendorVaultAssetsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'custodyVendorVaultAssets'> extends True ? Prisma__custodyVendorVaultAssetsClient<custodyVendorVaultAssetsGetPayload<T>> : Prisma__custodyVendorVaultAssetsClient<custodyVendorVaultAssetsGetPayload<T> | null, null>

    /**
     * Find the first CustodyVendorVaultAssets that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {custodyVendorVaultAssetsFindFirstOrThrowArgs} args - Arguments to find a CustodyVendorVaultAssets
     * @example
     * // Get one CustodyVendorVaultAssets
     * const custodyVendorVaultAssets = await prisma.custodyVendorVaultAssets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends custodyVendorVaultAssetsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, custodyVendorVaultAssetsFindFirstOrThrowArgs>
    ): Prisma__custodyVendorVaultAssetsClient<custodyVendorVaultAssetsGetPayload<T>>

    /**
     * Find zero or more CustodyVendorVaultAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {custodyVendorVaultAssetsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustodyVendorVaultAssets
     * const custodyVendorVaultAssets = await prisma.custodyVendorVaultAssets.findMany()
     * 
     * // Get first 10 CustodyVendorVaultAssets
     * const custodyVendorVaultAssets = await prisma.custodyVendorVaultAssets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const custodyVendorVaultAssetsWithIdOnly = await prisma.custodyVendorVaultAssets.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends custodyVendorVaultAssetsFindManyArgs>(
      args?: SelectSubset<T, custodyVendorVaultAssetsFindManyArgs>
    ): PrismaPromise<Array<custodyVendorVaultAssetsGetPayload<T>>>

    /**
     * Create a CustodyVendorVaultAssets.
     * @param {custodyVendorVaultAssetsCreateArgs} args - Arguments to create a CustodyVendorVaultAssets.
     * @example
     * // Create one CustodyVendorVaultAssets
     * const CustodyVendorVaultAssets = await prisma.custodyVendorVaultAssets.create({
     *   data: {
     *     // ... data to create a CustodyVendorVaultAssets
     *   }
     * })
     * 
    **/
    create<T extends custodyVendorVaultAssetsCreateArgs>(
      args: SelectSubset<T, custodyVendorVaultAssetsCreateArgs>
    ): Prisma__custodyVendorVaultAssetsClient<custodyVendorVaultAssetsGetPayload<T>>

    /**
     * Create many CustodyVendorVaultAssets.
     *     @param {custodyVendorVaultAssetsCreateManyArgs} args - Arguments to create many CustodyVendorVaultAssets.
     *     @example
     *     // Create many CustodyVendorVaultAssets
     *     const custodyVendorVaultAssets = await prisma.custodyVendorVaultAssets.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends custodyVendorVaultAssetsCreateManyArgs>(
      args?: SelectSubset<T, custodyVendorVaultAssetsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CustodyVendorVaultAssets.
     * @param {custodyVendorVaultAssetsDeleteArgs} args - Arguments to delete one CustodyVendorVaultAssets.
     * @example
     * // Delete one CustodyVendorVaultAssets
     * const CustodyVendorVaultAssets = await prisma.custodyVendorVaultAssets.delete({
     *   where: {
     *     // ... filter to delete one CustodyVendorVaultAssets
     *   }
     * })
     * 
    **/
    delete<T extends custodyVendorVaultAssetsDeleteArgs>(
      args: SelectSubset<T, custodyVendorVaultAssetsDeleteArgs>
    ): Prisma__custodyVendorVaultAssetsClient<custodyVendorVaultAssetsGetPayload<T>>

    /**
     * Update one CustodyVendorVaultAssets.
     * @param {custodyVendorVaultAssetsUpdateArgs} args - Arguments to update one CustodyVendorVaultAssets.
     * @example
     * // Update one CustodyVendorVaultAssets
     * const custodyVendorVaultAssets = await prisma.custodyVendorVaultAssets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends custodyVendorVaultAssetsUpdateArgs>(
      args: SelectSubset<T, custodyVendorVaultAssetsUpdateArgs>
    ): Prisma__custodyVendorVaultAssetsClient<custodyVendorVaultAssetsGetPayload<T>>

    /**
     * Delete zero or more CustodyVendorVaultAssets.
     * @param {custodyVendorVaultAssetsDeleteManyArgs} args - Arguments to filter CustodyVendorVaultAssets to delete.
     * @example
     * // Delete a few CustodyVendorVaultAssets
     * const { count } = await prisma.custodyVendorVaultAssets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends custodyVendorVaultAssetsDeleteManyArgs>(
      args?: SelectSubset<T, custodyVendorVaultAssetsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustodyVendorVaultAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {custodyVendorVaultAssetsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustodyVendorVaultAssets
     * const custodyVendorVaultAssets = await prisma.custodyVendorVaultAssets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends custodyVendorVaultAssetsUpdateManyArgs>(
      args: SelectSubset<T, custodyVendorVaultAssetsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CustodyVendorVaultAssets.
     * @param {custodyVendorVaultAssetsUpsertArgs} args - Arguments to update or create a CustodyVendorVaultAssets.
     * @example
     * // Update or create a CustodyVendorVaultAssets
     * const custodyVendorVaultAssets = await prisma.custodyVendorVaultAssets.upsert({
     *   create: {
     *     // ... data to create a CustodyVendorVaultAssets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustodyVendorVaultAssets we want to update
     *   }
     * })
    **/
    upsert<T extends custodyVendorVaultAssetsUpsertArgs>(
      args: SelectSubset<T, custodyVendorVaultAssetsUpsertArgs>
    ): Prisma__custodyVendorVaultAssetsClient<custodyVendorVaultAssetsGetPayload<T>>

    /**
     * Count the number of CustodyVendorVaultAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {custodyVendorVaultAssetsCountArgs} args - Arguments to filter CustodyVendorVaultAssets to count.
     * @example
     * // Count the number of CustodyVendorVaultAssets
     * const count = await prisma.custodyVendorVaultAssets.count({
     *   where: {
     *     // ... the filter for the CustodyVendorVaultAssets we want to count
     *   }
     * })
    **/
    count<T extends custodyVendorVaultAssetsCountArgs>(
      args?: Subset<T, custodyVendorVaultAssetsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustodyVendorVaultAssetsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustodyVendorVaultAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustodyVendorVaultAssetsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustodyVendorVaultAssetsAggregateArgs>(args: Subset<T, CustodyVendorVaultAssetsAggregateArgs>): PrismaPromise<GetCustodyVendorVaultAssetsAggregateType<T>>

    /**
     * Group by CustodyVendorVaultAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustodyVendorVaultAssetsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustodyVendorVaultAssetsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustodyVendorVaultAssetsGroupByArgs['orderBy'] }
        : { orderBy?: CustodyVendorVaultAssetsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustodyVendorVaultAssetsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustodyVendorVaultAssetsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for custodyVendorVaultAssets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__custodyVendorVaultAssetsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    vaultAssets<T extends vaultAssetsArgs= {}>(args?: Subset<T, vaultAssetsArgs>): Prisma__vaultAssetsClient<vaultAssetsGetPayload<T> | Null>;

    vendors<T extends vendorsArgs= {}>(args?: Subset<T, vendorsArgs>): Prisma__vendorsClient<vendorsGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * custodyVendorVaultAssets base type for findUnique actions
   */
  export type custodyVendorVaultAssetsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the custodyVendorVaultAssets
     */
    select?: custodyVendorVaultAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyVendorVaultAssetsInclude | null
    /**
     * Filter, which custodyVendorVaultAssets to fetch.
     */
    where: custodyVendorVaultAssetsWhereUniqueInput
  }

  /**
   * custodyVendorVaultAssets findUnique
   */
  export interface custodyVendorVaultAssetsFindUniqueArgs extends custodyVendorVaultAssetsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * custodyVendorVaultAssets findUniqueOrThrow
   */
  export type custodyVendorVaultAssetsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the custodyVendorVaultAssets
     */
    select?: custodyVendorVaultAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyVendorVaultAssetsInclude | null
    /**
     * Filter, which custodyVendorVaultAssets to fetch.
     */
    where: custodyVendorVaultAssetsWhereUniqueInput
  }


  /**
   * custodyVendorVaultAssets base type for findFirst actions
   */
  export type custodyVendorVaultAssetsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the custodyVendorVaultAssets
     */
    select?: custodyVendorVaultAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyVendorVaultAssetsInclude | null
    /**
     * Filter, which custodyVendorVaultAssets to fetch.
     */
    where?: custodyVendorVaultAssetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of custodyVendorVaultAssets to fetch.
     */
    orderBy?: Enumerable<custodyVendorVaultAssetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for custodyVendorVaultAssets.
     */
    cursor?: custodyVendorVaultAssetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` custodyVendorVaultAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` custodyVendorVaultAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of custodyVendorVaultAssets.
     */
    distinct?: Enumerable<CustodyVendorVaultAssetsScalarFieldEnum>
  }

  /**
   * custodyVendorVaultAssets findFirst
   */
  export interface custodyVendorVaultAssetsFindFirstArgs extends custodyVendorVaultAssetsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * custodyVendorVaultAssets findFirstOrThrow
   */
  export type custodyVendorVaultAssetsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the custodyVendorVaultAssets
     */
    select?: custodyVendorVaultAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyVendorVaultAssetsInclude | null
    /**
     * Filter, which custodyVendorVaultAssets to fetch.
     */
    where?: custodyVendorVaultAssetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of custodyVendorVaultAssets to fetch.
     */
    orderBy?: Enumerable<custodyVendorVaultAssetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for custodyVendorVaultAssets.
     */
    cursor?: custodyVendorVaultAssetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` custodyVendorVaultAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` custodyVendorVaultAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of custodyVendorVaultAssets.
     */
    distinct?: Enumerable<CustodyVendorVaultAssetsScalarFieldEnum>
  }


  /**
   * custodyVendorVaultAssets findMany
   */
  export type custodyVendorVaultAssetsFindManyArgs = {
    /**
     * Select specific fields to fetch from the custodyVendorVaultAssets
     */
    select?: custodyVendorVaultAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyVendorVaultAssetsInclude | null
    /**
     * Filter, which custodyVendorVaultAssets to fetch.
     */
    where?: custodyVendorVaultAssetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of custodyVendorVaultAssets to fetch.
     */
    orderBy?: Enumerable<custodyVendorVaultAssetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing custodyVendorVaultAssets.
     */
    cursor?: custodyVendorVaultAssetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` custodyVendorVaultAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` custodyVendorVaultAssets.
     */
    skip?: number
    distinct?: Enumerable<CustodyVendorVaultAssetsScalarFieldEnum>
  }


  /**
   * custodyVendorVaultAssets create
   */
  export type custodyVendorVaultAssetsCreateArgs = {
    /**
     * Select specific fields to fetch from the custodyVendorVaultAssets
     */
    select?: custodyVendorVaultAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyVendorVaultAssetsInclude | null
    /**
     * The data needed to create a custodyVendorVaultAssets.
     */
    data: XOR<custodyVendorVaultAssetsCreateInput, custodyVendorVaultAssetsUncheckedCreateInput>
  }


  /**
   * custodyVendorVaultAssets createMany
   */
  export type custodyVendorVaultAssetsCreateManyArgs = {
    /**
     * The data used to create many custodyVendorVaultAssets.
     */
    data: Enumerable<custodyVendorVaultAssetsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * custodyVendorVaultAssets update
   */
  export type custodyVendorVaultAssetsUpdateArgs = {
    /**
     * Select specific fields to fetch from the custodyVendorVaultAssets
     */
    select?: custodyVendorVaultAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyVendorVaultAssetsInclude | null
    /**
     * The data needed to update a custodyVendorVaultAssets.
     */
    data: XOR<custodyVendorVaultAssetsUpdateInput, custodyVendorVaultAssetsUncheckedUpdateInput>
    /**
     * Choose, which custodyVendorVaultAssets to update.
     */
    where: custodyVendorVaultAssetsWhereUniqueInput
  }


  /**
   * custodyVendorVaultAssets updateMany
   */
  export type custodyVendorVaultAssetsUpdateManyArgs = {
    /**
     * The data used to update custodyVendorVaultAssets.
     */
    data: XOR<custodyVendorVaultAssetsUpdateManyMutationInput, custodyVendorVaultAssetsUncheckedUpdateManyInput>
    /**
     * Filter which custodyVendorVaultAssets to update
     */
    where?: custodyVendorVaultAssetsWhereInput
  }


  /**
   * custodyVendorVaultAssets upsert
   */
  export type custodyVendorVaultAssetsUpsertArgs = {
    /**
     * Select specific fields to fetch from the custodyVendorVaultAssets
     */
    select?: custodyVendorVaultAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyVendorVaultAssetsInclude | null
    /**
     * The filter to search for the custodyVendorVaultAssets to update in case it exists.
     */
    where: custodyVendorVaultAssetsWhereUniqueInput
    /**
     * In case the custodyVendorVaultAssets found by the `where` argument doesn't exist, create a new custodyVendorVaultAssets with this data.
     */
    create: XOR<custodyVendorVaultAssetsCreateInput, custodyVendorVaultAssetsUncheckedCreateInput>
    /**
     * In case the custodyVendorVaultAssets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<custodyVendorVaultAssetsUpdateInput, custodyVendorVaultAssetsUncheckedUpdateInput>
  }


  /**
   * custodyVendorVaultAssets delete
   */
  export type custodyVendorVaultAssetsDeleteArgs = {
    /**
     * Select specific fields to fetch from the custodyVendorVaultAssets
     */
    select?: custodyVendorVaultAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyVendorVaultAssetsInclude | null
    /**
     * Filter which custodyVendorVaultAssets to delete.
     */
    where: custodyVendorVaultAssetsWhereUniqueInput
  }


  /**
   * custodyVendorVaultAssets deleteMany
   */
  export type custodyVendorVaultAssetsDeleteManyArgs = {
    /**
     * Filter which custodyVendorVaultAssets to delete
     */
    where?: custodyVendorVaultAssetsWhereInput
  }


  /**
   * custodyVendorVaultAssets without action
   */
  export type custodyVendorVaultAssetsArgs = {
    /**
     * Select specific fields to fetch from the custodyVendorVaultAssets
     */
    select?: custodyVendorVaultAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyVendorVaultAssetsInclude | null
  }



  /**
   * Model depositAddressStatusTypes
   */


  export type AggregateDepositAddressStatusTypes = {
    _count: DepositAddressStatusTypesCountAggregateOutputType | null
    _avg: DepositAddressStatusTypesAvgAggregateOutputType | null
    _sum: DepositAddressStatusTypesSumAggregateOutputType | null
    _min: DepositAddressStatusTypesMinAggregateOutputType | null
    _max: DepositAddressStatusTypesMaxAggregateOutputType | null
  }

  export type DepositAddressStatusTypesAvgAggregateOutputType = {
    id: number | null
  }

  export type DepositAddressStatusTypesSumAggregateOutputType = {
    id: number | null
  }

  export type DepositAddressStatusTypesMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepositAddressStatusTypesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepositAddressStatusTypesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepositAddressStatusTypesAvgAggregateInputType = {
    id?: true
  }

  export type DepositAddressStatusTypesSumAggregateInputType = {
    id?: true
  }

  export type DepositAddressStatusTypesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepositAddressStatusTypesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepositAddressStatusTypesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepositAddressStatusTypesAggregateArgs = {
    /**
     * Filter which depositAddressStatusTypes to aggregate.
     */
    where?: depositAddressStatusTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of depositAddressStatusTypes to fetch.
     */
    orderBy?: Enumerable<depositAddressStatusTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: depositAddressStatusTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` depositAddressStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` depositAddressStatusTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned depositAddressStatusTypes
    **/
    _count?: true | DepositAddressStatusTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepositAddressStatusTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepositAddressStatusTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepositAddressStatusTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepositAddressStatusTypesMaxAggregateInputType
  }

  export type GetDepositAddressStatusTypesAggregateType<T extends DepositAddressStatusTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateDepositAddressStatusTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepositAddressStatusTypes[P]>
      : GetScalarType<T[P], AggregateDepositAddressStatusTypes[P]>
  }




  export type DepositAddressStatusTypesGroupByArgs = {
    where?: depositAddressStatusTypesWhereInput
    orderBy?: Enumerable<depositAddressStatusTypesOrderByWithAggregationInput>
    by: DepositAddressStatusTypesScalarFieldEnum[]
    having?: depositAddressStatusTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepositAddressStatusTypesCountAggregateInputType | true
    _avg?: DepositAddressStatusTypesAvgAggregateInputType
    _sum?: DepositAddressStatusTypesSumAggregateInputType
    _min?: DepositAddressStatusTypesMinAggregateInputType
    _max?: DepositAddressStatusTypesMaxAggregateInputType
  }


  export type DepositAddressStatusTypesGroupByOutputType = {
    id: number
    name: string
    description: string
    createdAt: Date
    updatedAt: Date
    _count: DepositAddressStatusTypesCountAggregateOutputType | null
    _avg: DepositAddressStatusTypesAvgAggregateOutputType | null
    _sum: DepositAddressStatusTypesSumAggregateOutputType | null
    _min: DepositAddressStatusTypesMinAggregateOutputType | null
    _max: DepositAddressStatusTypesMaxAggregateOutputType | null
  }

  type GetDepositAddressStatusTypesGroupByPayload<T extends DepositAddressStatusTypesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DepositAddressStatusTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepositAddressStatusTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepositAddressStatusTypesGroupByOutputType[P]>
            : GetScalarType<T[P], DepositAddressStatusTypesGroupByOutputType[P]>
        }
      >
    >


  export type depositAddressStatusTypesSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type depositAddressStatusTypesGetPayload<S extends boolean | null | undefined | depositAddressStatusTypesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? depositAddressStatusTypes :
    S extends undefined ? never :
    S extends { include: any } & (depositAddressStatusTypesArgs | depositAddressStatusTypesFindManyArgs)
    ? depositAddressStatusTypes 
    : S extends { select: any } & (depositAddressStatusTypesArgs | depositAddressStatusTypesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof depositAddressStatusTypes ? depositAddressStatusTypes[P] : never
  } 
      : depositAddressStatusTypes


  type depositAddressStatusTypesCountArgs = 
    Omit<depositAddressStatusTypesFindManyArgs, 'select' | 'include'> & {
      select?: DepositAddressStatusTypesCountAggregateInputType | true
    }

  export interface depositAddressStatusTypesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one DepositAddressStatusTypes that matches the filter.
     * @param {depositAddressStatusTypesFindUniqueArgs} args - Arguments to find a DepositAddressStatusTypes
     * @example
     * // Get one DepositAddressStatusTypes
     * const depositAddressStatusTypes = await prisma.depositAddressStatusTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends depositAddressStatusTypesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, depositAddressStatusTypesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'depositAddressStatusTypes'> extends True ? Prisma__depositAddressStatusTypesClient<depositAddressStatusTypesGetPayload<T>> : Prisma__depositAddressStatusTypesClient<depositAddressStatusTypesGetPayload<T> | null, null>

    /**
     * Find one DepositAddressStatusTypes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {depositAddressStatusTypesFindUniqueOrThrowArgs} args - Arguments to find a DepositAddressStatusTypes
     * @example
     * // Get one DepositAddressStatusTypes
     * const depositAddressStatusTypes = await prisma.depositAddressStatusTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends depositAddressStatusTypesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, depositAddressStatusTypesFindUniqueOrThrowArgs>
    ): Prisma__depositAddressStatusTypesClient<depositAddressStatusTypesGetPayload<T>>

    /**
     * Find the first DepositAddressStatusTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {depositAddressStatusTypesFindFirstArgs} args - Arguments to find a DepositAddressStatusTypes
     * @example
     * // Get one DepositAddressStatusTypes
     * const depositAddressStatusTypes = await prisma.depositAddressStatusTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends depositAddressStatusTypesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, depositAddressStatusTypesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'depositAddressStatusTypes'> extends True ? Prisma__depositAddressStatusTypesClient<depositAddressStatusTypesGetPayload<T>> : Prisma__depositAddressStatusTypesClient<depositAddressStatusTypesGetPayload<T> | null, null>

    /**
     * Find the first DepositAddressStatusTypes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {depositAddressStatusTypesFindFirstOrThrowArgs} args - Arguments to find a DepositAddressStatusTypes
     * @example
     * // Get one DepositAddressStatusTypes
     * const depositAddressStatusTypes = await prisma.depositAddressStatusTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends depositAddressStatusTypesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, depositAddressStatusTypesFindFirstOrThrowArgs>
    ): Prisma__depositAddressStatusTypesClient<depositAddressStatusTypesGetPayload<T>>

    /**
     * Find zero or more DepositAddressStatusTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {depositAddressStatusTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DepositAddressStatusTypes
     * const depositAddressStatusTypes = await prisma.depositAddressStatusTypes.findMany()
     * 
     * // Get first 10 DepositAddressStatusTypes
     * const depositAddressStatusTypes = await prisma.depositAddressStatusTypes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const depositAddressStatusTypesWithIdOnly = await prisma.depositAddressStatusTypes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends depositAddressStatusTypesFindManyArgs>(
      args?: SelectSubset<T, depositAddressStatusTypesFindManyArgs>
    ): PrismaPromise<Array<depositAddressStatusTypesGetPayload<T>>>

    /**
     * Create a DepositAddressStatusTypes.
     * @param {depositAddressStatusTypesCreateArgs} args - Arguments to create a DepositAddressStatusTypes.
     * @example
     * // Create one DepositAddressStatusTypes
     * const DepositAddressStatusTypes = await prisma.depositAddressStatusTypes.create({
     *   data: {
     *     // ... data to create a DepositAddressStatusTypes
     *   }
     * })
     * 
    **/
    create<T extends depositAddressStatusTypesCreateArgs>(
      args: SelectSubset<T, depositAddressStatusTypesCreateArgs>
    ): Prisma__depositAddressStatusTypesClient<depositAddressStatusTypesGetPayload<T>>

    /**
     * Create many DepositAddressStatusTypes.
     *     @param {depositAddressStatusTypesCreateManyArgs} args - Arguments to create many DepositAddressStatusTypes.
     *     @example
     *     // Create many DepositAddressStatusTypes
     *     const depositAddressStatusTypes = await prisma.depositAddressStatusTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends depositAddressStatusTypesCreateManyArgs>(
      args?: SelectSubset<T, depositAddressStatusTypesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DepositAddressStatusTypes.
     * @param {depositAddressStatusTypesDeleteArgs} args - Arguments to delete one DepositAddressStatusTypes.
     * @example
     * // Delete one DepositAddressStatusTypes
     * const DepositAddressStatusTypes = await prisma.depositAddressStatusTypes.delete({
     *   where: {
     *     // ... filter to delete one DepositAddressStatusTypes
     *   }
     * })
     * 
    **/
    delete<T extends depositAddressStatusTypesDeleteArgs>(
      args: SelectSubset<T, depositAddressStatusTypesDeleteArgs>
    ): Prisma__depositAddressStatusTypesClient<depositAddressStatusTypesGetPayload<T>>

    /**
     * Update one DepositAddressStatusTypes.
     * @param {depositAddressStatusTypesUpdateArgs} args - Arguments to update one DepositAddressStatusTypes.
     * @example
     * // Update one DepositAddressStatusTypes
     * const depositAddressStatusTypes = await prisma.depositAddressStatusTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends depositAddressStatusTypesUpdateArgs>(
      args: SelectSubset<T, depositAddressStatusTypesUpdateArgs>
    ): Prisma__depositAddressStatusTypesClient<depositAddressStatusTypesGetPayload<T>>

    /**
     * Delete zero or more DepositAddressStatusTypes.
     * @param {depositAddressStatusTypesDeleteManyArgs} args - Arguments to filter DepositAddressStatusTypes to delete.
     * @example
     * // Delete a few DepositAddressStatusTypes
     * const { count } = await prisma.depositAddressStatusTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends depositAddressStatusTypesDeleteManyArgs>(
      args?: SelectSubset<T, depositAddressStatusTypesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepositAddressStatusTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {depositAddressStatusTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DepositAddressStatusTypes
     * const depositAddressStatusTypes = await prisma.depositAddressStatusTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends depositAddressStatusTypesUpdateManyArgs>(
      args: SelectSubset<T, depositAddressStatusTypesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DepositAddressStatusTypes.
     * @param {depositAddressStatusTypesUpsertArgs} args - Arguments to update or create a DepositAddressStatusTypes.
     * @example
     * // Update or create a DepositAddressStatusTypes
     * const depositAddressStatusTypes = await prisma.depositAddressStatusTypes.upsert({
     *   create: {
     *     // ... data to create a DepositAddressStatusTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DepositAddressStatusTypes we want to update
     *   }
     * })
    **/
    upsert<T extends depositAddressStatusTypesUpsertArgs>(
      args: SelectSubset<T, depositAddressStatusTypesUpsertArgs>
    ): Prisma__depositAddressStatusTypesClient<depositAddressStatusTypesGetPayload<T>>

    /**
     * Count the number of DepositAddressStatusTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {depositAddressStatusTypesCountArgs} args - Arguments to filter DepositAddressStatusTypes to count.
     * @example
     * // Count the number of DepositAddressStatusTypes
     * const count = await prisma.depositAddressStatusTypes.count({
     *   where: {
     *     // ... the filter for the DepositAddressStatusTypes we want to count
     *   }
     * })
    **/
    count<T extends depositAddressStatusTypesCountArgs>(
      args?: Subset<T, depositAddressStatusTypesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepositAddressStatusTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DepositAddressStatusTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositAddressStatusTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepositAddressStatusTypesAggregateArgs>(args: Subset<T, DepositAddressStatusTypesAggregateArgs>): PrismaPromise<GetDepositAddressStatusTypesAggregateType<T>>

    /**
     * Group by DepositAddressStatusTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositAddressStatusTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepositAddressStatusTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepositAddressStatusTypesGroupByArgs['orderBy'] }
        : { orderBy?: DepositAddressStatusTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepositAddressStatusTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepositAddressStatusTypesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for depositAddressStatusTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__depositAddressStatusTypesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * depositAddressStatusTypes base type for findUnique actions
   */
  export type depositAddressStatusTypesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the depositAddressStatusTypes
     */
    select?: depositAddressStatusTypesSelect | null
    /**
     * Filter, which depositAddressStatusTypes to fetch.
     */
    where: depositAddressStatusTypesWhereUniqueInput
  }

  /**
   * depositAddressStatusTypes findUnique
   */
  export interface depositAddressStatusTypesFindUniqueArgs extends depositAddressStatusTypesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * depositAddressStatusTypes findUniqueOrThrow
   */
  export type depositAddressStatusTypesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the depositAddressStatusTypes
     */
    select?: depositAddressStatusTypesSelect | null
    /**
     * Filter, which depositAddressStatusTypes to fetch.
     */
    where: depositAddressStatusTypesWhereUniqueInput
  }


  /**
   * depositAddressStatusTypes base type for findFirst actions
   */
  export type depositAddressStatusTypesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the depositAddressStatusTypes
     */
    select?: depositAddressStatusTypesSelect | null
    /**
     * Filter, which depositAddressStatusTypes to fetch.
     */
    where?: depositAddressStatusTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of depositAddressStatusTypes to fetch.
     */
    orderBy?: Enumerable<depositAddressStatusTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for depositAddressStatusTypes.
     */
    cursor?: depositAddressStatusTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` depositAddressStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` depositAddressStatusTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of depositAddressStatusTypes.
     */
    distinct?: Enumerable<DepositAddressStatusTypesScalarFieldEnum>
  }

  /**
   * depositAddressStatusTypes findFirst
   */
  export interface depositAddressStatusTypesFindFirstArgs extends depositAddressStatusTypesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * depositAddressStatusTypes findFirstOrThrow
   */
  export type depositAddressStatusTypesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the depositAddressStatusTypes
     */
    select?: depositAddressStatusTypesSelect | null
    /**
     * Filter, which depositAddressStatusTypes to fetch.
     */
    where?: depositAddressStatusTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of depositAddressStatusTypes to fetch.
     */
    orderBy?: Enumerable<depositAddressStatusTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for depositAddressStatusTypes.
     */
    cursor?: depositAddressStatusTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` depositAddressStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` depositAddressStatusTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of depositAddressStatusTypes.
     */
    distinct?: Enumerable<DepositAddressStatusTypesScalarFieldEnum>
  }


  /**
   * depositAddressStatusTypes findMany
   */
  export type depositAddressStatusTypesFindManyArgs = {
    /**
     * Select specific fields to fetch from the depositAddressStatusTypes
     */
    select?: depositAddressStatusTypesSelect | null
    /**
     * Filter, which depositAddressStatusTypes to fetch.
     */
    where?: depositAddressStatusTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of depositAddressStatusTypes to fetch.
     */
    orderBy?: Enumerable<depositAddressStatusTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing depositAddressStatusTypes.
     */
    cursor?: depositAddressStatusTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` depositAddressStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` depositAddressStatusTypes.
     */
    skip?: number
    distinct?: Enumerable<DepositAddressStatusTypesScalarFieldEnum>
  }


  /**
   * depositAddressStatusTypes create
   */
  export type depositAddressStatusTypesCreateArgs = {
    /**
     * Select specific fields to fetch from the depositAddressStatusTypes
     */
    select?: depositAddressStatusTypesSelect | null
    /**
     * The data needed to create a depositAddressStatusTypes.
     */
    data: XOR<depositAddressStatusTypesCreateInput, depositAddressStatusTypesUncheckedCreateInput>
  }


  /**
   * depositAddressStatusTypes createMany
   */
  export type depositAddressStatusTypesCreateManyArgs = {
    /**
     * The data used to create many depositAddressStatusTypes.
     */
    data: Enumerable<depositAddressStatusTypesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * depositAddressStatusTypes update
   */
  export type depositAddressStatusTypesUpdateArgs = {
    /**
     * Select specific fields to fetch from the depositAddressStatusTypes
     */
    select?: depositAddressStatusTypesSelect | null
    /**
     * The data needed to update a depositAddressStatusTypes.
     */
    data: XOR<depositAddressStatusTypesUpdateInput, depositAddressStatusTypesUncheckedUpdateInput>
    /**
     * Choose, which depositAddressStatusTypes to update.
     */
    where: depositAddressStatusTypesWhereUniqueInput
  }


  /**
   * depositAddressStatusTypes updateMany
   */
  export type depositAddressStatusTypesUpdateManyArgs = {
    /**
     * The data used to update depositAddressStatusTypes.
     */
    data: XOR<depositAddressStatusTypesUpdateManyMutationInput, depositAddressStatusTypesUncheckedUpdateManyInput>
    /**
     * Filter which depositAddressStatusTypes to update
     */
    where?: depositAddressStatusTypesWhereInput
  }


  /**
   * depositAddressStatusTypes upsert
   */
  export type depositAddressStatusTypesUpsertArgs = {
    /**
     * Select specific fields to fetch from the depositAddressStatusTypes
     */
    select?: depositAddressStatusTypesSelect | null
    /**
     * The filter to search for the depositAddressStatusTypes to update in case it exists.
     */
    where: depositAddressStatusTypesWhereUniqueInput
    /**
     * In case the depositAddressStatusTypes found by the `where` argument doesn't exist, create a new depositAddressStatusTypes with this data.
     */
    create: XOR<depositAddressStatusTypesCreateInput, depositAddressStatusTypesUncheckedCreateInput>
    /**
     * In case the depositAddressStatusTypes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<depositAddressStatusTypesUpdateInput, depositAddressStatusTypesUncheckedUpdateInput>
  }


  /**
   * depositAddressStatusTypes delete
   */
  export type depositAddressStatusTypesDeleteArgs = {
    /**
     * Select specific fields to fetch from the depositAddressStatusTypes
     */
    select?: depositAddressStatusTypesSelect | null
    /**
     * Filter which depositAddressStatusTypes to delete.
     */
    where: depositAddressStatusTypesWhereUniqueInput
  }


  /**
   * depositAddressStatusTypes deleteMany
   */
  export type depositAddressStatusTypesDeleteManyArgs = {
    /**
     * Filter which depositAddressStatusTypes to delete
     */
    where?: depositAddressStatusTypesWhereInput
  }


  /**
   * depositAddressStatusTypes without action
   */
  export type depositAddressStatusTypesArgs = {
    /**
     * Select specific fields to fetch from the depositAddressStatusTypes
     */
    select?: depositAddressStatusTypesSelect | null
  }



  /**
   * Model depositAddresses
   */


  export type AggregateDepositAddresses = {
    _count: DepositAddressesCountAggregateOutputType | null
    _avg: DepositAddressesAvgAggregateOutputType | null
    _sum: DepositAddressesSumAggregateOutputType | null
    _min: DepositAddressesMinAggregateOutputType | null
    _max: DepositAddressesMaxAggregateOutputType | null
  }

  export type DepositAddressesAvgAggregateOutputType = {
    vaultAssetId: number | null
    depositAddressStatusId: number | null
    vendorId: number | null
  }

  export type DepositAddressesSumAggregateOutputType = {
    vaultAssetId: number | null
    depositAddressStatusId: number | null
    vendorId: number | null
  }

  export type DepositAddressesMinAggregateOutputType = {
    id: string | null
    vaultAssetId: number | null
    address: string | null
    depositAddressStatusId: number | null
    vendorId: number | null
    vendorRef: string | null
    subjectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepositAddressesMaxAggregateOutputType = {
    id: string | null
    vaultAssetId: number | null
    address: string | null
    depositAddressStatusId: number | null
    vendorId: number | null
    vendorRef: string | null
    subjectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepositAddressesCountAggregateOutputType = {
    id: number
    vaultAssetId: number
    address: number
    depositAddressStatusId: number
    vendorId: number
    vendorRef: number
    subjectId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepositAddressesAvgAggregateInputType = {
    vaultAssetId?: true
    depositAddressStatusId?: true
    vendorId?: true
  }

  export type DepositAddressesSumAggregateInputType = {
    vaultAssetId?: true
    depositAddressStatusId?: true
    vendorId?: true
  }

  export type DepositAddressesMinAggregateInputType = {
    id?: true
    vaultAssetId?: true
    address?: true
    depositAddressStatusId?: true
    vendorId?: true
    vendorRef?: true
    subjectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepositAddressesMaxAggregateInputType = {
    id?: true
    vaultAssetId?: true
    address?: true
    depositAddressStatusId?: true
    vendorId?: true
    vendorRef?: true
    subjectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepositAddressesCountAggregateInputType = {
    id?: true
    vaultAssetId?: true
    address?: true
    depositAddressStatusId?: true
    vendorId?: true
    vendorRef?: true
    subjectId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepositAddressesAggregateArgs = {
    /**
     * Filter which depositAddresses to aggregate.
     */
    where?: depositAddressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of depositAddresses to fetch.
     */
    orderBy?: Enumerable<depositAddressesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: depositAddressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` depositAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` depositAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned depositAddresses
    **/
    _count?: true | DepositAddressesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepositAddressesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepositAddressesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepositAddressesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepositAddressesMaxAggregateInputType
  }

  export type GetDepositAddressesAggregateType<T extends DepositAddressesAggregateArgs> = {
        [P in keyof T & keyof AggregateDepositAddresses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepositAddresses[P]>
      : GetScalarType<T[P], AggregateDepositAddresses[P]>
  }




  export type DepositAddressesGroupByArgs = {
    where?: depositAddressesWhereInput
    orderBy?: Enumerable<depositAddressesOrderByWithAggregationInput>
    by: DepositAddressesScalarFieldEnum[]
    having?: depositAddressesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepositAddressesCountAggregateInputType | true
    _avg?: DepositAddressesAvgAggregateInputType
    _sum?: DepositAddressesSumAggregateInputType
    _min?: DepositAddressesMinAggregateInputType
    _max?: DepositAddressesMaxAggregateInputType
  }


  export type DepositAddressesGroupByOutputType = {
    id: string
    vaultAssetId: number
    address: string
    depositAddressStatusId: number | null
    vendorId: number | null
    vendorRef: string
    subjectId: string
    createdAt: Date
    updatedAt: Date
    _count: DepositAddressesCountAggregateOutputType | null
    _avg: DepositAddressesAvgAggregateOutputType | null
    _sum: DepositAddressesSumAggregateOutputType | null
    _min: DepositAddressesMinAggregateOutputType | null
    _max: DepositAddressesMaxAggregateOutputType | null
  }

  type GetDepositAddressesGroupByPayload<T extends DepositAddressesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DepositAddressesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepositAddressesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepositAddressesGroupByOutputType[P]>
            : GetScalarType<T[P], DepositAddressesGroupByOutputType[P]>
        }
      >
    >


  export type depositAddressesSelect = {
    id?: boolean
    vaultAssetId?: boolean
    address?: boolean
    depositAddressStatusId?: boolean
    vendorId?: boolean
    vendorRef?: boolean
    subjectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vaultAssets?: boolean | vaultAssetsArgs
    vendors?: boolean | vendorsArgs
  }


  export type depositAddressesInclude = {
    vaultAssets?: boolean | vaultAssetsArgs
    vendors?: boolean | vendorsArgs
  }

  export type depositAddressesGetPayload<S extends boolean | null | undefined | depositAddressesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? depositAddresses :
    S extends undefined ? never :
    S extends { include: any } & (depositAddressesArgs | depositAddressesFindManyArgs)
    ? depositAddresses  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'vaultAssets' ? vaultAssetsGetPayload<S['include'][P]> :
        P extends 'vendors' ? vendorsGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (depositAddressesArgs | depositAddressesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'vaultAssets' ? vaultAssetsGetPayload<S['select'][P]> :
        P extends 'vendors' ? vendorsGetPayload<S['select'][P]> | null :  P extends keyof depositAddresses ? depositAddresses[P] : never
  } 
      : depositAddresses


  type depositAddressesCountArgs = 
    Omit<depositAddressesFindManyArgs, 'select' | 'include'> & {
      select?: DepositAddressesCountAggregateInputType | true
    }

  export interface depositAddressesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one DepositAddresses that matches the filter.
     * @param {depositAddressesFindUniqueArgs} args - Arguments to find a DepositAddresses
     * @example
     * // Get one DepositAddresses
     * const depositAddresses = await prisma.depositAddresses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends depositAddressesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, depositAddressesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'depositAddresses'> extends True ? Prisma__depositAddressesClient<depositAddressesGetPayload<T>> : Prisma__depositAddressesClient<depositAddressesGetPayload<T> | null, null>

    /**
     * Find one DepositAddresses that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {depositAddressesFindUniqueOrThrowArgs} args - Arguments to find a DepositAddresses
     * @example
     * // Get one DepositAddresses
     * const depositAddresses = await prisma.depositAddresses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends depositAddressesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, depositAddressesFindUniqueOrThrowArgs>
    ): Prisma__depositAddressesClient<depositAddressesGetPayload<T>>

    /**
     * Find the first DepositAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {depositAddressesFindFirstArgs} args - Arguments to find a DepositAddresses
     * @example
     * // Get one DepositAddresses
     * const depositAddresses = await prisma.depositAddresses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends depositAddressesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, depositAddressesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'depositAddresses'> extends True ? Prisma__depositAddressesClient<depositAddressesGetPayload<T>> : Prisma__depositAddressesClient<depositAddressesGetPayload<T> | null, null>

    /**
     * Find the first DepositAddresses that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {depositAddressesFindFirstOrThrowArgs} args - Arguments to find a DepositAddresses
     * @example
     * // Get one DepositAddresses
     * const depositAddresses = await prisma.depositAddresses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends depositAddressesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, depositAddressesFindFirstOrThrowArgs>
    ): Prisma__depositAddressesClient<depositAddressesGetPayload<T>>

    /**
     * Find zero or more DepositAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {depositAddressesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DepositAddresses
     * const depositAddresses = await prisma.depositAddresses.findMany()
     * 
     * // Get first 10 DepositAddresses
     * const depositAddresses = await prisma.depositAddresses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const depositAddressesWithIdOnly = await prisma.depositAddresses.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends depositAddressesFindManyArgs>(
      args?: SelectSubset<T, depositAddressesFindManyArgs>
    ): PrismaPromise<Array<depositAddressesGetPayload<T>>>

    /**
     * Create a DepositAddresses.
     * @param {depositAddressesCreateArgs} args - Arguments to create a DepositAddresses.
     * @example
     * // Create one DepositAddresses
     * const DepositAddresses = await prisma.depositAddresses.create({
     *   data: {
     *     // ... data to create a DepositAddresses
     *   }
     * })
     * 
    **/
    create<T extends depositAddressesCreateArgs>(
      args: SelectSubset<T, depositAddressesCreateArgs>
    ): Prisma__depositAddressesClient<depositAddressesGetPayload<T>>

    /**
     * Create many DepositAddresses.
     *     @param {depositAddressesCreateManyArgs} args - Arguments to create many DepositAddresses.
     *     @example
     *     // Create many DepositAddresses
     *     const depositAddresses = await prisma.depositAddresses.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends depositAddressesCreateManyArgs>(
      args?: SelectSubset<T, depositAddressesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a DepositAddresses.
     * @param {depositAddressesDeleteArgs} args - Arguments to delete one DepositAddresses.
     * @example
     * // Delete one DepositAddresses
     * const DepositAddresses = await prisma.depositAddresses.delete({
     *   where: {
     *     // ... filter to delete one DepositAddresses
     *   }
     * })
     * 
    **/
    delete<T extends depositAddressesDeleteArgs>(
      args: SelectSubset<T, depositAddressesDeleteArgs>
    ): Prisma__depositAddressesClient<depositAddressesGetPayload<T>>

    /**
     * Update one DepositAddresses.
     * @param {depositAddressesUpdateArgs} args - Arguments to update one DepositAddresses.
     * @example
     * // Update one DepositAddresses
     * const depositAddresses = await prisma.depositAddresses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends depositAddressesUpdateArgs>(
      args: SelectSubset<T, depositAddressesUpdateArgs>
    ): Prisma__depositAddressesClient<depositAddressesGetPayload<T>>

    /**
     * Delete zero or more DepositAddresses.
     * @param {depositAddressesDeleteManyArgs} args - Arguments to filter DepositAddresses to delete.
     * @example
     * // Delete a few DepositAddresses
     * const { count } = await prisma.depositAddresses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends depositAddressesDeleteManyArgs>(
      args?: SelectSubset<T, depositAddressesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepositAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {depositAddressesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DepositAddresses
     * const depositAddresses = await prisma.depositAddresses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends depositAddressesUpdateManyArgs>(
      args: SelectSubset<T, depositAddressesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DepositAddresses.
     * @param {depositAddressesUpsertArgs} args - Arguments to update or create a DepositAddresses.
     * @example
     * // Update or create a DepositAddresses
     * const depositAddresses = await prisma.depositAddresses.upsert({
     *   create: {
     *     // ... data to create a DepositAddresses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DepositAddresses we want to update
     *   }
     * })
    **/
    upsert<T extends depositAddressesUpsertArgs>(
      args: SelectSubset<T, depositAddressesUpsertArgs>
    ): Prisma__depositAddressesClient<depositAddressesGetPayload<T>>

    /**
     * Count the number of DepositAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {depositAddressesCountArgs} args - Arguments to filter DepositAddresses to count.
     * @example
     * // Count the number of DepositAddresses
     * const count = await prisma.depositAddresses.count({
     *   where: {
     *     // ... the filter for the DepositAddresses we want to count
     *   }
     * })
    **/
    count<T extends depositAddressesCountArgs>(
      args?: Subset<T, depositAddressesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepositAddressesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DepositAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositAddressesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepositAddressesAggregateArgs>(args: Subset<T, DepositAddressesAggregateArgs>): PrismaPromise<GetDepositAddressesAggregateType<T>>

    /**
     * Group by DepositAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositAddressesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepositAddressesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepositAddressesGroupByArgs['orderBy'] }
        : { orderBy?: DepositAddressesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepositAddressesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepositAddressesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for depositAddresses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__depositAddressesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    vaultAssets<T extends vaultAssetsArgs= {}>(args?: Subset<T, vaultAssetsArgs>): Prisma__vaultAssetsClient<vaultAssetsGetPayload<T> | Null>;

    vendors<T extends vendorsArgs= {}>(args?: Subset<T, vendorsArgs>): Prisma__vendorsClient<vendorsGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * depositAddresses base type for findUnique actions
   */
  export type depositAddressesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the depositAddresses
     */
    select?: depositAddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: depositAddressesInclude | null
    /**
     * Filter, which depositAddresses to fetch.
     */
    where: depositAddressesWhereUniqueInput
  }

  /**
   * depositAddresses findUnique
   */
  export interface depositAddressesFindUniqueArgs extends depositAddressesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * depositAddresses findUniqueOrThrow
   */
  export type depositAddressesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the depositAddresses
     */
    select?: depositAddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: depositAddressesInclude | null
    /**
     * Filter, which depositAddresses to fetch.
     */
    where: depositAddressesWhereUniqueInput
  }


  /**
   * depositAddresses base type for findFirst actions
   */
  export type depositAddressesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the depositAddresses
     */
    select?: depositAddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: depositAddressesInclude | null
    /**
     * Filter, which depositAddresses to fetch.
     */
    where?: depositAddressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of depositAddresses to fetch.
     */
    orderBy?: Enumerable<depositAddressesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for depositAddresses.
     */
    cursor?: depositAddressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` depositAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` depositAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of depositAddresses.
     */
    distinct?: Enumerable<DepositAddressesScalarFieldEnum>
  }

  /**
   * depositAddresses findFirst
   */
  export interface depositAddressesFindFirstArgs extends depositAddressesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * depositAddresses findFirstOrThrow
   */
  export type depositAddressesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the depositAddresses
     */
    select?: depositAddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: depositAddressesInclude | null
    /**
     * Filter, which depositAddresses to fetch.
     */
    where?: depositAddressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of depositAddresses to fetch.
     */
    orderBy?: Enumerable<depositAddressesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for depositAddresses.
     */
    cursor?: depositAddressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` depositAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` depositAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of depositAddresses.
     */
    distinct?: Enumerable<DepositAddressesScalarFieldEnum>
  }


  /**
   * depositAddresses findMany
   */
  export type depositAddressesFindManyArgs = {
    /**
     * Select specific fields to fetch from the depositAddresses
     */
    select?: depositAddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: depositAddressesInclude | null
    /**
     * Filter, which depositAddresses to fetch.
     */
    where?: depositAddressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of depositAddresses to fetch.
     */
    orderBy?: Enumerable<depositAddressesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing depositAddresses.
     */
    cursor?: depositAddressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` depositAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` depositAddresses.
     */
    skip?: number
    distinct?: Enumerable<DepositAddressesScalarFieldEnum>
  }


  /**
   * depositAddresses create
   */
  export type depositAddressesCreateArgs = {
    /**
     * Select specific fields to fetch from the depositAddresses
     */
    select?: depositAddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: depositAddressesInclude | null
    /**
     * The data needed to create a depositAddresses.
     */
    data: XOR<depositAddressesCreateInput, depositAddressesUncheckedCreateInput>
  }


  /**
   * depositAddresses createMany
   */
  export type depositAddressesCreateManyArgs = {
    /**
     * The data used to create many depositAddresses.
     */
    data: Enumerable<depositAddressesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * depositAddresses update
   */
  export type depositAddressesUpdateArgs = {
    /**
     * Select specific fields to fetch from the depositAddresses
     */
    select?: depositAddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: depositAddressesInclude | null
    /**
     * The data needed to update a depositAddresses.
     */
    data: XOR<depositAddressesUpdateInput, depositAddressesUncheckedUpdateInput>
    /**
     * Choose, which depositAddresses to update.
     */
    where: depositAddressesWhereUniqueInput
  }


  /**
   * depositAddresses updateMany
   */
  export type depositAddressesUpdateManyArgs = {
    /**
     * The data used to update depositAddresses.
     */
    data: XOR<depositAddressesUpdateManyMutationInput, depositAddressesUncheckedUpdateManyInput>
    /**
     * Filter which depositAddresses to update
     */
    where?: depositAddressesWhereInput
  }


  /**
   * depositAddresses upsert
   */
  export type depositAddressesUpsertArgs = {
    /**
     * Select specific fields to fetch from the depositAddresses
     */
    select?: depositAddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: depositAddressesInclude | null
    /**
     * The filter to search for the depositAddresses to update in case it exists.
     */
    where: depositAddressesWhereUniqueInput
    /**
     * In case the depositAddresses found by the `where` argument doesn't exist, create a new depositAddresses with this data.
     */
    create: XOR<depositAddressesCreateInput, depositAddressesUncheckedCreateInput>
    /**
     * In case the depositAddresses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<depositAddressesUpdateInput, depositAddressesUncheckedUpdateInput>
  }


  /**
   * depositAddresses delete
   */
  export type depositAddressesDeleteArgs = {
    /**
     * Select specific fields to fetch from the depositAddresses
     */
    select?: depositAddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: depositAddressesInclude | null
    /**
     * Filter which depositAddresses to delete.
     */
    where: depositAddressesWhereUniqueInput
  }


  /**
   * depositAddresses deleteMany
   */
  export type depositAddressesDeleteManyArgs = {
    /**
     * Filter which depositAddresses to delete
     */
    where?: depositAddressesWhereInput
  }


  /**
   * depositAddresses without action
   */
  export type depositAddressesArgs = {
    /**
     * Select specific fields to fetch from the depositAddresses
     */
    select?: depositAddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: depositAddressesInclude | null
  }



  /**
   * Model institutionalProducts
   */


  export type AggregateInstitutionalProducts = {
    _count: InstitutionalProductsCountAggregateOutputType | null
    _min: InstitutionalProductsMinAggregateOutputType | null
    _max: InstitutionalProductsMaxAggregateOutputType | null
  }

  export type InstitutionalProductsMinAggregateOutputType = {
    id: string | null
    name: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstitutionalProductsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstitutionalProductsCountAggregateOutputType = {
    id: number
    name: number
    enabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InstitutionalProductsMinAggregateInputType = {
    id?: true
    name?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstitutionalProductsMaxAggregateInputType = {
    id?: true
    name?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstitutionalProductsCountAggregateInputType = {
    id?: true
    name?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InstitutionalProductsAggregateArgs = {
    /**
     * Filter which institutionalProducts to aggregate.
     */
    where?: institutionalProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of institutionalProducts to fetch.
     */
    orderBy?: Enumerable<institutionalProductsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: institutionalProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` institutionalProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` institutionalProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned institutionalProducts
    **/
    _count?: true | InstitutionalProductsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstitutionalProductsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstitutionalProductsMaxAggregateInputType
  }

  export type GetInstitutionalProductsAggregateType<T extends InstitutionalProductsAggregateArgs> = {
        [P in keyof T & keyof AggregateInstitutionalProducts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstitutionalProducts[P]>
      : GetScalarType<T[P], AggregateInstitutionalProducts[P]>
  }




  export type InstitutionalProductsGroupByArgs = {
    where?: institutionalProductsWhereInput
    orderBy?: Enumerable<institutionalProductsOrderByWithAggregationInput>
    by: InstitutionalProductsScalarFieldEnum[]
    having?: institutionalProductsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstitutionalProductsCountAggregateInputType | true
    _min?: InstitutionalProductsMinAggregateInputType
    _max?: InstitutionalProductsMaxAggregateInputType
  }


  export type InstitutionalProductsGroupByOutputType = {
    id: string
    name: string
    enabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: InstitutionalProductsCountAggregateOutputType | null
    _min: InstitutionalProductsMinAggregateOutputType | null
    _max: InstitutionalProductsMaxAggregateOutputType | null
  }

  type GetInstitutionalProductsGroupByPayload<T extends InstitutionalProductsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<InstitutionalProductsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstitutionalProductsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstitutionalProductsGroupByOutputType[P]>
            : GetScalarType<T[P], InstitutionalProductsGroupByOutputType[P]>
        }
      >
    >


  export type institutionalProductsSelect = {
    id?: boolean
    name?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    webhookRequests?: boolean | institutionalProducts$webhookRequestsArgs
    _count?: boolean | InstitutionalProductsCountOutputTypeArgs
  }


  export type institutionalProductsInclude = {
    webhookRequests?: boolean | institutionalProducts$webhookRequestsArgs
    _count?: boolean | InstitutionalProductsCountOutputTypeArgs
  }

  export type institutionalProductsGetPayload<S extends boolean | null | undefined | institutionalProductsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? institutionalProducts :
    S extends undefined ? never :
    S extends { include: any } & (institutionalProductsArgs | institutionalProductsFindManyArgs)
    ? institutionalProducts  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'webhookRequests' ? Array < webhookRequestsGetPayload<S['include'][P]>>  :
        P extends '_count' ? InstitutionalProductsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (institutionalProductsArgs | institutionalProductsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'webhookRequests' ? Array < webhookRequestsGetPayload<S['select'][P]>>  :
        P extends '_count' ? InstitutionalProductsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof institutionalProducts ? institutionalProducts[P] : never
  } 
      : institutionalProducts


  type institutionalProductsCountArgs = 
    Omit<institutionalProductsFindManyArgs, 'select' | 'include'> & {
      select?: InstitutionalProductsCountAggregateInputType | true
    }

  export interface institutionalProductsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one InstitutionalProducts that matches the filter.
     * @param {institutionalProductsFindUniqueArgs} args - Arguments to find a InstitutionalProducts
     * @example
     * // Get one InstitutionalProducts
     * const institutionalProducts = await prisma.institutionalProducts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends institutionalProductsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, institutionalProductsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'institutionalProducts'> extends True ? Prisma__institutionalProductsClient<institutionalProductsGetPayload<T>> : Prisma__institutionalProductsClient<institutionalProductsGetPayload<T> | null, null>

    /**
     * Find one InstitutionalProducts that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {institutionalProductsFindUniqueOrThrowArgs} args - Arguments to find a InstitutionalProducts
     * @example
     * // Get one InstitutionalProducts
     * const institutionalProducts = await prisma.institutionalProducts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends institutionalProductsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, institutionalProductsFindUniqueOrThrowArgs>
    ): Prisma__institutionalProductsClient<institutionalProductsGetPayload<T>>

    /**
     * Find the first InstitutionalProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institutionalProductsFindFirstArgs} args - Arguments to find a InstitutionalProducts
     * @example
     * // Get one InstitutionalProducts
     * const institutionalProducts = await prisma.institutionalProducts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends institutionalProductsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, institutionalProductsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'institutionalProducts'> extends True ? Prisma__institutionalProductsClient<institutionalProductsGetPayload<T>> : Prisma__institutionalProductsClient<institutionalProductsGetPayload<T> | null, null>

    /**
     * Find the first InstitutionalProducts that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institutionalProductsFindFirstOrThrowArgs} args - Arguments to find a InstitutionalProducts
     * @example
     * // Get one InstitutionalProducts
     * const institutionalProducts = await prisma.institutionalProducts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends institutionalProductsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, institutionalProductsFindFirstOrThrowArgs>
    ): Prisma__institutionalProductsClient<institutionalProductsGetPayload<T>>

    /**
     * Find zero or more InstitutionalProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institutionalProductsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InstitutionalProducts
     * const institutionalProducts = await prisma.institutionalProducts.findMany()
     * 
     * // Get first 10 InstitutionalProducts
     * const institutionalProducts = await prisma.institutionalProducts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const institutionalProductsWithIdOnly = await prisma.institutionalProducts.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends institutionalProductsFindManyArgs>(
      args?: SelectSubset<T, institutionalProductsFindManyArgs>
    ): PrismaPromise<Array<institutionalProductsGetPayload<T>>>

    /**
     * Create a InstitutionalProducts.
     * @param {institutionalProductsCreateArgs} args - Arguments to create a InstitutionalProducts.
     * @example
     * // Create one InstitutionalProducts
     * const InstitutionalProducts = await prisma.institutionalProducts.create({
     *   data: {
     *     // ... data to create a InstitutionalProducts
     *   }
     * })
     * 
    **/
    create<T extends institutionalProductsCreateArgs>(
      args: SelectSubset<T, institutionalProductsCreateArgs>
    ): Prisma__institutionalProductsClient<institutionalProductsGetPayload<T>>

    /**
     * Create many InstitutionalProducts.
     *     @param {institutionalProductsCreateManyArgs} args - Arguments to create many InstitutionalProducts.
     *     @example
     *     // Create many InstitutionalProducts
     *     const institutionalProducts = await prisma.institutionalProducts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends institutionalProductsCreateManyArgs>(
      args?: SelectSubset<T, institutionalProductsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a InstitutionalProducts.
     * @param {institutionalProductsDeleteArgs} args - Arguments to delete one InstitutionalProducts.
     * @example
     * // Delete one InstitutionalProducts
     * const InstitutionalProducts = await prisma.institutionalProducts.delete({
     *   where: {
     *     // ... filter to delete one InstitutionalProducts
     *   }
     * })
     * 
    **/
    delete<T extends institutionalProductsDeleteArgs>(
      args: SelectSubset<T, institutionalProductsDeleteArgs>
    ): Prisma__institutionalProductsClient<institutionalProductsGetPayload<T>>

    /**
     * Update one InstitutionalProducts.
     * @param {institutionalProductsUpdateArgs} args - Arguments to update one InstitutionalProducts.
     * @example
     * // Update one InstitutionalProducts
     * const institutionalProducts = await prisma.institutionalProducts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends institutionalProductsUpdateArgs>(
      args: SelectSubset<T, institutionalProductsUpdateArgs>
    ): Prisma__institutionalProductsClient<institutionalProductsGetPayload<T>>

    /**
     * Delete zero or more InstitutionalProducts.
     * @param {institutionalProductsDeleteManyArgs} args - Arguments to filter InstitutionalProducts to delete.
     * @example
     * // Delete a few InstitutionalProducts
     * const { count } = await prisma.institutionalProducts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends institutionalProductsDeleteManyArgs>(
      args?: SelectSubset<T, institutionalProductsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstitutionalProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institutionalProductsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InstitutionalProducts
     * const institutionalProducts = await prisma.institutionalProducts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends institutionalProductsUpdateManyArgs>(
      args: SelectSubset<T, institutionalProductsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one InstitutionalProducts.
     * @param {institutionalProductsUpsertArgs} args - Arguments to update or create a InstitutionalProducts.
     * @example
     * // Update or create a InstitutionalProducts
     * const institutionalProducts = await prisma.institutionalProducts.upsert({
     *   create: {
     *     // ... data to create a InstitutionalProducts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InstitutionalProducts we want to update
     *   }
     * })
    **/
    upsert<T extends institutionalProductsUpsertArgs>(
      args: SelectSubset<T, institutionalProductsUpsertArgs>
    ): Prisma__institutionalProductsClient<institutionalProductsGetPayload<T>>

    /**
     * Count the number of InstitutionalProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institutionalProductsCountArgs} args - Arguments to filter InstitutionalProducts to count.
     * @example
     * // Count the number of InstitutionalProducts
     * const count = await prisma.institutionalProducts.count({
     *   where: {
     *     // ... the filter for the InstitutionalProducts we want to count
     *   }
     * })
    **/
    count<T extends institutionalProductsCountArgs>(
      args?: Subset<T, institutionalProductsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstitutionalProductsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InstitutionalProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionalProductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstitutionalProductsAggregateArgs>(args: Subset<T, InstitutionalProductsAggregateArgs>): PrismaPromise<GetInstitutionalProductsAggregateType<T>>

    /**
     * Group by InstitutionalProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionalProductsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstitutionalProductsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstitutionalProductsGroupByArgs['orderBy'] }
        : { orderBy?: InstitutionalProductsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstitutionalProductsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstitutionalProductsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for institutionalProducts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__institutionalProductsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    webhookRequests<T extends institutionalProducts$webhookRequestsArgs= {}>(args?: Subset<T, institutionalProducts$webhookRequestsArgs>): PrismaPromise<Array<webhookRequestsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * institutionalProducts base type for findUnique actions
   */
  export type institutionalProductsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the institutionalProducts
     */
    select?: institutionalProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: institutionalProductsInclude | null
    /**
     * Filter, which institutionalProducts to fetch.
     */
    where: institutionalProductsWhereUniqueInput
  }

  /**
   * institutionalProducts findUnique
   */
  export interface institutionalProductsFindUniqueArgs extends institutionalProductsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * institutionalProducts findUniqueOrThrow
   */
  export type institutionalProductsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the institutionalProducts
     */
    select?: institutionalProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: institutionalProductsInclude | null
    /**
     * Filter, which institutionalProducts to fetch.
     */
    where: institutionalProductsWhereUniqueInput
  }


  /**
   * institutionalProducts base type for findFirst actions
   */
  export type institutionalProductsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the institutionalProducts
     */
    select?: institutionalProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: institutionalProductsInclude | null
    /**
     * Filter, which institutionalProducts to fetch.
     */
    where?: institutionalProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of institutionalProducts to fetch.
     */
    orderBy?: Enumerable<institutionalProductsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for institutionalProducts.
     */
    cursor?: institutionalProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` institutionalProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` institutionalProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of institutionalProducts.
     */
    distinct?: Enumerable<InstitutionalProductsScalarFieldEnum>
  }

  /**
   * institutionalProducts findFirst
   */
  export interface institutionalProductsFindFirstArgs extends institutionalProductsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * institutionalProducts findFirstOrThrow
   */
  export type institutionalProductsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the institutionalProducts
     */
    select?: institutionalProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: institutionalProductsInclude | null
    /**
     * Filter, which institutionalProducts to fetch.
     */
    where?: institutionalProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of institutionalProducts to fetch.
     */
    orderBy?: Enumerable<institutionalProductsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for institutionalProducts.
     */
    cursor?: institutionalProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` institutionalProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` institutionalProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of institutionalProducts.
     */
    distinct?: Enumerable<InstitutionalProductsScalarFieldEnum>
  }


  /**
   * institutionalProducts findMany
   */
  export type institutionalProductsFindManyArgs = {
    /**
     * Select specific fields to fetch from the institutionalProducts
     */
    select?: institutionalProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: institutionalProductsInclude | null
    /**
     * Filter, which institutionalProducts to fetch.
     */
    where?: institutionalProductsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of institutionalProducts to fetch.
     */
    orderBy?: Enumerable<institutionalProductsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing institutionalProducts.
     */
    cursor?: institutionalProductsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` institutionalProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` institutionalProducts.
     */
    skip?: number
    distinct?: Enumerable<InstitutionalProductsScalarFieldEnum>
  }


  /**
   * institutionalProducts create
   */
  export type institutionalProductsCreateArgs = {
    /**
     * Select specific fields to fetch from the institutionalProducts
     */
    select?: institutionalProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: institutionalProductsInclude | null
    /**
     * The data needed to create a institutionalProducts.
     */
    data: XOR<institutionalProductsCreateInput, institutionalProductsUncheckedCreateInput>
  }


  /**
   * institutionalProducts createMany
   */
  export type institutionalProductsCreateManyArgs = {
    /**
     * The data used to create many institutionalProducts.
     */
    data: Enumerable<institutionalProductsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * institutionalProducts update
   */
  export type institutionalProductsUpdateArgs = {
    /**
     * Select specific fields to fetch from the institutionalProducts
     */
    select?: institutionalProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: institutionalProductsInclude | null
    /**
     * The data needed to update a institutionalProducts.
     */
    data: XOR<institutionalProductsUpdateInput, institutionalProductsUncheckedUpdateInput>
    /**
     * Choose, which institutionalProducts to update.
     */
    where: institutionalProductsWhereUniqueInput
  }


  /**
   * institutionalProducts updateMany
   */
  export type institutionalProductsUpdateManyArgs = {
    /**
     * The data used to update institutionalProducts.
     */
    data: XOR<institutionalProductsUpdateManyMutationInput, institutionalProductsUncheckedUpdateManyInput>
    /**
     * Filter which institutionalProducts to update
     */
    where?: institutionalProductsWhereInput
  }


  /**
   * institutionalProducts upsert
   */
  export type institutionalProductsUpsertArgs = {
    /**
     * Select specific fields to fetch from the institutionalProducts
     */
    select?: institutionalProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: institutionalProductsInclude | null
    /**
     * The filter to search for the institutionalProducts to update in case it exists.
     */
    where: institutionalProductsWhereUniqueInput
    /**
     * In case the institutionalProducts found by the `where` argument doesn't exist, create a new institutionalProducts with this data.
     */
    create: XOR<institutionalProductsCreateInput, institutionalProductsUncheckedCreateInput>
    /**
     * In case the institutionalProducts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<institutionalProductsUpdateInput, institutionalProductsUncheckedUpdateInput>
  }


  /**
   * institutionalProducts delete
   */
  export type institutionalProductsDeleteArgs = {
    /**
     * Select specific fields to fetch from the institutionalProducts
     */
    select?: institutionalProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: institutionalProductsInclude | null
    /**
     * Filter which institutionalProducts to delete.
     */
    where: institutionalProductsWhereUniqueInput
  }


  /**
   * institutionalProducts deleteMany
   */
  export type institutionalProductsDeleteManyArgs = {
    /**
     * Filter which institutionalProducts to delete
     */
    where?: institutionalProductsWhereInput
  }


  /**
   * institutionalProducts.webhookRequests
   */
  export type institutionalProducts$webhookRequestsArgs = {
    /**
     * Select specific fields to fetch from the webhookRequests
     */
    select?: webhookRequestsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhookRequestsInclude | null
    where?: webhookRequestsWhereInput
    orderBy?: Enumerable<webhookRequestsOrderByWithRelationInput>
    cursor?: webhookRequestsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WebhookRequestsScalarFieldEnum>
  }


  /**
   * institutionalProducts without action
   */
  export type institutionalProductsArgs = {
    /**
     * Select specific fields to fetch from the institutionalProducts
     */
    select?: institutionalProductsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: institutionalProductsInclude | null
  }



  /**
   * Model orders
   */


  export type AggregateOrders = {
    _count: OrdersCountAggregateOutputType | null
    _min: OrdersMinAggregateOutputType | null
    _max: OrdersMaxAggregateOutputType | null
  }

  export type OrdersMinAggregateOutputType = {
    id: string | null
    quoteId: string | null
    orderStatus: string | null
    userAcceptedPrice: string | null
    userAcceptedQuantity: string | null
    userAcceptedSide: enum_orders_userAcceptedSide | null
    userAcceptedTimestamp: Date | null
    orderType: enum_orders_orderType | null
    orderTimeInForce: string | null
    vendorQuoteId: string | null
    vendorQuantityRequested: string | null
    vendorPriceRequested: string | null
    orderQuantityExecuted: string | null
    orderPriceExecuted: string | null
    orderTimestampExecuted: Date | null
    orderVendorStatus: string | null
    allowedSlippage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrdersMaxAggregateOutputType = {
    id: string | null
    quoteId: string | null
    orderStatus: string | null
    userAcceptedPrice: string | null
    userAcceptedQuantity: string | null
    userAcceptedSide: enum_orders_userAcceptedSide | null
    userAcceptedTimestamp: Date | null
    orderType: enum_orders_orderType | null
    orderTimeInForce: string | null
    vendorQuoteId: string | null
    vendorQuantityRequested: string | null
    vendorPriceRequested: string | null
    orderQuantityExecuted: string | null
    orderPriceExecuted: string | null
    orderTimestampExecuted: Date | null
    orderVendorStatus: string | null
    allowedSlippage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrdersCountAggregateOutputType = {
    id: number
    quoteId: number
    orderStatus: number
    userAcceptedPrice: number
    userAcceptedQuantity: number
    userAcceptedSide: number
    userAcceptedTradePair: number
    userAcceptedTimestamp: number
    orderType: number
    orderTimeInForce: number
    vendorQuoteId: number
    vendorQuantityRequested: number
    vendorPriceRequested: number
    orderQuantityExecuted: number
    orderPriceExecuted: number
    orderTimestampExecuted: number
    orderVendorStatus: number
    allowedSlippage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrdersMinAggregateInputType = {
    id?: true
    quoteId?: true
    orderStatus?: true
    userAcceptedPrice?: true
    userAcceptedQuantity?: true
    userAcceptedSide?: true
    userAcceptedTimestamp?: true
    orderType?: true
    orderTimeInForce?: true
    vendorQuoteId?: true
    vendorQuantityRequested?: true
    vendorPriceRequested?: true
    orderQuantityExecuted?: true
    orderPriceExecuted?: true
    orderTimestampExecuted?: true
    orderVendorStatus?: true
    allowedSlippage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrdersMaxAggregateInputType = {
    id?: true
    quoteId?: true
    orderStatus?: true
    userAcceptedPrice?: true
    userAcceptedQuantity?: true
    userAcceptedSide?: true
    userAcceptedTimestamp?: true
    orderType?: true
    orderTimeInForce?: true
    vendorQuoteId?: true
    vendorQuantityRequested?: true
    vendorPriceRequested?: true
    orderQuantityExecuted?: true
    orderPriceExecuted?: true
    orderTimestampExecuted?: true
    orderVendorStatus?: true
    allowedSlippage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrdersCountAggregateInputType = {
    id?: true
    quoteId?: true
    orderStatus?: true
    userAcceptedPrice?: true
    userAcceptedQuantity?: true
    userAcceptedSide?: true
    userAcceptedTradePair?: true
    userAcceptedTimestamp?: true
    orderType?: true
    orderTimeInForce?: true
    vendorQuoteId?: true
    vendorQuantityRequested?: true
    vendorPriceRequested?: true
    orderQuantityExecuted?: true
    orderPriceExecuted?: true
    orderTimestampExecuted?: true
    orderVendorStatus?: true
    allowedSlippage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrdersAggregateArgs = {
    /**
     * Filter which orders to aggregate.
     */
    where?: ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: Enumerable<ordersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned orders
    **/
    _count?: true | OrdersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrdersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrdersMaxAggregateInputType
  }

  export type GetOrdersAggregateType<T extends OrdersAggregateArgs> = {
        [P in keyof T & keyof AggregateOrders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrders[P]>
      : GetScalarType<T[P], AggregateOrders[P]>
  }




  export type OrdersGroupByArgs = {
    where?: ordersWhereInput
    orderBy?: Enumerable<ordersOrderByWithAggregationInput>
    by: OrdersScalarFieldEnum[]
    having?: ordersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrdersCountAggregateInputType | true
    _min?: OrdersMinAggregateInputType
    _max?: OrdersMaxAggregateInputType
  }


  export type OrdersGroupByOutputType = {
    id: string
    quoteId: string
    orderStatus: string | null
    userAcceptedPrice: string
    userAcceptedQuantity: string
    userAcceptedSide: enum_orders_userAcceptedSide
    userAcceptedTradePair: JsonValue
    userAcceptedTimestamp: Date
    orderType: enum_orders_orderType | null
    orderTimeInForce: string | null
    vendorQuoteId: string | null
    vendorQuantityRequested: string | null
    vendorPriceRequested: string | null
    orderQuantityExecuted: string | null
    orderPriceExecuted: string | null
    orderTimestampExecuted: Date | null
    orderVendorStatus: string | null
    allowedSlippage: string | null
    createdAt: Date
    updatedAt: Date
    _count: OrdersCountAggregateOutputType | null
    _min: OrdersMinAggregateOutputType | null
    _max: OrdersMaxAggregateOutputType | null
  }

  type GetOrdersGroupByPayload<T extends OrdersGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrdersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrdersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrdersGroupByOutputType[P]>
            : GetScalarType<T[P], OrdersGroupByOutputType[P]>
        }
      >
    >


  export type ordersSelect = {
    id?: boolean
    quoteId?: boolean
    orderStatus?: boolean
    userAcceptedPrice?: boolean
    userAcceptedQuantity?: boolean
    userAcceptedSide?: boolean
    userAcceptedTradePair?: boolean
    userAcceptedTimestamp?: boolean
    orderType?: boolean
    orderTimeInForce?: boolean
    vendorQuoteId?: boolean
    vendorQuantityRequested?: boolean
    vendorPriceRequested?: boolean
    orderQuantityExecuted?: boolean
    orderPriceExecuted?: boolean
    orderTimestampExecuted?: boolean
    orderVendorStatus?: boolean
    allowedSlippage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quotes?: boolean | quotesArgs
  }


  export type ordersInclude = {
    quotes?: boolean | quotesArgs
  }

  export type ordersGetPayload<S extends boolean | null | undefined | ordersArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? orders :
    S extends undefined ? never :
    S extends { include: any } & (ordersArgs | ordersFindManyArgs)
    ? orders  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'quotes' ? quotesGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ordersArgs | ordersFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'quotes' ? quotesGetPayload<S['select'][P]> :  P extends keyof orders ? orders[P] : never
  } 
      : orders


  type ordersCountArgs = 
    Omit<ordersFindManyArgs, 'select' | 'include'> & {
      select?: OrdersCountAggregateInputType | true
    }

  export interface ordersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Orders that matches the filter.
     * @param {ordersFindUniqueArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ordersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ordersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'orders'> extends True ? Prisma__ordersClient<ordersGetPayload<T>> : Prisma__ordersClient<ordersGetPayload<T> | null, null>

    /**
     * Find one Orders that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ordersFindUniqueOrThrowArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ordersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ordersFindUniqueOrThrowArgs>
    ): Prisma__ordersClient<ordersGetPayload<T>>

    /**
     * Find the first Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersFindFirstArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ordersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ordersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'orders'> extends True ? Prisma__ordersClient<ordersGetPayload<T>> : Prisma__ordersClient<ordersGetPayload<T> | null, null>

    /**
     * Find the first Orders that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersFindFirstOrThrowArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ordersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ordersFindFirstOrThrowArgs>
    ): Prisma__ordersClient<ordersGetPayload<T>>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.orders.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.orders.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ordersWithIdOnly = await prisma.orders.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ordersFindManyArgs>(
      args?: SelectSubset<T, ordersFindManyArgs>
    ): PrismaPromise<Array<ordersGetPayload<T>>>

    /**
     * Create a Orders.
     * @param {ordersCreateArgs} args - Arguments to create a Orders.
     * @example
     * // Create one Orders
     * const Orders = await prisma.orders.create({
     *   data: {
     *     // ... data to create a Orders
     *   }
     * })
     * 
    **/
    create<T extends ordersCreateArgs>(
      args: SelectSubset<T, ordersCreateArgs>
    ): Prisma__ordersClient<ordersGetPayload<T>>

    /**
     * Create many Orders.
     *     @param {ordersCreateManyArgs} args - Arguments to create many Orders.
     *     @example
     *     // Create many Orders
     *     const orders = await prisma.orders.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ordersCreateManyArgs>(
      args?: SelectSubset<T, ordersCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Orders.
     * @param {ordersDeleteArgs} args - Arguments to delete one Orders.
     * @example
     * // Delete one Orders
     * const Orders = await prisma.orders.delete({
     *   where: {
     *     // ... filter to delete one Orders
     *   }
     * })
     * 
    **/
    delete<T extends ordersDeleteArgs>(
      args: SelectSubset<T, ordersDeleteArgs>
    ): Prisma__ordersClient<ordersGetPayload<T>>

    /**
     * Update one Orders.
     * @param {ordersUpdateArgs} args - Arguments to update one Orders.
     * @example
     * // Update one Orders
     * const orders = await prisma.orders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ordersUpdateArgs>(
      args: SelectSubset<T, ordersUpdateArgs>
    ): Prisma__ordersClient<ordersGetPayload<T>>

    /**
     * Delete zero or more Orders.
     * @param {ordersDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.orders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ordersDeleteManyArgs>(
      args?: SelectSubset<T, ordersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const orders = await prisma.orders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ordersUpdateManyArgs>(
      args: SelectSubset<T, ordersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Orders.
     * @param {ordersUpsertArgs} args - Arguments to update or create a Orders.
     * @example
     * // Update or create a Orders
     * const orders = await prisma.orders.upsert({
     *   create: {
     *     // ... data to create a Orders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Orders we want to update
     *   }
     * })
    **/
    upsert<T extends ordersUpsertArgs>(
      args: SelectSubset<T, ordersUpsertArgs>
    ): Prisma__ordersClient<ordersGetPayload<T>>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.orders.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends ordersCountArgs>(
      args?: Subset<T, ordersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrdersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrdersAggregateArgs>(args: Subset<T, OrdersAggregateArgs>): PrismaPromise<GetOrdersAggregateType<T>>

    /**
     * Group by Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrdersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrdersGroupByArgs['orderBy'] }
        : { orderBy?: OrdersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrdersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrdersGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for orders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ordersClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    quotes<T extends quotesArgs= {}>(args?: Subset<T, quotesArgs>): Prisma__quotesClient<quotesGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * orders base type for findUnique actions
   */
  export type ordersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ordersInclude | null
    /**
     * Filter, which orders to fetch.
     */
    where: ordersWhereUniqueInput
  }

  /**
   * orders findUnique
   */
  export interface ordersFindUniqueArgs extends ordersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * orders findUniqueOrThrow
   */
  export type ordersFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ordersInclude | null
    /**
     * Filter, which orders to fetch.
     */
    where: ordersWhereUniqueInput
  }


  /**
   * orders base type for findFirst actions
   */
  export type ordersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ordersInclude | null
    /**
     * Filter, which orders to fetch.
     */
    where?: ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: Enumerable<ordersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orders.
     */
    cursor?: ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orders.
     */
    distinct?: Enumerable<OrdersScalarFieldEnum>
  }

  /**
   * orders findFirst
   */
  export interface ordersFindFirstArgs extends ordersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * orders findFirstOrThrow
   */
  export type ordersFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ordersInclude | null
    /**
     * Filter, which orders to fetch.
     */
    where?: ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: Enumerable<ordersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orders.
     */
    cursor?: ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orders.
     */
    distinct?: Enumerable<OrdersScalarFieldEnum>
  }


  /**
   * orders findMany
   */
  export type ordersFindManyArgs = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ordersInclude | null
    /**
     * Filter, which orders to fetch.
     */
    where?: ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: Enumerable<ordersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing orders.
     */
    cursor?: ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    distinct?: Enumerable<OrdersScalarFieldEnum>
  }


  /**
   * orders create
   */
  export type ordersCreateArgs = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ordersInclude | null
    /**
     * The data needed to create a orders.
     */
    data: XOR<ordersCreateInput, ordersUncheckedCreateInput>
  }


  /**
   * orders createMany
   */
  export type ordersCreateManyArgs = {
    /**
     * The data used to create many orders.
     */
    data: Enumerable<ordersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * orders update
   */
  export type ordersUpdateArgs = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ordersInclude | null
    /**
     * The data needed to update a orders.
     */
    data: XOR<ordersUpdateInput, ordersUncheckedUpdateInput>
    /**
     * Choose, which orders to update.
     */
    where: ordersWhereUniqueInput
  }


  /**
   * orders updateMany
   */
  export type ordersUpdateManyArgs = {
    /**
     * The data used to update orders.
     */
    data: XOR<ordersUpdateManyMutationInput, ordersUncheckedUpdateManyInput>
    /**
     * Filter which orders to update
     */
    where?: ordersWhereInput
  }


  /**
   * orders upsert
   */
  export type ordersUpsertArgs = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ordersInclude | null
    /**
     * The filter to search for the orders to update in case it exists.
     */
    where: ordersWhereUniqueInput
    /**
     * In case the orders found by the `where` argument doesn't exist, create a new orders with this data.
     */
    create: XOR<ordersCreateInput, ordersUncheckedCreateInput>
    /**
     * In case the orders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ordersUpdateInput, ordersUncheckedUpdateInput>
  }


  /**
   * orders delete
   */
  export type ordersDeleteArgs = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ordersInclude | null
    /**
     * Filter which orders to delete.
     */
    where: ordersWhereUniqueInput
  }


  /**
   * orders deleteMany
   */
  export type ordersDeleteManyArgs = {
    /**
     * Filter which orders to delete
     */
    where?: ordersWhereInput
  }


  /**
   * orders without action
   */
  export type ordersArgs = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ordersInclude | null
  }



  /**
   * Model organizationStatusTypes
   */


  export type AggregateOrganizationStatusTypes = {
    _count: OrganizationStatusTypesCountAggregateOutputType | null
    _avg: OrganizationStatusTypesAvgAggregateOutputType | null
    _sum: OrganizationStatusTypesSumAggregateOutputType | null
    _min: OrganizationStatusTypesMinAggregateOutputType | null
    _max: OrganizationStatusTypesMaxAggregateOutputType | null
  }

  export type OrganizationStatusTypesAvgAggregateOutputType = {
    id: number | null
  }

  export type OrganizationStatusTypesSumAggregateOutputType = {
    id: number | null
  }

  export type OrganizationStatusTypesMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationStatusTypesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationStatusTypesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationStatusTypesAvgAggregateInputType = {
    id?: true
  }

  export type OrganizationStatusTypesSumAggregateInputType = {
    id?: true
  }

  export type OrganizationStatusTypesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationStatusTypesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationStatusTypesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationStatusTypesAggregateArgs = {
    /**
     * Filter which organizationStatusTypes to aggregate.
     */
    where?: organizationStatusTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizationStatusTypes to fetch.
     */
    orderBy?: Enumerable<organizationStatusTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: organizationStatusTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizationStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizationStatusTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned organizationStatusTypes
    **/
    _count?: true | OrganizationStatusTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganizationStatusTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganizationStatusTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationStatusTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationStatusTypesMaxAggregateInputType
  }

  export type GetOrganizationStatusTypesAggregateType<T extends OrganizationStatusTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizationStatusTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizationStatusTypes[P]>
      : GetScalarType<T[P], AggregateOrganizationStatusTypes[P]>
  }




  export type OrganizationStatusTypesGroupByArgs = {
    where?: organizationStatusTypesWhereInput
    orderBy?: Enumerable<organizationStatusTypesOrderByWithAggregationInput>
    by: OrganizationStatusTypesScalarFieldEnum[]
    having?: organizationStatusTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationStatusTypesCountAggregateInputType | true
    _avg?: OrganizationStatusTypesAvgAggregateInputType
    _sum?: OrganizationStatusTypesSumAggregateInputType
    _min?: OrganizationStatusTypesMinAggregateInputType
    _max?: OrganizationStatusTypesMaxAggregateInputType
  }


  export type OrganizationStatusTypesGroupByOutputType = {
    id: number
    name: string
    description: string
    createdAt: Date
    updatedAt: Date
    _count: OrganizationStatusTypesCountAggregateOutputType | null
    _avg: OrganizationStatusTypesAvgAggregateOutputType | null
    _sum: OrganizationStatusTypesSumAggregateOutputType | null
    _min: OrganizationStatusTypesMinAggregateOutputType | null
    _max: OrganizationStatusTypesMaxAggregateOutputType | null
  }

  type GetOrganizationStatusTypesGroupByPayload<T extends OrganizationStatusTypesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrganizationStatusTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationStatusTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationStatusTypesGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationStatusTypesGroupByOutputType[P]>
        }
      >
    >


  export type organizationStatusTypesSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizations?: boolean | organizationStatusTypes$organizationsArgs
    _count?: boolean | OrganizationStatusTypesCountOutputTypeArgs
  }


  export type organizationStatusTypesInclude = {
    organizations?: boolean | organizationStatusTypes$organizationsArgs
    _count?: boolean | OrganizationStatusTypesCountOutputTypeArgs
  }

  export type organizationStatusTypesGetPayload<S extends boolean | null | undefined | organizationStatusTypesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? organizationStatusTypes :
    S extends undefined ? never :
    S extends { include: any } & (organizationStatusTypesArgs | organizationStatusTypesFindManyArgs)
    ? organizationStatusTypes  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'organizations' ? Array < organizationsGetPayload<S['include'][P]>>  :
        P extends '_count' ? OrganizationStatusTypesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (organizationStatusTypesArgs | organizationStatusTypesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'organizations' ? Array < organizationsGetPayload<S['select'][P]>>  :
        P extends '_count' ? OrganizationStatusTypesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof organizationStatusTypes ? organizationStatusTypes[P] : never
  } 
      : organizationStatusTypes


  type organizationStatusTypesCountArgs = 
    Omit<organizationStatusTypesFindManyArgs, 'select' | 'include'> & {
      select?: OrganizationStatusTypesCountAggregateInputType | true
    }

  export interface organizationStatusTypesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one OrganizationStatusTypes that matches the filter.
     * @param {organizationStatusTypesFindUniqueArgs} args - Arguments to find a OrganizationStatusTypes
     * @example
     * // Get one OrganizationStatusTypes
     * const organizationStatusTypes = await prisma.organizationStatusTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends organizationStatusTypesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, organizationStatusTypesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'organizationStatusTypes'> extends True ? Prisma__organizationStatusTypesClient<organizationStatusTypesGetPayload<T>> : Prisma__organizationStatusTypesClient<organizationStatusTypesGetPayload<T> | null, null>

    /**
     * Find one OrganizationStatusTypes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {organizationStatusTypesFindUniqueOrThrowArgs} args - Arguments to find a OrganizationStatusTypes
     * @example
     * // Get one OrganizationStatusTypes
     * const organizationStatusTypes = await prisma.organizationStatusTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends organizationStatusTypesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, organizationStatusTypesFindUniqueOrThrowArgs>
    ): Prisma__organizationStatusTypesClient<organizationStatusTypesGetPayload<T>>

    /**
     * Find the first OrganizationStatusTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationStatusTypesFindFirstArgs} args - Arguments to find a OrganizationStatusTypes
     * @example
     * // Get one OrganizationStatusTypes
     * const organizationStatusTypes = await prisma.organizationStatusTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends organizationStatusTypesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, organizationStatusTypesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'organizationStatusTypes'> extends True ? Prisma__organizationStatusTypesClient<organizationStatusTypesGetPayload<T>> : Prisma__organizationStatusTypesClient<organizationStatusTypesGetPayload<T> | null, null>

    /**
     * Find the first OrganizationStatusTypes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationStatusTypesFindFirstOrThrowArgs} args - Arguments to find a OrganizationStatusTypes
     * @example
     * // Get one OrganizationStatusTypes
     * const organizationStatusTypes = await prisma.organizationStatusTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends organizationStatusTypesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, organizationStatusTypesFindFirstOrThrowArgs>
    ): Prisma__organizationStatusTypesClient<organizationStatusTypesGetPayload<T>>

    /**
     * Find zero or more OrganizationStatusTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationStatusTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganizationStatusTypes
     * const organizationStatusTypes = await prisma.organizationStatusTypes.findMany()
     * 
     * // Get first 10 OrganizationStatusTypes
     * const organizationStatusTypes = await prisma.organizationStatusTypes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationStatusTypesWithIdOnly = await prisma.organizationStatusTypes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends organizationStatusTypesFindManyArgs>(
      args?: SelectSubset<T, organizationStatusTypesFindManyArgs>
    ): PrismaPromise<Array<organizationStatusTypesGetPayload<T>>>

    /**
     * Create a OrganizationStatusTypes.
     * @param {organizationStatusTypesCreateArgs} args - Arguments to create a OrganizationStatusTypes.
     * @example
     * // Create one OrganizationStatusTypes
     * const OrganizationStatusTypes = await prisma.organizationStatusTypes.create({
     *   data: {
     *     // ... data to create a OrganizationStatusTypes
     *   }
     * })
     * 
    **/
    create<T extends organizationStatusTypesCreateArgs>(
      args: SelectSubset<T, organizationStatusTypesCreateArgs>
    ): Prisma__organizationStatusTypesClient<organizationStatusTypesGetPayload<T>>

    /**
     * Create many OrganizationStatusTypes.
     *     @param {organizationStatusTypesCreateManyArgs} args - Arguments to create many OrganizationStatusTypes.
     *     @example
     *     // Create many OrganizationStatusTypes
     *     const organizationStatusTypes = await prisma.organizationStatusTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends organizationStatusTypesCreateManyArgs>(
      args?: SelectSubset<T, organizationStatusTypesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OrganizationStatusTypes.
     * @param {organizationStatusTypesDeleteArgs} args - Arguments to delete one OrganizationStatusTypes.
     * @example
     * // Delete one OrganizationStatusTypes
     * const OrganizationStatusTypes = await prisma.organizationStatusTypes.delete({
     *   where: {
     *     // ... filter to delete one OrganizationStatusTypes
     *   }
     * })
     * 
    **/
    delete<T extends organizationStatusTypesDeleteArgs>(
      args: SelectSubset<T, organizationStatusTypesDeleteArgs>
    ): Prisma__organizationStatusTypesClient<organizationStatusTypesGetPayload<T>>

    /**
     * Update one OrganizationStatusTypes.
     * @param {organizationStatusTypesUpdateArgs} args - Arguments to update one OrganizationStatusTypes.
     * @example
     * // Update one OrganizationStatusTypes
     * const organizationStatusTypes = await prisma.organizationStatusTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends organizationStatusTypesUpdateArgs>(
      args: SelectSubset<T, organizationStatusTypesUpdateArgs>
    ): Prisma__organizationStatusTypesClient<organizationStatusTypesGetPayload<T>>

    /**
     * Delete zero or more OrganizationStatusTypes.
     * @param {organizationStatusTypesDeleteManyArgs} args - Arguments to filter OrganizationStatusTypes to delete.
     * @example
     * // Delete a few OrganizationStatusTypes
     * const { count } = await prisma.organizationStatusTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends organizationStatusTypesDeleteManyArgs>(
      args?: SelectSubset<T, organizationStatusTypesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationStatusTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationStatusTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganizationStatusTypes
     * const organizationStatusTypes = await prisma.organizationStatusTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends organizationStatusTypesUpdateManyArgs>(
      args: SelectSubset<T, organizationStatusTypesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OrganizationStatusTypes.
     * @param {organizationStatusTypesUpsertArgs} args - Arguments to update or create a OrganizationStatusTypes.
     * @example
     * // Update or create a OrganizationStatusTypes
     * const organizationStatusTypes = await prisma.organizationStatusTypes.upsert({
     *   create: {
     *     // ... data to create a OrganizationStatusTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganizationStatusTypes we want to update
     *   }
     * })
    **/
    upsert<T extends organizationStatusTypesUpsertArgs>(
      args: SelectSubset<T, organizationStatusTypesUpsertArgs>
    ): Prisma__organizationStatusTypesClient<organizationStatusTypesGetPayload<T>>

    /**
     * Count the number of OrganizationStatusTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationStatusTypesCountArgs} args - Arguments to filter OrganizationStatusTypes to count.
     * @example
     * // Count the number of OrganizationStatusTypes
     * const count = await prisma.organizationStatusTypes.count({
     *   where: {
     *     // ... the filter for the OrganizationStatusTypes we want to count
     *   }
     * })
    **/
    count<T extends organizationStatusTypesCountArgs>(
      args?: Subset<T, organizationStatusTypesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationStatusTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganizationStatusTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationStatusTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationStatusTypesAggregateArgs>(args: Subset<T, OrganizationStatusTypesAggregateArgs>): PrismaPromise<GetOrganizationStatusTypesAggregateType<T>>

    /**
     * Group by OrganizationStatusTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationStatusTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationStatusTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationStatusTypesGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationStatusTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationStatusTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationStatusTypesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for organizationStatusTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__organizationStatusTypesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    organizations<T extends organizationStatusTypes$organizationsArgs= {}>(args?: Subset<T, organizationStatusTypes$organizationsArgs>): PrismaPromise<Array<organizationsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * organizationStatusTypes base type for findUnique actions
   */
  export type organizationStatusTypesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the organizationStatusTypes
     */
    select?: organizationStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationStatusTypesInclude | null
    /**
     * Filter, which organizationStatusTypes to fetch.
     */
    where: organizationStatusTypesWhereUniqueInput
  }

  /**
   * organizationStatusTypes findUnique
   */
  export interface organizationStatusTypesFindUniqueArgs extends organizationStatusTypesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * organizationStatusTypes findUniqueOrThrow
   */
  export type organizationStatusTypesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the organizationStatusTypes
     */
    select?: organizationStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationStatusTypesInclude | null
    /**
     * Filter, which organizationStatusTypes to fetch.
     */
    where: organizationStatusTypesWhereUniqueInput
  }


  /**
   * organizationStatusTypes base type for findFirst actions
   */
  export type organizationStatusTypesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the organizationStatusTypes
     */
    select?: organizationStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationStatusTypesInclude | null
    /**
     * Filter, which organizationStatusTypes to fetch.
     */
    where?: organizationStatusTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizationStatusTypes to fetch.
     */
    orderBy?: Enumerable<organizationStatusTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organizationStatusTypes.
     */
    cursor?: organizationStatusTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizationStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizationStatusTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organizationStatusTypes.
     */
    distinct?: Enumerable<OrganizationStatusTypesScalarFieldEnum>
  }

  /**
   * organizationStatusTypes findFirst
   */
  export interface organizationStatusTypesFindFirstArgs extends organizationStatusTypesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * organizationStatusTypes findFirstOrThrow
   */
  export type organizationStatusTypesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the organizationStatusTypes
     */
    select?: organizationStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationStatusTypesInclude | null
    /**
     * Filter, which organizationStatusTypes to fetch.
     */
    where?: organizationStatusTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizationStatusTypes to fetch.
     */
    orderBy?: Enumerable<organizationStatusTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organizationStatusTypes.
     */
    cursor?: organizationStatusTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizationStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizationStatusTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organizationStatusTypes.
     */
    distinct?: Enumerable<OrganizationStatusTypesScalarFieldEnum>
  }


  /**
   * organizationStatusTypes findMany
   */
  export type organizationStatusTypesFindManyArgs = {
    /**
     * Select specific fields to fetch from the organizationStatusTypes
     */
    select?: organizationStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationStatusTypesInclude | null
    /**
     * Filter, which organizationStatusTypes to fetch.
     */
    where?: organizationStatusTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizationStatusTypes to fetch.
     */
    orderBy?: Enumerable<organizationStatusTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing organizationStatusTypes.
     */
    cursor?: organizationStatusTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizationStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizationStatusTypes.
     */
    skip?: number
    distinct?: Enumerable<OrganizationStatusTypesScalarFieldEnum>
  }


  /**
   * organizationStatusTypes create
   */
  export type organizationStatusTypesCreateArgs = {
    /**
     * Select specific fields to fetch from the organizationStatusTypes
     */
    select?: organizationStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationStatusTypesInclude | null
    /**
     * The data needed to create a organizationStatusTypes.
     */
    data: XOR<organizationStatusTypesCreateInput, organizationStatusTypesUncheckedCreateInput>
  }


  /**
   * organizationStatusTypes createMany
   */
  export type organizationStatusTypesCreateManyArgs = {
    /**
     * The data used to create many organizationStatusTypes.
     */
    data: Enumerable<organizationStatusTypesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * organizationStatusTypes update
   */
  export type organizationStatusTypesUpdateArgs = {
    /**
     * Select specific fields to fetch from the organizationStatusTypes
     */
    select?: organizationStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationStatusTypesInclude | null
    /**
     * The data needed to update a organizationStatusTypes.
     */
    data: XOR<organizationStatusTypesUpdateInput, organizationStatusTypesUncheckedUpdateInput>
    /**
     * Choose, which organizationStatusTypes to update.
     */
    where: organizationStatusTypesWhereUniqueInput
  }


  /**
   * organizationStatusTypes updateMany
   */
  export type organizationStatusTypesUpdateManyArgs = {
    /**
     * The data used to update organizationStatusTypes.
     */
    data: XOR<organizationStatusTypesUpdateManyMutationInput, organizationStatusTypesUncheckedUpdateManyInput>
    /**
     * Filter which organizationStatusTypes to update
     */
    where?: organizationStatusTypesWhereInput
  }


  /**
   * organizationStatusTypes upsert
   */
  export type organizationStatusTypesUpsertArgs = {
    /**
     * Select specific fields to fetch from the organizationStatusTypes
     */
    select?: organizationStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationStatusTypesInclude | null
    /**
     * The filter to search for the organizationStatusTypes to update in case it exists.
     */
    where: organizationStatusTypesWhereUniqueInput
    /**
     * In case the organizationStatusTypes found by the `where` argument doesn't exist, create a new organizationStatusTypes with this data.
     */
    create: XOR<organizationStatusTypesCreateInput, organizationStatusTypesUncheckedCreateInput>
    /**
     * In case the organizationStatusTypes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<organizationStatusTypesUpdateInput, organizationStatusTypesUncheckedUpdateInput>
  }


  /**
   * organizationStatusTypes delete
   */
  export type organizationStatusTypesDeleteArgs = {
    /**
     * Select specific fields to fetch from the organizationStatusTypes
     */
    select?: organizationStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationStatusTypesInclude | null
    /**
     * Filter which organizationStatusTypes to delete.
     */
    where: organizationStatusTypesWhereUniqueInput
  }


  /**
   * organizationStatusTypes deleteMany
   */
  export type organizationStatusTypesDeleteManyArgs = {
    /**
     * Filter which organizationStatusTypes to delete
     */
    where?: organizationStatusTypesWhereInput
  }


  /**
   * organizationStatusTypes.organizations
   */
  export type organizationStatusTypes$organizationsArgs = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude | null
    where?: organizationsWhereInput
    orderBy?: Enumerable<organizationsOrderByWithRelationInput>
    cursor?: organizationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OrganizationsScalarFieldEnum>
  }


  /**
   * organizationStatusTypes without action
   */
  export type organizationStatusTypesArgs = {
    /**
     * Select specific fields to fetch from the organizationStatusTypes
     */
    select?: organizationStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationStatusTypesInclude | null
  }



  /**
   * Model organizations
   */


  export type AggregateOrganizations = {
    _count: OrganizationsCountAggregateOutputType | null
    _avg: OrganizationsAvgAggregateOutputType | null
    _sum: OrganizationsSumAggregateOutputType | null
    _min: OrganizationsMinAggregateOutputType | null
    _max: OrganizationsMaxAggregateOutputType | null
  }

  export type OrganizationsAvgAggregateOutputType = {
    id: number | null
    pricingPlanId: number | null
    statusId: number | null
  }

  export type OrganizationsSumAggregateOutputType = {
    id: number | null
    pricingPlanId: number | null
    statusId: number | null
  }

  export type OrganizationsMinAggregateOutputType = {
    id: number | null
    name: string | null
    primaryEmail: string | null
    pricingPlanId: number | null
    statusId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    primaryEmail: string | null
    pricingPlanId: number | null
    statusId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationsCountAggregateOutputType = {
    id: number
    name: number
    primaryEmail: number
    pricingPlanId: number
    statusId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationsAvgAggregateInputType = {
    id?: true
    pricingPlanId?: true
    statusId?: true
  }

  export type OrganizationsSumAggregateInputType = {
    id?: true
    pricingPlanId?: true
    statusId?: true
  }

  export type OrganizationsMinAggregateInputType = {
    id?: true
    name?: true
    primaryEmail?: true
    pricingPlanId?: true
    statusId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationsMaxAggregateInputType = {
    id?: true
    name?: true
    primaryEmail?: true
    pricingPlanId?: true
    statusId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationsCountAggregateInputType = {
    id?: true
    name?: true
    primaryEmail?: true
    pricingPlanId?: true
    statusId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationsAggregateArgs = {
    /**
     * Filter which organizations to aggregate.
     */
    where?: organizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations to fetch.
     */
    orderBy?: Enumerable<organizationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: organizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned organizations
    **/
    _count?: true | OrganizationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganizationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganizationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationsMaxAggregateInputType
  }

  export type GetOrganizationsAggregateType<T extends OrganizationsAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizations[P]>
      : GetScalarType<T[P], AggregateOrganizations[P]>
  }




  export type OrganizationsGroupByArgs = {
    where?: organizationsWhereInput
    orderBy?: Enumerable<organizationsOrderByWithAggregationInput>
    by: OrganizationsScalarFieldEnum[]
    having?: organizationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationsCountAggregateInputType | true
    _avg?: OrganizationsAvgAggregateInputType
    _sum?: OrganizationsSumAggregateInputType
    _min?: OrganizationsMinAggregateInputType
    _max?: OrganizationsMaxAggregateInputType
  }


  export type OrganizationsGroupByOutputType = {
    id: number
    name: string
    primaryEmail: string
    pricingPlanId: number
    statusId: number
    createdAt: Date
    updatedAt: Date
    _count: OrganizationsCountAggregateOutputType | null
    _avg: OrganizationsAvgAggregateOutputType | null
    _sum: OrganizationsSumAggregateOutputType | null
    _min: OrganizationsMinAggregateOutputType | null
    _max: OrganizationsMaxAggregateOutputType | null
  }

  type GetOrganizationsGroupByPayload<T extends OrganizationsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrganizationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationsGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationsGroupByOutputType[P]>
        }
      >
    >


  export type organizationsSelect = {
    id?: boolean
    name?: boolean
    primaryEmail?: boolean
    pricingPlanId?: boolean
    statusId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    custodyEngineEvents?: boolean | organizations$custodyEngineEventsArgs
    pricingPlans?: boolean | pricingPlansArgs
    organizationStatusTypes?: boolean | organizationStatusTypesArgs
    users?: boolean | organizations$usersArgs
    webhooks?: boolean | organizations$webhooksArgs
    withdrawalAddresses?: boolean | organizations$withdrawalAddressesArgs
    _count?: boolean | OrganizationsCountOutputTypeArgs
  }


  export type organizationsInclude = {
    custodyEngineEvents?: boolean | organizations$custodyEngineEventsArgs
    pricingPlans?: boolean | pricingPlansArgs
    organizationStatusTypes?: boolean | organizationStatusTypesArgs
    users?: boolean | organizations$usersArgs
    webhooks?: boolean | organizations$webhooksArgs
    withdrawalAddresses?: boolean | organizations$withdrawalAddressesArgs
    _count?: boolean | OrganizationsCountOutputTypeArgs
  }

  export type organizationsGetPayload<S extends boolean | null | undefined | organizationsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? organizations :
    S extends undefined ? never :
    S extends { include: any } & (organizationsArgs | organizationsFindManyArgs)
    ? organizations  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'custodyEngineEvents' ? Array < custodyEngineEventsGetPayload<S['include'][P]>>  :
        P extends 'pricingPlans' ? pricingPlansGetPayload<S['include'][P]> :
        P extends 'organizationStatusTypes' ? organizationStatusTypesGetPayload<S['include'][P]> :
        P extends 'users' ? Array < usersGetPayload<S['include'][P]>>  :
        P extends 'webhooks' ? Array < webhooksGetPayload<S['include'][P]>>  :
        P extends 'withdrawalAddresses' ? Array < withdrawalAddressesGetPayload<S['include'][P]>>  :
        P extends '_count' ? OrganizationsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (organizationsArgs | organizationsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'custodyEngineEvents' ? Array < custodyEngineEventsGetPayload<S['select'][P]>>  :
        P extends 'pricingPlans' ? pricingPlansGetPayload<S['select'][P]> :
        P extends 'organizationStatusTypes' ? organizationStatusTypesGetPayload<S['select'][P]> :
        P extends 'users' ? Array < usersGetPayload<S['select'][P]>>  :
        P extends 'webhooks' ? Array < webhooksGetPayload<S['select'][P]>>  :
        P extends 'withdrawalAddresses' ? Array < withdrawalAddressesGetPayload<S['select'][P]>>  :
        P extends '_count' ? OrganizationsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof organizations ? organizations[P] : never
  } 
      : organizations


  type organizationsCountArgs = 
    Omit<organizationsFindManyArgs, 'select' | 'include'> & {
      select?: OrganizationsCountAggregateInputType | true
    }

  export interface organizationsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Organizations that matches the filter.
     * @param {organizationsFindUniqueArgs} args - Arguments to find a Organizations
     * @example
     * // Get one Organizations
     * const organizations = await prisma.organizations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends organizationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, organizationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'organizations'> extends True ? Prisma__organizationsClient<organizationsGetPayload<T>> : Prisma__organizationsClient<organizationsGetPayload<T> | null, null>

    /**
     * Find one Organizations that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {organizationsFindUniqueOrThrowArgs} args - Arguments to find a Organizations
     * @example
     * // Get one Organizations
     * const organizations = await prisma.organizations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends organizationsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, organizationsFindUniqueOrThrowArgs>
    ): Prisma__organizationsClient<organizationsGetPayload<T>>

    /**
     * Find the first Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationsFindFirstArgs} args - Arguments to find a Organizations
     * @example
     * // Get one Organizations
     * const organizations = await prisma.organizations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends organizationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, organizationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'organizations'> extends True ? Prisma__organizationsClient<organizationsGetPayload<T>> : Prisma__organizationsClient<organizationsGetPayload<T> | null, null>

    /**
     * Find the first Organizations that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationsFindFirstOrThrowArgs} args - Arguments to find a Organizations
     * @example
     * // Get one Organizations
     * const organizations = await prisma.organizations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends organizationsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, organizationsFindFirstOrThrowArgs>
    ): Prisma__organizationsClient<organizationsGetPayload<T>>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organizations.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organizations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationsWithIdOnly = await prisma.organizations.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends organizationsFindManyArgs>(
      args?: SelectSubset<T, organizationsFindManyArgs>
    ): PrismaPromise<Array<organizationsGetPayload<T>>>

    /**
     * Create a Organizations.
     * @param {organizationsCreateArgs} args - Arguments to create a Organizations.
     * @example
     * // Create one Organizations
     * const Organizations = await prisma.organizations.create({
     *   data: {
     *     // ... data to create a Organizations
     *   }
     * })
     * 
    **/
    create<T extends organizationsCreateArgs>(
      args: SelectSubset<T, organizationsCreateArgs>
    ): Prisma__organizationsClient<organizationsGetPayload<T>>

    /**
     * Create many Organizations.
     *     @param {organizationsCreateManyArgs} args - Arguments to create many Organizations.
     *     @example
     *     // Create many Organizations
     *     const organizations = await prisma.organizations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends organizationsCreateManyArgs>(
      args?: SelectSubset<T, organizationsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Organizations.
     * @param {organizationsDeleteArgs} args - Arguments to delete one Organizations.
     * @example
     * // Delete one Organizations
     * const Organizations = await prisma.organizations.delete({
     *   where: {
     *     // ... filter to delete one Organizations
     *   }
     * })
     * 
    **/
    delete<T extends organizationsDeleteArgs>(
      args: SelectSubset<T, organizationsDeleteArgs>
    ): Prisma__organizationsClient<organizationsGetPayload<T>>

    /**
     * Update one Organizations.
     * @param {organizationsUpdateArgs} args - Arguments to update one Organizations.
     * @example
     * // Update one Organizations
     * const organizations = await prisma.organizations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends organizationsUpdateArgs>(
      args: SelectSubset<T, organizationsUpdateArgs>
    ): Prisma__organizationsClient<organizationsGetPayload<T>>

    /**
     * Delete zero or more Organizations.
     * @param {organizationsDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organizations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends organizationsDeleteManyArgs>(
      args?: SelectSubset<T, organizationsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organizations = await prisma.organizations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends organizationsUpdateManyArgs>(
      args: SelectSubset<T, organizationsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Organizations.
     * @param {organizationsUpsertArgs} args - Arguments to update or create a Organizations.
     * @example
     * // Update or create a Organizations
     * const organizations = await prisma.organizations.upsert({
     *   create: {
     *     // ... data to create a Organizations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organizations we want to update
     *   }
     * })
    **/
    upsert<T extends organizationsUpsertArgs>(
      args: SelectSubset<T, organizationsUpsertArgs>
    ): Prisma__organizationsClient<organizationsGetPayload<T>>

    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationsCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organizations.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends organizationsCountArgs>(
      args?: Subset<T, organizationsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationsAggregateArgs>(args: Subset<T, OrganizationsAggregateArgs>): PrismaPromise<GetOrganizationsAggregateType<T>>

    /**
     * Group by Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationsGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for organizations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__organizationsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    custodyEngineEvents<T extends organizations$custodyEngineEventsArgs= {}>(args?: Subset<T, organizations$custodyEngineEventsArgs>): PrismaPromise<Array<custodyEngineEventsGetPayload<T>>| Null>;

    pricingPlans<T extends pricingPlansArgs= {}>(args?: Subset<T, pricingPlansArgs>): Prisma__pricingPlansClient<pricingPlansGetPayload<T> | Null>;

    organizationStatusTypes<T extends organizationStatusTypesArgs= {}>(args?: Subset<T, organizationStatusTypesArgs>): Prisma__organizationStatusTypesClient<organizationStatusTypesGetPayload<T> | Null>;

    users<T extends organizations$usersArgs= {}>(args?: Subset<T, organizations$usersArgs>): PrismaPromise<Array<usersGetPayload<T>>| Null>;

    webhooks<T extends organizations$webhooksArgs= {}>(args?: Subset<T, organizations$webhooksArgs>): PrismaPromise<Array<webhooksGetPayload<T>>| Null>;

    withdrawalAddresses<T extends organizations$withdrawalAddressesArgs= {}>(args?: Subset<T, organizations$withdrawalAddressesArgs>): PrismaPromise<Array<withdrawalAddressesGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * organizations base type for findUnique actions
   */
  export type organizationsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude | null
    /**
     * Filter, which organizations to fetch.
     */
    where: organizationsWhereUniqueInput
  }

  /**
   * organizations findUnique
   */
  export interface organizationsFindUniqueArgs extends organizationsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * organizations findUniqueOrThrow
   */
  export type organizationsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude | null
    /**
     * Filter, which organizations to fetch.
     */
    where: organizationsWhereUniqueInput
  }


  /**
   * organizations base type for findFirst actions
   */
  export type organizationsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude | null
    /**
     * Filter, which organizations to fetch.
     */
    where?: organizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations to fetch.
     */
    orderBy?: Enumerable<organizationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organizations.
     */
    cursor?: organizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organizations.
     */
    distinct?: Enumerable<OrganizationsScalarFieldEnum>
  }

  /**
   * organizations findFirst
   */
  export interface organizationsFindFirstArgs extends organizationsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * organizations findFirstOrThrow
   */
  export type organizationsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude | null
    /**
     * Filter, which organizations to fetch.
     */
    where?: organizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations to fetch.
     */
    orderBy?: Enumerable<organizationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organizations.
     */
    cursor?: organizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organizations.
     */
    distinct?: Enumerable<OrganizationsScalarFieldEnum>
  }


  /**
   * organizations findMany
   */
  export type organizationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude | null
    /**
     * Filter, which organizations to fetch.
     */
    where?: organizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations to fetch.
     */
    orderBy?: Enumerable<organizationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing organizations.
     */
    cursor?: organizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations.
     */
    skip?: number
    distinct?: Enumerable<OrganizationsScalarFieldEnum>
  }


  /**
   * organizations create
   */
  export type organizationsCreateArgs = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude | null
    /**
     * The data needed to create a organizations.
     */
    data: XOR<organizationsCreateInput, organizationsUncheckedCreateInput>
  }


  /**
   * organizations createMany
   */
  export type organizationsCreateManyArgs = {
    /**
     * The data used to create many organizations.
     */
    data: Enumerable<organizationsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * organizations update
   */
  export type organizationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude | null
    /**
     * The data needed to update a organizations.
     */
    data: XOR<organizationsUpdateInput, organizationsUncheckedUpdateInput>
    /**
     * Choose, which organizations to update.
     */
    where: organizationsWhereUniqueInput
  }


  /**
   * organizations updateMany
   */
  export type organizationsUpdateManyArgs = {
    /**
     * The data used to update organizations.
     */
    data: XOR<organizationsUpdateManyMutationInput, organizationsUncheckedUpdateManyInput>
    /**
     * Filter which organizations to update
     */
    where?: organizationsWhereInput
  }


  /**
   * organizations upsert
   */
  export type organizationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude | null
    /**
     * The filter to search for the organizations to update in case it exists.
     */
    where: organizationsWhereUniqueInput
    /**
     * In case the organizations found by the `where` argument doesn't exist, create a new organizations with this data.
     */
    create: XOR<organizationsCreateInput, organizationsUncheckedCreateInput>
    /**
     * In case the organizations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<organizationsUpdateInput, organizationsUncheckedUpdateInput>
  }


  /**
   * organizations delete
   */
  export type organizationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude | null
    /**
     * Filter which organizations to delete.
     */
    where: organizationsWhereUniqueInput
  }


  /**
   * organizations deleteMany
   */
  export type organizationsDeleteManyArgs = {
    /**
     * Filter which organizations to delete
     */
    where?: organizationsWhereInput
  }


  /**
   * organizations.custodyEngineEvents
   */
  export type organizations$custodyEngineEventsArgs = {
    /**
     * Select specific fields to fetch from the custodyEngineEvents
     */
    select?: custodyEngineEventsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyEngineEventsInclude | null
    where?: custodyEngineEventsWhereInput
    orderBy?: Enumerable<custodyEngineEventsOrderByWithRelationInput>
    cursor?: custodyEngineEventsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CustodyEngineEventsScalarFieldEnum>
  }


  /**
   * organizations.users
   */
  export type organizations$usersArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    where?: usersWhereInput
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * organizations.webhooks
   */
  export type organizations$webhooksArgs = {
    /**
     * Select specific fields to fetch from the webhooks
     */
    select?: webhooksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhooksInclude | null
    where?: webhooksWhereInput
    orderBy?: Enumerable<webhooksOrderByWithRelationInput>
    cursor?: webhooksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WebhooksScalarFieldEnum>
  }


  /**
   * organizations.withdrawalAddresses
   */
  export type organizations$withdrawalAddressesArgs = {
    /**
     * Select specific fields to fetch from the withdrawalAddresses
     */
    select?: withdrawalAddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: withdrawalAddressesInclude | null
    where?: withdrawalAddressesWhereInput
    orderBy?: Enumerable<withdrawalAddressesOrderByWithRelationInput>
    cursor?: withdrawalAddressesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WithdrawalAddressesScalarFieldEnum>
  }


  /**
   * organizations without action
   */
  export type organizationsArgs = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude | null
  }



  /**
   * Model pricingPlanProfiles
   */


  export type AggregatePricingPlanProfiles = {
    _count: PricingPlanProfilesCountAggregateOutputType | null
    _avg: PricingPlanProfilesAvgAggregateOutputType | null
    _sum: PricingPlanProfilesSumAggregateOutputType | null
    _min: PricingPlanProfilesMinAggregateOutputType | null
    _max: PricingPlanProfilesMaxAggregateOutputType | null
  }

  export type PricingPlanProfilesAvgAggregateOutputType = {
    id: number | null
    quoteEngineRps: number | null
    custodyEngineRps: number | null
    numberOfUsers: number | null
    sla: number | null
  }

  export type PricingPlanProfilesSumAggregateOutputType = {
    id: number | null
    quoteEngineRps: number | null
    custodyEngineRps: number | null
    numberOfUsers: number | null
    sla: number | null
  }

  export type PricingPlanProfilesMinAggregateOutputType = {
    id: number | null
    name: string | null
    quoteEngineRps: number | null
    custodyEngineRps: number | null
    numberOfUsers: number | null
    sla: number | null
    rbac: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PricingPlanProfilesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    quoteEngineRps: number | null
    custodyEngineRps: number | null
    numberOfUsers: number | null
    sla: number | null
    rbac: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PricingPlanProfilesCountAggregateOutputType = {
    id: number
    name: number
    quoteEngineRps: number
    custodyEngineRps: number
    numberOfUsers: number
    sla: number
    rbac: number
    quoteEngineClaims: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PricingPlanProfilesAvgAggregateInputType = {
    id?: true
    quoteEngineRps?: true
    custodyEngineRps?: true
    numberOfUsers?: true
    sla?: true
  }

  export type PricingPlanProfilesSumAggregateInputType = {
    id?: true
    quoteEngineRps?: true
    custodyEngineRps?: true
    numberOfUsers?: true
    sla?: true
  }

  export type PricingPlanProfilesMinAggregateInputType = {
    id?: true
    name?: true
    quoteEngineRps?: true
    custodyEngineRps?: true
    numberOfUsers?: true
    sla?: true
    rbac?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PricingPlanProfilesMaxAggregateInputType = {
    id?: true
    name?: true
    quoteEngineRps?: true
    custodyEngineRps?: true
    numberOfUsers?: true
    sla?: true
    rbac?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PricingPlanProfilesCountAggregateInputType = {
    id?: true
    name?: true
    quoteEngineRps?: true
    custodyEngineRps?: true
    numberOfUsers?: true
    sla?: true
    rbac?: true
    quoteEngineClaims?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PricingPlanProfilesAggregateArgs = {
    /**
     * Filter which pricingPlanProfiles to aggregate.
     */
    where?: pricingPlanProfilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricingPlanProfiles to fetch.
     */
    orderBy?: Enumerable<pricingPlanProfilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pricingPlanProfilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricingPlanProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricingPlanProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pricingPlanProfiles
    **/
    _count?: true | PricingPlanProfilesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PricingPlanProfilesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PricingPlanProfilesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PricingPlanProfilesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PricingPlanProfilesMaxAggregateInputType
  }

  export type GetPricingPlanProfilesAggregateType<T extends PricingPlanProfilesAggregateArgs> = {
        [P in keyof T & keyof AggregatePricingPlanProfiles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePricingPlanProfiles[P]>
      : GetScalarType<T[P], AggregatePricingPlanProfiles[P]>
  }




  export type PricingPlanProfilesGroupByArgs = {
    where?: pricingPlanProfilesWhereInput
    orderBy?: Enumerable<pricingPlanProfilesOrderByWithAggregationInput>
    by: PricingPlanProfilesScalarFieldEnum[]
    having?: pricingPlanProfilesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PricingPlanProfilesCountAggregateInputType | true
    _avg?: PricingPlanProfilesAvgAggregateInputType
    _sum?: PricingPlanProfilesSumAggregateInputType
    _min?: PricingPlanProfilesMinAggregateInputType
    _max?: PricingPlanProfilesMaxAggregateInputType
  }


  export type PricingPlanProfilesGroupByOutputType = {
    id: number
    name: string
    quoteEngineRps: number
    custodyEngineRps: number
    numberOfUsers: number
    sla: number
    rbac: boolean
    quoteEngineClaims: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: PricingPlanProfilesCountAggregateOutputType | null
    _avg: PricingPlanProfilesAvgAggregateOutputType | null
    _sum: PricingPlanProfilesSumAggregateOutputType | null
    _min: PricingPlanProfilesMinAggregateOutputType | null
    _max: PricingPlanProfilesMaxAggregateOutputType | null
  }

  type GetPricingPlanProfilesGroupByPayload<T extends PricingPlanProfilesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PricingPlanProfilesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PricingPlanProfilesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PricingPlanProfilesGroupByOutputType[P]>
            : GetScalarType<T[P], PricingPlanProfilesGroupByOutputType[P]>
        }
      >
    >


  export type pricingPlanProfilesSelect = {
    id?: boolean
    name?: boolean
    quoteEngineRps?: boolean
    custodyEngineRps?: boolean
    numberOfUsers?: boolean
    sla?: boolean
    rbac?: boolean
    quoteEngineClaims?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pricingPlans?: boolean | pricingPlanProfiles$pricingPlansArgs
    _count?: boolean | PricingPlanProfilesCountOutputTypeArgs
  }


  export type pricingPlanProfilesInclude = {
    pricingPlans?: boolean | pricingPlanProfiles$pricingPlansArgs
    _count?: boolean | PricingPlanProfilesCountOutputTypeArgs
  }

  export type pricingPlanProfilesGetPayload<S extends boolean | null | undefined | pricingPlanProfilesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? pricingPlanProfiles :
    S extends undefined ? never :
    S extends { include: any } & (pricingPlanProfilesArgs | pricingPlanProfilesFindManyArgs)
    ? pricingPlanProfiles  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'pricingPlans' ? Array < pricingPlansGetPayload<S['include'][P]>>  :
        P extends '_count' ? PricingPlanProfilesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (pricingPlanProfilesArgs | pricingPlanProfilesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'pricingPlans' ? Array < pricingPlansGetPayload<S['select'][P]>>  :
        P extends '_count' ? PricingPlanProfilesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof pricingPlanProfiles ? pricingPlanProfiles[P] : never
  } 
      : pricingPlanProfiles


  type pricingPlanProfilesCountArgs = 
    Omit<pricingPlanProfilesFindManyArgs, 'select' | 'include'> & {
      select?: PricingPlanProfilesCountAggregateInputType | true
    }

  export interface pricingPlanProfilesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one PricingPlanProfiles that matches the filter.
     * @param {pricingPlanProfilesFindUniqueArgs} args - Arguments to find a PricingPlanProfiles
     * @example
     * // Get one PricingPlanProfiles
     * const pricingPlanProfiles = await prisma.pricingPlanProfiles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends pricingPlanProfilesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, pricingPlanProfilesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'pricingPlanProfiles'> extends True ? Prisma__pricingPlanProfilesClient<pricingPlanProfilesGetPayload<T>> : Prisma__pricingPlanProfilesClient<pricingPlanProfilesGetPayload<T> | null, null>

    /**
     * Find one PricingPlanProfiles that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {pricingPlanProfilesFindUniqueOrThrowArgs} args - Arguments to find a PricingPlanProfiles
     * @example
     * // Get one PricingPlanProfiles
     * const pricingPlanProfiles = await prisma.pricingPlanProfiles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends pricingPlanProfilesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, pricingPlanProfilesFindUniqueOrThrowArgs>
    ): Prisma__pricingPlanProfilesClient<pricingPlanProfilesGetPayload<T>>

    /**
     * Find the first PricingPlanProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricingPlanProfilesFindFirstArgs} args - Arguments to find a PricingPlanProfiles
     * @example
     * // Get one PricingPlanProfiles
     * const pricingPlanProfiles = await prisma.pricingPlanProfiles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends pricingPlanProfilesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, pricingPlanProfilesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'pricingPlanProfiles'> extends True ? Prisma__pricingPlanProfilesClient<pricingPlanProfilesGetPayload<T>> : Prisma__pricingPlanProfilesClient<pricingPlanProfilesGetPayload<T> | null, null>

    /**
     * Find the first PricingPlanProfiles that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricingPlanProfilesFindFirstOrThrowArgs} args - Arguments to find a PricingPlanProfiles
     * @example
     * // Get one PricingPlanProfiles
     * const pricingPlanProfiles = await prisma.pricingPlanProfiles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends pricingPlanProfilesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, pricingPlanProfilesFindFirstOrThrowArgs>
    ): Prisma__pricingPlanProfilesClient<pricingPlanProfilesGetPayload<T>>

    /**
     * Find zero or more PricingPlanProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricingPlanProfilesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PricingPlanProfiles
     * const pricingPlanProfiles = await prisma.pricingPlanProfiles.findMany()
     * 
     * // Get first 10 PricingPlanProfiles
     * const pricingPlanProfiles = await prisma.pricingPlanProfiles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pricingPlanProfilesWithIdOnly = await prisma.pricingPlanProfiles.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends pricingPlanProfilesFindManyArgs>(
      args?: SelectSubset<T, pricingPlanProfilesFindManyArgs>
    ): PrismaPromise<Array<pricingPlanProfilesGetPayload<T>>>

    /**
     * Create a PricingPlanProfiles.
     * @param {pricingPlanProfilesCreateArgs} args - Arguments to create a PricingPlanProfiles.
     * @example
     * // Create one PricingPlanProfiles
     * const PricingPlanProfiles = await prisma.pricingPlanProfiles.create({
     *   data: {
     *     // ... data to create a PricingPlanProfiles
     *   }
     * })
     * 
    **/
    create<T extends pricingPlanProfilesCreateArgs>(
      args: SelectSubset<T, pricingPlanProfilesCreateArgs>
    ): Prisma__pricingPlanProfilesClient<pricingPlanProfilesGetPayload<T>>

    /**
     * Create many PricingPlanProfiles.
     *     @param {pricingPlanProfilesCreateManyArgs} args - Arguments to create many PricingPlanProfiles.
     *     @example
     *     // Create many PricingPlanProfiles
     *     const pricingPlanProfiles = await prisma.pricingPlanProfiles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends pricingPlanProfilesCreateManyArgs>(
      args?: SelectSubset<T, pricingPlanProfilesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PricingPlanProfiles.
     * @param {pricingPlanProfilesDeleteArgs} args - Arguments to delete one PricingPlanProfiles.
     * @example
     * // Delete one PricingPlanProfiles
     * const PricingPlanProfiles = await prisma.pricingPlanProfiles.delete({
     *   where: {
     *     // ... filter to delete one PricingPlanProfiles
     *   }
     * })
     * 
    **/
    delete<T extends pricingPlanProfilesDeleteArgs>(
      args: SelectSubset<T, pricingPlanProfilesDeleteArgs>
    ): Prisma__pricingPlanProfilesClient<pricingPlanProfilesGetPayload<T>>

    /**
     * Update one PricingPlanProfiles.
     * @param {pricingPlanProfilesUpdateArgs} args - Arguments to update one PricingPlanProfiles.
     * @example
     * // Update one PricingPlanProfiles
     * const pricingPlanProfiles = await prisma.pricingPlanProfiles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends pricingPlanProfilesUpdateArgs>(
      args: SelectSubset<T, pricingPlanProfilesUpdateArgs>
    ): Prisma__pricingPlanProfilesClient<pricingPlanProfilesGetPayload<T>>

    /**
     * Delete zero or more PricingPlanProfiles.
     * @param {pricingPlanProfilesDeleteManyArgs} args - Arguments to filter PricingPlanProfiles to delete.
     * @example
     * // Delete a few PricingPlanProfiles
     * const { count } = await prisma.pricingPlanProfiles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends pricingPlanProfilesDeleteManyArgs>(
      args?: SelectSubset<T, pricingPlanProfilesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PricingPlanProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricingPlanProfilesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PricingPlanProfiles
     * const pricingPlanProfiles = await prisma.pricingPlanProfiles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends pricingPlanProfilesUpdateManyArgs>(
      args: SelectSubset<T, pricingPlanProfilesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PricingPlanProfiles.
     * @param {pricingPlanProfilesUpsertArgs} args - Arguments to update or create a PricingPlanProfiles.
     * @example
     * // Update or create a PricingPlanProfiles
     * const pricingPlanProfiles = await prisma.pricingPlanProfiles.upsert({
     *   create: {
     *     // ... data to create a PricingPlanProfiles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PricingPlanProfiles we want to update
     *   }
     * })
    **/
    upsert<T extends pricingPlanProfilesUpsertArgs>(
      args: SelectSubset<T, pricingPlanProfilesUpsertArgs>
    ): Prisma__pricingPlanProfilesClient<pricingPlanProfilesGetPayload<T>>

    /**
     * Count the number of PricingPlanProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricingPlanProfilesCountArgs} args - Arguments to filter PricingPlanProfiles to count.
     * @example
     * // Count the number of PricingPlanProfiles
     * const count = await prisma.pricingPlanProfiles.count({
     *   where: {
     *     // ... the filter for the PricingPlanProfiles we want to count
     *   }
     * })
    **/
    count<T extends pricingPlanProfilesCountArgs>(
      args?: Subset<T, pricingPlanProfilesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PricingPlanProfilesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PricingPlanProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingPlanProfilesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PricingPlanProfilesAggregateArgs>(args: Subset<T, PricingPlanProfilesAggregateArgs>): PrismaPromise<GetPricingPlanProfilesAggregateType<T>>

    /**
     * Group by PricingPlanProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingPlanProfilesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PricingPlanProfilesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PricingPlanProfilesGroupByArgs['orderBy'] }
        : { orderBy?: PricingPlanProfilesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PricingPlanProfilesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPricingPlanProfilesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for pricingPlanProfiles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__pricingPlanProfilesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    pricingPlans<T extends pricingPlanProfiles$pricingPlansArgs= {}>(args?: Subset<T, pricingPlanProfiles$pricingPlansArgs>): PrismaPromise<Array<pricingPlansGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * pricingPlanProfiles base type for findUnique actions
   */
  export type pricingPlanProfilesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the pricingPlanProfiles
     */
    select?: pricingPlanProfilesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlanProfilesInclude | null
    /**
     * Filter, which pricingPlanProfiles to fetch.
     */
    where: pricingPlanProfilesWhereUniqueInput
  }

  /**
   * pricingPlanProfiles findUnique
   */
  export interface pricingPlanProfilesFindUniqueArgs extends pricingPlanProfilesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pricingPlanProfiles findUniqueOrThrow
   */
  export type pricingPlanProfilesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the pricingPlanProfiles
     */
    select?: pricingPlanProfilesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlanProfilesInclude | null
    /**
     * Filter, which pricingPlanProfiles to fetch.
     */
    where: pricingPlanProfilesWhereUniqueInput
  }


  /**
   * pricingPlanProfiles base type for findFirst actions
   */
  export type pricingPlanProfilesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the pricingPlanProfiles
     */
    select?: pricingPlanProfilesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlanProfilesInclude | null
    /**
     * Filter, which pricingPlanProfiles to fetch.
     */
    where?: pricingPlanProfilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricingPlanProfiles to fetch.
     */
    orderBy?: Enumerable<pricingPlanProfilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pricingPlanProfiles.
     */
    cursor?: pricingPlanProfilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricingPlanProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricingPlanProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pricingPlanProfiles.
     */
    distinct?: Enumerable<PricingPlanProfilesScalarFieldEnum>
  }

  /**
   * pricingPlanProfiles findFirst
   */
  export interface pricingPlanProfilesFindFirstArgs extends pricingPlanProfilesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pricingPlanProfiles findFirstOrThrow
   */
  export type pricingPlanProfilesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the pricingPlanProfiles
     */
    select?: pricingPlanProfilesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlanProfilesInclude | null
    /**
     * Filter, which pricingPlanProfiles to fetch.
     */
    where?: pricingPlanProfilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricingPlanProfiles to fetch.
     */
    orderBy?: Enumerable<pricingPlanProfilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pricingPlanProfiles.
     */
    cursor?: pricingPlanProfilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricingPlanProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricingPlanProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pricingPlanProfiles.
     */
    distinct?: Enumerable<PricingPlanProfilesScalarFieldEnum>
  }


  /**
   * pricingPlanProfiles findMany
   */
  export type pricingPlanProfilesFindManyArgs = {
    /**
     * Select specific fields to fetch from the pricingPlanProfiles
     */
    select?: pricingPlanProfilesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlanProfilesInclude | null
    /**
     * Filter, which pricingPlanProfiles to fetch.
     */
    where?: pricingPlanProfilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricingPlanProfiles to fetch.
     */
    orderBy?: Enumerable<pricingPlanProfilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pricingPlanProfiles.
     */
    cursor?: pricingPlanProfilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricingPlanProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricingPlanProfiles.
     */
    skip?: number
    distinct?: Enumerable<PricingPlanProfilesScalarFieldEnum>
  }


  /**
   * pricingPlanProfiles create
   */
  export type pricingPlanProfilesCreateArgs = {
    /**
     * Select specific fields to fetch from the pricingPlanProfiles
     */
    select?: pricingPlanProfilesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlanProfilesInclude | null
    /**
     * The data needed to create a pricingPlanProfiles.
     */
    data: XOR<pricingPlanProfilesCreateInput, pricingPlanProfilesUncheckedCreateInput>
  }


  /**
   * pricingPlanProfiles createMany
   */
  export type pricingPlanProfilesCreateManyArgs = {
    /**
     * The data used to create many pricingPlanProfiles.
     */
    data: Enumerable<pricingPlanProfilesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * pricingPlanProfiles update
   */
  export type pricingPlanProfilesUpdateArgs = {
    /**
     * Select specific fields to fetch from the pricingPlanProfiles
     */
    select?: pricingPlanProfilesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlanProfilesInclude | null
    /**
     * The data needed to update a pricingPlanProfiles.
     */
    data: XOR<pricingPlanProfilesUpdateInput, pricingPlanProfilesUncheckedUpdateInput>
    /**
     * Choose, which pricingPlanProfiles to update.
     */
    where: pricingPlanProfilesWhereUniqueInput
  }


  /**
   * pricingPlanProfiles updateMany
   */
  export type pricingPlanProfilesUpdateManyArgs = {
    /**
     * The data used to update pricingPlanProfiles.
     */
    data: XOR<pricingPlanProfilesUpdateManyMutationInput, pricingPlanProfilesUncheckedUpdateManyInput>
    /**
     * Filter which pricingPlanProfiles to update
     */
    where?: pricingPlanProfilesWhereInput
  }


  /**
   * pricingPlanProfiles upsert
   */
  export type pricingPlanProfilesUpsertArgs = {
    /**
     * Select specific fields to fetch from the pricingPlanProfiles
     */
    select?: pricingPlanProfilesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlanProfilesInclude | null
    /**
     * The filter to search for the pricingPlanProfiles to update in case it exists.
     */
    where: pricingPlanProfilesWhereUniqueInput
    /**
     * In case the pricingPlanProfiles found by the `where` argument doesn't exist, create a new pricingPlanProfiles with this data.
     */
    create: XOR<pricingPlanProfilesCreateInput, pricingPlanProfilesUncheckedCreateInput>
    /**
     * In case the pricingPlanProfiles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pricingPlanProfilesUpdateInput, pricingPlanProfilesUncheckedUpdateInput>
  }


  /**
   * pricingPlanProfiles delete
   */
  export type pricingPlanProfilesDeleteArgs = {
    /**
     * Select specific fields to fetch from the pricingPlanProfiles
     */
    select?: pricingPlanProfilesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlanProfilesInclude | null
    /**
     * Filter which pricingPlanProfiles to delete.
     */
    where: pricingPlanProfilesWhereUniqueInput
  }


  /**
   * pricingPlanProfiles deleteMany
   */
  export type pricingPlanProfilesDeleteManyArgs = {
    /**
     * Filter which pricingPlanProfiles to delete
     */
    where?: pricingPlanProfilesWhereInput
  }


  /**
   * pricingPlanProfiles.pricingPlans
   */
  export type pricingPlanProfiles$pricingPlansArgs = {
    /**
     * Select specific fields to fetch from the pricingPlans
     */
    select?: pricingPlansSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlansInclude | null
    where?: pricingPlansWhereInput
    orderBy?: Enumerable<pricingPlansOrderByWithRelationInput>
    cursor?: pricingPlansWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PricingPlansScalarFieldEnum>
  }


  /**
   * pricingPlanProfiles without action
   */
  export type pricingPlanProfilesArgs = {
    /**
     * Select specific fields to fetch from the pricingPlanProfiles
     */
    select?: pricingPlanProfilesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlanProfilesInclude | null
  }



  /**
   * Model pricingPlanSupportsAssets
   */


  export type AggregatePricingPlanSupportsAssets = {
    _count: PricingPlanSupportsAssetsCountAggregateOutputType | null
    _avg: PricingPlanSupportsAssetsAvgAggregateOutputType | null
    _sum: PricingPlanSupportsAssetsSumAggregateOutputType | null
    _min: PricingPlanSupportsAssetsMinAggregateOutputType | null
    _max: PricingPlanSupportsAssetsMaxAggregateOutputType | null
  }

  export type PricingPlanSupportsAssetsAvgAggregateOutputType = {
    id: number | null
    vendorSupportsAssetId: number | null
    pricingPlanId: number | null
    buyBps: number | null
    sellBps: number | null
  }

  export type PricingPlanSupportsAssetsSumAggregateOutputType = {
    id: number | null
    vendorSupportsAssetId: number | null
    pricingPlanId: number | null
    buyBps: number | null
    sellBps: number | null
  }

  export type PricingPlanSupportsAssetsMinAggregateOutputType = {
    id: number | null
    vendorSupportsAssetId: number | null
    pricingPlanId: number | null
    enabled: boolean | null
    buyBps: number | null
    sellBps: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PricingPlanSupportsAssetsMaxAggregateOutputType = {
    id: number | null
    vendorSupportsAssetId: number | null
    pricingPlanId: number | null
    enabled: boolean | null
    buyBps: number | null
    sellBps: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PricingPlanSupportsAssetsCountAggregateOutputType = {
    id: number
    vendorSupportsAssetId: number
    pricingPlanId: number
    enabled: number
    buyBps: number
    sellBps: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PricingPlanSupportsAssetsAvgAggregateInputType = {
    id?: true
    vendorSupportsAssetId?: true
    pricingPlanId?: true
    buyBps?: true
    sellBps?: true
  }

  export type PricingPlanSupportsAssetsSumAggregateInputType = {
    id?: true
    vendorSupportsAssetId?: true
    pricingPlanId?: true
    buyBps?: true
    sellBps?: true
  }

  export type PricingPlanSupportsAssetsMinAggregateInputType = {
    id?: true
    vendorSupportsAssetId?: true
    pricingPlanId?: true
    enabled?: true
    buyBps?: true
    sellBps?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PricingPlanSupportsAssetsMaxAggregateInputType = {
    id?: true
    vendorSupportsAssetId?: true
    pricingPlanId?: true
    enabled?: true
    buyBps?: true
    sellBps?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PricingPlanSupportsAssetsCountAggregateInputType = {
    id?: true
    vendorSupportsAssetId?: true
    pricingPlanId?: true
    enabled?: true
    buyBps?: true
    sellBps?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PricingPlanSupportsAssetsAggregateArgs = {
    /**
     * Filter which pricingPlanSupportsAssets to aggregate.
     */
    where?: pricingPlanSupportsAssetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricingPlanSupportsAssets to fetch.
     */
    orderBy?: Enumerable<pricingPlanSupportsAssetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pricingPlanSupportsAssetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricingPlanSupportsAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricingPlanSupportsAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pricingPlanSupportsAssets
    **/
    _count?: true | PricingPlanSupportsAssetsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PricingPlanSupportsAssetsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PricingPlanSupportsAssetsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PricingPlanSupportsAssetsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PricingPlanSupportsAssetsMaxAggregateInputType
  }

  export type GetPricingPlanSupportsAssetsAggregateType<T extends PricingPlanSupportsAssetsAggregateArgs> = {
        [P in keyof T & keyof AggregatePricingPlanSupportsAssets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePricingPlanSupportsAssets[P]>
      : GetScalarType<T[P], AggregatePricingPlanSupportsAssets[P]>
  }




  export type PricingPlanSupportsAssetsGroupByArgs = {
    where?: pricingPlanSupportsAssetsWhereInput
    orderBy?: Enumerable<pricingPlanSupportsAssetsOrderByWithAggregationInput>
    by: PricingPlanSupportsAssetsScalarFieldEnum[]
    having?: pricingPlanSupportsAssetsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PricingPlanSupportsAssetsCountAggregateInputType | true
    _avg?: PricingPlanSupportsAssetsAvgAggregateInputType
    _sum?: PricingPlanSupportsAssetsSumAggregateInputType
    _min?: PricingPlanSupportsAssetsMinAggregateInputType
    _max?: PricingPlanSupportsAssetsMaxAggregateInputType
  }


  export type PricingPlanSupportsAssetsGroupByOutputType = {
    id: number
    vendorSupportsAssetId: number
    pricingPlanId: number
    enabled: boolean
    buyBps: number
    sellBps: number
    createdAt: Date
    updatedAt: Date
    _count: PricingPlanSupportsAssetsCountAggregateOutputType | null
    _avg: PricingPlanSupportsAssetsAvgAggregateOutputType | null
    _sum: PricingPlanSupportsAssetsSumAggregateOutputType | null
    _min: PricingPlanSupportsAssetsMinAggregateOutputType | null
    _max: PricingPlanSupportsAssetsMaxAggregateOutputType | null
  }

  type GetPricingPlanSupportsAssetsGroupByPayload<T extends PricingPlanSupportsAssetsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PricingPlanSupportsAssetsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PricingPlanSupportsAssetsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PricingPlanSupportsAssetsGroupByOutputType[P]>
            : GetScalarType<T[P], PricingPlanSupportsAssetsGroupByOutputType[P]>
        }
      >
    >


  export type pricingPlanSupportsAssetsSelect = {
    id?: boolean
    vendorSupportsAssetId?: boolean
    pricingPlanId?: boolean
    enabled?: boolean
    buyBps?: boolean
    sellBps?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pricingPlans?: boolean | pricingPlansArgs
    vendorSupportsAssets?: boolean | vendorSupportsAssetsArgs
  }


  export type pricingPlanSupportsAssetsInclude = {
    pricingPlans?: boolean | pricingPlansArgs
    vendorSupportsAssets?: boolean | vendorSupportsAssetsArgs
  }

  export type pricingPlanSupportsAssetsGetPayload<S extends boolean | null | undefined | pricingPlanSupportsAssetsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? pricingPlanSupportsAssets :
    S extends undefined ? never :
    S extends { include: any } & (pricingPlanSupportsAssetsArgs | pricingPlanSupportsAssetsFindManyArgs)
    ? pricingPlanSupportsAssets  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'pricingPlans' ? pricingPlansGetPayload<S['include'][P]> :
        P extends 'vendorSupportsAssets' ? vendorSupportsAssetsGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (pricingPlanSupportsAssetsArgs | pricingPlanSupportsAssetsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'pricingPlans' ? pricingPlansGetPayload<S['select'][P]> :
        P extends 'vendorSupportsAssets' ? vendorSupportsAssetsGetPayload<S['select'][P]> :  P extends keyof pricingPlanSupportsAssets ? pricingPlanSupportsAssets[P] : never
  } 
      : pricingPlanSupportsAssets


  type pricingPlanSupportsAssetsCountArgs = 
    Omit<pricingPlanSupportsAssetsFindManyArgs, 'select' | 'include'> & {
      select?: PricingPlanSupportsAssetsCountAggregateInputType | true
    }

  export interface pricingPlanSupportsAssetsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one PricingPlanSupportsAssets that matches the filter.
     * @param {pricingPlanSupportsAssetsFindUniqueArgs} args - Arguments to find a PricingPlanSupportsAssets
     * @example
     * // Get one PricingPlanSupportsAssets
     * const pricingPlanSupportsAssets = await prisma.pricingPlanSupportsAssets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends pricingPlanSupportsAssetsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, pricingPlanSupportsAssetsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'pricingPlanSupportsAssets'> extends True ? Prisma__pricingPlanSupportsAssetsClient<pricingPlanSupportsAssetsGetPayload<T>> : Prisma__pricingPlanSupportsAssetsClient<pricingPlanSupportsAssetsGetPayload<T> | null, null>

    /**
     * Find one PricingPlanSupportsAssets that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {pricingPlanSupportsAssetsFindUniqueOrThrowArgs} args - Arguments to find a PricingPlanSupportsAssets
     * @example
     * // Get one PricingPlanSupportsAssets
     * const pricingPlanSupportsAssets = await prisma.pricingPlanSupportsAssets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends pricingPlanSupportsAssetsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, pricingPlanSupportsAssetsFindUniqueOrThrowArgs>
    ): Prisma__pricingPlanSupportsAssetsClient<pricingPlanSupportsAssetsGetPayload<T>>

    /**
     * Find the first PricingPlanSupportsAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricingPlanSupportsAssetsFindFirstArgs} args - Arguments to find a PricingPlanSupportsAssets
     * @example
     * // Get one PricingPlanSupportsAssets
     * const pricingPlanSupportsAssets = await prisma.pricingPlanSupportsAssets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends pricingPlanSupportsAssetsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, pricingPlanSupportsAssetsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'pricingPlanSupportsAssets'> extends True ? Prisma__pricingPlanSupportsAssetsClient<pricingPlanSupportsAssetsGetPayload<T>> : Prisma__pricingPlanSupportsAssetsClient<pricingPlanSupportsAssetsGetPayload<T> | null, null>

    /**
     * Find the first PricingPlanSupportsAssets that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricingPlanSupportsAssetsFindFirstOrThrowArgs} args - Arguments to find a PricingPlanSupportsAssets
     * @example
     * // Get one PricingPlanSupportsAssets
     * const pricingPlanSupportsAssets = await prisma.pricingPlanSupportsAssets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends pricingPlanSupportsAssetsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, pricingPlanSupportsAssetsFindFirstOrThrowArgs>
    ): Prisma__pricingPlanSupportsAssetsClient<pricingPlanSupportsAssetsGetPayload<T>>

    /**
     * Find zero or more PricingPlanSupportsAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricingPlanSupportsAssetsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PricingPlanSupportsAssets
     * const pricingPlanSupportsAssets = await prisma.pricingPlanSupportsAssets.findMany()
     * 
     * // Get first 10 PricingPlanSupportsAssets
     * const pricingPlanSupportsAssets = await prisma.pricingPlanSupportsAssets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pricingPlanSupportsAssetsWithIdOnly = await prisma.pricingPlanSupportsAssets.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends pricingPlanSupportsAssetsFindManyArgs>(
      args?: SelectSubset<T, pricingPlanSupportsAssetsFindManyArgs>
    ): PrismaPromise<Array<pricingPlanSupportsAssetsGetPayload<T>>>

    /**
     * Create a PricingPlanSupportsAssets.
     * @param {pricingPlanSupportsAssetsCreateArgs} args - Arguments to create a PricingPlanSupportsAssets.
     * @example
     * // Create one PricingPlanSupportsAssets
     * const PricingPlanSupportsAssets = await prisma.pricingPlanSupportsAssets.create({
     *   data: {
     *     // ... data to create a PricingPlanSupportsAssets
     *   }
     * })
     * 
    **/
    create<T extends pricingPlanSupportsAssetsCreateArgs>(
      args: SelectSubset<T, pricingPlanSupportsAssetsCreateArgs>
    ): Prisma__pricingPlanSupportsAssetsClient<pricingPlanSupportsAssetsGetPayload<T>>

    /**
     * Create many PricingPlanSupportsAssets.
     *     @param {pricingPlanSupportsAssetsCreateManyArgs} args - Arguments to create many PricingPlanSupportsAssets.
     *     @example
     *     // Create many PricingPlanSupportsAssets
     *     const pricingPlanSupportsAssets = await prisma.pricingPlanSupportsAssets.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends pricingPlanSupportsAssetsCreateManyArgs>(
      args?: SelectSubset<T, pricingPlanSupportsAssetsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PricingPlanSupportsAssets.
     * @param {pricingPlanSupportsAssetsDeleteArgs} args - Arguments to delete one PricingPlanSupportsAssets.
     * @example
     * // Delete one PricingPlanSupportsAssets
     * const PricingPlanSupportsAssets = await prisma.pricingPlanSupportsAssets.delete({
     *   where: {
     *     // ... filter to delete one PricingPlanSupportsAssets
     *   }
     * })
     * 
    **/
    delete<T extends pricingPlanSupportsAssetsDeleteArgs>(
      args: SelectSubset<T, pricingPlanSupportsAssetsDeleteArgs>
    ): Prisma__pricingPlanSupportsAssetsClient<pricingPlanSupportsAssetsGetPayload<T>>

    /**
     * Update one PricingPlanSupportsAssets.
     * @param {pricingPlanSupportsAssetsUpdateArgs} args - Arguments to update one PricingPlanSupportsAssets.
     * @example
     * // Update one PricingPlanSupportsAssets
     * const pricingPlanSupportsAssets = await prisma.pricingPlanSupportsAssets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends pricingPlanSupportsAssetsUpdateArgs>(
      args: SelectSubset<T, pricingPlanSupportsAssetsUpdateArgs>
    ): Prisma__pricingPlanSupportsAssetsClient<pricingPlanSupportsAssetsGetPayload<T>>

    /**
     * Delete zero or more PricingPlanSupportsAssets.
     * @param {pricingPlanSupportsAssetsDeleteManyArgs} args - Arguments to filter PricingPlanSupportsAssets to delete.
     * @example
     * // Delete a few PricingPlanSupportsAssets
     * const { count } = await prisma.pricingPlanSupportsAssets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends pricingPlanSupportsAssetsDeleteManyArgs>(
      args?: SelectSubset<T, pricingPlanSupportsAssetsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PricingPlanSupportsAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricingPlanSupportsAssetsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PricingPlanSupportsAssets
     * const pricingPlanSupportsAssets = await prisma.pricingPlanSupportsAssets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends pricingPlanSupportsAssetsUpdateManyArgs>(
      args: SelectSubset<T, pricingPlanSupportsAssetsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PricingPlanSupportsAssets.
     * @param {pricingPlanSupportsAssetsUpsertArgs} args - Arguments to update or create a PricingPlanSupportsAssets.
     * @example
     * // Update or create a PricingPlanSupportsAssets
     * const pricingPlanSupportsAssets = await prisma.pricingPlanSupportsAssets.upsert({
     *   create: {
     *     // ... data to create a PricingPlanSupportsAssets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PricingPlanSupportsAssets we want to update
     *   }
     * })
    **/
    upsert<T extends pricingPlanSupportsAssetsUpsertArgs>(
      args: SelectSubset<T, pricingPlanSupportsAssetsUpsertArgs>
    ): Prisma__pricingPlanSupportsAssetsClient<pricingPlanSupportsAssetsGetPayload<T>>

    /**
     * Count the number of PricingPlanSupportsAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricingPlanSupportsAssetsCountArgs} args - Arguments to filter PricingPlanSupportsAssets to count.
     * @example
     * // Count the number of PricingPlanSupportsAssets
     * const count = await prisma.pricingPlanSupportsAssets.count({
     *   where: {
     *     // ... the filter for the PricingPlanSupportsAssets we want to count
     *   }
     * })
    **/
    count<T extends pricingPlanSupportsAssetsCountArgs>(
      args?: Subset<T, pricingPlanSupportsAssetsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PricingPlanSupportsAssetsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PricingPlanSupportsAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingPlanSupportsAssetsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PricingPlanSupportsAssetsAggregateArgs>(args: Subset<T, PricingPlanSupportsAssetsAggregateArgs>): PrismaPromise<GetPricingPlanSupportsAssetsAggregateType<T>>

    /**
     * Group by PricingPlanSupportsAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingPlanSupportsAssetsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PricingPlanSupportsAssetsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PricingPlanSupportsAssetsGroupByArgs['orderBy'] }
        : { orderBy?: PricingPlanSupportsAssetsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PricingPlanSupportsAssetsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPricingPlanSupportsAssetsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for pricingPlanSupportsAssets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__pricingPlanSupportsAssetsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    pricingPlans<T extends pricingPlansArgs= {}>(args?: Subset<T, pricingPlansArgs>): Prisma__pricingPlansClient<pricingPlansGetPayload<T> | Null>;

    vendorSupportsAssets<T extends vendorSupportsAssetsArgs= {}>(args?: Subset<T, vendorSupportsAssetsArgs>): Prisma__vendorSupportsAssetsClient<vendorSupportsAssetsGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * pricingPlanSupportsAssets base type for findUnique actions
   */
  export type pricingPlanSupportsAssetsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the pricingPlanSupportsAssets
     */
    select?: pricingPlanSupportsAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlanSupportsAssetsInclude | null
    /**
     * Filter, which pricingPlanSupportsAssets to fetch.
     */
    where: pricingPlanSupportsAssetsWhereUniqueInput
  }

  /**
   * pricingPlanSupportsAssets findUnique
   */
  export interface pricingPlanSupportsAssetsFindUniqueArgs extends pricingPlanSupportsAssetsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pricingPlanSupportsAssets findUniqueOrThrow
   */
  export type pricingPlanSupportsAssetsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the pricingPlanSupportsAssets
     */
    select?: pricingPlanSupportsAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlanSupportsAssetsInclude | null
    /**
     * Filter, which pricingPlanSupportsAssets to fetch.
     */
    where: pricingPlanSupportsAssetsWhereUniqueInput
  }


  /**
   * pricingPlanSupportsAssets base type for findFirst actions
   */
  export type pricingPlanSupportsAssetsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the pricingPlanSupportsAssets
     */
    select?: pricingPlanSupportsAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlanSupportsAssetsInclude | null
    /**
     * Filter, which pricingPlanSupportsAssets to fetch.
     */
    where?: pricingPlanSupportsAssetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricingPlanSupportsAssets to fetch.
     */
    orderBy?: Enumerable<pricingPlanSupportsAssetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pricingPlanSupportsAssets.
     */
    cursor?: pricingPlanSupportsAssetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricingPlanSupportsAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricingPlanSupportsAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pricingPlanSupportsAssets.
     */
    distinct?: Enumerable<PricingPlanSupportsAssetsScalarFieldEnum>
  }

  /**
   * pricingPlanSupportsAssets findFirst
   */
  export interface pricingPlanSupportsAssetsFindFirstArgs extends pricingPlanSupportsAssetsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pricingPlanSupportsAssets findFirstOrThrow
   */
  export type pricingPlanSupportsAssetsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the pricingPlanSupportsAssets
     */
    select?: pricingPlanSupportsAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlanSupportsAssetsInclude | null
    /**
     * Filter, which pricingPlanSupportsAssets to fetch.
     */
    where?: pricingPlanSupportsAssetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricingPlanSupportsAssets to fetch.
     */
    orderBy?: Enumerable<pricingPlanSupportsAssetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pricingPlanSupportsAssets.
     */
    cursor?: pricingPlanSupportsAssetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricingPlanSupportsAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricingPlanSupportsAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pricingPlanSupportsAssets.
     */
    distinct?: Enumerable<PricingPlanSupportsAssetsScalarFieldEnum>
  }


  /**
   * pricingPlanSupportsAssets findMany
   */
  export type pricingPlanSupportsAssetsFindManyArgs = {
    /**
     * Select specific fields to fetch from the pricingPlanSupportsAssets
     */
    select?: pricingPlanSupportsAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlanSupportsAssetsInclude | null
    /**
     * Filter, which pricingPlanSupportsAssets to fetch.
     */
    where?: pricingPlanSupportsAssetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricingPlanSupportsAssets to fetch.
     */
    orderBy?: Enumerable<pricingPlanSupportsAssetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pricingPlanSupportsAssets.
     */
    cursor?: pricingPlanSupportsAssetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricingPlanSupportsAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricingPlanSupportsAssets.
     */
    skip?: number
    distinct?: Enumerable<PricingPlanSupportsAssetsScalarFieldEnum>
  }


  /**
   * pricingPlanSupportsAssets create
   */
  export type pricingPlanSupportsAssetsCreateArgs = {
    /**
     * Select specific fields to fetch from the pricingPlanSupportsAssets
     */
    select?: pricingPlanSupportsAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlanSupportsAssetsInclude | null
    /**
     * The data needed to create a pricingPlanSupportsAssets.
     */
    data: XOR<pricingPlanSupportsAssetsCreateInput, pricingPlanSupportsAssetsUncheckedCreateInput>
  }


  /**
   * pricingPlanSupportsAssets createMany
   */
  export type pricingPlanSupportsAssetsCreateManyArgs = {
    /**
     * The data used to create many pricingPlanSupportsAssets.
     */
    data: Enumerable<pricingPlanSupportsAssetsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * pricingPlanSupportsAssets update
   */
  export type pricingPlanSupportsAssetsUpdateArgs = {
    /**
     * Select specific fields to fetch from the pricingPlanSupportsAssets
     */
    select?: pricingPlanSupportsAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlanSupportsAssetsInclude | null
    /**
     * The data needed to update a pricingPlanSupportsAssets.
     */
    data: XOR<pricingPlanSupportsAssetsUpdateInput, pricingPlanSupportsAssetsUncheckedUpdateInput>
    /**
     * Choose, which pricingPlanSupportsAssets to update.
     */
    where: pricingPlanSupportsAssetsWhereUniqueInput
  }


  /**
   * pricingPlanSupportsAssets updateMany
   */
  export type pricingPlanSupportsAssetsUpdateManyArgs = {
    /**
     * The data used to update pricingPlanSupportsAssets.
     */
    data: XOR<pricingPlanSupportsAssetsUpdateManyMutationInput, pricingPlanSupportsAssetsUncheckedUpdateManyInput>
    /**
     * Filter which pricingPlanSupportsAssets to update
     */
    where?: pricingPlanSupportsAssetsWhereInput
  }


  /**
   * pricingPlanSupportsAssets upsert
   */
  export type pricingPlanSupportsAssetsUpsertArgs = {
    /**
     * Select specific fields to fetch from the pricingPlanSupportsAssets
     */
    select?: pricingPlanSupportsAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlanSupportsAssetsInclude | null
    /**
     * The filter to search for the pricingPlanSupportsAssets to update in case it exists.
     */
    where: pricingPlanSupportsAssetsWhereUniqueInput
    /**
     * In case the pricingPlanSupportsAssets found by the `where` argument doesn't exist, create a new pricingPlanSupportsAssets with this data.
     */
    create: XOR<pricingPlanSupportsAssetsCreateInput, pricingPlanSupportsAssetsUncheckedCreateInput>
    /**
     * In case the pricingPlanSupportsAssets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pricingPlanSupportsAssetsUpdateInput, pricingPlanSupportsAssetsUncheckedUpdateInput>
  }


  /**
   * pricingPlanSupportsAssets delete
   */
  export type pricingPlanSupportsAssetsDeleteArgs = {
    /**
     * Select specific fields to fetch from the pricingPlanSupportsAssets
     */
    select?: pricingPlanSupportsAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlanSupportsAssetsInclude | null
    /**
     * Filter which pricingPlanSupportsAssets to delete.
     */
    where: pricingPlanSupportsAssetsWhereUniqueInput
  }


  /**
   * pricingPlanSupportsAssets deleteMany
   */
  export type pricingPlanSupportsAssetsDeleteManyArgs = {
    /**
     * Filter which pricingPlanSupportsAssets to delete
     */
    where?: pricingPlanSupportsAssetsWhereInput
  }


  /**
   * pricingPlanSupportsAssets without action
   */
  export type pricingPlanSupportsAssetsArgs = {
    /**
     * Select specific fields to fetch from the pricingPlanSupportsAssets
     */
    select?: pricingPlanSupportsAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlanSupportsAssetsInclude | null
  }



  /**
   * Model pricingPlans
   */


  export type AggregatePricingPlans = {
    _count: PricingPlansCountAggregateOutputType | null
    _avg: PricingPlansAvgAggregateOutputType | null
    _sum: PricingPlansSumAggregateOutputType | null
    _min: PricingPlansMinAggregateOutputType | null
    _max: PricingPlansMaxAggregateOutputType | null
  }

  export type PricingPlansAvgAggregateOutputType = {
    id: number | null
    price: number | null
    pricingPlanProfileId: number | null
  }

  export type PricingPlansSumAggregateOutputType = {
    id: number | null
    price: number | null
    pricingPlanProfileId: number | null
  }

  export type PricingPlansMinAggregateOutputType = {
    id: number | null
    price: number | null
    active: boolean | null
    pricingPlanProfileId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PricingPlansMaxAggregateOutputType = {
    id: number | null
    price: number | null
    active: boolean | null
    pricingPlanProfileId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PricingPlansCountAggregateOutputType = {
    id: number
    price: number
    active: number
    pricingPlanProfileId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PricingPlansAvgAggregateInputType = {
    id?: true
    price?: true
    pricingPlanProfileId?: true
  }

  export type PricingPlansSumAggregateInputType = {
    id?: true
    price?: true
    pricingPlanProfileId?: true
  }

  export type PricingPlansMinAggregateInputType = {
    id?: true
    price?: true
    active?: true
    pricingPlanProfileId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PricingPlansMaxAggregateInputType = {
    id?: true
    price?: true
    active?: true
    pricingPlanProfileId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PricingPlansCountAggregateInputType = {
    id?: true
    price?: true
    active?: true
    pricingPlanProfileId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PricingPlansAggregateArgs = {
    /**
     * Filter which pricingPlans to aggregate.
     */
    where?: pricingPlansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricingPlans to fetch.
     */
    orderBy?: Enumerable<pricingPlansOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pricingPlansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pricingPlans
    **/
    _count?: true | PricingPlansCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PricingPlansAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PricingPlansSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PricingPlansMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PricingPlansMaxAggregateInputType
  }

  export type GetPricingPlansAggregateType<T extends PricingPlansAggregateArgs> = {
        [P in keyof T & keyof AggregatePricingPlans]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePricingPlans[P]>
      : GetScalarType<T[P], AggregatePricingPlans[P]>
  }




  export type PricingPlansGroupByArgs = {
    where?: pricingPlansWhereInput
    orderBy?: Enumerable<pricingPlansOrderByWithAggregationInput>
    by: PricingPlansScalarFieldEnum[]
    having?: pricingPlansScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PricingPlansCountAggregateInputType | true
    _avg?: PricingPlansAvgAggregateInputType
    _sum?: PricingPlansSumAggregateInputType
    _min?: PricingPlansMinAggregateInputType
    _max?: PricingPlansMaxAggregateInputType
  }


  export type PricingPlansGroupByOutputType = {
    id: number
    price: number
    active: boolean
    pricingPlanProfileId: number
    createdAt: Date
    updatedAt: Date
    _count: PricingPlansCountAggregateOutputType | null
    _avg: PricingPlansAvgAggregateOutputType | null
    _sum: PricingPlansSumAggregateOutputType | null
    _min: PricingPlansMinAggregateOutputType | null
    _max: PricingPlansMaxAggregateOutputType | null
  }

  type GetPricingPlansGroupByPayload<T extends PricingPlansGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PricingPlansGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PricingPlansGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PricingPlansGroupByOutputType[P]>
            : GetScalarType<T[P], PricingPlansGroupByOutputType[P]>
        }
      >
    >


  export type pricingPlansSelect = {
    id?: boolean
    price?: boolean
    active?: boolean
    pricingPlanProfileId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organizations?: boolean | pricingPlans$organizationsArgs
    pricingPlanSupportsAssets?: boolean | pricingPlans$pricingPlanSupportsAssetsArgs
    pricingPlanProfiles?: boolean | pricingPlanProfilesArgs
    _count?: boolean | PricingPlansCountOutputTypeArgs
  }


  export type pricingPlansInclude = {
    organizations?: boolean | pricingPlans$organizationsArgs
    pricingPlanSupportsAssets?: boolean | pricingPlans$pricingPlanSupportsAssetsArgs
    pricingPlanProfiles?: boolean | pricingPlanProfilesArgs
    _count?: boolean | PricingPlansCountOutputTypeArgs
  }

  export type pricingPlansGetPayload<S extends boolean | null | undefined | pricingPlansArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? pricingPlans :
    S extends undefined ? never :
    S extends { include: any } & (pricingPlansArgs | pricingPlansFindManyArgs)
    ? pricingPlans  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'organizations' ? Array < organizationsGetPayload<S['include'][P]>>  :
        P extends 'pricingPlanSupportsAssets' ? Array < pricingPlanSupportsAssetsGetPayload<S['include'][P]>>  :
        P extends 'pricingPlanProfiles' ? pricingPlanProfilesGetPayload<S['include'][P]> :
        P extends '_count' ? PricingPlansCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (pricingPlansArgs | pricingPlansFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'organizations' ? Array < organizationsGetPayload<S['select'][P]>>  :
        P extends 'pricingPlanSupportsAssets' ? Array < pricingPlanSupportsAssetsGetPayload<S['select'][P]>>  :
        P extends 'pricingPlanProfiles' ? pricingPlanProfilesGetPayload<S['select'][P]> :
        P extends '_count' ? PricingPlansCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof pricingPlans ? pricingPlans[P] : never
  } 
      : pricingPlans


  type pricingPlansCountArgs = 
    Omit<pricingPlansFindManyArgs, 'select' | 'include'> & {
      select?: PricingPlansCountAggregateInputType | true
    }

  export interface pricingPlansDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one PricingPlans that matches the filter.
     * @param {pricingPlansFindUniqueArgs} args - Arguments to find a PricingPlans
     * @example
     * // Get one PricingPlans
     * const pricingPlans = await prisma.pricingPlans.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends pricingPlansFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, pricingPlansFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'pricingPlans'> extends True ? Prisma__pricingPlansClient<pricingPlansGetPayload<T>> : Prisma__pricingPlansClient<pricingPlansGetPayload<T> | null, null>

    /**
     * Find one PricingPlans that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {pricingPlansFindUniqueOrThrowArgs} args - Arguments to find a PricingPlans
     * @example
     * // Get one PricingPlans
     * const pricingPlans = await prisma.pricingPlans.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends pricingPlansFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, pricingPlansFindUniqueOrThrowArgs>
    ): Prisma__pricingPlansClient<pricingPlansGetPayload<T>>

    /**
     * Find the first PricingPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricingPlansFindFirstArgs} args - Arguments to find a PricingPlans
     * @example
     * // Get one PricingPlans
     * const pricingPlans = await prisma.pricingPlans.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends pricingPlansFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, pricingPlansFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'pricingPlans'> extends True ? Prisma__pricingPlansClient<pricingPlansGetPayload<T>> : Prisma__pricingPlansClient<pricingPlansGetPayload<T> | null, null>

    /**
     * Find the first PricingPlans that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricingPlansFindFirstOrThrowArgs} args - Arguments to find a PricingPlans
     * @example
     * // Get one PricingPlans
     * const pricingPlans = await prisma.pricingPlans.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends pricingPlansFindFirstOrThrowArgs>(
      args?: SelectSubset<T, pricingPlansFindFirstOrThrowArgs>
    ): Prisma__pricingPlansClient<pricingPlansGetPayload<T>>

    /**
     * Find zero or more PricingPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricingPlansFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PricingPlans
     * const pricingPlans = await prisma.pricingPlans.findMany()
     * 
     * // Get first 10 PricingPlans
     * const pricingPlans = await prisma.pricingPlans.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pricingPlansWithIdOnly = await prisma.pricingPlans.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends pricingPlansFindManyArgs>(
      args?: SelectSubset<T, pricingPlansFindManyArgs>
    ): PrismaPromise<Array<pricingPlansGetPayload<T>>>

    /**
     * Create a PricingPlans.
     * @param {pricingPlansCreateArgs} args - Arguments to create a PricingPlans.
     * @example
     * // Create one PricingPlans
     * const PricingPlans = await prisma.pricingPlans.create({
     *   data: {
     *     // ... data to create a PricingPlans
     *   }
     * })
     * 
    **/
    create<T extends pricingPlansCreateArgs>(
      args: SelectSubset<T, pricingPlansCreateArgs>
    ): Prisma__pricingPlansClient<pricingPlansGetPayload<T>>

    /**
     * Create many PricingPlans.
     *     @param {pricingPlansCreateManyArgs} args - Arguments to create many PricingPlans.
     *     @example
     *     // Create many PricingPlans
     *     const pricingPlans = await prisma.pricingPlans.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends pricingPlansCreateManyArgs>(
      args?: SelectSubset<T, pricingPlansCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PricingPlans.
     * @param {pricingPlansDeleteArgs} args - Arguments to delete one PricingPlans.
     * @example
     * // Delete one PricingPlans
     * const PricingPlans = await prisma.pricingPlans.delete({
     *   where: {
     *     // ... filter to delete one PricingPlans
     *   }
     * })
     * 
    **/
    delete<T extends pricingPlansDeleteArgs>(
      args: SelectSubset<T, pricingPlansDeleteArgs>
    ): Prisma__pricingPlansClient<pricingPlansGetPayload<T>>

    /**
     * Update one PricingPlans.
     * @param {pricingPlansUpdateArgs} args - Arguments to update one PricingPlans.
     * @example
     * // Update one PricingPlans
     * const pricingPlans = await prisma.pricingPlans.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends pricingPlansUpdateArgs>(
      args: SelectSubset<T, pricingPlansUpdateArgs>
    ): Prisma__pricingPlansClient<pricingPlansGetPayload<T>>

    /**
     * Delete zero or more PricingPlans.
     * @param {pricingPlansDeleteManyArgs} args - Arguments to filter PricingPlans to delete.
     * @example
     * // Delete a few PricingPlans
     * const { count } = await prisma.pricingPlans.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends pricingPlansDeleteManyArgs>(
      args?: SelectSubset<T, pricingPlansDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PricingPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricingPlansUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PricingPlans
     * const pricingPlans = await prisma.pricingPlans.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends pricingPlansUpdateManyArgs>(
      args: SelectSubset<T, pricingPlansUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PricingPlans.
     * @param {pricingPlansUpsertArgs} args - Arguments to update or create a PricingPlans.
     * @example
     * // Update or create a PricingPlans
     * const pricingPlans = await prisma.pricingPlans.upsert({
     *   create: {
     *     // ... data to create a PricingPlans
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PricingPlans we want to update
     *   }
     * })
    **/
    upsert<T extends pricingPlansUpsertArgs>(
      args: SelectSubset<T, pricingPlansUpsertArgs>
    ): Prisma__pricingPlansClient<pricingPlansGetPayload<T>>

    /**
     * Count the number of PricingPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricingPlansCountArgs} args - Arguments to filter PricingPlans to count.
     * @example
     * // Count the number of PricingPlans
     * const count = await prisma.pricingPlans.count({
     *   where: {
     *     // ... the filter for the PricingPlans we want to count
     *   }
     * })
    **/
    count<T extends pricingPlansCountArgs>(
      args?: Subset<T, pricingPlansCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PricingPlansCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PricingPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingPlansAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PricingPlansAggregateArgs>(args: Subset<T, PricingPlansAggregateArgs>): PrismaPromise<GetPricingPlansAggregateType<T>>

    /**
     * Group by PricingPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingPlansGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PricingPlansGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PricingPlansGroupByArgs['orderBy'] }
        : { orderBy?: PricingPlansGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PricingPlansGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPricingPlansGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for pricingPlans.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__pricingPlansClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    organizations<T extends pricingPlans$organizationsArgs= {}>(args?: Subset<T, pricingPlans$organizationsArgs>): PrismaPromise<Array<organizationsGetPayload<T>>| Null>;

    pricingPlanSupportsAssets<T extends pricingPlans$pricingPlanSupportsAssetsArgs= {}>(args?: Subset<T, pricingPlans$pricingPlanSupportsAssetsArgs>): PrismaPromise<Array<pricingPlanSupportsAssetsGetPayload<T>>| Null>;

    pricingPlanProfiles<T extends pricingPlanProfilesArgs= {}>(args?: Subset<T, pricingPlanProfilesArgs>): Prisma__pricingPlanProfilesClient<pricingPlanProfilesGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * pricingPlans base type for findUnique actions
   */
  export type pricingPlansFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the pricingPlans
     */
    select?: pricingPlansSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlansInclude | null
    /**
     * Filter, which pricingPlans to fetch.
     */
    where: pricingPlansWhereUniqueInput
  }

  /**
   * pricingPlans findUnique
   */
  export interface pricingPlansFindUniqueArgs extends pricingPlansFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pricingPlans findUniqueOrThrow
   */
  export type pricingPlansFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the pricingPlans
     */
    select?: pricingPlansSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlansInclude | null
    /**
     * Filter, which pricingPlans to fetch.
     */
    where: pricingPlansWhereUniqueInput
  }


  /**
   * pricingPlans base type for findFirst actions
   */
  export type pricingPlansFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the pricingPlans
     */
    select?: pricingPlansSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlansInclude | null
    /**
     * Filter, which pricingPlans to fetch.
     */
    where?: pricingPlansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricingPlans to fetch.
     */
    orderBy?: Enumerable<pricingPlansOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pricingPlans.
     */
    cursor?: pricingPlansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pricingPlans.
     */
    distinct?: Enumerable<PricingPlansScalarFieldEnum>
  }

  /**
   * pricingPlans findFirst
   */
  export interface pricingPlansFindFirstArgs extends pricingPlansFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pricingPlans findFirstOrThrow
   */
  export type pricingPlansFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the pricingPlans
     */
    select?: pricingPlansSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlansInclude | null
    /**
     * Filter, which pricingPlans to fetch.
     */
    where?: pricingPlansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricingPlans to fetch.
     */
    orderBy?: Enumerable<pricingPlansOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pricingPlans.
     */
    cursor?: pricingPlansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricingPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pricingPlans.
     */
    distinct?: Enumerable<PricingPlansScalarFieldEnum>
  }


  /**
   * pricingPlans findMany
   */
  export type pricingPlansFindManyArgs = {
    /**
     * Select specific fields to fetch from the pricingPlans
     */
    select?: pricingPlansSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlansInclude | null
    /**
     * Filter, which pricingPlans to fetch.
     */
    where?: pricingPlansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricingPlans to fetch.
     */
    orderBy?: Enumerable<pricingPlansOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pricingPlans.
     */
    cursor?: pricingPlansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricingPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricingPlans.
     */
    skip?: number
    distinct?: Enumerable<PricingPlansScalarFieldEnum>
  }


  /**
   * pricingPlans create
   */
  export type pricingPlansCreateArgs = {
    /**
     * Select specific fields to fetch from the pricingPlans
     */
    select?: pricingPlansSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlansInclude | null
    /**
     * The data needed to create a pricingPlans.
     */
    data: XOR<pricingPlansCreateInput, pricingPlansUncheckedCreateInput>
  }


  /**
   * pricingPlans createMany
   */
  export type pricingPlansCreateManyArgs = {
    /**
     * The data used to create many pricingPlans.
     */
    data: Enumerable<pricingPlansCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * pricingPlans update
   */
  export type pricingPlansUpdateArgs = {
    /**
     * Select specific fields to fetch from the pricingPlans
     */
    select?: pricingPlansSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlansInclude | null
    /**
     * The data needed to update a pricingPlans.
     */
    data: XOR<pricingPlansUpdateInput, pricingPlansUncheckedUpdateInput>
    /**
     * Choose, which pricingPlans to update.
     */
    where: pricingPlansWhereUniqueInput
  }


  /**
   * pricingPlans updateMany
   */
  export type pricingPlansUpdateManyArgs = {
    /**
     * The data used to update pricingPlans.
     */
    data: XOR<pricingPlansUpdateManyMutationInput, pricingPlansUncheckedUpdateManyInput>
    /**
     * Filter which pricingPlans to update
     */
    where?: pricingPlansWhereInput
  }


  /**
   * pricingPlans upsert
   */
  export type pricingPlansUpsertArgs = {
    /**
     * Select specific fields to fetch from the pricingPlans
     */
    select?: pricingPlansSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlansInclude | null
    /**
     * The filter to search for the pricingPlans to update in case it exists.
     */
    where: pricingPlansWhereUniqueInput
    /**
     * In case the pricingPlans found by the `where` argument doesn't exist, create a new pricingPlans with this data.
     */
    create: XOR<pricingPlansCreateInput, pricingPlansUncheckedCreateInput>
    /**
     * In case the pricingPlans was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pricingPlansUpdateInput, pricingPlansUncheckedUpdateInput>
  }


  /**
   * pricingPlans delete
   */
  export type pricingPlansDeleteArgs = {
    /**
     * Select specific fields to fetch from the pricingPlans
     */
    select?: pricingPlansSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlansInclude | null
    /**
     * Filter which pricingPlans to delete.
     */
    where: pricingPlansWhereUniqueInput
  }


  /**
   * pricingPlans deleteMany
   */
  export type pricingPlansDeleteManyArgs = {
    /**
     * Filter which pricingPlans to delete
     */
    where?: pricingPlansWhereInput
  }


  /**
   * pricingPlans.organizations
   */
  export type pricingPlans$organizationsArgs = {
    /**
     * Select specific fields to fetch from the organizations
     */
    select?: organizationsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: organizationsInclude | null
    where?: organizationsWhereInput
    orderBy?: Enumerable<organizationsOrderByWithRelationInput>
    cursor?: organizationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OrganizationsScalarFieldEnum>
  }


  /**
   * pricingPlans.pricingPlanSupportsAssets
   */
  export type pricingPlans$pricingPlanSupportsAssetsArgs = {
    /**
     * Select specific fields to fetch from the pricingPlanSupportsAssets
     */
    select?: pricingPlanSupportsAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlanSupportsAssetsInclude | null
    where?: pricingPlanSupportsAssetsWhereInput
    orderBy?: Enumerable<pricingPlanSupportsAssetsOrderByWithRelationInput>
    cursor?: pricingPlanSupportsAssetsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PricingPlanSupportsAssetsScalarFieldEnum>
  }


  /**
   * pricingPlans without action
   */
  export type pricingPlansArgs = {
    /**
     * Select specific fields to fetch from the pricingPlans
     */
    select?: pricingPlansSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlansInclude | null
  }



  /**
   * Model quoteStatuses
   */


  export type AggregateQuoteStatuses = {
    _count: QuoteStatusesCountAggregateOutputType | null
    _avg: QuoteStatusesAvgAggregateOutputType | null
    _sum: QuoteStatusesSumAggregateOutputType | null
    _min: QuoteStatusesMinAggregateOutputType | null
    _max: QuoteStatusesMaxAggregateOutputType | null
  }

  export type QuoteStatusesAvgAggregateOutputType = {
    id: number | null
  }

  export type QuoteStatusesSumAggregateOutputType = {
    id: number | null
  }

  export type QuoteStatusesMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuoteStatusesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuoteStatusesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuoteStatusesAvgAggregateInputType = {
    id?: true
  }

  export type QuoteStatusesSumAggregateInputType = {
    id?: true
  }

  export type QuoteStatusesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuoteStatusesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuoteStatusesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuoteStatusesAggregateArgs = {
    /**
     * Filter which quoteStatuses to aggregate.
     */
    where?: quoteStatusesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quoteStatuses to fetch.
     */
    orderBy?: Enumerable<quoteStatusesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: quoteStatusesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quoteStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quoteStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned quoteStatuses
    **/
    _count?: true | QuoteStatusesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuoteStatusesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuoteStatusesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuoteStatusesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuoteStatusesMaxAggregateInputType
  }

  export type GetQuoteStatusesAggregateType<T extends QuoteStatusesAggregateArgs> = {
        [P in keyof T & keyof AggregateQuoteStatuses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuoteStatuses[P]>
      : GetScalarType<T[P], AggregateQuoteStatuses[P]>
  }




  export type QuoteStatusesGroupByArgs = {
    where?: quoteStatusesWhereInput
    orderBy?: Enumerable<quoteStatusesOrderByWithAggregationInput>
    by: QuoteStatusesScalarFieldEnum[]
    having?: quoteStatusesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuoteStatusesCountAggregateInputType | true
    _avg?: QuoteStatusesAvgAggregateInputType
    _sum?: QuoteStatusesSumAggregateInputType
    _min?: QuoteStatusesMinAggregateInputType
    _max?: QuoteStatusesMaxAggregateInputType
  }


  export type QuoteStatusesGroupByOutputType = {
    id: number
    name: string
    description: string
    createdAt: Date
    updatedAt: Date
    _count: QuoteStatusesCountAggregateOutputType | null
    _avg: QuoteStatusesAvgAggregateOutputType | null
    _sum: QuoteStatusesSumAggregateOutputType | null
    _min: QuoteStatusesMinAggregateOutputType | null
    _max: QuoteStatusesMaxAggregateOutputType | null
  }

  type GetQuoteStatusesGroupByPayload<T extends QuoteStatusesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<QuoteStatusesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuoteStatusesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuoteStatusesGroupByOutputType[P]>
            : GetScalarType<T[P], QuoteStatusesGroupByOutputType[P]>
        }
      >
    >


  export type quoteStatusesSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quotes?: boolean | quoteStatuses$quotesArgs
    _count?: boolean | QuoteStatusesCountOutputTypeArgs
  }


  export type quoteStatusesInclude = {
    quotes?: boolean | quoteStatuses$quotesArgs
    _count?: boolean | QuoteStatusesCountOutputTypeArgs
  }

  export type quoteStatusesGetPayload<S extends boolean | null | undefined | quoteStatusesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? quoteStatuses :
    S extends undefined ? never :
    S extends { include: any } & (quoteStatusesArgs | quoteStatusesFindManyArgs)
    ? quoteStatuses  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'quotes' ? Array < quotesGetPayload<S['include'][P]>>  :
        P extends '_count' ? QuoteStatusesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (quoteStatusesArgs | quoteStatusesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'quotes' ? Array < quotesGetPayload<S['select'][P]>>  :
        P extends '_count' ? QuoteStatusesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof quoteStatuses ? quoteStatuses[P] : never
  } 
      : quoteStatuses


  type quoteStatusesCountArgs = 
    Omit<quoteStatusesFindManyArgs, 'select' | 'include'> & {
      select?: QuoteStatusesCountAggregateInputType | true
    }

  export interface quoteStatusesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one QuoteStatuses that matches the filter.
     * @param {quoteStatusesFindUniqueArgs} args - Arguments to find a QuoteStatuses
     * @example
     * // Get one QuoteStatuses
     * const quoteStatuses = await prisma.quoteStatuses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends quoteStatusesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, quoteStatusesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'quoteStatuses'> extends True ? Prisma__quoteStatusesClient<quoteStatusesGetPayload<T>> : Prisma__quoteStatusesClient<quoteStatusesGetPayload<T> | null, null>

    /**
     * Find one QuoteStatuses that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {quoteStatusesFindUniqueOrThrowArgs} args - Arguments to find a QuoteStatuses
     * @example
     * // Get one QuoteStatuses
     * const quoteStatuses = await prisma.quoteStatuses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends quoteStatusesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, quoteStatusesFindUniqueOrThrowArgs>
    ): Prisma__quoteStatusesClient<quoteStatusesGetPayload<T>>

    /**
     * Find the first QuoteStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quoteStatusesFindFirstArgs} args - Arguments to find a QuoteStatuses
     * @example
     * // Get one QuoteStatuses
     * const quoteStatuses = await prisma.quoteStatuses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends quoteStatusesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, quoteStatusesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'quoteStatuses'> extends True ? Prisma__quoteStatusesClient<quoteStatusesGetPayload<T>> : Prisma__quoteStatusesClient<quoteStatusesGetPayload<T> | null, null>

    /**
     * Find the first QuoteStatuses that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quoteStatusesFindFirstOrThrowArgs} args - Arguments to find a QuoteStatuses
     * @example
     * // Get one QuoteStatuses
     * const quoteStatuses = await prisma.quoteStatuses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends quoteStatusesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, quoteStatusesFindFirstOrThrowArgs>
    ): Prisma__quoteStatusesClient<quoteStatusesGetPayload<T>>

    /**
     * Find zero or more QuoteStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quoteStatusesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuoteStatuses
     * const quoteStatuses = await prisma.quoteStatuses.findMany()
     * 
     * // Get first 10 QuoteStatuses
     * const quoteStatuses = await prisma.quoteStatuses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quoteStatusesWithIdOnly = await prisma.quoteStatuses.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends quoteStatusesFindManyArgs>(
      args?: SelectSubset<T, quoteStatusesFindManyArgs>
    ): PrismaPromise<Array<quoteStatusesGetPayload<T>>>

    /**
     * Create a QuoteStatuses.
     * @param {quoteStatusesCreateArgs} args - Arguments to create a QuoteStatuses.
     * @example
     * // Create one QuoteStatuses
     * const QuoteStatuses = await prisma.quoteStatuses.create({
     *   data: {
     *     // ... data to create a QuoteStatuses
     *   }
     * })
     * 
    **/
    create<T extends quoteStatusesCreateArgs>(
      args: SelectSubset<T, quoteStatusesCreateArgs>
    ): Prisma__quoteStatusesClient<quoteStatusesGetPayload<T>>

    /**
     * Create many QuoteStatuses.
     *     @param {quoteStatusesCreateManyArgs} args - Arguments to create many QuoteStatuses.
     *     @example
     *     // Create many QuoteStatuses
     *     const quoteStatuses = await prisma.quoteStatuses.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends quoteStatusesCreateManyArgs>(
      args?: SelectSubset<T, quoteStatusesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a QuoteStatuses.
     * @param {quoteStatusesDeleteArgs} args - Arguments to delete one QuoteStatuses.
     * @example
     * // Delete one QuoteStatuses
     * const QuoteStatuses = await prisma.quoteStatuses.delete({
     *   where: {
     *     // ... filter to delete one QuoteStatuses
     *   }
     * })
     * 
    **/
    delete<T extends quoteStatusesDeleteArgs>(
      args: SelectSubset<T, quoteStatusesDeleteArgs>
    ): Prisma__quoteStatusesClient<quoteStatusesGetPayload<T>>

    /**
     * Update one QuoteStatuses.
     * @param {quoteStatusesUpdateArgs} args - Arguments to update one QuoteStatuses.
     * @example
     * // Update one QuoteStatuses
     * const quoteStatuses = await prisma.quoteStatuses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends quoteStatusesUpdateArgs>(
      args: SelectSubset<T, quoteStatusesUpdateArgs>
    ): Prisma__quoteStatusesClient<quoteStatusesGetPayload<T>>

    /**
     * Delete zero or more QuoteStatuses.
     * @param {quoteStatusesDeleteManyArgs} args - Arguments to filter QuoteStatuses to delete.
     * @example
     * // Delete a few QuoteStatuses
     * const { count } = await prisma.quoteStatuses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends quoteStatusesDeleteManyArgs>(
      args?: SelectSubset<T, quoteStatusesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuoteStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quoteStatusesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuoteStatuses
     * const quoteStatuses = await prisma.quoteStatuses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends quoteStatusesUpdateManyArgs>(
      args: SelectSubset<T, quoteStatusesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one QuoteStatuses.
     * @param {quoteStatusesUpsertArgs} args - Arguments to update or create a QuoteStatuses.
     * @example
     * // Update or create a QuoteStatuses
     * const quoteStatuses = await prisma.quoteStatuses.upsert({
     *   create: {
     *     // ... data to create a QuoteStatuses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuoteStatuses we want to update
     *   }
     * })
    **/
    upsert<T extends quoteStatusesUpsertArgs>(
      args: SelectSubset<T, quoteStatusesUpsertArgs>
    ): Prisma__quoteStatusesClient<quoteStatusesGetPayload<T>>

    /**
     * Count the number of QuoteStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quoteStatusesCountArgs} args - Arguments to filter QuoteStatuses to count.
     * @example
     * // Count the number of QuoteStatuses
     * const count = await prisma.quoteStatuses.count({
     *   where: {
     *     // ... the filter for the QuoteStatuses we want to count
     *   }
     * })
    **/
    count<T extends quoteStatusesCountArgs>(
      args?: Subset<T, quoteStatusesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuoteStatusesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuoteStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteStatusesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuoteStatusesAggregateArgs>(args: Subset<T, QuoteStatusesAggregateArgs>): PrismaPromise<GetQuoteStatusesAggregateType<T>>

    /**
     * Group by QuoteStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteStatusesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuoteStatusesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuoteStatusesGroupByArgs['orderBy'] }
        : { orderBy?: QuoteStatusesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuoteStatusesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuoteStatusesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for quoteStatuses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__quoteStatusesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    quotes<T extends quoteStatuses$quotesArgs= {}>(args?: Subset<T, quoteStatuses$quotesArgs>): PrismaPromise<Array<quotesGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * quoteStatuses base type for findUnique actions
   */
  export type quoteStatusesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the quoteStatuses
     */
    select?: quoteStatusesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: quoteStatusesInclude | null
    /**
     * Filter, which quoteStatuses to fetch.
     */
    where: quoteStatusesWhereUniqueInput
  }

  /**
   * quoteStatuses findUnique
   */
  export interface quoteStatusesFindUniqueArgs extends quoteStatusesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * quoteStatuses findUniqueOrThrow
   */
  export type quoteStatusesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the quoteStatuses
     */
    select?: quoteStatusesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: quoteStatusesInclude | null
    /**
     * Filter, which quoteStatuses to fetch.
     */
    where: quoteStatusesWhereUniqueInput
  }


  /**
   * quoteStatuses base type for findFirst actions
   */
  export type quoteStatusesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the quoteStatuses
     */
    select?: quoteStatusesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: quoteStatusesInclude | null
    /**
     * Filter, which quoteStatuses to fetch.
     */
    where?: quoteStatusesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quoteStatuses to fetch.
     */
    orderBy?: Enumerable<quoteStatusesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quoteStatuses.
     */
    cursor?: quoteStatusesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quoteStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quoteStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quoteStatuses.
     */
    distinct?: Enumerable<QuoteStatusesScalarFieldEnum>
  }

  /**
   * quoteStatuses findFirst
   */
  export interface quoteStatusesFindFirstArgs extends quoteStatusesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * quoteStatuses findFirstOrThrow
   */
  export type quoteStatusesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the quoteStatuses
     */
    select?: quoteStatusesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: quoteStatusesInclude | null
    /**
     * Filter, which quoteStatuses to fetch.
     */
    where?: quoteStatusesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quoteStatuses to fetch.
     */
    orderBy?: Enumerable<quoteStatusesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quoteStatuses.
     */
    cursor?: quoteStatusesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quoteStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quoteStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quoteStatuses.
     */
    distinct?: Enumerable<QuoteStatusesScalarFieldEnum>
  }


  /**
   * quoteStatuses findMany
   */
  export type quoteStatusesFindManyArgs = {
    /**
     * Select specific fields to fetch from the quoteStatuses
     */
    select?: quoteStatusesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: quoteStatusesInclude | null
    /**
     * Filter, which quoteStatuses to fetch.
     */
    where?: quoteStatusesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quoteStatuses to fetch.
     */
    orderBy?: Enumerable<quoteStatusesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing quoteStatuses.
     */
    cursor?: quoteStatusesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quoteStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quoteStatuses.
     */
    skip?: number
    distinct?: Enumerable<QuoteStatusesScalarFieldEnum>
  }


  /**
   * quoteStatuses create
   */
  export type quoteStatusesCreateArgs = {
    /**
     * Select specific fields to fetch from the quoteStatuses
     */
    select?: quoteStatusesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: quoteStatusesInclude | null
    /**
     * The data needed to create a quoteStatuses.
     */
    data: XOR<quoteStatusesCreateInput, quoteStatusesUncheckedCreateInput>
  }


  /**
   * quoteStatuses createMany
   */
  export type quoteStatusesCreateManyArgs = {
    /**
     * The data used to create many quoteStatuses.
     */
    data: Enumerable<quoteStatusesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * quoteStatuses update
   */
  export type quoteStatusesUpdateArgs = {
    /**
     * Select specific fields to fetch from the quoteStatuses
     */
    select?: quoteStatusesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: quoteStatusesInclude | null
    /**
     * The data needed to update a quoteStatuses.
     */
    data: XOR<quoteStatusesUpdateInput, quoteStatusesUncheckedUpdateInput>
    /**
     * Choose, which quoteStatuses to update.
     */
    where: quoteStatusesWhereUniqueInput
  }


  /**
   * quoteStatuses updateMany
   */
  export type quoteStatusesUpdateManyArgs = {
    /**
     * The data used to update quoteStatuses.
     */
    data: XOR<quoteStatusesUpdateManyMutationInput, quoteStatusesUncheckedUpdateManyInput>
    /**
     * Filter which quoteStatuses to update
     */
    where?: quoteStatusesWhereInput
  }


  /**
   * quoteStatuses upsert
   */
  export type quoteStatusesUpsertArgs = {
    /**
     * Select specific fields to fetch from the quoteStatuses
     */
    select?: quoteStatusesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: quoteStatusesInclude | null
    /**
     * The filter to search for the quoteStatuses to update in case it exists.
     */
    where: quoteStatusesWhereUniqueInput
    /**
     * In case the quoteStatuses found by the `where` argument doesn't exist, create a new quoteStatuses with this data.
     */
    create: XOR<quoteStatusesCreateInput, quoteStatusesUncheckedCreateInput>
    /**
     * In case the quoteStatuses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<quoteStatusesUpdateInput, quoteStatusesUncheckedUpdateInput>
  }


  /**
   * quoteStatuses delete
   */
  export type quoteStatusesDeleteArgs = {
    /**
     * Select specific fields to fetch from the quoteStatuses
     */
    select?: quoteStatusesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: quoteStatusesInclude | null
    /**
     * Filter which quoteStatuses to delete.
     */
    where: quoteStatusesWhereUniqueInput
  }


  /**
   * quoteStatuses deleteMany
   */
  export type quoteStatusesDeleteManyArgs = {
    /**
     * Filter which quoteStatuses to delete
     */
    where?: quoteStatusesWhereInput
  }


  /**
   * quoteStatuses.quotes
   */
  export type quoteStatuses$quotesArgs = {
    /**
     * Select specific fields to fetch from the quotes
     */
    select?: quotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: quotesInclude | null
    where?: quotesWhereInput
    orderBy?: Enumerable<quotesOrderByWithRelationInput>
    cursor?: quotesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QuotesScalarFieldEnum>
  }


  /**
   * quoteStatuses without action
   */
  export type quoteStatusesArgs = {
    /**
     * Select specific fields to fetch from the quoteStatuses
     */
    select?: quoteStatusesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: quoteStatusesInclude | null
  }



  /**
   * Model tokenPairs
   */


  export type AggregateTokenPairs = {
    _count: TokenPairsCountAggregateOutputType | null
    _avg: TokenPairsAvgAggregateOutputType | null
    _sum: TokenPairsSumAggregateOutputType | null
    _min: TokenPairsMinAggregateOutputType | null
    _max: TokenPairsMaxAggregateOutputType | null
  }

  export type TokenPairsAvgAggregateOutputType = {
    id: number | null
    vendorId: number | null
  }

  export type TokenPairsSumAggregateOutputType = {
    id: number | null
    vendorId: number | null
  }

  export type TokenPairsMinAggregateOutputType = {
    id: number | null
    baseToken: string | null
    quoteToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    vendorId: number | null
  }

  export type TokenPairsMaxAggregateOutputType = {
    id: number | null
    baseToken: string | null
    quoteToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    vendorId: number | null
  }

  export type TokenPairsCountAggregateOutputType = {
    id: number
    baseToken: number
    quoteToken: number
    createdAt: number
    updatedAt: number
    vendorId: number
    _all: number
  }


  export type TokenPairsAvgAggregateInputType = {
    id?: true
    vendorId?: true
  }

  export type TokenPairsSumAggregateInputType = {
    id?: true
    vendorId?: true
  }

  export type TokenPairsMinAggregateInputType = {
    id?: true
    baseToken?: true
    quoteToken?: true
    createdAt?: true
    updatedAt?: true
    vendorId?: true
  }

  export type TokenPairsMaxAggregateInputType = {
    id?: true
    baseToken?: true
    quoteToken?: true
    createdAt?: true
    updatedAt?: true
    vendorId?: true
  }

  export type TokenPairsCountAggregateInputType = {
    id?: true
    baseToken?: true
    quoteToken?: true
    createdAt?: true
    updatedAt?: true
    vendorId?: true
    _all?: true
  }

  export type TokenPairsAggregateArgs = {
    /**
     * Filter which tokenPairs to aggregate.
     */
    where?: tokenPairsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokenPairs to fetch.
     */
    orderBy?: Enumerable<tokenPairsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tokenPairsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokenPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokenPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tokenPairs
    **/
    _count?: true | TokenPairsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TokenPairsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TokenPairsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenPairsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenPairsMaxAggregateInputType
  }

  export type GetTokenPairsAggregateType<T extends TokenPairsAggregateArgs> = {
        [P in keyof T & keyof AggregateTokenPairs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTokenPairs[P]>
      : GetScalarType<T[P], AggregateTokenPairs[P]>
  }




  export type TokenPairsGroupByArgs = {
    where?: tokenPairsWhereInput
    orderBy?: Enumerable<tokenPairsOrderByWithAggregationInput>
    by: TokenPairsScalarFieldEnum[]
    having?: tokenPairsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenPairsCountAggregateInputType | true
    _avg?: TokenPairsAvgAggregateInputType
    _sum?: TokenPairsSumAggregateInputType
    _min?: TokenPairsMinAggregateInputType
    _max?: TokenPairsMaxAggregateInputType
  }


  export type TokenPairsGroupByOutputType = {
    id: number
    baseToken: string
    quoteToken: string
    createdAt: Date
    updatedAt: Date
    vendorId: number
    _count: TokenPairsCountAggregateOutputType | null
    _avg: TokenPairsAvgAggregateOutputType | null
    _sum: TokenPairsSumAggregateOutputType | null
    _min: TokenPairsMinAggregateOutputType | null
    _max: TokenPairsMaxAggregateOutputType | null
  }

  type GetTokenPairsGroupByPayload<T extends TokenPairsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TokenPairsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenPairsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenPairsGroupByOutputType[P]>
            : GetScalarType<T[P], TokenPairsGroupByOutputType[P]>
        }
      >
    >


  export type tokenPairsSelect = {
    id?: boolean
    baseToken?: boolean
    quoteToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendorId?: boolean
    vendors?: boolean | vendorsArgs
    tokenPairsInfo?: boolean | tokenPairs$tokenPairsInfoArgs
    _count?: boolean | TokenPairsCountOutputTypeArgs
  }


  export type tokenPairsInclude = {
    vendors?: boolean | vendorsArgs
    tokenPairsInfo?: boolean | tokenPairs$tokenPairsInfoArgs
    _count?: boolean | TokenPairsCountOutputTypeArgs
  }

  export type tokenPairsGetPayload<S extends boolean | null | undefined | tokenPairsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? tokenPairs :
    S extends undefined ? never :
    S extends { include: any } & (tokenPairsArgs | tokenPairsFindManyArgs)
    ? tokenPairs  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'vendors' ? vendorsGetPayload<S['include'][P]> :
        P extends 'tokenPairsInfo' ? Array < tokenPairsInfoGetPayload<S['include'][P]>>  :
        P extends '_count' ? TokenPairsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (tokenPairsArgs | tokenPairsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'vendors' ? vendorsGetPayload<S['select'][P]> :
        P extends 'tokenPairsInfo' ? Array < tokenPairsInfoGetPayload<S['select'][P]>>  :
        P extends '_count' ? TokenPairsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof tokenPairs ? tokenPairs[P] : never
  } 
      : tokenPairs


  type tokenPairsCountArgs = 
    Omit<tokenPairsFindManyArgs, 'select' | 'include'> & {
      select?: TokenPairsCountAggregateInputType | true
    }

  export interface tokenPairsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TokenPairs that matches the filter.
     * @param {tokenPairsFindUniqueArgs} args - Arguments to find a TokenPairs
     * @example
     * // Get one TokenPairs
     * const tokenPairs = await prisma.tokenPairs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tokenPairsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tokenPairsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tokenPairs'> extends True ? Prisma__tokenPairsClient<tokenPairsGetPayload<T>> : Prisma__tokenPairsClient<tokenPairsGetPayload<T> | null, null>

    /**
     * Find one TokenPairs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tokenPairsFindUniqueOrThrowArgs} args - Arguments to find a TokenPairs
     * @example
     * // Get one TokenPairs
     * const tokenPairs = await prisma.tokenPairs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tokenPairsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, tokenPairsFindUniqueOrThrowArgs>
    ): Prisma__tokenPairsClient<tokenPairsGetPayload<T>>

    /**
     * Find the first TokenPairs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokenPairsFindFirstArgs} args - Arguments to find a TokenPairs
     * @example
     * // Get one TokenPairs
     * const tokenPairs = await prisma.tokenPairs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tokenPairsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tokenPairsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tokenPairs'> extends True ? Prisma__tokenPairsClient<tokenPairsGetPayload<T>> : Prisma__tokenPairsClient<tokenPairsGetPayload<T> | null, null>

    /**
     * Find the first TokenPairs that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokenPairsFindFirstOrThrowArgs} args - Arguments to find a TokenPairs
     * @example
     * // Get one TokenPairs
     * const tokenPairs = await prisma.tokenPairs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tokenPairsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, tokenPairsFindFirstOrThrowArgs>
    ): Prisma__tokenPairsClient<tokenPairsGetPayload<T>>

    /**
     * Find zero or more TokenPairs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokenPairsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TokenPairs
     * const tokenPairs = await prisma.tokenPairs.findMany()
     * 
     * // Get first 10 TokenPairs
     * const tokenPairs = await prisma.tokenPairs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenPairsWithIdOnly = await prisma.tokenPairs.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends tokenPairsFindManyArgs>(
      args?: SelectSubset<T, tokenPairsFindManyArgs>
    ): PrismaPromise<Array<tokenPairsGetPayload<T>>>

    /**
     * Create a TokenPairs.
     * @param {tokenPairsCreateArgs} args - Arguments to create a TokenPairs.
     * @example
     * // Create one TokenPairs
     * const TokenPairs = await prisma.tokenPairs.create({
     *   data: {
     *     // ... data to create a TokenPairs
     *   }
     * })
     * 
    **/
    create<T extends tokenPairsCreateArgs>(
      args: SelectSubset<T, tokenPairsCreateArgs>
    ): Prisma__tokenPairsClient<tokenPairsGetPayload<T>>

    /**
     * Create many TokenPairs.
     *     @param {tokenPairsCreateManyArgs} args - Arguments to create many TokenPairs.
     *     @example
     *     // Create many TokenPairs
     *     const tokenPairs = await prisma.tokenPairs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tokenPairsCreateManyArgs>(
      args?: SelectSubset<T, tokenPairsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TokenPairs.
     * @param {tokenPairsDeleteArgs} args - Arguments to delete one TokenPairs.
     * @example
     * // Delete one TokenPairs
     * const TokenPairs = await prisma.tokenPairs.delete({
     *   where: {
     *     // ... filter to delete one TokenPairs
     *   }
     * })
     * 
    **/
    delete<T extends tokenPairsDeleteArgs>(
      args: SelectSubset<T, tokenPairsDeleteArgs>
    ): Prisma__tokenPairsClient<tokenPairsGetPayload<T>>

    /**
     * Update one TokenPairs.
     * @param {tokenPairsUpdateArgs} args - Arguments to update one TokenPairs.
     * @example
     * // Update one TokenPairs
     * const tokenPairs = await prisma.tokenPairs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tokenPairsUpdateArgs>(
      args: SelectSubset<T, tokenPairsUpdateArgs>
    ): Prisma__tokenPairsClient<tokenPairsGetPayload<T>>

    /**
     * Delete zero or more TokenPairs.
     * @param {tokenPairsDeleteManyArgs} args - Arguments to filter TokenPairs to delete.
     * @example
     * // Delete a few TokenPairs
     * const { count } = await prisma.tokenPairs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tokenPairsDeleteManyArgs>(
      args?: SelectSubset<T, tokenPairsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TokenPairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokenPairsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TokenPairs
     * const tokenPairs = await prisma.tokenPairs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tokenPairsUpdateManyArgs>(
      args: SelectSubset<T, tokenPairsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TokenPairs.
     * @param {tokenPairsUpsertArgs} args - Arguments to update or create a TokenPairs.
     * @example
     * // Update or create a TokenPairs
     * const tokenPairs = await prisma.tokenPairs.upsert({
     *   create: {
     *     // ... data to create a TokenPairs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TokenPairs we want to update
     *   }
     * })
    **/
    upsert<T extends tokenPairsUpsertArgs>(
      args: SelectSubset<T, tokenPairsUpsertArgs>
    ): Prisma__tokenPairsClient<tokenPairsGetPayload<T>>

    /**
     * Count the number of TokenPairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokenPairsCountArgs} args - Arguments to filter TokenPairs to count.
     * @example
     * // Count the number of TokenPairs
     * const count = await prisma.tokenPairs.count({
     *   where: {
     *     // ... the filter for the TokenPairs we want to count
     *   }
     * })
    **/
    count<T extends tokenPairsCountArgs>(
      args?: Subset<T, tokenPairsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenPairsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TokenPairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenPairsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenPairsAggregateArgs>(args: Subset<T, TokenPairsAggregateArgs>): PrismaPromise<GetTokenPairsAggregateType<T>>

    /**
     * Group by TokenPairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenPairsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenPairsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenPairsGroupByArgs['orderBy'] }
        : { orderBy?: TokenPairsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenPairsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenPairsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tokenPairs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tokenPairsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    vendors<T extends vendorsArgs= {}>(args?: Subset<T, vendorsArgs>): Prisma__vendorsClient<vendorsGetPayload<T> | Null>;

    tokenPairsInfo<T extends tokenPairs$tokenPairsInfoArgs= {}>(args?: Subset<T, tokenPairs$tokenPairsInfoArgs>): PrismaPromise<Array<tokenPairsInfoGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tokenPairs base type for findUnique actions
   */
  export type tokenPairsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the tokenPairs
     */
    select?: tokenPairsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tokenPairsInclude | null
    /**
     * Filter, which tokenPairs to fetch.
     */
    where: tokenPairsWhereUniqueInput
  }

  /**
   * tokenPairs findUnique
   */
  export interface tokenPairsFindUniqueArgs extends tokenPairsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tokenPairs findUniqueOrThrow
   */
  export type tokenPairsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tokenPairs
     */
    select?: tokenPairsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tokenPairsInclude | null
    /**
     * Filter, which tokenPairs to fetch.
     */
    where: tokenPairsWhereUniqueInput
  }


  /**
   * tokenPairs base type for findFirst actions
   */
  export type tokenPairsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the tokenPairs
     */
    select?: tokenPairsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tokenPairsInclude | null
    /**
     * Filter, which tokenPairs to fetch.
     */
    where?: tokenPairsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokenPairs to fetch.
     */
    orderBy?: Enumerable<tokenPairsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tokenPairs.
     */
    cursor?: tokenPairsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokenPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokenPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tokenPairs.
     */
    distinct?: Enumerable<TokenPairsScalarFieldEnum>
  }

  /**
   * tokenPairs findFirst
   */
  export interface tokenPairsFindFirstArgs extends tokenPairsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tokenPairs findFirstOrThrow
   */
  export type tokenPairsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tokenPairs
     */
    select?: tokenPairsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tokenPairsInclude | null
    /**
     * Filter, which tokenPairs to fetch.
     */
    where?: tokenPairsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokenPairs to fetch.
     */
    orderBy?: Enumerable<tokenPairsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tokenPairs.
     */
    cursor?: tokenPairsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokenPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokenPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tokenPairs.
     */
    distinct?: Enumerable<TokenPairsScalarFieldEnum>
  }


  /**
   * tokenPairs findMany
   */
  export type tokenPairsFindManyArgs = {
    /**
     * Select specific fields to fetch from the tokenPairs
     */
    select?: tokenPairsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tokenPairsInclude | null
    /**
     * Filter, which tokenPairs to fetch.
     */
    where?: tokenPairsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokenPairs to fetch.
     */
    orderBy?: Enumerable<tokenPairsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tokenPairs.
     */
    cursor?: tokenPairsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokenPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokenPairs.
     */
    skip?: number
    distinct?: Enumerable<TokenPairsScalarFieldEnum>
  }


  /**
   * tokenPairs create
   */
  export type tokenPairsCreateArgs = {
    /**
     * Select specific fields to fetch from the tokenPairs
     */
    select?: tokenPairsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tokenPairsInclude | null
    /**
     * The data needed to create a tokenPairs.
     */
    data: XOR<tokenPairsCreateInput, tokenPairsUncheckedCreateInput>
  }


  /**
   * tokenPairs createMany
   */
  export type tokenPairsCreateManyArgs = {
    /**
     * The data used to create many tokenPairs.
     */
    data: Enumerable<tokenPairsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * tokenPairs update
   */
  export type tokenPairsUpdateArgs = {
    /**
     * Select specific fields to fetch from the tokenPairs
     */
    select?: tokenPairsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tokenPairsInclude | null
    /**
     * The data needed to update a tokenPairs.
     */
    data: XOR<tokenPairsUpdateInput, tokenPairsUncheckedUpdateInput>
    /**
     * Choose, which tokenPairs to update.
     */
    where: tokenPairsWhereUniqueInput
  }


  /**
   * tokenPairs updateMany
   */
  export type tokenPairsUpdateManyArgs = {
    /**
     * The data used to update tokenPairs.
     */
    data: XOR<tokenPairsUpdateManyMutationInput, tokenPairsUncheckedUpdateManyInput>
    /**
     * Filter which tokenPairs to update
     */
    where?: tokenPairsWhereInput
  }


  /**
   * tokenPairs upsert
   */
  export type tokenPairsUpsertArgs = {
    /**
     * Select specific fields to fetch from the tokenPairs
     */
    select?: tokenPairsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tokenPairsInclude | null
    /**
     * The filter to search for the tokenPairs to update in case it exists.
     */
    where: tokenPairsWhereUniqueInput
    /**
     * In case the tokenPairs found by the `where` argument doesn't exist, create a new tokenPairs with this data.
     */
    create: XOR<tokenPairsCreateInput, tokenPairsUncheckedCreateInput>
    /**
     * In case the tokenPairs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tokenPairsUpdateInput, tokenPairsUncheckedUpdateInput>
  }


  /**
   * tokenPairs delete
   */
  export type tokenPairsDeleteArgs = {
    /**
     * Select specific fields to fetch from the tokenPairs
     */
    select?: tokenPairsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tokenPairsInclude | null
    /**
     * Filter which tokenPairs to delete.
     */
    where: tokenPairsWhereUniqueInput
  }


  /**
   * tokenPairs deleteMany
   */
  export type tokenPairsDeleteManyArgs = {
    /**
     * Filter which tokenPairs to delete
     */
    where?: tokenPairsWhereInput
  }


  /**
   * tokenPairs.tokenPairsInfo
   */
  export type tokenPairs$tokenPairsInfoArgs = {
    /**
     * Select specific fields to fetch from the tokenPairsInfo
     */
    select?: tokenPairsInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tokenPairsInfoInclude | null
    where?: tokenPairsInfoWhereInput
    orderBy?: Enumerable<tokenPairsInfoOrderByWithRelationInput>
    cursor?: tokenPairsInfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TokenPairsInfoScalarFieldEnum>
  }


  /**
   * tokenPairs without action
   */
  export type tokenPairsArgs = {
    /**
     * Select specific fields to fetch from the tokenPairs
     */
    select?: tokenPairsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tokenPairsInclude | null
  }



  /**
   * Model tokenPairsInfo
   */


  export type AggregateTokenPairsInfo = {
    _count: TokenPairsInfoCountAggregateOutputType | null
    _avg: TokenPairsInfoAvgAggregateOutputType | null
    _sum: TokenPairsInfoSumAggregateOutputType | null
    _min: TokenPairsInfoMinAggregateOutputType | null
    _max: TokenPairsInfoMaxAggregateOutputType | null
  }

  export type TokenPairsInfoAvgAggregateOutputType = {
    id: number | null
    tokenPairId: number | null
  }

  export type TokenPairsInfoSumAggregateOutputType = {
    id: number | null
    tokenPairId: number | null
  }

  export type TokenPairsInfoMinAggregateOutputType = {
    id: number | null
    tokenPairId: number | null
    fxRequestID: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TokenPairsInfoMaxAggregateOutputType = {
    id: number | null
    tokenPairId: number | null
    fxRequestID: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TokenPairsInfoCountAggregateOutputType = {
    id: number
    tokenPairId: number
    fxRequestID: number
    quantity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TokenPairsInfoAvgAggregateInputType = {
    id?: true
    tokenPairId?: true
  }

  export type TokenPairsInfoSumAggregateInputType = {
    id?: true
    tokenPairId?: true
  }

  export type TokenPairsInfoMinAggregateInputType = {
    id?: true
    tokenPairId?: true
    fxRequestID?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TokenPairsInfoMaxAggregateInputType = {
    id?: true
    tokenPairId?: true
    fxRequestID?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TokenPairsInfoCountAggregateInputType = {
    id?: true
    tokenPairId?: true
    fxRequestID?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TokenPairsInfoAggregateArgs = {
    /**
     * Filter which tokenPairsInfo to aggregate.
     */
    where?: tokenPairsInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokenPairsInfos to fetch.
     */
    orderBy?: Enumerable<tokenPairsInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tokenPairsInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokenPairsInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokenPairsInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tokenPairsInfos
    **/
    _count?: true | TokenPairsInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TokenPairsInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TokenPairsInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenPairsInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenPairsInfoMaxAggregateInputType
  }

  export type GetTokenPairsInfoAggregateType<T extends TokenPairsInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateTokenPairsInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTokenPairsInfo[P]>
      : GetScalarType<T[P], AggregateTokenPairsInfo[P]>
  }




  export type TokenPairsInfoGroupByArgs = {
    where?: tokenPairsInfoWhereInput
    orderBy?: Enumerable<tokenPairsInfoOrderByWithAggregationInput>
    by: TokenPairsInfoScalarFieldEnum[]
    having?: tokenPairsInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenPairsInfoCountAggregateInputType | true
    _avg?: TokenPairsInfoAvgAggregateInputType
    _sum?: TokenPairsInfoSumAggregateInputType
    _min?: TokenPairsInfoMinAggregateInputType
    _max?: TokenPairsInfoMaxAggregateInputType
  }


  export type TokenPairsInfoGroupByOutputType = {
    id: number
    tokenPairId: number
    fxRequestID: string
    quantity: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: TokenPairsInfoCountAggregateOutputType | null
    _avg: TokenPairsInfoAvgAggregateOutputType | null
    _sum: TokenPairsInfoSumAggregateOutputType | null
    _min: TokenPairsInfoMinAggregateOutputType | null
    _max: TokenPairsInfoMaxAggregateOutputType | null
  }

  type GetTokenPairsInfoGroupByPayload<T extends TokenPairsInfoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TokenPairsInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenPairsInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenPairsInfoGroupByOutputType[P]>
            : GetScalarType<T[P], TokenPairsInfoGroupByOutputType[P]>
        }
      >
    >


  export type tokenPairsInfoSelect = {
    id?: boolean
    tokenPairId?: boolean
    fxRequestID?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quotes?: boolean | tokenPairsInfo$quotesArgs
    tokenPairs?: boolean | tokenPairsArgs
    _count?: boolean | TokenPairsInfoCountOutputTypeArgs
  }


  export type tokenPairsInfoInclude = {
    quotes?: boolean | tokenPairsInfo$quotesArgs
    tokenPairs?: boolean | tokenPairsArgs
    _count?: boolean | TokenPairsInfoCountOutputTypeArgs
  }

  export type tokenPairsInfoGetPayload<S extends boolean | null | undefined | tokenPairsInfoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? tokenPairsInfo :
    S extends undefined ? never :
    S extends { include: any } & (tokenPairsInfoArgs | tokenPairsInfoFindManyArgs)
    ? tokenPairsInfo  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'quotes' ? Array < quotesGetPayload<S['include'][P]>>  :
        P extends 'tokenPairs' ? tokenPairsGetPayload<S['include'][P]> :
        P extends '_count' ? TokenPairsInfoCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (tokenPairsInfoArgs | tokenPairsInfoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'quotes' ? Array < quotesGetPayload<S['select'][P]>>  :
        P extends 'tokenPairs' ? tokenPairsGetPayload<S['select'][P]> :
        P extends '_count' ? TokenPairsInfoCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof tokenPairsInfo ? tokenPairsInfo[P] : never
  } 
      : tokenPairsInfo


  type tokenPairsInfoCountArgs = 
    Omit<tokenPairsInfoFindManyArgs, 'select' | 'include'> & {
      select?: TokenPairsInfoCountAggregateInputType | true
    }

  export interface tokenPairsInfoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TokenPairsInfo that matches the filter.
     * @param {tokenPairsInfoFindUniqueArgs} args - Arguments to find a TokenPairsInfo
     * @example
     * // Get one TokenPairsInfo
     * const tokenPairsInfo = await prisma.tokenPairsInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tokenPairsInfoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tokenPairsInfoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tokenPairsInfo'> extends True ? Prisma__tokenPairsInfoClient<tokenPairsInfoGetPayload<T>> : Prisma__tokenPairsInfoClient<tokenPairsInfoGetPayload<T> | null, null>

    /**
     * Find one TokenPairsInfo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tokenPairsInfoFindUniqueOrThrowArgs} args - Arguments to find a TokenPairsInfo
     * @example
     * // Get one TokenPairsInfo
     * const tokenPairsInfo = await prisma.tokenPairsInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tokenPairsInfoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, tokenPairsInfoFindUniqueOrThrowArgs>
    ): Prisma__tokenPairsInfoClient<tokenPairsInfoGetPayload<T>>

    /**
     * Find the first TokenPairsInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokenPairsInfoFindFirstArgs} args - Arguments to find a TokenPairsInfo
     * @example
     * // Get one TokenPairsInfo
     * const tokenPairsInfo = await prisma.tokenPairsInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tokenPairsInfoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tokenPairsInfoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tokenPairsInfo'> extends True ? Prisma__tokenPairsInfoClient<tokenPairsInfoGetPayload<T>> : Prisma__tokenPairsInfoClient<tokenPairsInfoGetPayload<T> | null, null>

    /**
     * Find the first TokenPairsInfo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokenPairsInfoFindFirstOrThrowArgs} args - Arguments to find a TokenPairsInfo
     * @example
     * // Get one TokenPairsInfo
     * const tokenPairsInfo = await prisma.tokenPairsInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tokenPairsInfoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, tokenPairsInfoFindFirstOrThrowArgs>
    ): Prisma__tokenPairsInfoClient<tokenPairsInfoGetPayload<T>>

    /**
     * Find zero or more TokenPairsInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokenPairsInfoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TokenPairsInfos
     * const tokenPairsInfos = await prisma.tokenPairsInfo.findMany()
     * 
     * // Get first 10 TokenPairsInfos
     * const tokenPairsInfos = await prisma.tokenPairsInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenPairsInfoWithIdOnly = await prisma.tokenPairsInfo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends tokenPairsInfoFindManyArgs>(
      args?: SelectSubset<T, tokenPairsInfoFindManyArgs>
    ): PrismaPromise<Array<tokenPairsInfoGetPayload<T>>>

    /**
     * Create a TokenPairsInfo.
     * @param {tokenPairsInfoCreateArgs} args - Arguments to create a TokenPairsInfo.
     * @example
     * // Create one TokenPairsInfo
     * const TokenPairsInfo = await prisma.tokenPairsInfo.create({
     *   data: {
     *     // ... data to create a TokenPairsInfo
     *   }
     * })
     * 
    **/
    create<T extends tokenPairsInfoCreateArgs>(
      args: SelectSubset<T, tokenPairsInfoCreateArgs>
    ): Prisma__tokenPairsInfoClient<tokenPairsInfoGetPayload<T>>

    /**
     * Create many TokenPairsInfos.
     *     @param {tokenPairsInfoCreateManyArgs} args - Arguments to create many TokenPairsInfos.
     *     @example
     *     // Create many TokenPairsInfos
     *     const tokenPairsInfo = await prisma.tokenPairsInfo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tokenPairsInfoCreateManyArgs>(
      args?: SelectSubset<T, tokenPairsInfoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TokenPairsInfo.
     * @param {tokenPairsInfoDeleteArgs} args - Arguments to delete one TokenPairsInfo.
     * @example
     * // Delete one TokenPairsInfo
     * const TokenPairsInfo = await prisma.tokenPairsInfo.delete({
     *   where: {
     *     // ... filter to delete one TokenPairsInfo
     *   }
     * })
     * 
    **/
    delete<T extends tokenPairsInfoDeleteArgs>(
      args: SelectSubset<T, tokenPairsInfoDeleteArgs>
    ): Prisma__tokenPairsInfoClient<tokenPairsInfoGetPayload<T>>

    /**
     * Update one TokenPairsInfo.
     * @param {tokenPairsInfoUpdateArgs} args - Arguments to update one TokenPairsInfo.
     * @example
     * // Update one TokenPairsInfo
     * const tokenPairsInfo = await prisma.tokenPairsInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tokenPairsInfoUpdateArgs>(
      args: SelectSubset<T, tokenPairsInfoUpdateArgs>
    ): Prisma__tokenPairsInfoClient<tokenPairsInfoGetPayload<T>>

    /**
     * Delete zero or more TokenPairsInfos.
     * @param {tokenPairsInfoDeleteManyArgs} args - Arguments to filter TokenPairsInfos to delete.
     * @example
     * // Delete a few TokenPairsInfos
     * const { count } = await prisma.tokenPairsInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tokenPairsInfoDeleteManyArgs>(
      args?: SelectSubset<T, tokenPairsInfoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TokenPairsInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokenPairsInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TokenPairsInfos
     * const tokenPairsInfo = await prisma.tokenPairsInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tokenPairsInfoUpdateManyArgs>(
      args: SelectSubset<T, tokenPairsInfoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TokenPairsInfo.
     * @param {tokenPairsInfoUpsertArgs} args - Arguments to update or create a TokenPairsInfo.
     * @example
     * // Update or create a TokenPairsInfo
     * const tokenPairsInfo = await prisma.tokenPairsInfo.upsert({
     *   create: {
     *     // ... data to create a TokenPairsInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TokenPairsInfo we want to update
     *   }
     * })
    **/
    upsert<T extends tokenPairsInfoUpsertArgs>(
      args: SelectSubset<T, tokenPairsInfoUpsertArgs>
    ): Prisma__tokenPairsInfoClient<tokenPairsInfoGetPayload<T>>

    /**
     * Count the number of TokenPairsInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokenPairsInfoCountArgs} args - Arguments to filter TokenPairsInfos to count.
     * @example
     * // Count the number of TokenPairsInfos
     * const count = await prisma.tokenPairsInfo.count({
     *   where: {
     *     // ... the filter for the TokenPairsInfos we want to count
     *   }
     * })
    **/
    count<T extends tokenPairsInfoCountArgs>(
      args?: Subset<T, tokenPairsInfoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenPairsInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TokenPairsInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenPairsInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenPairsInfoAggregateArgs>(args: Subset<T, TokenPairsInfoAggregateArgs>): PrismaPromise<GetTokenPairsInfoAggregateType<T>>

    /**
     * Group by TokenPairsInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenPairsInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenPairsInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenPairsInfoGroupByArgs['orderBy'] }
        : { orderBy?: TokenPairsInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenPairsInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenPairsInfoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tokenPairsInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tokenPairsInfoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    quotes<T extends tokenPairsInfo$quotesArgs= {}>(args?: Subset<T, tokenPairsInfo$quotesArgs>): PrismaPromise<Array<quotesGetPayload<T>>| Null>;

    tokenPairs<T extends tokenPairsArgs= {}>(args?: Subset<T, tokenPairsArgs>): Prisma__tokenPairsClient<tokenPairsGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tokenPairsInfo base type for findUnique actions
   */
  export type tokenPairsInfoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the tokenPairsInfo
     */
    select?: tokenPairsInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tokenPairsInfoInclude | null
    /**
     * Filter, which tokenPairsInfo to fetch.
     */
    where: tokenPairsInfoWhereUniqueInput
  }

  /**
   * tokenPairsInfo findUnique
   */
  export interface tokenPairsInfoFindUniqueArgs extends tokenPairsInfoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tokenPairsInfo findUniqueOrThrow
   */
  export type tokenPairsInfoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tokenPairsInfo
     */
    select?: tokenPairsInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tokenPairsInfoInclude | null
    /**
     * Filter, which tokenPairsInfo to fetch.
     */
    where: tokenPairsInfoWhereUniqueInput
  }


  /**
   * tokenPairsInfo base type for findFirst actions
   */
  export type tokenPairsInfoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the tokenPairsInfo
     */
    select?: tokenPairsInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tokenPairsInfoInclude | null
    /**
     * Filter, which tokenPairsInfo to fetch.
     */
    where?: tokenPairsInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokenPairsInfos to fetch.
     */
    orderBy?: Enumerable<tokenPairsInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tokenPairsInfos.
     */
    cursor?: tokenPairsInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokenPairsInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokenPairsInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tokenPairsInfos.
     */
    distinct?: Enumerable<TokenPairsInfoScalarFieldEnum>
  }

  /**
   * tokenPairsInfo findFirst
   */
  export interface tokenPairsInfoFindFirstArgs extends tokenPairsInfoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tokenPairsInfo findFirstOrThrow
   */
  export type tokenPairsInfoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tokenPairsInfo
     */
    select?: tokenPairsInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tokenPairsInfoInclude | null
    /**
     * Filter, which tokenPairsInfo to fetch.
     */
    where?: tokenPairsInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokenPairsInfos to fetch.
     */
    orderBy?: Enumerable<tokenPairsInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tokenPairsInfos.
     */
    cursor?: tokenPairsInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokenPairsInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokenPairsInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tokenPairsInfos.
     */
    distinct?: Enumerable<TokenPairsInfoScalarFieldEnum>
  }


  /**
   * tokenPairsInfo findMany
   */
  export type tokenPairsInfoFindManyArgs = {
    /**
     * Select specific fields to fetch from the tokenPairsInfo
     */
    select?: tokenPairsInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tokenPairsInfoInclude | null
    /**
     * Filter, which tokenPairsInfos to fetch.
     */
    where?: tokenPairsInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokenPairsInfos to fetch.
     */
    orderBy?: Enumerable<tokenPairsInfoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tokenPairsInfos.
     */
    cursor?: tokenPairsInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokenPairsInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokenPairsInfos.
     */
    skip?: number
    distinct?: Enumerable<TokenPairsInfoScalarFieldEnum>
  }


  /**
   * tokenPairsInfo create
   */
  export type tokenPairsInfoCreateArgs = {
    /**
     * Select specific fields to fetch from the tokenPairsInfo
     */
    select?: tokenPairsInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tokenPairsInfoInclude | null
    /**
     * The data needed to create a tokenPairsInfo.
     */
    data: XOR<tokenPairsInfoCreateInput, tokenPairsInfoUncheckedCreateInput>
  }


  /**
   * tokenPairsInfo createMany
   */
  export type tokenPairsInfoCreateManyArgs = {
    /**
     * The data used to create many tokenPairsInfos.
     */
    data: Enumerable<tokenPairsInfoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * tokenPairsInfo update
   */
  export type tokenPairsInfoUpdateArgs = {
    /**
     * Select specific fields to fetch from the tokenPairsInfo
     */
    select?: tokenPairsInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tokenPairsInfoInclude | null
    /**
     * The data needed to update a tokenPairsInfo.
     */
    data: XOR<tokenPairsInfoUpdateInput, tokenPairsInfoUncheckedUpdateInput>
    /**
     * Choose, which tokenPairsInfo to update.
     */
    where: tokenPairsInfoWhereUniqueInput
  }


  /**
   * tokenPairsInfo updateMany
   */
  export type tokenPairsInfoUpdateManyArgs = {
    /**
     * The data used to update tokenPairsInfos.
     */
    data: XOR<tokenPairsInfoUpdateManyMutationInput, tokenPairsInfoUncheckedUpdateManyInput>
    /**
     * Filter which tokenPairsInfos to update
     */
    where?: tokenPairsInfoWhereInput
  }


  /**
   * tokenPairsInfo upsert
   */
  export type tokenPairsInfoUpsertArgs = {
    /**
     * Select specific fields to fetch from the tokenPairsInfo
     */
    select?: tokenPairsInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tokenPairsInfoInclude | null
    /**
     * The filter to search for the tokenPairsInfo to update in case it exists.
     */
    where: tokenPairsInfoWhereUniqueInput
    /**
     * In case the tokenPairsInfo found by the `where` argument doesn't exist, create a new tokenPairsInfo with this data.
     */
    create: XOR<tokenPairsInfoCreateInput, tokenPairsInfoUncheckedCreateInput>
    /**
     * In case the tokenPairsInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tokenPairsInfoUpdateInput, tokenPairsInfoUncheckedUpdateInput>
  }


  /**
   * tokenPairsInfo delete
   */
  export type tokenPairsInfoDeleteArgs = {
    /**
     * Select specific fields to fetch from the tokenPairsInfo
     */
    select?: tokenPairsInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tokenPairsInfoInclude | null
    /**
     * Filter which tokenPairsInfo to delete.
     */
    where: tokenPairsInfoWhereUniqueInput
  }


  /**
   * tokenPairsInfo deleteMany
   */
  export type tokenPairsInfoDeleteManyArgs = {
    /**
     * Filter which tokenPairsInfos to delete
     */
    where?: tokenPairsInfoWhereInput
  }


  /**
   * tokenPairsInfo.quotes
   */
  export type tokenPairsInfo$quotesArgs = {
    /**
     * Select specific fields to fetch from the quotes
     */
    select?: quotesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: quotesInclude | null
    where?: quotesWhereInput
    orderBy?: Enumerable<quotesOrderByWithRelationInput>
    cursor?: quotesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<QuotesScalarFieldEnum>
  }


  /**
   * tokenPairsInfo without action
   */
  export type tokenPairsInfoArgs = {
    /**
     * Select specific fields to fetch from the tokenPairsInfo
     */
    select?: tokenPairsInfoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tokenPairsInfoInclude | null
  }



  /**
   * Model transactionPolicies
   */


  export type AggregateTransactionPolicies = {
    _count: TransactionPoliciesCountAggregateOutputType | null
    _avg: TransactionPoliciesAvgAggregateOutputType | null
    _sum: TransactionPoliciesSumAggregateOutputType | null
    _min: TransactionPoliciesMinAggregateOutputType | null
    _max: TransactionPoliciesMaxAggregateOutputType | null
  }

  export type TransactionPoliciesAvgAggregateOutputType = {
    transactionTypeId: number | null
    assetId: number | null
  }

  export type TransactionPoliciesSumAggregateOutputType = {
    transactionTypeId: number | null
    assetId: number | null
  }

  export type TransactionPoliciesMinAggregateOutputType = {
    id: string | null
    userId: string | null
    transactionTypeId: number | null
    sourceVaultId: string | null
    targetVaultId: string | null
    targetWithdrawalAddressId: string | null
    toOneTimeAddresses: boolean | null
    greaterThanUSD: string | null
    assetId: number | null
    action: enum_transactionPolicies_action | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionPoliciesMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    transactionTypeId: number | null
    sourceVaultId: string | null
    targetVaultId: string | null
    targetWithdrawalAddressId: string | null
    toOneTimeAddresses: boolean | null
    greaterThanUSD: string | null
    assetId: number | null
    action: enum_transactionPolicies_action | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionPoliciesCountAggregateOutputType = {
    id: number
    userId: number
    transactionTypeId: number
    sourceVaultId: number
    targetVaultId: number
    targetWithdrawalAddressId: number
    toOneTimeAddresses: number
    greaterThanUSD: number
    assetId: number
    action: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionPoliciesAvgAggregateInputType = {
    transactionTypeId?: true
    assetId?: true
  }

  export type TransactionPoliciesSumAggregateInputType = {
    transactionTypeId?: true
    assetId?: true
  }

  export type TransactionPoliciesMinAggregateInputType = {
    id?: true
    userId?: true
    transactionTypeId?: true
    sourceVaultId?: true
    targetVaultId?: true
    targetWithdrawalAddressId?: true
    toOneTimeAddresses?: true
    greaterThanUSD?: true
    assetId?: true
    action?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionPoliciesMaxAggregateInputType = {
    id?: true
    userId?: true
    transactionTypeId?: true
    sourceVaultId?: true
    targetVaultId?: true
    targetWithdrawalAddressId?: true
    toOneTimeAddresses?: true
    greaterThanUSD?: true
    assetId?: true
    action?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionPoliciesCountAggregateInputType = {
    id?: true
    userId?: true
    transactionTypeId?: true
    sourceVaultId?: true
    targetVaultId?: true
    targetWithdrawalAddressId?: true
    toOneTimeAddresses?: true
    greaterThanUSD?: true
    assetId?: true
    action?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionPoliciesAggregateArgs = {
    /**
     * Filter which transactionPolicies to aggregate.
     */
    where?: transactionPoliciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactionPolicies to fetch.
     */
    orderBy?: Enumerable<transactionPoliciesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transactionPoliciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactionPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactionPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transactionPolicies
    **/
    _count?: true | TransactionPoliciesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionPoliciesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionPoliciesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionPoliciesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionPoliciesMaxAggregateInputType
  }

  export type GetTransactionPoliciesAggregateType<T extends TransactionPoliciesAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionPolicies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionPolicies[P]>
      : GetScalarType<T[P], AggregateTransactionPolicies[P]>
  }




  export type TransactionPoliciesGroupByArgs = {
    where?: transactionPoliciesWhereInput
    orderBy?: Enumerable<transactionPoliciesOrderByWithAggregationInput>
    by: TransactionPoliciesScalarFieldEnum[]
    having?: transactionPoliciesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionPoliciesCountAggregateInputType | true
    _avg?: TransactionPoliciesAvgAggregateInputType
    _sum?: TransactionPoliciesSumAggregateInputType
    _min?: TransactionPoliciesMinAggregateInputType
    _max?: TransactionPoliciesMaxAggregateInputType
  }


  export type TransactionPoliciesGroupByOutputType = {
    id: string
    userId: string
    transactionTypeId: number
    sourceVaultId: string
    targetVaultId: string | null
    targetWithdrawalAddressId: string | null
    toOneTimeAddresses: boolean | null
    greaterThanUSD: string
    assetId: number
    action: enum_transactionPolicies_action
    createdAt: Date
    updatedAt: Date
    _count: TransactionPoliciesCountAggregateOutputType | null
    _avg: TransactionPoliciesAvgAggregateOutputType | null
    _sum: TransactionPoliciesSumAggregateOutputType | null
    _min: TransactionPoliciesMinAggregateOutputType | null
    _max: TransactionPoliciesMaxAggregateOutputType | null
  }

  type GetTransactionPoliciesGroupByPayload<T extends TransactionPoliciesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TransactionPoliciesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionPoliciesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionPoliciesGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionPoliciesGroupByOutputType[P]>
        }
      >
    >


  export type transactionPoliciesSelect = {
    id?: boolean
    userId?: boolean
    transactionTypeId?: boolean
    sourceVaultId?: boolean
    targetVaultId?: boolean
    targetWithdrawalAddressId?: boolean
    toOneTimeAddresses?: boolean
    greaterThanUSD?: boolean
    assetId?: boolean
    action?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assets?: boolean | assetsArgs
    vaults_transactionPolicies_sourceVaultIdTovaults?: boolean | vaultsArgs
    vaults_transactionPolicies_targetVaultIdTovaults?: boolean | vaultsArgs
    withdrawalAddresses?: boolean | withdrawalAddressesArgs
    transactionTypes?: boolean | transactionTypesArgs
    users?: boolean | usersArgs
  }


  export type transactionPoliciesInclude = {
    assets?: boolean | assetsArgs
    vaults_transactionPolicies_sourceVaultIdTovaults?: boolean | vaultsArgs
    vaults_transactionPolicies_targetVaultIdTovaults?: boolean | vaultsArgs
    withdrawalAddresses?: boolean | withdrawalAddressesArgs
    transactionTypes?: boolean | transactionTypesArgs
    users?: boolean | usersArgs
  }

  export type transactionPoliciesGetPayload<S extends boolean | null | undefined | transactionPoliciesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? transactionPolicies :
    S extends undefined ? never :
    S extends { include: any } & (transactionPoliciesArgs | transactionPoliciesFindManyArgs)
    ? transactionPolicies  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'assets' ? assetsGetPayload<S['include'][P]> :
        P extends 'vaults_transactionPolicies_sourceVaultIdTovaults' ? vaultsGetPayload<S['include'][P]> :
        P extends 'vaults_transactionPolicies_targetVaultIdTovaults' ? vaultsGetPayload<S['include'][P]> | null :
        P extends 'withdrawalAddresses' ? withdrawalAddressesGetPayload<S['include'][P]> | null :
        P extends 'transactionTypes' ? transactionTypesGetPayload<S['include'][P]> :
        P extends 'users' ? usersGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (transactionPoliciesArgs | transactionPoliciesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'assets' ? assetsGetPayload<S['select'][P]> :
        P extends 'vaults_transactionPolicies_sourceVaultIdTovaults' ? vaultsGetPayload<S['select'][P]> :
        P extends 'vaults_transactionPolicies_targetVaultIdTovaults' ? vaultsGetPayload<S['select'][P]> | null :
        P extends 'withdrawalAddresses' ? withdrawalAddressesGetPayload<S['select'][P]> | null :
        P extends 'transactionTypes' ? transactionTypesGetPayload<S['select'][P]> :
        P extends 'users' ? usersGetPayload<S['select'][P]> :  P extends keyof transactionPolicies ? transactionPolicies[P] : never
  } 
      : transactionPolicies


  type transactionPoliciesCountArgs = 
    Omit<transactionPoliciesFindManyArgs, 'select' | 'include'> & {
      select?: TransactionPoliciesCountAggregateInputType | true
    }

  export interface transactionPoliciesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TransactionPolicies that matches the filter.
     * @param {transactionPoliciesFindUniqueArgs} args - Arguments to find a TransactionPolicies
     * @example
     * // Get one TransactionPolicies
     * const transactionPolicies = await prisma.transactionPolicies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends transactionPoliciesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, transactionPoliciesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'transactionPolicies'> extends True ? Prisma__transactionPoliciesClient<transactionPoliciesGetPayload<T>> : Prisma__transactionPoliciesClient<transactionPoliciesGetPayload<T> | null, null>

    /**
     * Find one TransactionPolicies that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {transactionPoliciesFindUniqueOrThrowArgs} args - Arguments to find a TransactionPolicies
     * @example
     * // Get one TransactionPolicies
     * const transactionPolicies = await prisma.transactionPolicies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends transactionPoliciesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, transactionPoliciesFindUniqueOrThrowArgs>
    ): Prisma__transactionPoliciesClient<transactionPoliciesGetPayload<T>>

    /**
     * Find the first TransactionPolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionPoliciesFindFirstArgs} args - Arguments to find a TransactionPolicies
     * @example
     * // Get one TransactionPolicies
     * const transactionPolicies = await prisma.transactionPolicies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends transactionPoliciesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, transactionPoliciesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'transactionPolicies'> extends True ? Prisma__transactionPoliciesClient<transactionPoliciesGetPayload<T>> : Prisma__transactionPoliciesClient<transactionPoliciesGetPayload<T> | null, null>

    /**
     * Find the first TransactionPolicies that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionPoliciesFindFirstOrThrowArgs} args - Arguments to find a TransactionPolicies
     * @example
     * // Get one TransactionPolicies
     * const transactionPolicies = await prisma.transactionPolicies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends transactionPoliciesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, transactionPoliciesFindFirstOrThrowArgs>
    ): Prisma__transactionPoliciesClient<transactionPoliciesGetPayload<T>>

    /**
     * Find zero or more TransactionPolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionPoliciesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionPolicies
     * const transactionPolicies = await prisma.transactionPolicies.findMany()
     * 
     * // Get first 10 TransactionPolicies
     * const transactionPolicies = await prisma.transactionPolicies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionPoliciesWithIdOnly = await prisma.transactionPolicies.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends transactionPoliciesFindManyArgs>(
      args?: SelectSubset<T, transactionPoliciesFindManyArgs>
    ): PrismaPromise<Array<transactionPoliciesGetPayload<T>>>

    /**
     * Create a TransactionPolicies.
     * @param {transactionPoliciesCreateArgs} args - Arguments to create a TransactionPolicies.
     * @example
     * // Create one TransactionPolicies
     * const TransactionPolicies = await prisma.transactionPolicies.create({
     *   data: {
     *     // ... data to create a TransactionPolicies
     *   }
     * })
     * 
    **/
    create<T extends transactionPoliciesCreateArgs>(
      args: SelectSubset<T, transactionPoliciesCreateArgs>
    ): Prisma__transactionPoliciesClient<transactionPoliciesGetPayload<T>>

    /**
     * Create many TransactionPolicies.
     *     @param {transactionPoliciesCreateManyArgs} args - Arguments to create many TransactionPolicies.
     *     @example
     *     // Create many TransactionPolicies
     *     const transactionPolicies = await prisma.transactionPolicies.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends transactionPoliciesCreateManyArgs>(
      args?: SelectSubset<T, transactionPoliciesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TransactionPolicies.
     * @param {transactionPoliciesDeleteArgs} args - Arguments to delete one TransactionPolicies.
     * @example
     * // Delete one TransactionPolicies
     * const TransactionPolicies = await prisma.transactionPolicies.delete({
     *   where: {
     *     // ... filter to delete one TransactionPolicies
     *   }
     * })
     * 
    **/
    delete<T extends transactionPoliciesDeleteArgs>(
      args: SelectSubset<T, transactionPoliciesDeleteArgs>
    ): Prisma__transactionPoliciesClient<transactionPoliciesGetPayload<T>>

    /**
     * Update one TransactionPolicies.
     * @param {transactionPoliciesUpdateArgs} args - Arguments to update one TransactionPolicies.
     * @example
     * // Update one TransactionPolicies
     * const transactionPolicies = await prisma.transactionPolicies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends transactionPoliciesUpdateArgs>(
      args: SelectSubset<T, transactionPoliciesUpdateArgs>
    ): Prisma__transactionPoliciesClient<transactionPoliciesGetPayload<T>>

    /**
     * Delete zero or more TransactionPolicies.
     * @param {transactionPoliciesDeleteManyArgs} args - Arguments to filter TransactionPolicies to delete.
     * @example
     * // Delete a few TransactionPolicies
     * const { count } = await prisma.transactionPolicies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends transactionPoliciesDeleteManyArgs>(
      args?: SelectSubset<T, transactionPoliciesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionPoliciesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionPolicies
     * const transactionPolicies = await prisma.transactionPolicies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends transactionPoliciesUpdateManyArgs>(
      args: SelectSubset<T, transactionPoliciesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TransactionPolicies.
     * @param {transactionPoliciesUpsertArgs} args - Arguments to update or create a TransactionPolicies.
     * @example
     * // Update or create a TransactionPolicies
     * const transactionPolicies = await prisma.transactionPolicies.upsert({
     *   create: {
     *     // ... data to create a TransactionPolicies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionPolicies we want to update
     *   }
     * })
    **/
    upsert<T extends transactionPoliciesUpsertArgs>(
      args: SelectSubset<T, transactionPoliciesUpsertArgs>
    ): Prisma__transactionPoliciesClient<transactionPoliciesGetPayload<T>>

    /**
     * Count the number of TransactionPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionPoliciesCountArgs} args - Arguments to filter TransactionPolicies to count.
     * @example
     * // Count the number of TransactionPolicies
     * const count = await prisma.transactionPolicies.count({
     *   where: {
     *     // ... the filter for the TransactionPolicies we want to count
     *   }
     * })
    **/
    count<T extends transactionPoliciesCountArgs>(
      args?: Subset<T, transactionPoliciesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionPoliciesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionPoliciesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionPoliciesAggregateArgs>(args: Subset<T, TransactionPoliciesAggregateArgs>): PrismaPromise<GetTransactionPoliciesAggregateType<T>>

    /**
     * Group by TransactionPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionPoliciesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionPoliciesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionPoliciesGroupByArgs['orderBy'] }
        : { orderBy?: TransactionPoliciesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionPoliciesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionPoliciesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for transactionPolicies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__transactionPoliciesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    assets<T extends assetsArgs= {}>(args?: Subset<T, assetsArgs>): Prisma__assetsClient<assetsGetPayload<T> | Null>;

    vaults_transactionPolicies_sourceVaultIdTovaults<T extends vaultsArgs= {}>(args?: Subset<T, vaultsArgs>): Prisma__vaultsClient<vaultsGetPayload<T> | Null>;

    vaults_transactionPolicies_targetVaultIdTovaults<T extends vaultsArgs= {}>(args?: Subset<T, vaultsArgs>): Prisma__vaultsClient<vaultsGetPayload<T> | Null>;

    withdrawalAddresses<T extends withdrawalAddressesArgs= {}>(args?: Subset<T, withdrawalAddressesArgs>): Prisma__withdrawalAddressesClient<withdrawalAddressesGetPayload<T> | Null>;

    transactionTypes<T extends transactionTypesArgs= {}>(args?: Subset<T, transactionTypesArgs>): Prisma__transactionTypesClient<transactionTypesGetPayload<T> | Null>;

    users<T extends usersArgs= {}>(args?: Subset<T, usersArgs>): Prisma__usersClient<usersGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * transactionPolicies base type for findUnique actions
   */
  export type transactionPoliciesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the transactionPolicies
     */
    select?: transactionPoliciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionPoliciesInclude | null
    /**
     * Filter, which transactionPolicies to fetch.
     */
    where: transactionPoliciesWhereUniqueInput
  }

  /**
   * transactionPolicies findUnique
   */
  export interface transactionPoliciesFindUniqueArgs extends transactionPoliciesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * transactionPolicies findUniqueOrThrow
   */
  export type transactionPoliciesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the transactionPolicies
     */
    select?: transactionPoliciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionPoliciesInclude | null
    /**
     * Filter, which transactionPolicies to fetch.
     */
    where: transactionPoliciesWhereUniqueInput
  }


  /**
   * transactionPolicies base type for findFirst actions
   */
  export type transactionPoliciesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the transactionPolicies
     */
    select?: transactionPoliciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionPoliciesInclude | null
    /**
     * Filter, which transactionPolicies to fetch.
     */
    where?: transactionPoliciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactionPolicies to fetch.
     */
    orderBy?: Enumerable<transactionPoliciesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactionPolicies.
     */
    cursor?: transactionPoliciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactionPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactionPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactionPolicies.
     */
    distinct?: Enumerable<TransactionPoliciesScalarFieldEnum>
  }

  /**
   * transactionPolicies findFirst
   */
  export interface transactionPoliciesFindFirstArgs extends transactionPoliciesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * transactionPolicies findFirstOrThrow
   */
  export type transactionPoliciesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the transactionPolicies
     */
    select?: transactionPoliciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionPoliciesInclude | null
    /**
     * Filter, which transactionPolicies to fetch.
     */
    where?: transactionPoliciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactionPolicies to fetch.
     */
    orderBy?: Enumerable<transactionPoliciesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactionPolicies.
     */
    cursor?: transactionPoliciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactionPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactionPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactionPolicies.
     */
    distinct?: Enumerable<TransactionPoliciesScalarFieldEnum>
  }


  /**
   * transactionPolicies findMany
   */
  export type transactionPoliciesFindManyArgs = {
    /**
     * Select specific fields to fetch from the transactionPolicies
     */
    select?: transactionPoliciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionPoliciesInclude | null
    /**
     * Filter, which transactionPolicies to fetch.
     */
    where?: transactionPoliciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactionPolicies to fetch.
     */
    orderBy?: Enumerable<transactionPoliciesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transactionPolicies.
     */
    cursor?: transactionPoliciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactionPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactionPolicies.
     */
    skip?: number
    distinct?: Enumerable<TransactionPoliciesScalarFieldEnum>
  }


  /**
   * transactionPolicies create
   */
  export type transactionPoliciesCreateArgs = {
    /**
     * Select specific fields to fetch from the transactionPolicies
     */
    select?: transactionPoliciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionPoliciesInclude | null
    /**
     * The data needed to create a transactionPolicies.
     */
    data: XOR<transactionPoliciesCreateInput, transactionPoliciesUncheckedCreateInput>
  }


  /**
   * transactionPolicies createMany
   */
  export type transactionPoliciesCreateManyArgs = {
    /**
     * The data used to create many transactionPolicies.
     */
    data: Enumerable<transactionPoliciesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * transactionPolicies update
   */
  export type transactionPoliciesUpdateArgs = {
    /**
     * Select specific fields to fetch from the transactionPolicies
     */
    select?: transactionPoliciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionPoliciesInclude | null
    /**
     * The data needed to update a transactionPolicies.
     */
    data: XOR<transactionPoliciesUpdateInput, transactionPoliciesUncheckedUpdateInput>
    /**
     * Choose, which transactionPolicies to update.
     */
    where: transactionPoliciesWhereUniqueInput
  }


  /**
   * transactionPolicies updateMany
   */
  export type transactionPoliciesUpdateManyArgs = {
    /**
     * The data used to update transactionPolicies.
     */
    data: XOR<transactionPoliciesUpdateManyMutationInput, transactionPoliciesUncheckedUpdateManyInput>
    /**
     * Filter which transactionPolicies to update
     */
    where?: transactionPoliciesWhereInput
  }


  /**
   * transactionPolicies upsert
   */
  export type transactionPoliciesUpsertArgs = {
    /**
     * Select specific fields to fetch from the transactionPolicies
     */
    select?: transactionPoliciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionPoliciesInclude | null
    /**
     * The filter to search for the transactionPolicies to update in case it exists.
     */
    where: transactionPoliciesWhereUniqueInput
    /**
     * In case the transactionPolicies found by the `where` argument doesn't exist, create a new transactionPolicies with this data.
     */
    create: XOR<transactionPoliciesCreateInput, transactionPoliciesUncheckedCreateInput>
    /**
     * In case the transactionPolicies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transactionPoliciesUpdateInput, transactionPoliciesUncheckedUpdateInput>
  }


  /**
   * transactionPolicies delete
   */
  export type transactionPoliciesDeleteArgs = {
    /**
     * Select specific fields to fetch from the transactionPolicies
     */
    select?: transactionPoliciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionPoliciesInclude | null
    /**
     * Filter which transactionPolicies to delete.
     */
    where: transactionPoliciesWhereUniqueInput
  }


  /**
   * transactionPolicies deleteMany
   */
  export type transactionPoliciesDeleteManyArgs = {
    /**
     * Filter which transactionPolicies to delete
     */
    where?: transactionPoliciesWhereInput
  }


  /**
   * transactionPolicies without action
   */
  export type transactionPoliciesArgs = {
    /**
     * Select specific fields to fetch from the transactionPolicies
     */
    select?: transactionPoliciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionPoliciesInclude | null
  }



  /**
   * Model userTypes
   */


  export type AggregateUserTypes = {
    _count: UserTypesCountAggregateOutputType | null
    _avg: UserTypesAvgAggregateOutputType | null
    _sum: UserTypesSumAggregateOutputType | null
    _min: UserTypesMinAggregateOutputType | null
    _max: UserTypesMaxAggregateOutputType | null
  }

  export type UserTypesAvgAggregateOutputType = {
    id: number | null
  }

  export type UserTypesSumAggregateOutputType = {
    id: number | null
  }

  export type UserTypesMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isServiceAccount: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserTypesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    isServiceAccount: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserTypesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    claims: number
    isServiceAccount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserTypesAvgAggregateInputType = {
    id?: true
  }

  export type UserTypesSumAggregateInputType = {
    id?: true
  }

  export type UserTypesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isServiceAccount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserTypesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isServiceAccount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserTypesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    claims?: true
    isServiceAccount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserTypesAggregateArgs = {
    /**
     * Filter which userTypes to aggregate.
     */
    where?: userTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userTypes to fetch.
     */
    orderBy?: Enumerable<userTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userTypes
    **/
    _count?: true | UserTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTypesMaxAggregateInputType
  }

  export type GetUserTypesAggregateType<T extends UserTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTypes[P]>
      : GetScalarType<T[P], AggregateUserTypes[P]>
  }




  export type UserTypesGroupByArgs = {
    where?: userTypesWhereInput
    orderBy?: Enumerable<userTypesOrderByWithAggregationInput>
    by: UserTypesScalarFieldEnum[]
    having?: userTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTypesCountAggregateInputType | true
    _avg?: UserTypesAvgAggregateInputType
    _sum?: UserTypesSumAggregateInputType
    _min?: UserTypesMinAggregateInputType
    _max?: UserTypesMaxAggregateInputType
  }


  export type UserTypesGroupByOutputType = {
    id: number
    name: string
    description: string
    claims: JsonValue
    isServiceAccount: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserTypesCountAggregateOutputType | null
    _avg: UserTypesAvgAggregateOutputType | null
    _sum: UserTypesSumAggregateOutputType | null
    _min: UserTypesMinAggregateOutputType | null
    _max: UserTypesMaxAggregateOutputType | null
  }

  type GetUserTypesGroupByPayload<T extends UserTypesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTypesGroupByOutputType[P]>
            : GetScalarType<T[P], UserTypesGroupByOutputType[P]>
        }
      >
    >


  export type userTypesSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    claims?: boolean
    isServiceAccount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | userTypes$usersArgs
    _count?: boolean | UserTypesCountOutputTypeArgs
  }


  export type userTypesInclude = {
    users?: boolean | userTypes$usersArgs
    _count?: boolean | UserTypesCountOutputTypeArgs
  }

  export type userTypesGetPayload<S extends boolean | null | undefined | userTypesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? userTypes :
    S extends undefined ? never :
    S extends { include: any } & (userTypesArgs | userTypesFindManyArgs)
    ? userTypes  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'users' ? Array < usersGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserTypesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (userTypesArgs | userTypesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'users' ? Array < usersGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserTypesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof userTypes ? userTypes[P] : never
  } 
      : userTypes


  type userTypesCountArgs = 
    Omit<userTypesFindManyArgs, 'select' | 'include'> & {
      select?: UserTypesCountAggregateInputType | true
    }

  export interface userTypesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UserTypes that matches the filter.
     * @param {userTypesFindUniqueArgs} args - Arguments to find a UserTypes
     * @example
     * // Get one UserTypes
     * const userTypes = await prisma.userTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userTypesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, userTypesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'userTypes'> extends True ? Prisma__userTypesClient<userTypesGetPayload<T>> : Prisma__userTypesClient<userTypesGetPayload<T> | null, null>

    /**
     * Find one UserTypes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {userTypesFindUniqueOrThrowArgs} args - Arguments to find a UserTypes
     * @example
     * // Get one UserTypes
     * const userTypes = await prisma.userTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends userTypesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, userTypesFindUniqueOrThrowArgs>
    ): Prisma__userTypesClient<userTypesGetPayload<T>>

    /**
     * Find the first UserTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userTypesFindFirstArgs} args - Arguments to find a UserTypes
     * @example
     * // Get one UserTypes
     * const userTypes = await prisma.userTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userTypesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, userTypesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'userTypes'> extends True ? Prisma__userTypesClient<userTypesGetPayload<T>> : Prisma__userTypesClient<userTypesGetPayload<T> | null, null>

    /**
     * Find the first UserTypes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userTypesFindFirstOrThrowArgs} args - Arguments to find a UserTypes
     * @example
     * // Get one UserTypes
     * const userTypes = await prisma.userTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends userTypesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, userTypesFindFirstOrThrowArgs>
    ): Prisma__userTypesClient<userTypesGetPayload<T>>

    /**
     * Find zero or more UserTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTypes
     * const userTypes = await prisma.userTypes.findMany()
     * 
     * // Get first 10 UserTypes
     * const userTypes = await prisma.userTypes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userTypesWithIdOnly = await prisma.userTypes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends userTypesFindManyArgs>(
      args?: SelectSubset<T, userTypesFindManyArgs>
    ): PrismaPromise<Array<userTypesGetPayload<T>>>

    /**
     * Create a UserTypes.
     * @param {userTypesCreateArgs} args - Arguments to create a UserTypes.
     * @example
     * // Create one UserTypes
     * const UserTypes = await prisma.userTypes.create({
     *   data: {
     *     // ... data to create a UserTypes
     *   }
     * })
     * 
    **/
    create<T extends userTypesCreateArgs>(
      args: SelectSubset<T, userTypesCreateArgs>
    ): Prisma__userTypesClient<userTypesGetPayload<T>>

    /**
     * Create many UserTypes.
     *     @param {userTypesCreateManyArgs} args - Arguments to create many UserTypes.
     *     @example
     *     // Create many UserTypes
     *     const userTypes = await prisma.userTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userTypesCreateManyArgs>(
      args?: SelectSubset<T, userTypesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a UserTypes.
     * @param {userTypesDeleteArgs} args - Arguments to delete one UserTypes.
     * @example
     * // Delete one UserTypes
     * const UserTypes = await prisma.userTypes.delete({
     *   where: {
     *     // ... filter to delete one UserTypes
     *   }
     * })
     * 
    **/
    delete<T extends userTypesDeleteArgs>(
      args: SelectSubset<T, userTypesDeleteArgs>
    ): Prisma__userTypesClient<userTypesGetPayload<T>>

    /**
     * Update one UserTypes.
     * @param {userTypesUpdateArgs} args - Arguments to update one UserTypes.
     * @example
     * // Update one UserTypes
     * const userTypes = await prisma.userTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userTypesUpdateArgs>(
      args: SelectSubset<T, userTypesUpdateArgs>
    ): Prisma__userTypesClient<userTypesGetPayload<T>>

    /**
     * Delete zero or more UserTypes.
     * @param {userTypesDeleteManyArgs} args - Arguments to filter UserTypes to delete.
     * @example
     * // Delete a few UserTypes
     * const { count } = await prisma.userTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userTypesDeleteManyArgs>(
      args?: SelectSubset<T, userTypesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTypes
     * const userTypes = await prisma.userTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userTypesUpdateManyArgs>(
      args: SelectSubset<T, userTypesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UserTypes.
     * @param {userTypesUpsertArgs} args - Arguments to update or create a UserTypes.
     * @example
     * // Update or create a UserTypes
     * const userTypes = await prisma.userTypes.upsert({
     *   create: {
     *     // ... data to create a UserTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTypes we want to update
     *   }
     * })
    **/
    upsert<T extends userTypesUpsertArgs>(
      args: SelectSubset<T, userTypesUpsertArgs>
    ): Prisma__userTypesClient<userTypesGetPayload<T>>

    /**
     * Count the number of UserTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userTypesCountArgs} args - Arguments to filter UserTypes to count.
     * @example
     * // Count the number of UserTypes
     * const count = await prisma.userTypes.count({
     *   where: {
     *     // ... the filter for the UserTypes we want to count
     *   }
     * })
    **/
    count<T extends userTypesCountArgs>(
      args?: Subset<T, userTypesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTypesAggregateArgs>(args: Subset<T, UserTypesAggregateArgs>): PrismaPromise<GetUserTypesAggregateType<T>>

    /**
     * Group by UserTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTypesGroupByArgs['orderBy'] }
        : { orderBy?: UserTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTypesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for userTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__userTypesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users<T extends userTypes$usersArgs= {}>(args?: Subset<T, userTypes$usersArgs>): PrismaPromise<Array<usersGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * userTypes base type for findUnique actions
   */
  export type userTypesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the userTypes
     */
    select?: userTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userTypesInclude | null
    /**
     * Filter, which userTypes to fetch.
     */
    where: userTypesWhereUniqueInput
  }

  /**
   * userTypes findUnique
   */
  export interface userTypesFindUniqueArgs extends userTypesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * userTypes findUniqueOrThrow
   */
  export type userTypesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the userTypes
     */
    select?: userTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userTypesInclude | null
    /**
     * Filter, which userTypes to fetch.
     */
    where: userTypesWhereUniqueInput
  }


  /**
   * userTypes base type for findFirst actions
   */
  export type userTypesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the userTypes
     */
    select?: userTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userTypesInclude | null
    /**
     * Filter, which userTypes to fetch.
     */
    where?: userTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userTypes to fetch.
     */
    orderBy?: Enumerable<userTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userTypes.
     */
    cursor?: userTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userTypes.
     */
    distinct?: Enumerable<UserTypesScalarFieldEnum>
  }

  /**
   * userTypes findFirst
   */
  export interface userTypesFindFirstArgs extends userTypesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * userTypes findFirstOrThrow
   */
  export type userTypesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the userTypes
     */
    select?: userTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userTypesInclude | null
    /**
     * Filter, which userTypes to fetch.
     */
    where?: userTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userTypes to fetch.
     */
    orderBy?: Enumerable<userTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userTypes.
     */
    cursor?: userTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userTypes.
     */
    distinct?: Enumerable<UserTypesScalarFieldEnum>
  }


  /**
   * userTypes findMany
   */
  export type userTypesFindManyArgs = {
    /**
     * Select specific fields to fetch from the userTypes
     */
    select?: userTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userTypesInclude | null
    /**
     * Filter, which userTypes to fetch.
     */
    where?: userTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userTypes to fetch.
     */
    orderBy?: Enumerable<userTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userTypes.
     */
    cursor?: userTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userTypes.
     */
    skip?: number
    distinct?: Enumerable<UserTypesScalarFieldEnum>
  }


  /**
   * userTypes create
   */
  export type userTypesCreateArgs = {
    /**
     * Select specific fields to fetch from the userTypes
     */
    select?: userTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userTypesInclude | null
    /**
     * The data needed to create a userTypes.
     */
    data: XOR<userTypesCreateInput, userTypesUncheckedCreateInput>
  }


  /**
   * userTypes createMany
   */
  export type userTypesCreateManyArgs = {
    /**
     * The data used to create many userTypes.
     */
    data: Enumerable<userTypesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * userTypes update
   */
  export type userTypesUpdateArgs = {
    /**
     * Select specific fields to fetch from the userTypes
     */
    select?: userTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userTypesInclude | null
    /**
     * The data needed to update a userTypes.
     */
    data: XOR<userTypesUpdateInput, userTypesUncheckedUpdateInput>
    /**
     * Choose, which userTypes to update.
     */
    where: userTypesWhereUniqueInput
  }


  /**
   * userTypes updateMany
   */
  export type userTypesUpdateManyArgs = {
    /**
     * The data used to update userTypes.
     */
    data: XOR<userTypesUpdateManyMutationInput, userTypesUncheckedUpdateManyInput>
    /**
     * Filter which userTypes to update
     */
    where?: userTypesWhereInput
  }


  /**
   * userTypes upsert
   */
  export type userTypesUpsertArgs = {
    /**
     * Select specific fields to fetch from the userTypes
     */
    select?: userTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userTypesInclude | null
    /**
     * The filter to search for the userTypes to update in case it exists.
     */
    where: userTypesWhereUniqueInput
    /**
     * In case the userTypes found by the `where` argument doesn't exist, create a new userTypes with this data.
     */
    create: XOR<userTypesCreateInput, userTypesUncheckedCreateInput>
    /**
     * In case the userTypes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userTypesUpdateInput, userTypesUncheckedUpdateInput>
  }


  /**
   * userTypes delete
   */
  export type userTypesDeleteArgs = {
    /**
     * Select specific fields to fetch from the userTypes
     */
    select?: userTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userTypesInclude | null
    /**
     * Filter which userTypes to delete.
     */
    where: userTypesWhereUniqueInput
  }


  /**
   * userTypes deleteMany
   */
  export type userTypesDeleteManyArgs = {
    /**
     * Filter which userTypes to delete
     */
    where?: userTypesWhereInput
  }


  /**
   * userTypes.users
   */
  export type userTypes$usersArgs = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude | null
    where?: usersWhereInput
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * userTypes without action
   */
  export type userTypesArgs = {
    /**
     * Select specific fields to fetch from the userTypes
     */
    select?: userTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userTypesInclude | null
  }



  /**
   * Model vaultAssets
   */


  export type AggregateVaultAssets = {
    _count: VaultAssetsCountAggregateOutputType | null
    _avg: VaultAssetsAvgAggregateOutputType | null
    _sum: VaultAssetsSumAggregateOutputType | null
    _min: VaultAssetsMinAggregateOutputType | null
    _max: VaultAssetsMaxAggregateOutputType | null
  }

  export type VaultAssetsAvgAggregateOutputType = {
    id: number | null
    assetId: number | null
  }

  export type VaultAssetsSumAggregateOutputType = {
    id: number | null
    assetId: number | null
  }

  export type VaultAssetsMinAggregateOutputType = {
    id: number | null
    vaultId: string | null
    assetId: number | null
    balance: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VaultAssetsMaxAggregateOutputType = {
    id: number | null
    vaultId: string | null
    assetId: number | null
    balance: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VaultAssetsCountAggregateOutputType = {
    id: number
    vaultId: number
    assetId: number
    balance: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VaultAssetsAvgAggregateInputType = {
    id?: true
    assetId?: true
  }

  export type VaultAssetsSumAggregateInputType = {
    id?: true
    assetId?: true
  }

  export type VaultAssetsMinAggregateInputType = {
    id?: true
    vaultId?: true
    assetId?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VaultAssetsMaxAggregateInputType = {
    id?: true
    vaultId?: true
    assetId?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VaultAssetsCountAggregateInputType = {
    id?: true
    vaultId?: true
    assetId?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VaultAssetsAggregateArgs = {
    /**
     * Filter which vaultAssets to aggregate.
     */
    where?: vaultAssetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vaultAssets to fetch.
     */
    orderBy?: Enumerable<vaultAssetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vaultAssetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vaultAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vaultAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vaultAssets
    **/
    _count?: true | VaultAssetsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VaultAssetsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VaultAssetsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VaultAssetsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VaultAssetsMaxAggregateInputType
  }

  export type GetVaultAssetsAggregateType<T extends VaultAssetsAggregateArgs> = {
        [P in keyof T & keyof AggregateVaultAssets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVaultAssets[P]>
      : GetScalarType<T[P], AggregateVaultAssets[P]>
  }




  export type VaultAssetsGroupByArgs = {
    where?: vaultAssetsWhereInput
    orderBy?: Enumerable<vaultAssetsOrderByWithAggregationInput>
    by: VaultAssetsScalarFieldEnum[]
    having?: vaultAssetsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VaultAssetsCountAggregateInputType | true
    _avg?: VaultAssetsAvgAggregateInputType
    _sum?: VaultAssetsSumAggregateInputType
    _min?: VaultAssetsMinAggregateInputType
    _max?: VaultAssetsMaxAggregateInputType
  }


  export type VaultAssetsGroupByOutputType = {
    id: number
    vaultId: string
    assetId: number
    balance: string
    createdAt: Date
    updatedAt: Date
    _count: VaultAssetsCountAggregateOutputType | null
    _avg: VaultAssetsAvgAggregateOutputType | null
    _sum: VaultAssetsSumAggregateOutputType | null
    _min: VaultAssetsMinAggregateOutputType | null
    _max: VaultAssetsMaxAggregateOutputType | null
  }

  type GetVaultAssetsGroupByPayload<T extends VaultAssetsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VaultAssetsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VaultAssetsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VaultAssetsGroupByOutputType[P]>
            : GetScalarType<T[P], VaultAssetsGroupByOutputType[P]>
        }
      >
    >


  export type vaultAssetsSelect = {
    id?: boolean
    vaultId?: boolean
    assetId?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    custodyVendorVaultAssets?: boolean | vaultAssets$custodyVendorVaultAssetsArgs
    depositAddresses?: boolean | vaultAssets$depositAddressesArgs
    assets?: boolean | assetsArgs
    vaults?: boolean | vaultsArgs
    _count?: boolean | VaultAssetsCountOutputTypeArgs
  }


  export type vaultAssetsInclude = {
    custodyVendorVaultAssets?: boolean | vaultAssets$custodyVendorVaultAssetsArgs
    depositAddresses?: boolean | vaultAssets$depositAddressesArgs
    assets?: boolean | assetsArgs
    vaults?: boolean | vaultsArgs
    _count?: boolean | VaultAssetsCountOutputTypeArgs
  }

  export type vaultAssetsGetPayload<S extends boolean | null | undefined | vaultAssetsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? vaultAssets :
    S extends undefined ? never :
    S extends { include: any } & (vaultAssetsArgs | vaultAssetsFindManyArgs)
    ? vaultAssets  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'custodyVendorVaultAssets' ? Array < custodyVendorVaultAssetsGetPayload<S['include'][P]>>  :
        P extends 'depositAddresses' ? Array < depositAddressesGetPayload<S['include'][P]>>  :
        P extends 'assets' ? assetsGetPayload<S['include'][P]> :
        P extends 'vaults' ? vaultsGetPayload<S['include'][P]> :
        P extends '_count' ? VaultAssetsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (vaultAssetsArgs | vaultAssetsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'custodyVendorVaultAssets' ? Array < custodyVendorVaultAssetsGetPayload<S['select'][P]>>  :
        P extends 'depositAddresses' ? Array < depositAddressesGetPayload<S['select'][P]>>  :
        P extends 'assets' ? assetsGetPayload<S['select'][P]> :
        P extends 'vaults' ? vaultsGetPayload<S['select'][P]> :
        P extends '_count' ? VaultAssetsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof vaultAssets ? vaultAssets[P] : never
  } 
      : vaultAssets


  type vaultAssetsCountArgs = 
    Omit<vaultAssetsFindManyArgs, 'select' | 'include'> & {
      select?: VaultAssetsCountAggregateInputType | true
    }

  export interface vaultAssetsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one VaultAssets that matches the filter.
     * @param {vaultAssetsFindUniqueArgs} args - Arguments to find a VaultAssets
     * @example
     * // Get one VaultAssets
     * const vaultAssets = await prisma.vaultAssets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends vaultAssetsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, vaultAssetsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'vaultAssets'> extends True ? Prisma__vaultAssetsClient<vaultAssetsGetPayload<T>> : Prisma__vaultAssetsClient<vaultAssetsGetPayload<T> | null, null>

    /**
     * Find one VaultAssets that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {vaultAssetsFindUniqueOrThrowArgs} args - Arguments to find a VaultAssets
     * @example
     * // Get one VaultAssets
     * const vaultAssets = await prisma.vaultAssets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends vaultAssetsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, vaultAssetsFindUniqueOrThrowArgs>
    ): Prisma__vaultAssetsClient<vaultAssetsGetPayload<T>>

    /**
     * Find the first VaultAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vaultAssetsFindFirstArgs} args - Arguments to find a VaultAssets
     * @example
     * // Get one VaultAssets
     * const vaultAssets = await prisma.vaultAssets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends vaultAssetsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, vaultAssetsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'vaultAssets'> extends True ? Prisma__vaultAssetsClient<vaultAssetsGetPayload<T>> : Prisma__vaultAssetsClient<vaultAssetsGetPayload<T> | null, null>

    /**
     * Find the first VaultAssets that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vaultAssetsFindFirstOrThrowArgs} args - Arguments to find a VaultAssets
     * @example
     * // Get one VaultAssets
     * const vaultAssets = await prisma.vaultAssets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends vaultAssetsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, vaultAssetsFindFirstOrThrowArgs>
    ): Prisma__vaultAssetsClient<vaultAssetsGetPayload<T>>

    /**
     * Find zero or more VaultAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vaultAssetsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VaultAssets
     * const vaultAssets = await prisma.vaultAssets.findMany()
     * 
     * // Get first 10 VaultAssets
     * const vaultAssets = await prisma.vaultAssets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vaultAssetsWithIdOnly = await prisma.vaultAssets.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends vaultAssetsFindManyArgs>(
      args?: SelectSubset<T, vaultAssetsFindManyArgs>
    ): PrismaPromise<Array<vaultAssetsGetPayload<T>>>

    /**
     * Create a VaultAssets.
     * @param {vaultAssetsCreateArgs} args - Arguments to create a VaultAssets.
     * @example
     * // Create one VaultAssets
     * const VaultAssets = await prisma.vaultAssets.create({
     *   data: {
     *     // ... data to create a VaultAssets
     *   }
     * })
     * 
    **/
    create<T extends vaultAssetsCreateArgs>(
      args: SelectSubset<T, vaultAssetsCreateArgs>
    ): Prisma__vaultAssetsClient<vaultAssetsGetPayload<T>>

    /**
     * Create many VaultAssets.
     *     @param {vaultAssetsCreateManyArgs} args - Arguments to create many VaultAssets.
     *     @example
     *     // Create many VaultAssets
     *     const vaultAssets = await prisma.vaultAssets.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends vaultAssetsCreateManyArgs>(
      args?: SelectSubset<T, vaultAssetsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a VaultAssets.
     * @param {vaultAssetsDeleteArgs} args - Arguments to delete one VaultAssets.
     * @example
     * // Delete one VaultAssets
     * const VaultAssets = await prisma.vaultAssets.delete({
     *   where: {
     *     // ... filter to delete one VaultAssets
     *   }
     * })
     * 
    **/
    delete<T extends vaultAssetsDeleteArgs>(
      args: SelectSubset<T, vaultAssetsDeleteArgs>
    ): Prisma__vaultAssetsClient<vaultAssetsGetPayload<T>>

    /**
     * Update one VaultAssets.
     * @param {vaultAssetsUpdateArgs} args - Arguments to update one VaultAssets.
     * @example
     * // Update one VaultAssets
     * const vaultAssets = await prisma.vaultAssets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends vaultAssetsUpdateArgs>(
      args: SelectSubset<T, vaultAssetsUpdateArgs>
    ): Prisma__vaultAssetsClient<vaultAssetsGetPayload<T>>

    /**
     * Delete zero or more VaultAssets.
     * @param {vaultAssetsDeleteManyArgs} args - Arguments to filter VaultAssets to delete.
     * @example
     * // Delete a few VaultAssets
     * const { count } = await prisma.vaultAssets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends vaultAssetsDeleteManyArgs>(
      args?: SelectSubset<T, vaultAssetsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more VaultAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vaultAssetsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VaultAssets
     * const vaultAssets = await prisma.vaultAssets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends vaultAssetsUpdateManyArgs>(
      args: SelectSubset<T, vaultAssetsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one VaultAssets.
     * @param {vaultAssetsUpsertArgs} args - Arguments to update or create a VaultAssets.
     * @example
     * // Update or create a VaultAssets
     * const vaultAssets = await prisma.vaultAssets.upsert({
     *   create: {
     *     // ... data to create a VaultAssets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VaultAssets we want to update
     *   }
     * })
    **/
    upsert<T extends vaultAssetsUpsertArgs>(
      args: SelectSubset<T, vaultAssetsUpsertArgs>
    ): Prisma__vaultAssetsClient<vaultAssetsGetPayload<T>>

    /**
     * Count the number of VaultAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vaultAssetsCountArgs} args - Arguments to filter VaultAssets to count.
     * @example
     * // Count the number of VaultAssets
     * const count = await prisma.vaultAssets.count({
     *   where: {
     *     // ... the filter for the VaultAssets we want to count
     *   }
     * })
    **/
    count<T extends vaultAssetsCountArgs>(
      args?: Subset<T, vaultAssetsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VaultAssetsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VaultAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaultAssetsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VaultAssetsAggregateArgs>(args: Subset<T, VaultAssetsAggregateArgs>): PrismaPromise<GetVaultAssetsAggregateType<T>>

    /**
     * Group by VaultAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaultAssetsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VaultAssetsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VaultAssetsGroupByArgs['orderBy'] }
        : { orderBy?: VaultAssetsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VaultAssetsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVaultAssetsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for vaultAssets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__vaultAssetsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    custodyVendorVaultAssets<T extends vaultAssets$custodyVendorVaultAssetsArgs= {}>(args?: Subset<T, vaultAssets$custodyVendorVaultAssetsArgs>): PrismaPromise<Array<custodyVendorVaultAssetsGetPayload<T>>| Null>;

    depositAddresses<T extends vaultAssets$depositAddressesArgs= {}>(args?: Subset<T, vaultAssets$depositAddressesArgs>): PrismaPromise<Array<depositAddressesGetPayload<T>>| Null>;

    assets<T extends assetsArgs= {}>(args?: Subset<T, assetsArgs>): Prisma__assetsClient<assetsGetPayload<T> | Null>;

    vaults<T extends vaultsArgs= {}>(args?: Subset<T, vaultsArgs>): Prisma__vaultsClient<vaultsGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * vaultAssets base type for findUnique actions
   */
  export type vaultAssetsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the vaultAssets
     */
    select?: vaultAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultAssetsInclude | null
    /**
     * Filter, which vaultAssets to fetch.
     */
    where: vaultAssetsWhereUniqueInput
  }

  /**
   * vaultAssets findUnique
   */
  export interface vaultAssetsFindUniqueArgs extends vaultAssetsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * vaultAssets findUniqueOrThrow
   */
  export type vaultAssetsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the vaultAssets
     */
    select?: vaultAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultAssetsInclude | null
    /**
     * Filter, which vaultAssets to fetch.
     */
    where: vaultAssetsWhereUniqueInput
  }


  /**
   * vaultAssets base type for findFirst actions
   */
  export type vaultAssetsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the vaultAssets
     */
    select?: vaultAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultAssetsInclude | null
    /**
     * Filter, which vaultAssets to fetch.
     */
    where?: vaultAssetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vaultAssets to fetch.
     */
    orderBy?: Enumerable<vaultAssetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vaultAssets.
     */
    cursor?: vaultAssetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vaultAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vaultAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vaultAssets.
     */
    distinct?: Enumerable<VaultAssetsScalarFieldEnum>
  }

  /**
   * vaultAssets findFirst
   */
  export interface vaultAssetsFindFirstArgs extends vaultAssetsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * vaultAssets findFirstOrThrow
   */
  export type vaultAssetsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the vaultAssets
     */
    select?: vaultAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultAssetsInclude | null
    /**
     * Filter, which vaultAssets to fetch.
     */
    where?: vaultAssetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vaultAssets to fetch.
     */
    orderBy?: Enumerable<vaultAssetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vaultAssets.
     */
    cursor?: vaultAssetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vaultAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vaultAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vaultAssets.
     */
    distinct?: Enumerable<VaultAssetsScalarFieldEnum>
  }


  /**
   * vaultAssets findMany
   */
  export type vaultAssetsFindManyArgs = {
    /**
     * Select specific fields to fetch from the vaultAssets
     */
    select?: vaultAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultAssetsInclude | null
    /**
     * Filter, which vaultAssets to fetch.
     */
    where?: vaultAssetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vaultAssets to fetch.
     */
    orderBy?: Enumerable<vaultAssetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vaultAssets.
     */
    cursor?: vaultAssetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vaultAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vaultAssets.
     */
    skip?: number
    distinct?: Enumerable<VaultAssetsScalarFieldEnum>
  }


  /**
   * vaultAssets create
   */
  export type vaultAssetsCreateArgs = {
    /**
     * Select specific fields to fetch from the vaultAssets
     */
    select?: vaultAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultAssetsInclude | null
    /**
     * The data needed to create a vaultAssets.
     */
    data: XOR<vaultAssetsCreateInput, vaultAssetsUncheckedCreateInput>
  }


  /**
   * vaultAssets createMany
   */
  export type vaultAssetsCreateManyArgs = {
    /**
     * The data used to create many vaultAssets.
     */
    data: Enumerable<vaultAssetsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * vaultAssets update
   */
  export type vaultAssetsUpdateArgs = {
    /**
     * Select specific fields to fetch from the vaultAssets
     */
    select?: vaultAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultAssetsInclude | null
    /**
     * The data needed to update a vaultAssets.
     */
    data: XOR<vaultAssetsUpdateInput, vaultAssetsUncheckedUpdateInput>
    /**
     * Choose, which vaultAssets to update.
     */
    where: vaultAssetsWhereUniqueInput
  }


  /**
   * vaultAssets updateMany
   */
  export type vaultAssetsUpdateManyArgs = {
    /**
     * The data used to update vaultAssets.
     */
    data: XOR<vaultAssetsUpdateManyMutationInput, vaultAssetsUncheckedUpdateManyInput>
    /**
     * Filter which vaultAssets to update
     */
    where?: vaultAssetsWhereInput
  }


  /**
   * vaultAssets upsert
   */
  export type vaultAssetsUpsertArgs = {
    /**
     * Select specific fields to fetch from the vaultAssets
     */
    select?: vaultAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultAssetsInclude | null
    /**
     * The filter to search for the vaultAssets to update in case it exists.
     */
    where: vaultAssetsWhereUniqueInput
    /**
     * In case the vaultAssets found by the `where` argument doesn't exist, create a new vaultAssets with this data.
     */
    create: XOR<vaultAssetsCreateInput, vaultAssetsUncheckedCreateInput>
    /**
     * In case the vaultAssets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vaultAssetsUpdateInput, vaultAssetsUncheckedUpdateInput>
  }


  /**
   * vaultAssets delete
   */
  export type vaultAssetsDeleteArgs = {
    /**
     * Select specific fields to fetch from the vaultAssets
     */
    select?: vaultAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultAssetsInclude | null
    /**
     * Filter which vaultAssets to delete.
     */
    where: vaultAssetsWhereUniqueInput
  }


  /**
   * vaultAssets deleteMany
   */
  export type vaultAssetsDeleteManyArgs = {
    /**
     * Filter which vaultAssets to delete
     */
    where?: vaultAssetsWhereInput
  }


  /**
   * vaultAssets.custodyVendorVaultAssets
   */
  export type vaultAssets$custodyVendorVaultAssetsArgs = {
    /**
     * Select specific fields to fetch from the custodyVendorVaultAssets
     */
    select?: custodyVendorVaultAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: custodyVendorVaultAssetsInclude | null
    where?: custodyVendorVaultAssetsWhereInput
    orderBy?: Enumerable<custodyVendorVaultAssetsOrderByWithRelationInput>
    cursor?: custodyVendorVaultAssetsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CustodyVendorVaultAssetsScalarFieldEnum>
  }


  /**
   * vaultAssets.depositAddresses
   */
  export type vaultAssets$depositAddressesArgs = {
    /**
     * Select specific fields to fetch from the depositAddresses
     */
    select?: depositAddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: depositAddressesInclude | null
    where?: depositAddressesWhereInput
    orderBy?: Enumerable<depositAddressesOrderByWithRelationInput>
    cursor?: depositAddressesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DepositAddressesScalarFieldEnum>
  }


  /**
   * vaultAssets without action
   */
  export type vaultAssetsArgs = {
    /**
     * Select specific fields to fetch from the vaultAssets
     */
    select?: vaultAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultAssetsInclude | null
  }



  /**
   * Model vaultStatusTypes
   */


  export type AggregateVaultStatusTypes = {
    _count: VaultStatusTypesCountAggregateOutputType | null
    _avg: VaultStatusTypesAvgAggregateOutputType | null
    _sum: VaultStatusTypesSumAggregateOutputType | null
    _min: VaultStatusTypesMinAggregateOutputType | null
    _max: VaultStatusTypesMaxAggregateOutputType | null
  }

  export type VaultStatusTypesAvgAggregateOutputType = {
    id: number | null
  }

  export type VaultStatusTypesSumAggregateOutputType = {
    id: number | null
  }

  export type VaultStatusTypesMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VaultStatusTypesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VaultStatusTypesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VaultStatusTypesAvgAggregateInputType = {
    id?: true
  }

  export type VaultStatusTypesSumAggregateInputType = {
    id?: true
  }

  export type VaultStatusTypesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VaultStatusTypesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VaultStatusTypesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VaultStatusTypesAggregateArgs = {
    /**
     * Filter which vaultStatusTypes to aggregate.
     */
    where?: vaultStatusTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vaultStatusTypes to fetch.
     */
    orderBy?: Enumerable<vaultStatusTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vaultStatusTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vaultStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vaultStatusTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vaultStatusTypes
    **/
    _count?: true | VaultStatusTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VaultStatusTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VaultStatusTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VaultStatusTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VaultStatusTypesMaxAggregateInputType
  }

  export type GetVaultStatusTypesAggregateType<T extends VaultStatusTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateVaultStatusTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVaultStatusTypes[P]>
      : GetScalarType<T[P], AggregateVaultStatusTypes[P]>
  }




  export type VaultStatusTypesGroupByArgs = {
    where?: vaultStatusTypesWhereInput
    orderBy?: Enumerable<vaultStatusTypesOrderByWithAggregationInput>
    by: VaultStatusTypesScalarFieldEnum[]
    having?: vaultStatusTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VaultStatusTypesCountAggregateInputType | true
    _avg?: VaultStatusTypesAvgAggregateInputType
    _sum?: VaultStatusTypesSumAggregateInputType
    _min?: VaultStatusTypesMinAggregateInputType
    _max?: VaultStatusTypesMaxAggregateInputType
  }


  export type VaultStatusTypesGroupByOutputType = {
    id: number
    name: string
    description: string
    createdAt: Date
    updatedAt: Date
    _count: VaultStatusTypesCountAggregateOutputType | null
    _avg: VaultStatusTypesAvgAggregateOutputType | null
    _sum: VaultStatusTypesSumAggregateOutputType | null
    _min: VaultStatusTypesMinAggregateOutputType | null
    _max: VaultStatusTypesMaxAggregateOutputType | null
  }

  type GetVaultStatusTypesGroupByPayload<T extends VaultStatusTypesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VaultStatusTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VaultStatusTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VaultStatusTypesGroupByOutputType[P]>
            : GetScalarType<T[P], VaultStatusTypesGroupByOutputType[P]>
        }
      >
    >


  export type vaultStatusTypesSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vaults?: boolean | vaultStatusTypes$vaultsArgs
    _count?: boolean | VaultStatusTypesCountOutputTypeArgs
  }


  export type vaultStatusTypesInclude = {
    vaults?: boolean | vaultStatusTypes$vaultsArgs
    _count?: boolean | VaultStatusTypesCountOutputTypeArgs
  }

  export type vaultStatusTypesGetPayload<S extends boolean | null | undefined | vaultStatusTypesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? vaultStatusTypes :
    S extends undefined ? never :
    S extends { include: any } & (vaultStatusTypesArgs | vaultStatusTypesFindManyArgs)
    ? vaultStatusTypes  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'vaults' ? Array < vaultsGetPayload<S['include'][P]>>  :
        P extends '_count' ? VaultStatusTypesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (vaultStatusTypesArgs | vaultStatusTypesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'vaults' ? Array < vaultsGetPayload<S['select'][P]>>  :
        P extends '_count' ? VaultStatusTypesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof vaultStatusTypes ? vaultStatusTypes[P] : never
  } 
      : vaultStatusTypes


  type vaultStatusTypesCountArgs = 
    Omit<vaultStatusTypesFindManyArgs, 'select' | 'include'> & {
      select?: VaultStatusTypesCountAggregateInputType | true
    }

  export interface vaultStatusTypesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one VaultStatusTypes that matches the filter.
     * @param {vaultStatusTypesFindUniqueArgs} args - Arguments to find a VaultStatusTypes
     * @example
     * // Get one VaultStatusTypes
     * const vaultStatusTypes = await prisma.vaultStatusTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends vaultStatusTypesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, vaultStatusTypesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'vaultStatusTypes'> extends True ? Prisma__vaultStatusTypesClient<vaultStatusTypesGetPayload<T>> : Prisma__vaultStatusTypesClient<vaultStatusTypesGetPayload<T> | null, null>

    /**
     * Find one VaultStatusTypes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {vaultStatusTypesFindUniqueOrThrowArgs} args - Arguments to find a VaultStatusTypes
     * @example
     * // Get one VaultStatusTypes
     * const vaultStatusTypes = await prisma.vaultStatusTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends vaultStatusTypesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, vaultStatusTypesFindUniqueOrThrowArgs>
    ): Prisma__vaultStatusTypesClient<vaultStatusTypesGetPayload<T>>

    /**
     * Find the first VaultStatusTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vaultStatusTypesFindFirstArgs} args - Arguments to find a VaultStatusTypes
     * @example
     * // Get one VaultStatusTypes
     * const vaultStatusTypes = await prisma.vaultStatusTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends vaultStatusTypesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, vaultStatusTypesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'vaultStatusTypes'> extends True ? Prisma__vaultStatusTypesClient<vaultStatusTypesGetPayload<T>> : Prisma__vaultStatusTypesClient<vaultStatusTypesGetPayload<T> | null, null>

    /**
     * Find the first VaultStatusTypes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vaultStatusTypesFindFirstOrThrowArgs} args - Arguments to find a VaultStatusTypes
     * @example
     * // Get one VaultStatusTypes
     * const vaultStatusTypes = await prisma.vaultStatusTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends vaultStatusTypesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, vaultStatusTypesFindFirstOrThrowArgs>
    ): Prisma__vaultStatusTypesClient<vaultStatusTypesGetPayload<T>>

    /**
     * Find zero or more VaultStatusTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vaultStatusTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VaultStatusTypes
     * const vaultStatusTypes = await prisma.vaultStatusTypes.findMany()
     * 
     * // Get first 10 VaultStatusTypes
     * const vaultStatusTypes = await prisma.vaultStatusTypes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vaultStatusTypesWithIdOnly = await prisma.vaultStatusTypes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends vaultStatusTypesFindManyArgs>(
      args?: SelectSubset<T, vaultStatusTypesFindManyArgs>
    ): PrismaPromise<Array<vaultStatusTypesGetPayload<T>>>

    /**
     * Create a VaultStatusTypes.
     * @param {vaultStatusTypesCreateArgs} args - Arguments to create a VaultStatusTypes.
     * @example
     * // Create one VaultStatusTypes
     * const VaultStatusTypes = await prisma.vaultStatusTypes.create({
     *   data: {
     *     // ... data to create a VaultStatusTypes
     *   }
     * })
     * 
    **/
    create<T extends vaultStatusTypesCreateArgs>(
      args: SelectSubset<T, vaultStatusTypesCreateArgs>
    ): Prisma__vaultStatusTypesClient<vaultStatusTypesGetPayload<T>>

    /**
     * Create many VaultStatusTypes.
     *     @param {vaultStatusTypesCreateManyArgs} args - Arguments to create many VaultStatusTypes.
     *     @example
     *     // Create many VaultStatusTypes
     *     const vaultStatusTypes = await prisma.vaultStatusTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends vaultStatusTypesCreateManyArgs>(
      args?: SelectSubset<T, vaultStatusTypesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a VaultStatusTypes.
     * @param {vaultStatusTypesDeleteArgs} args - Arguments to delete one VaultStatusTypes.
     * @example
     * // Delete one VaultStatusTypes
     * const VaultStatusTypes = await prisma.vaultStatusTypes.delete({
     *   where: {
     *     // ... filter to delete one VaultStatusTypes
     *   }
     * })
     * 
    **/
    delete<T extends vaultStatusTypesDeleteArgs>(
      args: SelectSubset<T, vaultStatusTypesDeleteArgs>
    ): Prisma__vaultStatusTypesClient<vaultStatusTypesGetPayload<T>>

    /**
     * Update one VaultStatusTypes.
     * @param {vaultStatusTypesUpdateArgs} args - Arguments to update one VaultStatusTypes.
     * @example
     * // Update one VaultStatusTypes
     * const vaultStatusTypes = await prisma.vaultStatusTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends vaultStatusTypesUpdateArgs>(
      args: SelectSubset<T, vaultStatusTypesUpdateArgs>
    ): Prisma__vaultStatusTypesClient<vaultStatusTypesGetPayload<T>>

    /**
     * Delete zero or more VaultStatusTypes.
     * @param {vaultStatusTypesDeleteManyArgs} args - Arguments to filter VaultStatusTypes to delete.
     * @example
     * // Delete a few VaultStatusTypes
     * const { count } = await prisma.vaultStatusTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends vaultStatusTypesDeleteManyArgs>(
      args?: SelectSubset<T, vaultStatusTypesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more VaultStatusTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vaultStatusTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VaultStatusTypes
     * const vaultStatusTypes = await prisma.vaultStatusTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends vaultStatusTypesUpdateManyArgs>(
      args: SelectSubset<T, vaultStatusTypesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one VaultStatusTypes.
     * @param {vaultStatusTypesUpsertArgs} args - Arguments to update or create a VaultStatusTypes.
     * @example
     * // Update or create a VaultStatusTypes
     * const vaultStatusTypes = await prisma.vaultStatusTypes.upsert({
     *   create: {
     *     // ... data to create a VaultStatusTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VaultStatusTypes we want to update
     *   }
     * })
    **/
    upsert<T extends vaultStatusTypesUpsertArgs>(
      args: SelectSubset<T, vaultStatusTypesUpsertArgs>
    ): Prisma__vaultStatusTypesClient<vaultStatusTypesGetPayload<T>>

    /**
     * Count the number of VaultStatusTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vaultStatusTypesCountArgs} args - Arguments to filter VaultStatusTypes to count.
     * @example
     * // Count the number of VaultStatusTypes
     * const count = await prisma.vaultStatusTypes.count({
     *   where: {
     *     // ... the filter for the VaultStatusTypes we want to count
     *   }
     * })
    **/
    count<T extends vaultStatusTypesCountArgs>(
      args?: Subset<T, vaultStatusTypesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VaultStatusTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VaultStatusTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaultStatusTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VaultStatusTypesAggregateArgs>(args: Subset<T, VaultStatusTypesAggregateArgs>): PrismaPromise<GetVaultStatusTypesAggregateType<T>>

    /**
     * Group by VaultStatusTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaultStatusTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VaultStatusTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VaultStatusTypesGroupByArgs['orderBy'] }
        : { orderBy?: VaultStatusTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VaultStatusTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVaultStatusTypesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for vaultStatusTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__vaultStatusTypesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    vaults<T extends vaultStatusTypes$vaultsArgs= {}>(args?: Subset<T, vaultStatusTypes$vaultsArgs>): PrismaPromise<Array<vaultsGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * vaultStatusTypes base type for findUnique actions
   */
  export type vaultStatusTypesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the vaultStatusTypes
     */
    select?: vaultStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultStatusTypesInclude | null
    /**
     * Filter, which vaultStatusTypes to fetch.
     */
    where: vaultStatusTypesWhereUniqueInput
  }

  /**
   * vaultStatusTypes findUnique
   */
  export interface vaultStatusTypesFindUniqueArgs extends vaultStatusTypesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * vaultStatusTypes findUniqueOrThrow
   */
  export type vaultStatusTypesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the vaultStatusTypes
     */
    select?: vaultStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultStatusTypesInclude | null
    /**
     * Filter, which vaultStatusTypes to fetch.
     */
    where: vaultStatusTypesWhereUniqueInput
  }


  /**
   * vaultStatusTypes base type for findFirst actions
   */
  export type vaultStatusTypesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the vaultStatusTypes
     */
    select?: vaultStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultStatusTypesInclude | null
    /**
     * Filter, which vaultStatusTypes to fetch.
     */
    where?: vaultStatusTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vaultStatusTypes to fetch.
     */
    orderBy?: Enumerable<vaultStatusTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vaultStatusTypes.
     */
    cursor?: vaultStatusTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vaultStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vaultStatusTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vaultStatusTypes.
     */
    distinct?: Enumerable<VaultStatusTypesScalarFieldEnum>
  }

  /**
   * vaultStatusTypes findFirst
   */
  export interface vaultStatusTypesFindFirstArgs extends vaultStatusTypesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * vaultStatusTypes findFirstOrThrow
   */
  export type vaultStatusTypesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the vaultStatusTypes
     */
    select?: vaultStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultStatusTypesInclude | null
    /**
     * Filter, which vaultStatusTypes to fetch.
     */
    where?: vaultStatusTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vaultStatusTypes to fetch.
     */
    orderBy?: Enumerable<vaultStatusTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vaultStatusTypes.
     */
    cursor?: vaultStatusTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vaultStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vaultStatusTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vaultStatusTypes.
     */
    distinct?: Enumerable<VaultStatusTypesScalarFieldEnum>
  }


  /**
   * vaultStatusTypes findMany
   */
  export type vaultStatusTypesFindManyArgs = {
    /**
     * Select specific fields to fetch from the vaultStatusTypes
     */
    select?: vaultStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultStatusTypesInclude | null
    /**
     * Filter, which vaultStatusTypes to fetch.
     */
    where?: vaultStatusTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vaultStatusTypes to fetch.
     */
    orderBy?: Enumerable<vaultStatusTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vaultStatusTypes.
     */
    cursor?: vaultStatusTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vaultStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vaultStatusTypes.
     */
    skip?: number
    distinct?: Enumerable<VaultStatusTypesScalarFieldEnum>
  }


  /**
   * vaultStatusTypes create
   */
  export type vaultStatusTypesCreateArgs = {
    /**
     * Select specific fields to fetch from the vaultStatusTypes
     */
    select?: vaultStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultStatusTypesInclude | null
    /**
     * The data needed to create a vaultStatusTypes.
     */
    data: XOR<vaultStatusTypesCreateInput, vaultStatusTypesUncheckedCreateInput>
  }


  /**
   * vaultStatusTypes createMany
   */
  export type vaultStatusTypesCreateManyArgs = {
    /**
     * The data used to create many vaultStatusTypes.
     */
    data: Enumerable<vaultStatusTypesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * vaultStatusTypes update
   */
  export type vaultStatusTypesUpdateArgs = {
    /**
     * Select specific fields to fetch from the vaultStatusTypes
     */
    select?: vaultStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultStatusTypesInclude | null
    /**
     * The data needed to update a vaultStatusTypes.
     */
    data: XOR<vaultStatusTypesUpdateInput, vaultStatusTypesUncheckedUpdateInput>
    /**
     * Choose, which vaultStatusTypes to update.
     */
    where: vaultStatusTypesWhereUniqueInput
  }


  /**
   * vaultStatusTypes updateMany
   */
  export type vaultStatusTypesUpdateManyArgs = {
    /**
     * The data used to update vaultStatusTypes.
     */
    data: XOR<vaultStatusTypesUpdateManyMutationInput, vaultStatusTypesUncheckedUpdateManyInput>
    /**
     * Filter which vaultStatusTypes to update
     */
    where?: vaultStatusTypesWhereInput
  }


  /**
   * vaultStatusTypes upsert
   */
  export type vaultStatusTypesUpsertArgs = {
    /**
     * Select specific fields to fetch from the vaultStatusTypes
     */
    select?: vaultStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultStatusTypesInclude | null
    /**
     * The filter to search for the vaultStatusTypes to update in case it exists.
     */
    where: vaultStatusTypesWhereUniqueInput
    /**
     * In case the vaultStatusTypes found by the `where` argument doesn't exist, create a new vaultStatusTypes with this data.
     */
    create: XOR<vaultStatusTypesCreateInput, vaultStatusTypesUncheckedCreateInput>
    /**
     * In case the vaultStatusTypes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vaultStatusTypesUpdateInput, vaultStatusTypesUncheckedUpdateInput>
  }


  /**
   * vaultStatusTypes delete
   */
  export type vaultStatusTypesDeleteArgs = {
    /**
     * Select specific fields to fetch from the vaultStatusTypes
     */
    select?: vaultStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultStatusTypesInclude | null
    /**
     * Filter which vaultStatusTypes to delete.
     */
    where: vaultStatusTypesWhereUniqueInput
  }


  /**
   * vaultStatusTypes deleteMany
   */
  export type vaultStatusTypesDeleteManyArgs = {
    /**
     * Filter which vaultStatusTypes to delete
     */
    where?: vaultStatusTypesWhereInput
  }


  /**
   * vaultStatusTypes.vaults
   */
  export type vaultStatusTypes$vaultsArgs = {
    /**
     * Select specific fields to fetch from the vaults
     */
    select?: vaultsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultsInclude | null
    where?: vaultsWhereInput
    orderBy?: Enumerable<vaultsOrderByWithRelationInput>
    cursor?: vaultsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VaultsScalarFieldEnum>
  }


  /**
   * vaultStatusTypes without action
   */
  export type vaultStatusTypesArgs = {
    /**
     * Select specific fields to fetch from the vaultStatusTypes
     */
    select?: vaultStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultStatusTypesInclude | null
  }



  /**
   * Model vaults
   */


  export type AggregateVaults = {
    _count: VaultsCountAggregateOutputType | null
    _avg: VaultsAvgAggregateOutputType | null
    _sum: VaultsSumAggregateOutputType | null
    _min: VaultsMinAggregateOutputType | null
    _max: VaultsMaxAggregateOutputType | null
  }

  export type VaultsAvgAggregateOutputType = {
    vaultStatusId: number | null
  }

  export type VaultsSumAggregateOutputType = {
    vaultStatusId: number | null
  }

  export type VaultsMinAggregateOutputType = {
    id: string | null
    createdByUserId: string | null
    vaultStatusId: number | null
    vaultName: string | null
    subjectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VaultsMaxAggregateOutputType = {
    id: string | null
    createdByUserId: string | null
    vaultStatusId: number | null
    vaultName: string | null
    subjectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VaultsCountAggregateOutputType = {
    id: number
    createdByUserId: number
    vaultStatusId: number
    vaultName: number
    subjectId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VaultsAvgAggregateInputType = {
    vaultStatusId?: true
  }

  export type VaultsSumAggregateInputType = {
    vaultStatusId?: true
  }

  export type VaultsMinAggregateInputType = {
    id?: true
    createdByUserId?: true
    vaultStatusId?: true
    vaultName?: true
    subjectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VaultsMaxAggregateInputType = {
    id?: true
    createdByUserId?: true
    vaultStatusId?: true
    vaultName?: true
    subjectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VaultsCountAggregateInputType = {
    id?: true
    createdByUserId?: true
    vaultStatusId?: true
    vaultName?: true
    subjectId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VaultsAggregateArgs = {
    /**
     * Filter which vaults to aggregate.
     */
    where?: vaultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vaults to fetch.
     */
    orderBy?: Enumerable<vaultsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vaultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vaults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vaults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vaults
    **/
    _count?: true | VaultsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VaultsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VaultsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VaultsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VaultsMaxAggregateInputType
  }

  export type GetVaultsAggregateType<T extends VaultsAggregateArgs> = {
        [P in keyof T & keyof AggregateVaults]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVaults[P]>
      : GetScalarType<T[P], AggregateVaults[P]>
  }




  export type VaultsGroupByArgs = {
    where?: vaultsWhereInput
    orderBy?: Enumerable<vaultsOrderByWithAggregationInput>
    by: VaultsScalarFieldEnum[]
    having?: vaultsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VaultsCountAggregateInputType | true
    _avg?: VaultsAvgAggregateInputType
    _sum?: VaultsSumAggregateInputType
    _min?: VaultsMinAggregateInputType
    _max?: VaultsMaxAggregateInputType
  }


  export type VaultsGroupByOutputType = {
    id: string
    createdByUserId: string
    vaultStatusId: number | null
    vaultName: string | null
    subjectId: string
    createdAt: Date
    updatedAt: Date
    _count: VaultsCountAggregateOutputType | null
    _avg: VaultsAvgAggregateOutputType | null
    _sum: VaultsSumAggregateOutputType | null
    _min: VaultsMinAggregateOutputType | null
    _max: VaultsMaxAggregateOutputType | null
  }

  type GetVaultsGroupByPayload<T extends VaultsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VaultsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VaultsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VaultsGroupByOutputType[P]>
            : GetScalarType<T[P], VaultsGroupByOutputType[P]>
        }
      >
    >


  export type vaultsSelect = {
    id?: boolean
    createdByUserId?: boolean
    vaultStatusId?: boolean
    vaultName?: boolean
    subjectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: boolean | vaults$transactionPolicies_transactionPolicies_sourceVaultIdTovaultsArgs
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: boolean | vaults$transactionPolicies_transactionPolicies_targetVaultIdTovaultsArgs
    transactions_transactions_sourceVaultIdTovaults?: boolean | vaults$transactions_transactions_sourceVaultIdTovaultsArgs
    transactions_transactions_targetVaultIdTovaults?: boolean | vaults$transactions_transactions_targetVaultIdTovaultsArgs
    vaultAssets?: boolean | vaults$vaultAssetsArgs
    users?: boolean | usersArgs
    vaultStatusTypes?: boolean | vaultStatusTypesArgs
    _count?: boolean | VaultsCountOutputTypeArgs
  }


  export type vaultsInclude = {
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: boolean | vaults$transactionPolicies_transactionPolicies_sourceVaultIdTovaultsArgs
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: boolean | vaults$transactionPolicies_transactionPolicies_targetVaultIdTovaultsArgs
    transactions_transactions_sourceVaultIdTovaults?: boolean | vaults$transactions_transactions_sourceVaultIdTovaultsArgs
    transactions_transactions_targetVaultIdTovaults?: boolean | vaults$transactions_transactions_targetVaultIdTovaultsArgs
    vaultAssets?: boolean | vaults$vaultAssetsArgs
    users?: boolean | usersArgs
    vaultStatusTypes?: boolean | vaultStatusTypesArgs
    _count?: boolean | VaultsCountOutputTypeArgs
  }

  export type vaultsGetPayload<S extends boolean | null | undefined | vaultsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? vaults :
    S extends undefined ? never :
    S extends { include: any } & (vaultsArgs | vaultsFindManyArgs)
    ? vaults  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'transactionPolicies_transactionPolicies_sourceVaultIdTovaults' ? Array < transactionPoliciesGetPayload<S['include'][P]>>  :
        P extends 'transactionPolicies_transactionPolicies_targetVaultIdTovaults' ? Array < transactionPoliciesGetPayload<S['include'][P]>>  :
        P extends 'transactions_transactions_sourceVaultIdTovaults' ? Array < transactionsGetPayload<S['include'][P]>>  :
        P extends 'transactions_transactions_targetVaultIdTovaults' ? Array < transactionsGetPayload<S['include'][P]>>  :
        P extends 'vaultAssets' ? Array < vaultAssetsGetPayload<S['include'][P]>>  :
        P extends 'users' ? usersGetPayload<S['include'][P]> :
        P extends 'vaultStatusTypes' ? vaultStatusTypesGetPayload<S['include'][P]> | null :
        P extends '_count' ? VaultsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (vaultsArgs | vaultsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'transactionPolicies_transactionPolicies_sourceVaultIdTovaults' ? Array < transactionPoliciesGetPayload<S['select'][P]>>  :
        P extends 'transactionPolicies_transactionPolicies_targetVaultIdTovaults' ? Array < transactionPoliciesGetPayload<S['select'][P]>>  :
        P extends 'transactions_transactions_sourceVaultIdTovaults' ? Array < transactionsGetPayload<S['select'][P]>>  :
        P extends 'transactions_transactions_targetVaultIdTovaults' ? Array < transactionsGetPayload<S['select'][P]>>  :
        P extends 'vaultAssets' ? Array < vaultAssetsGetPayload<S['select'][P]>>  :
        P extends 'users' ? usersGetPayload<S['select'][P]> :
        P extends 'vaultStatusTypes' ? vaultStatusTypesGetPayload<S['select'][P]> | null :
        P extends '_count' ? VaultsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof vaults ? vaults[P] : never
  } 
      : vaults


  type vaultsCountArgs = 
    Omit<vaultsFindManyArgs, 'select' | 'include'> & {
      select?: VaultsCountAggregateInputType | true
    }

  export interface vaultsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Vaults that matches the filter.
     * @param {vaultsFindUniqueArgs} args - Arguments to find a Vaults
     * @example
     * // Get one Vaults
     * const vaults = await prisma.vaults.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends vaultsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, vaultsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'vaults'> extends True ? Prisma__vaultsClient<vaultsGetPayload<T>> : Prisma__vaultsClient<vaultsGetPayload<T> | null, null>

    /**
     * Find one Vaults that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {vaultsFindUniqueOrThrowArgs} args - Arguments to find a Vaults
     * @example
     * // Get one Vaults
     * const vaults = await prisma.vaults.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends vaultsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, vaultsFindUniqueOrThrowArgs>
    ): Prisma__vaultsClient<vaultsGetPayload<T>>

    /**
     * Find the first Vaults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vaultsFindFirstArgs} args - Arguments to find a Vaults
     * @example
     * // Get one Vaults
     * const vaults = await prisma.vaults.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends vaultsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, vaultsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'vaults'> extends True ? Prisma__vaultsClient<vaultsGetPayload<T>> : Prisma__vaultsClient<vaultsGetPayload<T> | null, null>

    /**
     * Find the first Vaults that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vaultsFindFirstOrThrowArgs} args - Arguments to find a Vaults
     * @example
     * // Get one Vaults
     * const vaults = await prisma.vaults.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends vaultsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, vaultsFindFirstOrThrowArgs>
    ): Prisma__vaultsClient<vaultsGetPayload<T>>

    /**
     * Find zero or more Vaults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vaultsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vaults
     * const vaults = await prisma.vaults.findMany()
     * 
     * // Get first 10 Vaults
     * const vaults = await prisma.vaults.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vaultsWithIdOnly = await prisma.vaults.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends vaultsFindManyArgs>(
      args?: SelectSubset<T, vaultsFindManyArgs>
    ): PrismaPromise<Array<vaultsGetPayload<T>>>

    /**
     * Create a Vaults.
     * @param {vaultsCreateArgs} args - Arguments to create a Vaults.
     * @example
     * // Create one Vaults
     * const Vaults = await prisma.vaults.create({
     *   data: {
     *     // ... data to create a Vaults
     *   }
     * })
     * 
    **/
    create<T extends vaultsCreateArgs>(
      args: SelectSubset<T, vaultsCreateArgs>
    ): Prisma__vaultsClient<vaultsGetPayload<T>>

    /**
     * Create many Vaults.
     *     @param {vaultsCreateManyArgs} args - Arguments to create many Vaults.
     *     @example
     *     // Create many Vaults
     *     const vaults = await prisma.vaults.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends vaultsCreateManyArgs>(
      args?: SelectSubset<T, vaultsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Vaults.
     * @param {vaultsDeleteArgs} args - Arguments to delete one Vaults.
     * @example
     * // Delete one Vaults
     * const Vaults = await prisma.vaults.delete({
     *   where: {
     *     // ... filter to delete one Vaults
     *   }
     * })
     * 
    **/
    delete<T extends vaultsDeleteArgs>(
      args: SelectSubset<T, vaultsDeleteArgs>
    ): Prisma__vaultsClient<vaultsGetPayload<T>>

    /**
     * Update one Vaults.
     * @param {vaultsUpdateArgs} args - Arguments to update one Vaults.
     * @example
     * // Update one Vaults
     * const vaults = await prisma.vaults.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends vaultsUpdateArgs>(
      args: SelectSubset<T, vaultsUpdateArgs>
    ): Prisma__vaultsClient<vaultsGetPayload<T>>

    /**
     * Delete zero or more Vaults.
     * @param {vaultsDeleteManyArgs} args - Arguments to filter Vaults to delete.
     * @example
     * // Delete a few Vaults
     * const { count } = await prisma.vaults.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends vaultsDeleteManyArgs>(
      args?: SelectSubset<T, vaultsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vaults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vaultsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vaults
     * const vaults = await prisma.vaults.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends vaultsUpdateManyArgs>(
      args: SelectSubset<T, vaultsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Vaults.
     * @param {vaultsUpsertArgs} args - Arguments to update or create a Vaults.
     * @example
     * // Update or create a Vaults
     * const vaults = await prisma.vaults.upsert({
     *   create: {
     *     // ... data to create a Vaults
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vaults we want to update
     *   }
     * })
    **/
    upsert<T extends vaultsUpsertArgs>(
      args: SelectSubset<T, vaultsUpsertArgs>
    ): Prisma__vaultsClient<vaultsGetPayload<T>>

    /**
     * Count the number of Vaults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vaultsCountArgs} args - Arguments to filter Vaults to count.
     * @example
     * // Count the number of Vaults
     * const count = await prisma.vaults.count({
     *   where: {
     *     // ... the filter for the Vaults we want to count
     *   }
     * })
    **/
    count<T extends vaultsCountArgs>(
      args?: Subset<T, vaultsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VaultsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vaults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaultsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VaultsAggregateArgs>(args: Subset<T, VaultsAggregateArgs>): PrismaPromise<GetVaultsAggregateType<T>>

    /**
     * Group by Vaults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaultsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VaultsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VaultsGroupByArgs['orderBy'] }
        : { orderBy?: VaultsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VaultsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVaultsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for vaults.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__vaultsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    transactionPolicies_transactionPolicies_sourceVaultIdTovaults<T extends vaults$transactionPolicies_transactionPolicies_sourceVaultIdTovaultsArgs= {}>(args?: Subset<T, vaults$transactionPolicies_transactionPolicies_sourceVaultIdTovaultsArgs>): PrismaPromise<Array<transactionPoliciesGetPayload<T>>| Null>;

    transactionPolicies_transactionPolicies_targetVaultIdTovaults<T extends vaults$transactionPolicies_transactionPolicies_targetVaultIdTovaultsArgs= {}>(args?: Subset<T, vaults$transactionPolicies_transactionPolicies_targetVaultIdTovaultsArgs>): PrismaPromise<Array<transactionPoliciesGetPayload<T>>| Null>;

    transactions_transactions_sourceVaultIdTovaults<T extends vaults$transactions_transactions_sourceVaultIdTovaultsArgs= {}>(args?: Subset<T, vaults$transactions_transactions_sourceVaultIdTovaultsArgs>): PrismaPromise<Array<transactionsGetPayload<T>>| Null>;

    transactions_transactions_targetVaultIdTovaults<T extends vaults$transactions_transactions_targetVaultIdTovaultsArgs= {}>(args?: Subset<T, vaults$transactions_transactions_targetVaultIdTovaultsArgs>): PrismaPromise<Array<transactionsGetPayload<T>>| Null>;

    vaultAssets<T extends vaults$vaultAssetsArgs= {}>(args?: Subset<T, vaults$vaultAssetsArgs>): PrismaPromise<Array<vaultAssetsGetPayload<T>>| Null>;

    users<T extends usersArgs= {}>(args?: Subset<T, usersArgs>): Prisma__usersClient<usersGetPayload<T> | Null>;

    vaultStatusTypes<T extends vaultStatusTypesArgs= {}>(args?: Subset<T, vaultStatusTypesArgs>): Prisma__vaultStatusTypesClient<vaultStatusTypesGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * vaults base type for findUnique actions
   */
  export type vaultsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the vaults
     */
    select?: vaultsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultsInclude | null
    /**
     * Filter, which vaults to fetch.
     */
    where: vaultsWhereUniqueInput
  }

  /**
   * vaults findUnique
   */
  export interface vaultsFindUniqueArgs extends vaultsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * vaults findUniqueOrThrow
   */
  export type vaultsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the vaults
     */
    select?: vaultsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultsInclude | null
    /**
     * Filter, which vaults to fetch.
     */
    where: vaultsWhereUniqueInput
  }


  /**
   * vaults base type for findFirst actions
   */
  export type vaultsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the vaults
     */
    select?: vaultsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultsInclude | null
    /**
     * Filter, which vaults to fetch.
     */
    where?: vaultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vaults to fetch.
     */
    orderBy?: Enumerable<vaultsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vaults.
     */
    cursor?: vaultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vaults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vaults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vaults.
     */
    distinct?: Enumerable<VaultsScalarFieldEnum>
  }

  /**
   * vaults findFirst
   */
  export interface vaultsFindFirstArgs extends vaultsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * vaults findFirstOrThrow
   */
  export type vaultsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the vaults
     */
    select?: vaultsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultsInclude | null
    /**
     * Filter, which vaults to fetch.
     */
    where?: vaultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vaults to fetch.
     */
    orderBy?: Enumerable<vaultsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vaults.
     */
    cursor?: vaultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vaults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vaults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vaults.
     */
    distinct?: Enumerable<VaultsScalarFieldEnum>
  }


  /**
   * vaults findMany
   */
  export type vaultsFindManyArgs = {
    /**
     * Select specific fields to fetch from the vaults
     */
    select?: vaultsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultsInclude | null
    /**
     * Filter, which vaults to fetch.
     */
    where?: vaultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vaults to fetch.
     */
    orderBy?: Enumerable<vaultsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vaults.
     */
    cursor?: vaultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vaults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vaults.
     */
    skip?: number
    distinct?: Enumerable<VaultsScalarFieldEnum>
  }


  /**
   * vaults create
   */
  export type vaultsCreateArgs = {
    /**
     * Select specific fields to fetch from the vaults
     */
    select?: vaultsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultsInclude | null
    /**
     * The data needed to create a vaults.
     */
    data: XOR<vaultsCreateInput, vaultsUncheckedCreateInput>
  }


  /**
   * vaults createMany
   */
  export type vaultsCreateManyArgs = {
    /**
     * The data used to create many vaults.
     */
    data: Enumerable<vaultsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * vaults update
   */
  export type vaultsUpdateArgs = {
    /**
     * Select specific fields to fetch from the vaults
     */
    select?: vaultsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultsInclude | null
    /**
     * The data needed to update a vaults.
     */
    data: XOR<vaultsUpdateInput, vaultsUncheckedUpdateInput>
    /**
     * Choose, which vaults to update.
     */
    where: vaultsWhereUniqueInput
  }


  /**
   * vaults updateMany
   */
  export type vaultsUpdateManyArgs = {
    /**
     * The data used to update vaults.
     */
    data: XOR<vaultsUpdateManyMutationInput, vaultsUncheckedUpdateManyInput>
    /**
     * Filter which vaults to update
     */
    where?: vaultsWhereInput
  }


  /**
   * vaults upsert
   */
  export type vaultsUpsertArgs = {
    /**
     * Select specific fields to fetch from the vaults
     */
    select?: vaultsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultsInclude | null
    /**
     * The filter to search for the vaults to update in case it exists.
     */
    where: vaultsWhereUniqueInput
    /**
     * In case the vaults found by the `where` argument doesn't exist, create a new vaults with this data.
     */
    create: XOR<vaultsCreateInput, vaultsUncheckedCreateInput>
    /**
     * In case the vaults was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vaultsUpdateInput, vaultsUncheckedUpdateInput>
  }


  /**
   * vaults delete
   */
  export type vaultsDeleteArgs = {
    /**
     * Select specific fields to fetch from the vaults
     */
    select?: vaultsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultsInclude | null
    /**
     * Filter which vaults to delete.
     */
    where: vaultsWhereUniqueInput
  }


  /**
   * vaults deleteMany
   */
  export type vaultsDeleteManyArgs = {
    /**
     * Filter which vaults to delete
     */
    where?: vaultsWhereInput
  }


  /**
   * vaults.transactionPolicies_transactionPolicies_sourceVaultIdTovaults
   */
  export type vaults$transactionPolicies_transactionPolicies_sourceVaultIdTovaultsArgs = {
    /**
     * Select specific fields to fetch from the transactionPolicies
     */
    select?: transactionPoliciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionPoliciesInclude | null
    where?: transactionPoliciesWhereInput
    orderBy?: Enumerable<transactionPoliciesOrderByWithRelationInput>
    cursor?: transactionPoliciesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TransactionPoliciesScalarFieldEnum>
  }


  /**
   * vaults.transactionPolicies_transactionPolicies_targetVaultIdTovaults
   */
  export type vaults$transactionPolicies_transactionPolicies_targetVaultIdTovaultsArgs = {
    /**
     * Select specific fields to fetch from the transactionPolicies
     */
    select?: transactionPoliciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionPoliciesInclude | null
    where?: transactionPoliciesWhereInput
    orderBy?: Enumerable<transactionPoliciesOrderByWithRelationInput>
    cursor?: transactionPoliciesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TransactionPoliciesScalarFieldEnum>
  }


  /**
   * vaults.transactions_transactions_sourceVaultIdTovaults
   */
  export type vaults$transactions_transactions_sourceVaultIdTovaultsArgs = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionsInclude | null
    where?: transactionsWhereInput
    orderBy?: Enumerable<transactionsOrderByWithRelationInput>
    cursor?: transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TransactionsScalarFieldEnum>
  }


  /**
   * vaults.transactions_transactions_targetVaultIdTovaults
   */
  export type vaults$transactions_transactions_targetVaultIdTovaultsArgs = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionsInclude | null
    where?: transactionsWhereInput
    orderBy?: Enumerable<transactionsOrderByWithRelationInput>
    cursor?: transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TransactionsScalarFieldEnum>
  }


  /**
   * vaults.vaultAssets
   */
  export type vaults$vaultAssetsArgs = {
    /**
     * Select specific fields to fetch from the vaultAssets
     */
    select?: vaultAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultAssetsInclude | null
    where?: vaultAssetsWhereInput
    orderBy?: Enumerable<vaultAssetsOrderByWithRelationInput>
    cursor?: vaultAssetsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<VaultAssetsScalarFieldEnum>
  }


  /**
   * vaults without action
   */
  export type vaultsArgs = {
    /**
     * Select specific fields to fetch from the vaults
     */
    select?: vaultsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vaultsInclude | null
  }



  /**
   * Model vendorSupportsAssets
   */


  export type AggregateVendorSupportsAssets = {
    _count: VendorSupportsAssetsCountAggregateOutputType | null
    _avg: VendorSupportsAssetsAvgAggregateOutputType | null
    _sum: VendorSupportsAssetsSumAggregateOutputType | null
    _min: VendorSupportsAssetsMinAggregateOutputType | null
    _max: VendorSupportsAssetsMaxAggregateOutputType | null
  }

  export type VendorSupportsAssetsAvgAggregateOutputType = {
    id: number | null
    assetId: number | null
    vendorId: number | null
  }

  export type VendorSupportsAssetsSumAggregateOutputType = {
    id: number | null
    assetId: number | null
    vendorId: number | null
  }

  export type VendorSupportsAssetsMinAggregateOutputType = {
    id: number | null
    assetId: number | null
    vendorId: number | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    theirId: string | null
  }

  export type VendorSupportsAssetsMaxAggregateOutputType = {
    id: number | null
    assetId: number | null
    vendorId: number | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    theirId: string | null
  }

  export type VendorSupportsAssetsCountAggregateOutputType = {
    id: number
    assetId: number
    vendorId: number
    enabled: number
    createdAt: number
    updatedAt: number
    theirId: number
    _all: number
  }


  export type VendorSupportsAssetsAvgAggregateInputType = {
    id?: true
    assetId?: true
    vendorId?: true
  }

  export type VendorSupportsAssetsSumAggregateInputType = {
    id?: true
    assetId?: true
    vendorId?: true
  }

  export type VendorSupportsAssetsMinAggregateInputType = {
    id?: true
    assetId?: true
    vendorId?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    theirId?: true
  }

  export type VendorSupportsAssetsMaxAggregateInputType = {
    id?: true
    assetId?: true
    vendorId?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    theirId?: true
  }

  export type VendorSupportsAssetsCountAggregateInputType = {
    id?: true
    assetId?: true
    vendorId?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    theirId?: true
    _all?: true
  }

  export type VendorSupportsAssetsAggregateArgs = {
    /**
     * Filter which vendorSupportsAssets to aggregate.
     */
    where?: vendorSupportsAssetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vendorSupportsAssets to fetch.
     */
    orderBy?: Enumerable<vendorSupportsAssetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vendorSupportsAssetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vendorSupportsAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vendorSupportsAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vendorSupportsAssets
    **/
    _count?: true | VendorSupportsAssetsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorSupportsAssetsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorSupportsAssetsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorSupportsAssetsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorSupportsAssetsMaxAggregateInputType
  }

  export type GetVendorSupportsAssetsAggregateType<T extends VendorSupportsAssetsAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorSupportsAssets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorSupportsAssets[P]>
      : GetScalarType<T[P], AggregateVendorSupportsAssets[P]>
  }




  export type VendorSupportsAssetsGroupByArgs = {
    where?: vendorSupportsAssetsWhereInput
    orderBy?: Enumerable<vendorSupportsAssetsOrderByWithAggregationInput>
    by: VendorSupportsAssetsScalarFieldEnum[]
    having?: vendorSupportsAssetsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorSupportsAssetsCountAggregateInputType | true
    _avg?: VendorSupportsAssetsAvgAggregateInputType
    _sum?: VendorSupportsAssetsSumAggregateInputType
    _min?: VendorSupportsAssetsMinAggregateInputType
    _max?: VendorSupportsAssetsMaxAggregateInputType
  }


  export type VendorSupportsAssetsGroupByOutputType = {
    id: number
    assetId: number
    vendorId: number
    enabled: boolean | null
    createdAt: Date
    updatedAt: Date
    theirId: string | null
    _count: VendorSupportsAssetsCountAggregateOutputType | null
    _avg: VendorSupportsAssetsAvgAggregateOutputType | null
    _sum: VendorSupportsAssetsSumAggregateOutputType | null
    _min: VendorSupportsAssetsMinAggregateOutputType | null
    _max: VendorSupportsAssetsMaxAggregateOutputType | null
  }

  type GetVendorSupportsAssetsGroupByPayload<T extends VendorSupportsAssetsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VendorSupportsAssetsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorSupportsAssetsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorSupportsAssetsGroupByOutputType[P]>
            : GetScalarType<T[P], VendorSupportsAssetsGroupByOutputType[P]>
        }
      >
    >


  export type vendorSupportsAssetsSelect = {
    id?: boolean
    assetId?: boolean
    vendorId?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    theirId?: boolean
    pricingPlanSupportsAssets?: boolean | vendorSupportsAssets$pricingPlanSupportsAssetsArgs
    assets?: boolean | assetsArgs
    vendors?: boolean | vendorsArgs
    _count?: boolean | VendorSupportsAssetsCountOutputTypeArgs
  }


  export type vendorSupportsAssetsInclude = {
    pricingPlanSupportsAssets?: boolean | vendorSupportsAssets$pricingPlanSupportsAssetsArgs
    assets?: boolean | assetsArgs
    vendors?: boolean | vendorsArgs
    _count?: boolean | VendorSupportsAssetsCountOutputTypeArgs
  }

  export type vendorSupportsAssetsGetPayload<S extends boolean | null | undefined | vendorSupportsAssetsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? vendorSupportsAssets :
    S extends undefined ? never :
    S extends { include: any } & (vendorSupportsAssetsArgs | vendorSupportsAssetsFindManyArgs)
    ? vendorSupportsAssets  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'pricingPlanSupportsAssets' ? Array < pricingPlanSupportsAssetsGetPayload<S['include'][P]>>  :
        P extends 'assets' ? assetsGetPayload<S['include'][P]> :
        P extends 'vendors' ? vendorsGetPayload<S['include'][P]> :
        P extends '_count' ? VendorSupportsAssetsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (vendorSupportsAssetsArgs | vendorSupportsAssetsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'pricingPlanSupportsAssets' ? Array < pricingPlanSupportsAssetsGetPayload<S['select'][P]>>  :
        P extends 'assets' ? assetsGetPayload<S['select'][P]> :
        P extends 'vendors' ? vendorsGetPayload<S['select'][P]> :
        P extends '_count' ? VendorSupportsAssetsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof vendorSupportsAssets ? vendorSupportsAssets[P] : never
  } 
      : vendorSupportsAssets


  type vendorSupportsAssetsCountArgs = 
    Omit<vendorSupportsAssetsFindManyArgs, 'select' | 'include'> & {
      select?: VendorSupportsAssetsCountAggregateInputType | true
    }

  export interface vendorSupportsAssetsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one VendorSupportsAssets that matches the filter.
     * @param {vendorSupportsAssetsFindUniqueArgs} args - Arguments to find a VendorSupportsAssets
     * @example
     * // Get one VendorSupportsAssets
     * const vendorSupportsAssets = await prisma.vendorSupportsAssets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends vendorSupportsAssetsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, vendorSupportsAssetsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'vendorSupportsAssets'> extends True ? Prisma__vendorSupportsAssetsClient<vendorSupportsAssetsGetPayload<T>> : Prisma__vendorSupportsAssetsClient<vendorSupportsAssetsGetPayload<T> | null, null>

    /**
     * Find one VendorSupportsAssets that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {vendorSupportsAssetsFindUniqueOrThrowArgs} args - Arguments to find a VendorSupportsAssets
     * @example
     * // Get one VendorSupportsAssets
     * const vendorSupportsAssets = await prisma.vendorSupportsAssets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends vendorSupportsAssetsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, vendorSupportsAssetsFindUniqueOrThrowArgs>
    ): Prisma__vendorSupportsAssetsClient<vendorSupportsAssetsGetPayload<T>>

    /**
     * Find the first VendorSupportsAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vendorSupportsAssetsFindFirstArgs} args - Arguments to find a VendorSupportsAssets
     * @example
     * // Get one VendorSupportsAssets
     * const vendorSupportsAssets = await prisma.vendorSupportsAssets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends vendorSupportsAssetsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, vendorSupportsAssetsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'vendorSupportsAssets'> extends True ? Prisma__vendorSupportsAssetsClient<vendorSupportsAssetsGetPayload<T>> : Prisma__vendorSupportsAssetsClient<vendorSupportsAssetsGetPayload<T> | null, null>

    /**
     * Find the first VendorSupportsAssets that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vendorSupportsAssetsFindFirstOrThrowArgs} args - Arguments to find a VendorSupportsAssets
     * @example
     * // Get one VendorSupportsAssets
     * const vendorSupportsAssets = await prisma.vendorSupportsAssets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends vendorSupportsAssetsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, vendorSupportsAssetsFindFirstOrThrowArgs>
    ): Prisma__vendorSupportsAssetsClient<vendorSupportsAssetsGetPayload<T>>

    /**
     * Find zero or more VendorSupportsAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vendorSupportsAssetsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorSupportsAssets
     * const vendorSupportsAssets = await prisma.vendorSupportsAssets.findMany()
     * 
     * // Get first 10 VendorSupportsAssets
     * const vendorSupportsAssets = await prisma.vendorSupportsAssets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorSupportsAssetsWithIdOnly = await prisma.vendorSupportsAssets.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends vendorSupportsAssetsFindManyArgs>(
      args?: SelectSubset<T, vendorSupportsAssetsFindManyArgs>
    ): PrismaPromise<Array<vendorSupportsAssetsGetPayload<T>>>

    /**
     * Create a VendorSupportsAssets.
     * @param {vendorSupportsAssetsCreateArgs} args - Arguments to create a VendorSupportsAssets.
     * @example
     * // Create one VendorSupportsAssets
     * const VendorSupportsAssets = await prisma.vendorSupportsAssets.create({
     *   data: {
     *     // ... data to create a VendorSupportsAssets
     *   }
     * })
     * 
    **/
    create<T extends vendorSupportsAssetsCreateArgs>(
      args: SelectSubset<T, vendorSupportsAssetsCreateArgs>
    ): Prisma__vendorSupportsAssetsClient<vendorSupportsAssetsGetPayload<T>>

    /**
     * Create many VendorSupportsAssets.
     *     @param {vendorSupportsAssetsCreateManyArgs} args - Arguments to create many VendorSupportsAssets.
     *     @example
     *     // Create many VendorSupportsAssets
     *     const vendorSupportsAssets = await prisma.vendorSupportsAssets.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends vendorSupportsAssetsCreateManyArgs>(
      args?: SelectSubset<T, vendorSupportsAssetsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a VendorSupportsAssets.
     * @param {vendorSupportsAssetsDeleteArgs} args - Arguments to delete one VendorSupportsAssets.
     * @example
     * // Delete one VendorSupportsAssets
     * const VendorSupportsAssets = await prisma.vendorSupportsAssets.delete({
     *   where: {
     *     // ... filter to delete one VendorSupportsAssets
     *   }
     * })
     * 
    **/
    delete<T extends vendorSupportsAssetsDeleteArgs>(
      args: SelectSubset<T, vendorSupportsAssetsDeleteArgs>
    ): Prisma__vendorSupportsAssetsClient<vendorSupportsAssetsGetPayload<T>>

    /**
     * Update one VendorSupportsAssets.
     * @param {vendorSupportsAssetsUpdateArgs} args - Arguments to update one VendorSupportsAssets.
     * @example
     * // Update one VendorSupportsAssets
     * const vendorSupportsAssets = await prisma.vendorSupportsAssets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends vendorSupportsAssetsUpdateArgs>(
      args: SelectSubset<T, vendorSupportsAssetsUpdateArgs>
    ): Prisma__vendorSupportsAssetsClient<vendorSupportsAssetsGetPayload<T>>

    /**
     * Delete zero or more VendorSupportsAssets.
     * @param {vendorSupportsAssetsDeleteManyArgs} args - Arguments to filter VendorSupportsAssets to delete.
     * @example
     * // Delete a few VendorSupportsAssets
     * const { count } = await prisma.vendorSupportsAssets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends vendorSupportsAssetsDeleteManyArgs>(
      args?: SelectSubset<T, vendorSupportsAssetsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorSupportsAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vendorSupportsAssetsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorSupportsAssets
     * const vendorSupportsAssets = await prisma.vendorSupportsAssets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends vendorSupportsAssetsUpdateManyArgs>(
      args: SelectSubset<T, vendorSupportsAssetsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one VendorSupportsAssets.
     * @param {vendorSupportsAssetsUpsertArgs} args - Arguments to update or create a VendorSupportsAssets.
     * @example
     * // Update or create a VendorSupportsAssets
     * const vendorSupportsAssets = await prisma.vendorSupportsAssets.upsert({
     *   create: {
     *     // ... data to create a VendorSupportsAssets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorSupportsAssets we want to update
     *   }
     * })
    **/
    upsert<T extends vendorSupportsAssetsUpsertArgs>(
      args: SelectSubset<T, vendorSupportsAssetsUpsertArgs>
    ): Prisma__vendorSupportsAssetsClient<vendorSupportsAssetsGetPayload<T>>

    /**
     * Count the number of VendorSupportsAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vendorSupportsAssetsCountArgs} args - Arguments to filter VendorSupportsAssets to count.
     * @example
     * // Count the number of VendorSupportsAssets
     * const count = await prisma.vendorSupportsAssets.count({
     *   where: {
     *     // ... the filter for the VendorSupportsAssets we want to count
     *   }
     * })
    **/
    count<T extends vendorSupportsAssetsCountArgs>(
      args?: Subset<T, vendorSupportsAssetsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorSupportsAssetsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorSupportsAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorSupportsAssetsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorSupportsAssetsAggregateArgs>(args: Subset<T, VendorSupportsAssetsAggregateArgs>): PrismaPromise<GetVendorSupportsAssetsAggregateType<T>>

    /**
     * Group by VendorSupportsAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorSupportsAssetsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorSupportsAssetsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorSupportsAssetsGroupByArgs['orderBy'] }
        : { orderBy?: VendorSupportsAssetsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorSupportsAssetsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorSupportsAssetsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for vendorSupportsAssets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__vendorSupportsAssetsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    pricingPlanSupportsAssets<T extends vendorSupportsAssets$pricingPlanSupportsAssetsArgs= {}>(args?: Subset<T, vendorSupportsAssets$pricingPlanSupportsAssetsArgs>): PrismaPromise<Array<pricingPlanSupportsAssetsGetPayload<T>>| Null>;

    assets<T extends assetsArgs= {}>(args?: Subset<T, assetsArgs>): Prisma__assetsClient<assetsGetPayload<T> | Null>;

    vendors<T extends vendorsArgs= {}>(args?: Subset<T, vendorsArgs>): Prisma__vendorsClient<vendorsGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * vendorSupportsAssets base type for findUnique actions
   */
  export type vendorSupportsAssetsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the vendorSupportsAssets
     */
    select?: vendorSupportsAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorSupportsAssetsInclude | null
    /**
     * Filter, which vendorSupportsAssets to fetch.
     */
    where: vendorSupportsAssetsWhereUniqueInput
  }

  /**
   * vendorSupportsAssets findUnique
   */
  export interface vendorSupportsAssetsFindUniqueArgs extends vendorSupportsAssetsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * vendorSupportsAssets findUniqueOrThrow
   */
  export type vendorSupportsAssetsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the vendorSupportsAssets
     */
    select?: vendorSupportsAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorSupportsAssetsInclude | null
    /**
     * Filter, which vendorSupportsAssets to fetch.
     */
    where: vendorSupportsAssetsWhereUniqueInput
  }


  /**
   * vendorSupportsAssets base type for findFirst actions
   */
  export type vendorSupportsAssetsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the vendorSupportsAssets
     */
    select?: vendorSupportsAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorSupportsAssetsInclude | null
    /**
     * Filter, which vendorSupportsAssets to fetch.
     */
    where?: vendorSupportsAssetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vendorSupportsAssets to fetch.
     */
    orderBy?: Enumerable<vendorSupportsAssetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vendorSupportsAssets.
     */
    cursor?: vendorSupportsAssetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vendorSupportsAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vendorSupportsAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vendorSupportsAssets.
     */
    distinct?: Enumerable<VendorSupportsAssetsScalarFieldEnum>
  }

  /**
   * vendorSupportsAssets findFirst
   */
  export interface vendorSupportsAssetsFindFirstArgs extends vendorSupportsAssetsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * vendorSupportsAssets findFirstOrThrow
   */
  export type vendorSupportsAssetsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the vendorSupportsAssets
     */
    select?: vendorSupportsAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorSupportsAssetsInclude | null
    /**
     * Filter, which vendorSupportsAssets to fetch.
     */
    where?: vendorSupportsAssetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vendorSupportsAssets to fetch.
     */
    orderBy?: Enumerable<vendorSupportsAssetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vendorSupportsAssets.
     */
    cursor?: vendorSupportsAssetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vendorSupportsAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vendorSupportsAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vendorSupportsAssets.
     */
    distinct?: Enumerable<VendorSupportsAssetsScalarFieldEnum>
  }


  /**
   * vendorSupportsAssets findMany
   */
  export type vendorSupportsAssetsFindManyArgs = {
    /**
     * Select specific fields to fetch from the vendorSupportsAssets
     */
    select?: vendorSupportsAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorSupportsAssetsInclude | null
    /**
     * Filter, which vendorSupportsAssets to fetch.
     */
    where?: vendorSupportsAssetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vendorSupportsAssets to fetch.
     */
    orderBy?: Enumerable<vendorSupportsAssetsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vendorSupportsAssets.
     */
    cursor?: vendorSupportsAssetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vendorSupportsAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vendorSupportsAssets.
     */
    skip?: number
    distinct?: Enumerable<VendorSupportsAssetsScalarFieldEnum>
  }


  /**
   * vendorSupportsAssets create
   */
  export type vendorSupportsAssetsCreateArgs = {
    /**
     * Select specific fields to fetch from the vendorSupportsAssets
     */
    select?: vendorSupportsAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorSupportsAssetsInclude | null
    /**
     * The data needed to create a vendorSupportsAssets.
     */
    data: XOR<vendorSupportsAssetsCreateInput, vendorSupportsAssetsUncheckedCreateInput>
  }


  /**
   * vendorSupportsAssets createMany
   */
  export type vendorSupportsAssetsCreateManyArgs = {
    /**
     * The data used to create many vendorSupportsAssets.
     */
    data: Enumerable<vendorSupportsAssetsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * vendorSupportsAssets update
   */
  export type vendorSupportsAssetsUpdateArgs = {
    /**
     * Select specific fields to fetch from the vendorSupportsAssets
     */
    select?: vendorSupportsAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorSupportsAssetsInclude | null
    /**
     * The data needed to update a vendorSupportsAssets.
     */
    data: XOR<vendorSupportsAssetsUpdateInput, vendorSupportsAssetsUncheckedUpdateInput>
    /**
     * Choose, which vendorSupportsAssets to update.
     */
    where: vendorSupportsAssetsWhereUniqueInput
  }


  /**
   * vendorSupportsAssets updateMany
   */
  export type vendorSupportsAssetsUpdateManyArgs = {
    /**
     * The data used to update vendorSupportsAssets.
     */
    data: XOR<vendorSupportsAssetsUpdateManyMutationInput, vendorSupportsAssetsUncheckedUpdateManyInput>
    /**
     * Filter which vendorSupportsAssets to update
     */
    where?: vendorSupportsAssetsWhereInput
  }


  /**
   * vendorSupportsAssets upsert
   */
  export type vendorSupportsAssetsUpsertArgs = {
    /**
     * Select specific fields to fetch from the vendorSupportsAssets
     */
    select?: vendorSupportsAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorSupportsAssetsInclude | null
    /**
     * The filter to search for the vendorSupportsAssets to update in case it exists.
     */
    where: vendorSupportsAssetsWhereUniqueInput
    /**
     * In case the vendorSupportsAssets found by the `where` argument doesn't exist, create a new vendorSupportsAssets with this data.
     */
    create: XOR<vendorSupportsAssetsCreateInput, vendorSupportsAssetsUncheckedCreateInput>
    /**
     * In case the vendorSupportsAssets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vendorSupportsAssetsUpdateInput, vendorSupportsAssetsUncheckedUpdateInput>
  }


  /**
   * vendorSupportsAssets delete
   */
  export type vendorSupportsAssetsDeleteArgs = {
    /**
     * Select specific fields to fetch from the vendorSupportsAssets
     */
    select?: vendorSupportsAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorSupportsAssetsInclude | null
    /**
     * Filter which vendorSupportsAssets to delete.
     */
    where: vendorSupportsAssetsWhereUniqueInput
  }


  /**
   * vendorSupportsAssets deleteMany
   */
  export type vendorSupportsAssetsDeleteManyArgs = {
    /**
     * Filter which vendorSupportsAssets to delete
     */
    where?: vendorSupportsAssetsWhereInput
  }


  /**
   * vendorSupportsAssets.pricingPlanSupportsAssets
   */
  export type vendorSupportsAssets$pricingPlanSupportsAssetsArgs = {
    /**
     * Select specific fields to fetch from the pricingPlanSupportsAssets
     */
    select?: pricingPlanSupportsAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: pricingPlanSupportsAssetsInclude | null
    where?: pricingPlanSupportsAssetsWhereInput
    orderBy?: Enumerable<pricingPlanSupportsAssetsOrderByWithRelationInput>
    cursor?: pricingPlanSupportsAssetsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PricingPlanSupportsAssetsScalarFieldEnum>
  }


  /**
   * vendorSupportsAssets without action
   */
  export type vendorSupportsAssetsArgs = {
    /**
     * Select specific fields to fetch from the vendorSupportsAssets
     */
    select?: vendorSupportsAssetsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: vendorSupportsAssetsInclude | null
  }



  /**
   * Model webhookRequests
   */


  export type AggregateWebhookRequests = {
    _count: WebhookRequestsCountAggregateOutputType | null
    _avg: WebhookRequestsAvgAggregateOutputType | null
    _sum: WebhookRequestsSumAggregateOutputType | null
    _min: WebhookRequestsMinAggregateOutputType | null
    _max: WebhookRequestsMaxAggregateOutputType | null
  }

  export type WebhookRequestsAvgAggregateOutputType = {
    httpStatusCode: number | null
  }

  export type WebhookRequestsSumAggregateOutputType = {
    httpStatusCode: number | null
  }

  export type WebhookRequestsMinAggregateOutputType = {
    id: string | null
    webhookId: string | null
    institutionalProductId: string | null
    httpStatusCode: number | null
    custodyEngineEventId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhookRequestsMaxAggregateOutputType = {
    id: string | null
    webhookId: string | null
    institutionalProductId: string | null
    httpStatusCode: number | null
    custodyEngineEventId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhookRequestsCountAggregateOutputType = {
    id: number
    webhookId: number
    institutionalProductId: number
    httpStatusCode: number
    requestPayload: number
    responsePayload: number
    custodyEngineEventId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WebhookRequestsAvgAggregateInputType = {
    httpStatusCode?: true
  }

  export type WebhookRequestsSumAggregateInputType = {
    httpStatusCode?: true
  }

  export type WebhookRequestsMinAggregateInputType = {
    id?: true
    webhookId?: true
    institutionalProductId?: true
    httpStatusCode?: true
    custodyEngineEventId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhookRequestsMaxAggregateInputType = {
    id?: true
    webhookId?: true
    institutionalProductId?: true
    httpStatusCode?: true
    custodyEngineEventId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhookRequestsCountAggregateInputType = {
    id?: true
    webhookId?: true
    institutionalProductId?: true
    httpStatusCode?: true
    requestPayload?: true
    responsePayload?: true
    custodyEngineEventId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WebhookRequestsAggregateArgs = {
    /**
     * Filter which webhookRequests to aggregate.
     */
    where?: webhookRequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webhookRequests to fetch.
     */
    orderBy?: Enumerable<webhookRequestsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: webhookRequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webhookRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webhookRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned webhookRequests
    **/
    _count?: true | WebhookRequestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookRequestsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookRequestsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookRequestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookRequestsMaxAggregateInputType
  }

  export type GetWebhookRequestsAggregateType<T extends WebhookRequestsAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookRequests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookRequests[P]>
      : GetScalarType<T[P], AggregateWebhookRequests[P]>
  }




  export type WebhookRequestsGroupByArgs = {
    where?: webhookRequestsWhereInput
    orderBy?: Enumerable<webhookRequestsOrderByWithAggregationInput>
    by: WebhookRequestsScalarFieldEnum[]
    having?: webhookRequestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookRequestsCountAggregateInputType | true
    _avg?: WebhookRequestsAvgAggregateInputType
    _sum?: WebhookRequestsSumAggregateInputType
    _min?: WebhookRequestsMinAggregateInputType
    _max?: WebhookRequestsMaxAggregateInputType
  }


  export type WebhookRequestsGroupByOutputType = {
    id: string
    webhookId: string
    institutionalProductId: string | null
    httpStatusCode: number
    requestPayload: JsonValue
    responsePayload: JsonValue | null
    custodyEngineEventId: string | null
    createdAt: Date
    updatedAt: Date
    _count: WebhookRequestsCountAggregateOutputType | null
    _avg: WebhookRequestsAvgAggregateOutputType | null
    _sum: WebhookRequestsSumAggregateOutputType | null
    _min: WebhookRequestsMinAggregateOutputType | null
    _max: WebhookRequestsMaxAggregateOutputType | null
  }

  type GetWebhookRequestsGroupByPayload<T extends WebhookRequestsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<WebhookRequestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookRequestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookRequestsGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookRequestsGroupByOutputType[P]>
        }
      >
    >


  export type webhookRequestsSelect = {
    id?: boolean
    webhookId?: boolean
    institutionalProductId?: boolean
    httpStatusCode?: boolean
    requestPayload?: boolean
    responsePayload?: boolean
    custodyEngineEventId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    custodyEngineEvents?: boolean | custodyEngineEventsArgs
    institutionalProducts?: boolean | institutionalProductsArgs
    webhooks?: boolean | webhooksArgs
  }


  export type webhookRequestsInclude = {
    custodyEngineEvents?: boolean | custodyEngineEventsArgs
    institutionalProducts?: boolean | institutionalProductsArgs
    webhooks?: boolean | webhooksArgs
  }

  export type webhookRequestsGetPayload<S extends boolean | null | undefined | webhookRequestsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? webhookRequests :
    S extends undefined ? never :
    S extends { include: any } & (webhookRequestsArgs | webhookRequestsFindManyArgs)
    ? webhookRequests  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'custodyEngineEvents' ? custodyEngineEventsGetPayload<S['include'][P]> | null :
        P extends 'institutionalProducts' ? institutionalProductsGetPayload<S['include'][P]> | null :
        P extends 'webhooks' ? webhooksGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (webhookRequestsArgs | webhookRequestsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'custodyEngineEvents' ? custodyEngineEventsGetPayload<S['select'][P]> | null :
        P extends 'institutionalProducts' ? institutionalProductsGetPayload<S['select'][P]> | null :
        P extends 'webhooks' ? webhooksGetPayload<S['select'][P]> :  P extends keyof webhookRequests ? webhookRequests[P] : never
  } 
      : webhookRequests


  type webhookRequestsCountArgs = 
    Omit<webhookRequestsFindManyArgs, 'select' | 'include'> & {
      select?: WebhookRequestsCountAggregateInputType | true
    }

  export interface webhookRequestsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one WebhookRequests that matches the filter.
     * @param {webhookRequestsFindUniqueArgs} args - Arguments to find a WebhookRequests
     * @example
     * // Get one WebhookRequests
     * const webhookRequests = await prisma.webhookRequests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends webhookRequestsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, webhookRequestsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'webhookRequests'> extends True ? Prisma__webhookRequestsClient<webhookRequestsGetPayload<T>> : Prisma__webhookRequestsClient<webhookRequestsGetPayload<T> | null, null>

    /**
     * Find one WebhookRequests that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {webhookRequestsFindUniqueOrThrowArgs} args - Arguments to find a WebhookRequests
     * @example
     * // Get one WebhookRequests
     * const webhookRequests = await prisma.webhookRequests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends webhookRequestsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, webhookRequestsFindUniqueOrThrowArgs>
    ): Prisma__webhookRequestsClient<webhookRequestsGetPayload<T>>

    /**
     * Find the first WebhookRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhookRequestsFindFirstArgs} args - Arguments to find a WebhookRequests
     * @example
     * // Get one WebhookRequests
     * const webhookRequests = await prisma.webhookRequests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends webhookRequestsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, webhookRequestsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'webhookRequests'> extends True ? Prisma__webhookRequestsClient<webhookRequestsGetPayload<T>> : Prisma__webhookRequestsClient<webhookRequestsGetPayload<T> | null, null>

    /**
     * Find the first WebhookRequests that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhookRequestsFindFirstOrThrowArgs} args - Arguments to find a WebhookRequests
     * @example
     * // Get one WebhookRequests
     * const webhookRequests = await prisma.webhookRequests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends webhookRequestsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, webhookRequestsFindFirstOrThrowArgs>
    ): Prisma__webhookRequestsClient<webhookRequestsGetPayload<T>>

    /**
     * Find zero or more WebhookRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhookRequestsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookRequests
     * const webhookRequests = await prisma.webhookRequests.findMany()
     * 
     * // Get first 10 WebhookRequests
     * const webhookRequests = await prisma.webhookRequests.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookRequestsWithIdOnly = await prisma.webhookRequests.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends webhookRequestsFindManyArgs>(
      args?: SelectSubset<T, webhookRequestsFindManyArgs>
    ): PrismaPromise<Array<webhookRequestsGetPayload<T>>>

    /**
     * Create a WebhookRequests.
     * @param {webhookRequestsCreateArgs} args - Arguments to create a WebhookRequests.
     * @example
     * // Create one WebhookRequests
     * const WebhookRequests = await prisma.webhookRequests.create({
     *   data: {
     *     // ... data to create a WebhookRequests
     *   }
     * })
     * 
    **/
    create<T extends webhookRequestsCreateArgs>(
      args: SelectSubset<T, webhookRequestsCreateArgs>
    ): Prisma__webhookRequestsClient<webhookRequestsGetPayload<T>>

    /**
     * Create many WebhookRequests.
     *     @param {webhookRequestsCreateManyArgs} args - Arguments to create many WebhookRequests.
     *     @example
     *     // Create many WebhookRequests
     *     const webhookRequests = await prisma.webhookRequests.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends webhookRequestsCreateManyArgs>(
      args?: SelectSubset<T, webhookRequestsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a WebhookRequests.
     * @param {webhookRequestsDeleteArgs} args - Arguments to delete one WebhookRequests.
     * @example
     * // Delete one WebhookRequests
     * const WebhookRequests = await prisma.webhookRequests.delete({
     *   where: {
     *     // ... filter to delete one WebhookRequests
     *   }
     * })
     * 
    **/
    delete<T extends webhookRequestsDeleteArgs>(
      args: SelectSubset<T, webhookRequestsDeleteArgs>
    ): Prisma__webhookRequestsClient<webhookRequestsGetPayload<T>>

    /**
     * Update one WebhookRequests.
     * @param {webhookRequestsUpdateArgs} args - Arguments to update one WebhookRequests.
     * @example
     * // Update one WebhookRequests
     * const webhookRequests = await prisma.webhookRequests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends webhookRequestsUpdateArgs>(
      args: SelectSubset<T, webhookRequestsUpdateArgs>
    ): Prisma__webhookRequestsClient<webhookRequestsGetPayload<T>>

    /**
     * Delete zero or more WebhookRequests.
     * @param {webhookRequestsDeleteManyArgs} args - Arguments to filter WebhookRequests to delete.
     * @example
     * // Delete a few WebhookRequests
     * const { count } = await prisma.webhookRequests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends webhookRequestsDeleteManyArgs>(
      args?: SelectSubset<T, webhookRequestsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhookRequestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookRequests
     * const webhookRequests = await prisma.webhookRequests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends webhookRequestsUpdateManyArgs>(
      args: SelectSubset<T, webhookRequestsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one WebhookRequests.
     * @param {webhookRequestsUpsertArgs} args - Arguments to update or create a WebhookRequests.
     * @example
     * // Update or create a WebhookRequests
     * const webhookRequests = await prisma.webhookRequests.upsert({
     *   create: {
     *     // ... data to create a WebhookRequests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookRequests we want to update
     *   }
     * })
    **/
    upsert<T extends webhookRequestsUpsertArgs>(
      args: SelectSubset<T, webhookRequestsUpsertArgs>
    ): Prisma__webhookRequestsClient<webhookRequestsGetPayload<T>>

    /**
     * Count the number of WebhookRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhookRequestsCountArgs} args - Arguments to filter WebhookRequests to count.
     * @example
     * // Count the number of WebhookRequests
     * const count = await prisma.webhookRequests.count({
     *   where: {
     *     // ... the filter for the WebhookRequests we want to count
     *   }
     * })
    **/
    count<T extends webhookRequestsCountArgs>(
      args?: Subset<T, webhookRequestsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookRequestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookRequestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookRequestsAggregateArgs>(args: Subset<T, WebhookRequestsAggregateArgs>): PrismaPromise<GetWebhookRequestsAggregateType<T>>

    /**
     * Group by WebhookRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookRequestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookRequestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookRequestsGroupByArgs['orderBy'] }
        : { orderBy?: WebhookRequestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookRequestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookRequestsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for webhookRequests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__webhookRequestsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    custodyEngineEvents<T extends custodyEngineEventsArgs= {}>(args?: Subset<T, custodyEngineEventsArgs>): Prisma__custodyEngineEventsClient<custodyEngineEventsGetPayload<T> | Null>;

    institutionalProducts<T extends institutionalProductsArgs= {}>(args?: Subset<T, institutionalProductsArgs>): Prisma__institutionalProductsClient<institutionalProductsGetPayload<T> | Null>;

    webhooks<T extends webhooksArgs= {}>(args?: Subset<T, webhooksArgs>): Prisma__webhooksClient<webhooksGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * webhookRequests base type for findUnique actions
   */
  export type webhookRequestsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the webhookRequests
     */
    select?: webhookRequestsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhookRequestsInclude | null
    /**
     * Filter, which webhookRequests to fetch.
     */
    where: webhookRequestsWhereUniqueInput
  }

  /**
   * webhookRequests findUnique
   */
  export interface webhookRequestsFindUniqueArgs extends webhookRequestsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * webhookRequests findUniqueOrThrow
   */
  export type webhookRequestsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the webhookRequests
     */
    select?: webhookRequestsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhookRequestsInclude | null
    /**
     * Filter, which webhookRequests to fetch.
     */
    where: webhookRequestsWhereUniqueInput
  }


  /**
   * webhookRequests base type for findFirst actions
   */
  export type webhookRequestsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the webhookRequests
     */
    select?: webhookRequestsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhookRequestsInclude | null
    /**
     * Filter, which webhookRequests to fetch.
     */
    where?: webhookRequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webhookRequests to fetch.
     */
    orderBy?: Enumerable<webhookRequestsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for webhookRequests.
     */
    cursor?: webhookRequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webhookRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webhookRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of webhookRequests.
     */
    distinct?: Enumerable<WebhookRequestsScalarFieldEnum>
  }

  /**
   * webhookRequests findFirst
   */
  export interface webhookRequestsFindFirstArgs extends webhookRequestsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * webhookRequests findFirstOrThrow
   */
  export type webhookRequestsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the webhookRequests
     */
    select?: webhookRequestsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhookRequestsInclude | null
    /**
     * Filter, which webhookRequests to fetch.
     */
    where?: webhookRequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webhookRequests to fetch.
     */
    orderBy?: Enumerable<webhookRequestsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for webhookRequests.
     */
    cursor?: webhookRequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webhookRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webhookRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of webhookRequests.
     */
    distinct?: Enumerable<WebhookRequestsScalarFieldEnum>
  }


  /**
   * webhookRequests findMany
   */
  export type webhookRequestsFindManyArgs = {
    /**
     * Select specific fields to fetch from the webhookRequests
     */
    select?: webhookRequestsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhookRequestsInclude | null
    /**
     * Filter, which webhookRequests to fetch.
     */
    where?: webhookRequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webhookRequests to fetch.
     */
    orderBy?: Enumerable<webhookRequestsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing webhookRequests.
     */
    cursor?: webhookRequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webhookRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webhookRequests.
     */
    skip?: number
    distinct?: Enumerable<WebhookRequestsScalarFieldEnum>
  }


  /**
   * webhookRequests create
   */
  export type webhookRequestsCreateArgs = {
    /**
     * Select specific fields to fetch from the webhookRequests
     */
    select?: webhookRequestsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhookRequestsInclude | null
    /**
     * The data needed to create a webhookRequests.
     */
    data: XOR<webhookRequestsCreateInput, webhookRequestsUncheckedCreateInput>
  }


  /**
   * webhookRequests createMany
   */
  export type webhookRequestsCreateManyArgs = {
    /**
     * The data used to create many webhookRequests.
     */
    data: Enumerable<webhookRequestsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * webhookRequests update
   */
  export type webhookRequestsUpdateArgs = {
    /**
     * Select specific fields to fetch from the webhookRequests
     */
    select?: webhookRequestsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhookRequestsInclude | null
    /**
     * The data needed to update a webhookRequests.
     */
    data: XOR<webhookRequestsUpdateInput, webhookRequestsUncheckedUpdateInput>
    /**
     * Choose, which webhookRequests to update.
     */
    where: webhookRequestsWhereUniqueInput
  }


  /**
   * webhookRequests updateMany
   */
  export type webhookRequestsUpdateManyArgs = {
    /**
     * The data used to update webhookRequests.
     */
    data: XOR<webhookRequestsUpdateManyMutationInput, webhookRequestsUncheckedUpdateManyInput>
    /**
     * Filter which webhookRequests to update
     */
    where?: webhookRequestsWhereInput
  }


  /**
   * webhookRequests upsert
   */
  export type webhookRequestsUpsertArgs = {
    /**
     * Select specific fields to fetch from the webhookRequests
     */
    select?: webhookRequestsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhookRequestsInclude | null
    /**
     * The filter to search for the webhookRequests to update in case it exists.
     */
    where: webhookRequestsWhereUniqueInput
    /**
     * In case the webhookRequests found by the `where` argument doesn't exist, create a new webhookRequests with this data.
     */
    create: XOR<webhookRequestsCreateInput, webhookRequestsUncheckedCreateInput>
    /**
     * In case the webhookRequests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<webhookRequestsUpdateInput, webhookRequestsUncheckedUpdateInput>
  }


  /**
   * webhookRequests delete
   */
  export type webhookRequestsDeleteArgs = {
    /**
     * Select specific fields to fetch from the webhookRequests
     */
    select?: webhookRequestsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhookRequestsInclude | null
    /**
     * Filter which webhookRequests to delete.
     */
    where: webhookRequestsWhereUniqueInput
  }


  /**
   * webhookRequests deleteMany
   */
  export type webhookRequestsDeleteManyArgs = {
    /**
     * Filter which webhookRequests to delete
     */
    where?: webhookRequestsWhereInput
  }


  /**
   * webhookRequests without action
   */
  export type webhookRequestsArgs = {
    /**
     * Select specific fields to fetch from the webhookRequests
     */
    select?: webhookRequestsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhookRequestsInclude | null
  }



  /**
   * Model webhookStatusTypes
   */


  export type AggregateWebhookStatusTypes = {
    _count: WebhookStatusTypesCountAggregateOutputType | null
    _avg: WebhookStatusTypesAvgAggregateOutputType | null
    _sum: WebhookStatusTypesSumAggregateOutputType | null
    _min: WebhookStatusTypesMinAggregateOutputType | null
    _max: WebhookStatusTypesMaxAggregateOutputType | null
  }

  export type WebhookStatusTypesAvgAggregateOutputType = {
    id: number | null
  }

  export type WebhookStatusTypesSumAggregateOutputType = {
    id: number | null
  }

  export type WebhookStatusTypesMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhookStatusTypesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhookStatusTypesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WebhookStatusTypesAvgAggregateInputType = {
    id?: true
  }

  export type WebhookStatusTypesSumAggregateInputType = {
    id?: true
  }

  export type WebhookStatusTypesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhookStatusTypesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhookStatusTypesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WebhookStatusTypesAggregateArgs = {
    /**
     * Filter which webhookStatusTypes to aggregate.
     */
    where?: webhookStatusTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webhookStatusTypes to fetch.
     */
    orderBy?: Enumerable<webhookStatusTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: webhookStatusTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webhookStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webhookStatusTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned webhookStatusTypes
    **/
    _count?: true | WebhookStatusTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookStatusTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookStatusTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookStatusTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookStatusTypesMaxAggregateInputType
  }

  export type GetWebhookStatusTypesAggregateType<T extends WebhookStatusTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookStatusTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookStatusTypes[P]>
      : GetScalarType<T[P], AggregateWebhookStatusTypes[P]>
  }




  export type WebhookStatusTypesGroupByArgs = {
    where?: webhookStatusTypesWhereInput
    orderBy?: Enumerable<webhookStatusTypesOrderByWithAggregationInput>
    by: WebhookStatusTypesScalarFieldEnum[]
    having?: webhookStatusTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookStatusTypesCountAggregateInputType | true
    _avg?: WebhookStatusTypesAvgAggregateInputType
    _sum?: WebhookStatusTypesSumAggregateInputType
    _min?: WebhookStatusTypesMinAggregateInputType
    _max?: WebhookStatusTypesMaxAggregateInputType
  }


  export type WebhookStatusTypesGroupByOutputType = {
    id: number
    name: string
    description: string
    createdAt: Date
    updatedAt: Date
    _count: WebhookStatusTypesCountAggregateOutputType | null
    _avg: WebhookStatusTypesAvgAggregateOutputType | null
    _sum: WebhookStatusTypesSumAggregateOutputType | null
    _min: WebhookStatusTypesMinAggregateOutputType | null
    _max: WebhookStatusTypesMaxAggregateOutputType | null
  }

  type GetWebhookStatusTypesGroupByPayload<T extends WebhookStatusTypesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<WebhookStatusTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookStatusTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookStatusTypesGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookStatusTypesGroupByOutputType[P]>
        }
      >
    >


  export type webhookStatusTypesSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    webhooks?: boolean | webhookStatusTypes$webhooksArgs
    _count?: boolean | WebhookStatusTypesCountOutputTypeArgs
  }


  export type webhookStatusTypesInclude = {
    webhooks?: boolean | webhookStatusTypes$webhooksArgs
    _count?: boolean | WebhookStatusTypesCountOutputTypeArgs
  }

  export type webhookStatusTypesGetPayload<S extends boolean | null | undefined | webhookStatusTypesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? webhookStatusTypes :
    S extends undefined ? never :
    S extends { include: any } & (webhookStatusTypesArgs | webhookStatusTypesFindManyArgs)
    ? webhookStatusTypes  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'webhooks' ? Array < webhooksGetPayload<S['include'][P]>>  :
        P extends '_count' ? WebhookStatusTypesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (webhookStatusTypesArgs | webhookStatusTypesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'webhooks' ? Array < webhooksGetPayload<S['select'][P]>>  :
        P extends '_count' ? WebhookStatusTypesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof webhookStatusTypes ? webhookStatusTypes[P] : never
  } 
      : webhookStatusTypes


  type webhookStatusTypesCountArgs = 
    Omit<webhookStatusTypesFindManyArgs, 'select' | 'include'> & {
      select?: WebhookStatusTypesCountAggregateInputType | true
    }

  export interface webhookStatusTypesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one WebhookStatusTypes that matches the filter.
     * @param {webhookStatusTypesFindUniqueArgs} args - Arguments to find a WebhookStatusTypes
     * @example
     * // Get one WebhookStatusTypes
     * const webhookStatusTypes = await prisma.webhookStatusTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends webhookStatusTypesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, webhookStatusTypesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'webhookStatusTypes'> extends True ? Prisma__webhookStatusTypesClient<webhookStatusTypesGetPayload<T>> : Prisma__webhookStatusTypesClient<webhookStatusTypesGetPayload<T> | null, null>

    /**
     * Find one WebhookStatusTypes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {webhookStatusTypesFindUniqueOrThrowArgs} args - Arguments to find a WebhookStatusTypes
     * @example
     * // Get one WebhookStatusTypes
     * const webhookStatusTypes = await prisma.webhookStatusTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends webhookStatusTypesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, webhookStatusTypesFindUniqueOrThrowArgs>
    ): Prisma__webhookStatusTypesClient<webhookStatusTypesGetPayload<T>>

    /**
     * Find the first WebhookStatusTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhookStatusTypesFindFirstArgs} args - Arguments to find a WebhookStatusTypes
     * @example
     * // Get one WebhookStatusTypes
     * const webhookStatusTypes = await prisma.webhookStatusTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends webhookStatusTypesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, webhookStatusTypesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'webhookStatusTypes'> extends True ? Prisma__webhookStatusTypesClient<webhookStatusTypesGetPayload<T>> : Prisma__webhookStatusTypesClient<webhookStatusTypesGetPayload<T> | null, null>

    /**
     * Find the first WebhookStatusTypes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhookStatusTypesFindFirstOrThrowArgs} args - Arguments to find a WebhookStatusTypes
     * @example
     * // Get one WebhookStatusTypes
     * const webhookStatusTypes = await prisma.webhookStatusTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends webhookStatusTypesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, webhookStatusTypesFindFirstOrThrowArgs>
    ): Prisma__webhookStatusTypesClient<webhookStatusTypesGetPayload<T>>

    /**
     * Find zero or more WebhookStatusTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhookStatusTypesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookStatusTypes
     * const webhookStatusTypes = await prisma.webhookStatusTypes.findMany()
     * 
     * // Get first 10 WebhookStatusTypes
     * const webhookStatusTypes = await prisma.webhookStatusTypes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookStatusTypesWithIdOnly = await prisma.webhookStatusTypes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends webhookStatusTypesFindManyArgs>(
      args?: SelectSubset<T, webhookStatusTypesFindManyArgs>
    ): PrismaPromise<Array<webhookStatusTypesGetPayload<T>>>

    /**
     * Create a WebhookStatusTypes.
     * @param {webhookStatusTypesCreateArgs} args - Arguments to create a WebhookStatusTypes.
     * @example
     * // Create one WebhookStatusTypes
     * const WebhookStatusTypes = await prisma.webhookStatusTypes.create({
     *   data: {
     *     // ... data to create a WebhookStatusTypes
     *   }
     * })
     * 
    **/
    create<T extends webhookStatusTypesCreateArgs>(
      args: SelectSubset<T, webhookStatusTypesCreateArgs>
    ): Prisma__webhookStatusTypesClient<webhookStatusTypesGetPayload<T>>

    /**
     * Create many WebhookStatusTypes.
     *     @param {webhookStatusTypesCreateManyArgs} args - Arguments to create many WebhookStatusTypes.
     *     @example
     *     // Create many WebhookStatusTypes
     *     const webhookStatusTypes = await prisma.webhookStatusTypes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends webhookStatusTypesCreateManyArgs>(
      args?: SelectSubset<T, webhookStatusTypesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a WebhookStatusTypes.
     * @param {webhookStatusTypesDeleteArgs} args - Arguments to delete one WebhookStatusTypes.
     * @example
     * // Delete one WebhookStatusTypes
     * const WebhookStatusTypes = await prisma.webhookStatusTypes.delete({
     *   where: {
     *     // ... filter to delete one WebhookStatusTypes
     *   }
     * })
     * 
    **/
    delete<T extends webhookStatusTypesDeleteArgs>(
      args: SelectSubset<T, webhookStatusTypesDeleteArgs>
    ): Prisma__webhookStatusTypesClient<webhookStatusTypesGetPayload<T>>

    /**
     * Update one WebhookStatusTypes.
     * @param {webhookStatusTypesUpdateArgs} args - Arguments to update one WebhookStatusTypes.
     * @example
     * // Update one WebhookStatusTypes
     * const webhookStatusTypes = await prisma.webhookStatusTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends webhookStatusTypesUpdateArgs>(
      args: SelectSubset<T, webhookStatusTypesUpdateArgs>
    ): Prisma__webhookStatusTypesClient<webhookStatusTypesGetPayload<T>>

    /**
     * Delete zero or more WebhookStatusTypes.
     * @param {webhookStatusTypesDeleteManyArgs} args - Arguments to filter WebhookStatusTypes to delete.
     * @example
     * // Delete a few WebhookStatusTypes
     * const { count } = await prisma.webhookStatusTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends webhookStatusTypesDeleteManyArgs>(
      args?: SelectSubset<T, webhookStatusTypesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookStatusTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhookStatusTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookStatusTypes
     * const webhookStatusTypes = await prisma.webhookStatusTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends webhookStatusTypesUpdateManyArgs>(
      args: SelectSubset<T, webhookStatusTypesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one WebhookStatusTypes.
     * @param {webhookStatusTypesUpsertArgs} args - Arguments to update or create a WebhookStatusTypes.
     * @example
     * // Update or create a WebhookStatusTypes
     * const webhookStatusTypes = await prisma.webhookStatusTypes.upsert({
     *   create: {
     *     // ... data to create a WebhookStatusTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookStatusTypes we want to update
     *   }
     * })
    **/
    upsert<T extends webhookStatusTypesUpsertArgs>(
      args: SelectSubset<T, webhookStatusTypesUpsertArgs>
    ): Prisma__webhookStatusTypesClient<webhookStatusTypesGetPayload<T>>

    /**
     * Count the number of WebhookStatusTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhookStatusTypesCountArgs} args - Arguments to filter WebhookStatusTypes to count.
     * @example
     * // Count the number of WebhookStatusTypes
     * const count = await prisma.webhookStatusTypes.count({
     *   where: {
     *     // ... the filter for the WebhookStatusTypes we want to count
     *   }
     * })
    **/
    count<T extends webhookStatusTypesCountArgs>(
      args?: Subset<T, webhookStatusTypesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookStatusTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookStatusTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookStatusTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookStatusTypesAggregateArgs>(args: Subset<T, WebhookStatusTypesAggregateArgs>): PrismaPromise<GetWebhookStatusTypesAggregateType<T>>

    /**
     * Group by WebhookStatusTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookStatusTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookStatusTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookStatusTypesGroupByArgs['orderBy'] }
        : { orderBy?: WebhookStatusTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookStatusTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookStatusTypesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for webhookStatusTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__webhookStatusTypesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    webhooks<T extends webhookStatusTypes$webhooksArgs= {}>(args?: Subset<T, webhookStatusTypes$webhooksArgs>): PrismaPromise<Array<webhooksGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * webhookStatusTypes base type for findUnique actions
   */
  export type webhookStatusTypesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the webhookStatusTypes
     */
    select?: webhookStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhookStatusTypesInclude | null
    /**
     * Filter, which webhookStatusTypes to fetch.
     */
    where: webhookStatusTypesWhereUniqueInput
  }

  /**
   * webhookStatusTypes findUnique
   */
  export interface webhookStatusTypesFindUniqueArgs extends webhookStatusTypesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * webhookStatusTypes findUniqueOrThrow
   */
  export type webhookStatusTypesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the webhookStatusTypes
     */
    select?: webhookStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhookStatusTypesInclude | null
    /**
     * Filter, which webhookStatusTypes to fetch.
     */
    where: webhookStatusTypesWhereUniqueInput
  }


  /**
   * webhookStatusTypes base type for findFirst actions
   */
  export type webhookStatusTypesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the webhookStatusTypes
     */
    select?: webhookStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhookStatusTypesInclude | null
    /**
     * Filter, which webhookStatusTypes to fetch.
     */
    where?: webhookStatusTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webhookStatusTypes to fetch.
     */
    orderBy?: Enumerable<webhookStatusTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for webhookStatusTypes.
     */
    cursor?: webhookStatusTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webhookStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webhookStatusTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of webhookStatusTypes.
     */
    distinct?: Enumerable<WebhookStatusTypesScalarFieldEnum>
  }

  /**
   * webhookStatusTypes findFirst
   */
  export interface webhookStatusTypesFindFirstArgs extends webhookStatusTypesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * webhookStatusTypes findFirstOrThrow
   */
  export type webhookStatusTypesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the webhookStatusTypes
     */
    select?: webhookStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhookStatusTypesInclude | null
    /**
     * Filter, which webhookStatusTypes to fetch.
     */
    where?: webhookStatusTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webhookStatusTypes to fetch.
     */
    orderBy?: Enumerable<webhookStatusTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for webhookStatusTypes.
     */
    cursor?: webhookStatusTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webhookStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webhookStatusTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of webhookStatusTypes.
     */
    distinct?: Enumerable<WebhookStatusTypesScalarFieldEnum>
  }


  /**
   * webhookStatusTypes findMany
   */
  export type webhookStatusTypesFindManyArgs = {
    /**
     * Select specific fields to fetch from the webhookStatusTypes
     */
    select?: webhookStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhookStatusTypesInclude | null
    /**
     * Filter, which webhookStatusTypes to fetch.
     */
    where?: webhookStatusTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webhookStatusTypes to fetch.
     */
    orderBy?: Enumerable<webhookStatusTypesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing webhookStatusTypes.
     */
    cursor?: webhookStatusTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webhookStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webhookStatusTypes.
     */
    skip?: number
    distinct?: Enumerable<WebhookStatusTypesScalarFieldEnum>
  }


  /**
   * webhookStatusTypes create
   */
  export type webhookStatusTypesCreateArgs = {
    /**
     * Select specific fields to fetch from the webhookStatusTypes
     */
    select?: webhookStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhookStatusTypesInclude | null
    /**
     * The data needed to create a webhookStatusTypes.
     */
    data: XOR<webhookStatusTypesCreateInput, webhookStatusTypesUncheckedCreateInput>
  }


  /**
   * webhookStatusTypes createMany
   */
  export type webhookStatusTypesCreateManyArgs = {
    /**
     * The data used to create many webhookStatusTypes.
     */
    data: Enumerable<webhookStatusTypesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * webhookStatusTypes update
   */
  export type webhookStatusTypesUpdateArgs = {
    /**
     * Select specific fields to fetch from the webhookStatusTypes
     */
    select?: webhookStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhookStatusTypesInclude | null
    /**
     * The data needed to update a webhookStatusTypes.
     */
    data: XOR<webhookStatusTypesUpdateInput, webhookStatusTypesUncheckedUpdateInput>
    /**
     * Choose, which webhookStatusTypes to update.
     */
    where: webhookStatusTypesWhereUniqueInput
  }


  /**
   * webhookStatusTypes updateMany
   */
  export type webhookStatusTypesUpdateManyArgs = {
    /**
     * The data used to update webhookStatusTypes.
     */
    data: XOR<webhookStatusTypesUpdateManyMutationInput, webhookStatusTypesUncheckedUpdateManyInput>
    /**
     * Filter which webhookStatusTypes to update
     */
    where?: webhookStatusTypesWhereInput
  }


  /**
   * webhookStatusTypes upsert
   */
  export type webhookStatusTypesUpsertArgs = {
    /**
     * Select specific fields to fetch from the webhookStatusTypes
     */
    select?: webhookStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhookStatusTypesInclude | null
    /**
     * The filter to search for the webhookStatusTypes to update in case it exists.
     */
    where: webhookStatusTypesWhereUniqueInput
    /**
     * In case the webhookStatusTypes found by the `where` argument doesn't exist, create a new webhookStatusTypes with this data.
     */
    create: XOR<webhookStatusTypesCreateInput, webhookStatusTypesUncheckedCreateInput>
    /**
     * In case the webhookStatusTypes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<webhookStatusTypesUpdateInput, webhookStatusTypesUncheckedUpdateInput>
  }


  /**
   * webhookStatusTypes delete
   */
  export type webhookStatusTypesDeleteArgs = {
    /**
     * Select specific fields to fetch from the webhookStatusTypes
     */
    select?: webhookStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhookStatusTypesInclude | null
    /**
     * Filter which webhookStatusTypes to delete.
     */
    where: webhookStatusTypesWhereUniqueInput
  }


  /**
   * webhookStatusTypes deleteMany
   */
  export type webhookStatusTypesDeleteManyArgs = {
    /**
     * Filter which webhookStatusTypes to delete
     */
    where?: webhookStatusTypesWhereInput
  }


  /**
   * webhookStatusTypes.webhooks
   */
  export type webhookStatusTypes$webhooksArgs = {
    /**
     * Select specific fields to fetch from the webhooks
     */
    select?: webhooksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhooksInclude | null
    where?: webhooksWhereInput
    orderBy?: Enumerable<webhooksOrderByWithRelationInput>
    cursor?: webhooksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WebhooksScalarFieldEnum>
  }


  /**
   * webhookStatusTypes without action
   */
  export type webhookStatusTypesArgs = {
    /**
     * Select specific fields to fetch from the webhookStatusTypes
     */
    select?: webhookStatusTypesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhookStatusTypesInclude | null
  }



  /**
   * Model webhooks
   */


  export type AggregateWebhooks = {
    _count: WebhooksCountAggregateOutputType | null
    _avg: WebhooksAvgAggregateOutputType | null
    _sum: WebhooksSumAggregateOutputType | null
    _min: WebhooksMinAggregateOutputType | null
    _max: WebhooksMaxAggregateOutputType | null
  }

  export type WebhooksAvgAggregateOutputType = {
    organizationId: number | null
    webhookStatusTypeId: number | null
  }

  export type WebhooksSumAggregateOutputType = {
    organizationId: number | null
    webhookStatusTypeId: number | null
  }

  export type WebhooksMinAggregateOutputType = {
    id: string | null
    organizationId: number | null
    webhookStatusTypeId: number | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhooksMaxAggregateOutputType = {
    id: string | null
    organizationId: number | null
    webhookStatusTypeId: number | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhooksCountAggregateOutputType = {
    id: number
    organizationId: number
    webhookStatusTypeId: number
    url: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WebhooksAvgAggregateInputType = {
    organizationId?: true
    webhookStatusTypeId?: true
  }

  export type WebhooksSumAggregateInputType = {
    organizationId?: true
    webhookStatusTypeId?: true
  }

  export type WebhooksMinAggregateInputType = {
    id?: true
    organizationId?: true
    webhookStatusTypeId?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhooksMaxAggregateInputType = {
    id?: true
    organizationId?: true
    webhookStatusTypeId?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhooksCountAggregateInputType = {
    id?: true
    organizationId?: true
    webhookStatusTypeId?: true
    url?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WebhooksAggregateArgs = {
    /**
     * Filter which webhooks to aggregate.
     */
    where?: webhooksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webhooks to fetch.
     */
    orderBy?: Enumerable<webhooksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: webhooksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned webhooks
    **/
    _count?: true | WebhooksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhooksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhooksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhooksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhooksMaxAggregateInputType
  }

  export type GetWebhooksAggregateType<T extends WebhooksAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhooks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhooks[P]>
      : GetScalarType<T[P], AggregateWebhooks[P]>
  }




  export type WebhooksGroupByArgs = {
    where?: webhooksWhereInput
    orderBy?: Enumerable<webhooksOrderByWithAggregationInput>
    by: WebhooksScalarFieldEnum[]
    having?: webhooksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhooksCountAggregateInputType | true
    _avg?: WebhooksAvgAggregateInputType
    _sum?: WebhooksSumAggregateInputType
    _min?: WebhooksMinAggregateInputType
    _max?: WebhooksMaxAggregateInputType
  }


  export type WebhooksGroupByOutputType = {
    id: string
    organizationId: number
    webhookStatusTypeId: number
    url: string
    createdAt: Date
    updatedAt: Date
    _count: WebhooksCountAggregateOutputType | null
    _avg: WebhooksAvgAggregateOutputType | null
    _sum: WebhooksSumAggregateOutputType | null
    _min: WebhooksMinAggregateOutputType | null
    _max: WebhooksMaxAggregateOutputType | null
  }

  type GetWebhooksGroupByPayload<T extends WebhooksGroupByArgs> = PrismaPromise<
    Array<
      PickArray<WebhooksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhooksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhooksGroupByOutputType[P]>
            : GetScalarType<T[P], WebhooksGroupByOutputType[P]>
        }
      >
    >


  export type webhooksSelect = {
    id?: boolean
    organizationId?: boolean
    webhookStatusTypeId?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    webhookRequests?: boolean | webhooks$webhookRequestsArgs
    organizations?: boolean | organizationsArgs
    webhookStatusTypes?: boolean | webhookStatusTypesArgs
    _count?: boolean | WebhooksCountOutputTypeArgs
  }


  export type webhooksInclude = {
    webhookRequests?: boolean | webhooks$webhookRequestsArgs
    organizations?: boolean | organizationsArgs
    webhookStatusTypes?: boolean | webhookStatusTypesArgs
    _count?: boolean | WebhooksCountOutputTypeArgs
  }

  export type webhooksGetPayload<S extends boolean | null | undefined | webhooksArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? webhooks :
    S extends undefined ? never :
    S extends { include: any } & (webhooksArgs | webhooksFindManyArgs)
    ? webhooks  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'webhookRequests' ? Array < webhookRequestsGetPayload<S['include'][P]>>  :
        P extends 'organizations' ? organizationsGetPayload<S['include'][P]> :
        P extends 'webhookStatusTypes' ? webhookStatusTypesGetPayload<S['include'][P]> :
        P extends '_count' ? WebhooksCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (webhooksArgs | webhooksFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'webhookRequests' ? Array < webhookRequestsGetPayload<S['select'][P]>>  :
        P extends 'organizations' ? organizationsGetPayload<S['select'][P]> :
        P extends 'webhookStatusTypes' ? webhookStatusTypesGetPayload<S['select'][P]> :
        P extends '_count' ? WebhooksCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof webhooks ? webhooks[P] : never
  } 
      : webhooks


  type webhooksCountArgs = 
    Omit<webhooksFindManyArgs, 'select' | 'include'> & {
      select?: WebhooksCountAggregateInputType | true
    }

  export interface webhooksDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Webhooks that matches the filter.
     * @param {webhooksFindUniqueArgs} args - Arguments to find a Webhooks
     * @example
     * // Get one Webhooks
     * const webhooks = await prisma.webhooks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends webhooksFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, webhooksFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'webhooks'> extends True ? Prisma__webhooksClient<webhooksGetPayload<T>> : Prisma__webhooksClient<webhooksGetPayload<T> | null, null>

    /**
     * Find one Webhooks that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {webhooksFindUniqueOrThrowArgs} args - Arguments to find a Webhooks
     * @example
     * // Get one Webhooks
     * const webhooks = await prisma.webhooks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends webhooksFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, webhooksFindUniqueOrThrowArgs>
    ): Prisma__webhooksClient<webhooksGetPayload<T>>

    /**
     * Find the first Webhooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhooksFindFirstArgs} args - Arguments to find a Webhooks
     * @example
     * // Get one Webhooks
     * const webhooks = await prisma.webhooks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends webhooksFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, webhooksFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'webhooks'> extends True ? Prisma__webhooksClient<webhooksGetPayload<T>> : Prisma__webhooksClient<webhooksGetPayload<T> | null, null>

    /**
     * Find the first Webhooks that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhooksFindFirstOrThrowArgs} args - Arguments to find a Webhooks
     * @example
     * // Get one Webhooks
     * const webhooks = await prisma.webhooks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends webhooksFindFirstOrThrowArgs>(
      args?: SelectSubset<T, webhooksFindFirstOrThrowArgs>
    ): Prisma__webhooksClient<webhooksGetPayload<T>>

    /**
     * Find zero or more Webhooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhooksFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Webhooks
     * const webhooks = await prisma.webhooks.findMany()
     * 
     * // Get first 10 Webhooks
     * const webhooks = await prisma.webhooks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhooksWithIdOnly = await prisma.webhooks.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends webhooksFindManyArgs>(
      args?: SelectSubset<T, webhooksFindManyArgs>
    ): PrismaPromise<Array<webhooksGetPayload<T>>>

    /**
     * Create a Webhooks.
     * @param {webhooksCreateArgs} args - Arguments to create a Webhooks.
     * @example
     * // Create one Webhooks
     * const Webhooks = await prisma.webhooks.create({
     *   data: {
     *     // ... data to create a Webhooks
     *   }
     * })
     * 
    **/
    create<T extends webhooksCreateArgs>(
      args: SelectSubset<T, webhooksCreateArgs>
    ): Prisma__webhooksClient<webhooksGetPayload<T>>

    /**
     * Create many Webhooks.
     *     @param {webhooksCreateManyArgs} args - Arguments to create many Webhooks.
     *     @example
     *     // Create many Webhooks
     *     const webhooks = await prisma.webhooks.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends webhooksCreateManyArgs>(
      args?: SelectSubset<T, webhooksCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Webhooks.
     * @param {webhooksDeleteArgs} args - Arguments to delete one Webhooks.
     * @example
     * // Delete one Webhooks
     * const Webhooks = await prisma.webhooks.delete({
     *   where: {
     *     // ... filter to delete one Webhooks
     *   }
     * })
     * 
    **/
    delete<T extends webhooksDeleteArgs>(
      args: SelectSubset<T, webhooksDeleteArgs>
    ): Prisma__webhooksClient<webhooksGetPayload<T>>

    /**
     * Update one Webhooks.
     * @param {webhooksUpdateArgs} args - Arguments to update one Webhooks.
     * @example
     * // Update one Webhooks
     * const webhooks = await prisma.webhooks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends webhooksUpdateArgs>(
      args: SelectSubset<T, webhooksUpdateArgs>
    ): Prisma__webhooksClient<webhooksGetPayload<T>>

    /**
     * Delete zero or more Webhooks.
     * @param {webhooksDeleteManyArgs} args - Arguments to filter Webhooks to delete.
     * @example
     * // Delete a few Webhooks
     * const { count } = await prisma.webhooks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends webhooksDeleteManyArgs>(
      args?: SelectSubset<T, webhooksDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhooksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Webhooks
     * const webhooks = await prisma.webhooks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends webhooksUpdateManyArgs>(
      args: SelectSubset<T, webhooksUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Webhooks.
     * @param {webhooksUpsertArgs} args - Arguments to update or create a Webhooks.
     * @example
     * // Update or create a Webhooks
     * const webhooks = await prisma.webhooks.upsert({
     *   create: {
     *     // ... data to create a Webhooks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Webhooks we want to update
     *   }
     * })
    **/
    upsert<T extends webhooksUpsertArgs>(
      args: SelectSubset<T, webhooksUpsertArgs>
    ): Prisma__webhooksClient<webhooksGetPayload<T>>

    /**
     * Count the number of Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhooksCountArgs} args - Arguments to filter Webhooks to count.
     * @example
     * // Count the number of Webhooks
     * const count = await prisma.webhooks.count({
     *   where: {
     *     // ... the filter for the Webhooks we want to count
     *   }
     * })
    **/
    count<T extends webhooksCountArgs>(
      args?: Subset<T, webhooksCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhooksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhooksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhooksAggregateArgs>(args: Subset<T, WebhooksAggregateArgs>): PrismaPromise<GetWebhooksAggregateType<T>>

    /**
     * Group by Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhooksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhooksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhooksGroupByArgs['orderBy'] }
        : { orderBy?: WebhooksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhooksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhooksGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for webhooks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__webhooksClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    webhookRequests<T extends webhooks$webhookRequestsArgs= {}>(args?: Subset<T, webhooks$webhookRequestsArgs>): PrismaPromise<Array<webhookRequestsGetPayload<T>>| Null>;

    organizations<T extends organizationsArgs= {}>(args?: Subset<T, organizationsArgs>): Prisma__organizationsClient<organizationsGetPayload<T> | Null>;

    webhookStatusTypes<T extends webhookStatusTypesArgs= {}>(args?: Subset<T, webhookStatusTypesArgs>): Prisma__webhookStatusTypesClient<webhookStatusTypesGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * webhooks base type for findUnique actions
   */
  export type webhooksFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the webhooks
     */
    select?: webhooksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhooksInclude | null
    /**
     * Filter, which webhooks to fetch.
     */
    where: webhooksWhereUniqueInput
  }

  /**
   * webhooks findUnique
   */
  export interface webhooksFindUniqueArgs extends webhooksFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * webhooks findUniqueOrThrow
   */
  export type webhooksFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the webhooks
     */
    select?: webhooksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhooksInclude | null
    /**
     * Filter, which webhooks to fetch.
     */
    where: webhooksWhereUniqueInput
  }


  /**
   * webhooks base type for findFirst actions
   */
  export type webhooksFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the webhooks
     */
    select?: webhooksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhooksInclude | null
    /**
     * Filter, which webhooks to fetch.
     */
    where?: webhooksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webhooks to fetch.
     */
    orderBy?: Enumerable<webhooksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for webhooks.
     */
    cursor?: webhooksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of webhooks.
     */
    distinct?: Enumerable<WebhooksScalarFieldEnum>
  }

  /**
   * webhooks findFirst
   */
  export interface webhooksFindFirstArgs extends webhooksFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * webhooks findFirstOrThrow
   */
  export type webhooksFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the webhooks
     */
    select?: webhooksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhooksInclude | null
    /**
     * Filter, which webhooks to fetch.
     */
    where?: webhooksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webhooks to fetch.
     */
    orderBy?: Enumerable<webhooksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for webhooks.
     */
    cursor?: webhooksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of webhooks.
     */
    distinct?: Enumerable<WebhooksScalarFieldEnum>
  }


  /**
   * webhooks findMany
   */
  export type webhooksFindManyArgs = {
    /**
     * Select specific fields to fetch from the webhooks
     */
    select?: webhooksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhooksInclude | null
    /**
     * Filter, which webhooks to fetch.
     */
    where?: webhooksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webhooks to fetch.
     */
    orderBy?: Enumerable<webhooksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing webhooks.
     */
    cursor?: webhooksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webhooks.
     */
    skip?: number
    distinct?: Enumerable<WebhooksScalarFieldEnum>
  }


  /**
   * webhooks create
   */
  export type webhooksCreateArgs = {
    /**
     * Select specific fields to fetch from the webhooks
     */
    select?: webhooksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhooksInclude | null
    /**
     * The data needed to create a webhooks.
     */
    data: XOR<webhooksCreateInput, webhooksUncheckedCreateInput>
  }


  /**
   * webhooks createMany
   */
  export type webhooksCreateManyArgs = {
    /**
     * The data used to create many webhooks.
     */
    data: Enumerable<webhooksCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * webhooks update
   */
  export type webhooksUpdateArgs = {
    /**
     * Select specific fields to fetch from the webhooks
     */
    select?: webhooksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhooksInclude | null
    /**
     * The data needed to update a webhooks.
     */
    data: XOR<webhooksUpdateInput, webhooksUncheckedUpdateInput>
    /**
     * Choose, which webhooks to update.
     */
    where: webhooksWhereUniqueInput
  }


  /**
   * webhooks updateMany
   */
  export type webhooksUpdateManyArgs = {
    /**
     * The data used to update webhooks.
     */
    data: XOR<webhooksUpdateManyMutationInput, webhooksUncheckedUpdateManyInput>
    /**
     * Filter which webhooks to update
     */
    where?: webhooksWhereInput
  }


  /**
   * webhooks upsert
   */
  export type webhooksUpsertArgs = {
    /**
     * Select specific fields to fetch from the webhooks
     */
    select?: webhooksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhooksInclude | null
    /**
     * The filter to search for the webhooks to update in case it exists.
     */
    where: webhooksWhereUniqueInput
    /**
     * In case the webhooks found by the `where` argument doesn't exist, create a new webhooks with this data.
     */
    create: XOR<webhooksCreateInput, webhooksUncheckedCreateInput>
    /**
     * In case the webhooks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<webhooksUpdateInput, webhooksUncheckedUpdateInput>
  }


  /**
   * webhooks delete
   */
  export type webhooksDeleteArgs = {
    /**
     * Select specific fields to fetch from the webhooks
     */
    select?: webhooksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhooksInclude | null
    /**
     * Filter which webhooks to delete.
     */
    where: webhooksWhereUniqueInput
  }


  /**
   * webhooks deleteMany
   */
  export type webhooksDeleteManyArgs = {
    /**
     * Filter which webhooks to delete
     */
    where?: webhooksWhereInput
  }


  /**
   * webhooks.webhookRequests
   */
  export type webhooks$webhookRequestsArgs = {
    /**
     * Select specific fields to fetch from the webhookRequests
     */
    select?: webhookRequestsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhookRequestsInclude | null
    where?: webhookRequestsWhereInput
    orderBy?: Enumerable<webhookRequestsOrderByWithRelationInput>
    cursor?: webhookRequestsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WebhookRequestsScalarFieldEnum>
  }


  /**
   * webhooks without action
   */
  export type webhooksArgs = {
    /**
     * Select specific fields to fetch from the webhooks
     */
    select?: webhooksSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: webhooksInclude | null
  }



  /**
   * Model withdrawalAddresses
   */


  export type AggregateWithdrawalAddresses = {
    _count: WithdrawalAddressesCountAggregateOutputType | null
    _avg: WithdrawalAddressesAvgAggregateOutputType | null
    _sum: WithdrawalAddressesSumAggregateOutputType | null
    _min: WithdrawalAddressesMinAggregateOutputType | null
    _max: WithdrawalAddressesMaxAggregateOutputType | null
  }

  export type WithdrawalAddressesAvgAggregateOutputType = {
    organizationId: number | null
    assetId: number | null
  }

  export type WithdrawalAddressesSumAggregateOutputType = {
    organizationId: number | null
    assetId: number | null
  }

  export type WithdrawalAddressesMinAggregateOutputType = {
    id: string | null
    organizationId: number | null
    assetId: number | null
    nickname: string | null
    address: string | null
    subjectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WithdrawalAddressesMaxAggregateOutputType = {
    id: string | null
    organizationId: number | null
    assetId: number | null
    nickname: string | null
    address: string | null
    subjectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WithdrawalAddressesCountAggregateOutputType = {
    id: number
    organizationId: number
    assetId: number
    nickname: number
    address: number
    subjectId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WithdrawalAddressesAvgAggregateInputType = {
    organizationId?: true
    assetId?: true
  }

  export type WithdrawalAddressesSumAggregateInputType = {
    organizationId?: true
    assetId?: true
  }

  export type WithdrawalAddressesMinAggregateInputType = {
    id?: true
    organizationId?: true
    assetId?: true
    nickname?: true
    address?: true
    subjectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WithdrawalAddressesMaxAggregateInputType = {
    id?: true
    organizationId?: true
    assetId?: true
    nickname?: true
    address?: true
    subjectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WithdrawalAddressesCountAggregateInputType = {
    id?: true
    organizationId?: true
    assetId?: true
    nickname?: true
    address?: true
    subjectId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WithdrawalAddressesAggregateArgs = {
    /**
     * Filter which withdrawalAddresses to aggregate.
     */
    where?: withdrawalAddressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of withdrawalAddresses to fetch.
     */
    orderBy?: Enumerable<withdrawalAddressesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: withdrawalAddressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` withdrawalAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` withdrawalAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned withdrawalAddresses
    **/
    _count?: true | WithdrawalAddressesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WithdrawalAddressesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WithdrawalAddressesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WithdrawalAddressesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WithdrawalAddressesMaxAggregateInputType
  }

  export type GetWithdrawalAddressesAggregateType<T extends WithdrawalAddressesAggregateArgs> = {
        [P in keyof T & keyof AggregateWithdrawalAddresses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWithdrawalAddresses[P]>
      : GetScalarType<T[P], AggregateWithdrawalAddresses[P]>
  }




  export type WithdrawalAddressesGroupByArgs = {
    where?: withdrawalAddressesWhereInput
    orderBy?: Enumerable<withdrawalAddressesOrderByWithAggregationInput>
    by: WithdrawalAddressesScalarFieldEnum[]
    having?: withdrawalAddressesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WithdrawalAddressesCountAggregateInputType | true
    _avg?: WithdrawalAddressesAvgAggregateInputType
    _sum?: WithdrawalAddressesSumAggregateInputType
    _min?: WithdrawalAddressesMinAggregateInputType
    _max?: WithdrawalAddressesMaxAggregateInputType
  }


  export type WithdrawalAddressesGroupByOutputType = {
    id: string
    organizationId: number
    assetId: number
    nickname: string | null
    address: string
    subjectId: string
    createdAt: Date
    updatedAt: Date
    _count: WithdrawalAddressesCountAggregateOutputType | null
    _avg: WithdrawalAddressesAvgAggregateOutputType | null
    _sum: WithdrawalAddressesSumAggregateOutputType | null
    _min: WithdrawalAddressesMinAggregateOutputType | null
    _max: WithdrawalAddressesMaxAggregateOutputType | null
  }

  type GetWithdrawalAddressesGroupByPayload<T extends WithdrawalAddressesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<WithdrawalAddressesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WithdrawalAddressesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WithdrawalAddressesGroupByOutputType[P]>
            : GetScalarType<T[P], WithdrawalAddressesGroupByOutputType[P]>
        }
      >
    >


  export type withdrawalAddressesSelect = {
    id?: boolean
    organizationId?: boolean
    assetId?: boolean
    nickname?: boolean
    address?: boolean
    subjectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactionPolicies?: boolean | withdrawalAddresses$transactionPoliciesArgs
    transactions?: boolean | withdrawalAddresses$transactionsArgs
    assets?: boolean | assetsArgs
    organizations?: boolean | organizationsArgs
    _count?: boolean | WithdrawalAddressesCountOutputTypeArgs
  }


  export type withdrawalAddressesInclude = {
    transactionPolicies?: boolean | withdrawalAddresses$transactionPoliciesArgs
    transactions?: boolean | withdrawalAddresses$transactionsArgs
    assets?: boolean | assetsArgs
    organizations?: boolean | organizationsArgs
    _count?: boolean | WithdrawalAddressesCountOutputTypeArgs
  }

  export type withdrawalAddressesGetPayload<S extends boolean | null | undefined | withdrawalAddressesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? withdrawalAddresses :
    S extends undefined ? never :
    S extends { include: any } & (withdrawalAddressesArgs | withdrawalAddressesFindManyArgs)
    ? withdrawalAddresses  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'transactionPolicies' ? Array < transactionPoliciesGetPayload<S['include'][P]>>  :
        P extends 'transactions' ? Array < transactionsGetPayload<S['include'][P]>>  :
        P extends 'assets' ? assetsGetPayload<S['include'][P]> :
        P extends 'organizations' ? organizationsGetPayload<S['include'][P]> :
        P extends '_count' ? WithdrawalAddressesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (withdrawalAddressesArgs | withdrawalAddressesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'transactionPolicies' ? Array < transactionPoliciesGetPayload<S['select'][P]>>  :
        P extends 'transactions' ? Array < transactionsGetPayload<S['select'][P]>>  :
        P extends 'assets' ? assetsGetPayload<S['select'][P]> :
        P extends 'organizations' ? organizationsGetPayload<S['select'][P]> :
        P extends '_count' ? WithdrawalAddressesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof withdrawalAddresses ? withdrawalAddresses[P] : never
  } 
      : withdrawalAddresses


  type withdrawalAddressesCountArgs = 
    Omit<withdrawalAddressesFindManyArgs, 'select' | 'include'> & {
      select?: WithdrawalAddressesCountAggregateInputType | true
    }

  export interface withdrawalAddressesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one WithdrawalAddresses that matches the filter.
     * @param {withdrawalAddressesFindUniqueArgs} args - Arguments to find a WithdrawalAddresses
     * @example
     * // Get one WithdrawalAddresses
     * const withdrawalAddresses = await prisma.withdrawalAddresses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends withdrawalAddressesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, withdrawalAddressesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'withdrawalAddresses'> extends True ? Prisma__withdrawalAddressesClient<withdrawalAddressesGetPayload<T>> : Prisma__withdrawalAddressesClient<withdrawalAddressesGetPayload<T> | null, null>

    /**
     * Find one WithdrawalAddresses that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {withdrawalAddressesFindUniqueOrThrowArgs} args - Arguments to find a WithdrawalAddresses
     * @example
     * // Get one WithdrawalAddresses
     * const withdrawalAddresses = await prisma.withdrawalAddresses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends withdrawalAddressesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, withdrawalAddressesFindUniqueOrThrowArgs>
    ): Prisma__withdrawalAddressesClient<withdrawalAddressesGetPayload<T>>

    /**
     * Find the first WithdrawalAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {withdrawalAddressesFindFirstArgs} args - Arguments to find a WithdrawalAddresses
     * @example
     * // Get one WithdrawalAddresses
     * const withdrawalAddresses = await prisma.withdrawalAddresses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends withdrawalAddressesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, withdrawalAddressesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'withdrawalAddresses'> extends True ? Prisma__withdrawalAddressesClient<withdrawalAddressesGetPayload<T>> : Prisma__withdrawalAddressesClient<withdrawalAddressesGetPayload<T> | null, null>

    /**
     * Find the first WithdrawalAddresses that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {withdrawalAddressesFindFirstOrThrowArgs} args - Arguments to find a WithdrawalAddresses
     * @example
     * // Get one WithdrawalAddresses
     * const withdrawalAddresses = await prisma.withdrawalAddresses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends withdrawalAddressesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, withdrawalAddressesFindFirstOrThrowArgs>
    ): Prisma__withdrawalAddressesClient<withdrawalAddressesGetPayload<T>>

    /**
     * Find zero or more WithdrawalAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {withdrawalAddressesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WithdrawalAddresses
     * const withdrawalAddresses = await prisma.withdrawalAddresses.findMany()
     * 
     * // Get first 10 WithdrawalAddresses
     * const withdrawalAddresses = await prisma.withdrawalAddresses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const withdrawalAddressesWithIdOnly = await prisma.withdrawalAddresses.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends withdrawalAddressesFindManyArgs>(
      args?: SelectSubset<T, withdrawalAddressesFindManyArgs>
    ): PrismaPromise<Array<withdrawalAddressesGetPayload<T>>>

    /**
     * Create a WithdrawalAddresses.
     * @param {withdrawalAddressesCreateArgs} args - Arguments to create a WithdrawalAddresses.
     * @example
     * // Create one WithdrawalAddresses
     * const WithdrawalAddresses = await prisma.withdrawalAddresses.create({
     *   data: {
     *     // ... data to create a WithdrawalAddresses
     *   }
     * })
     * 
    **/
    create<T extends withdrawalAddressesCreateArgs>(
      args: SelectSubset<T, withdrawalAddressesCreateArgs>
    ): Prisma__withdrawalAddressesClient<withdrawalAddressesGetPayload<T>>

    /**
     * Create many WithdrawalAddresses.
     *     @param {withdrawalAddressesCreateManyArgs} args - Arguments to create many WithdrawalAddresses.
     *     @example
     *     // Create many WithdrawalAddresses
     *     const withdrawalAddresses = await prisma.withdrawalAddresses.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends withdrawalAddressesCreateManyArgs>(
      args?: SelectSubset<T, withdrawalAddressesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a WithdrawalAddresses.
     * @param {withdrawalAddressesDeleteArgs} args - Arguments to delete one WithdrawalAddresses.
     * @example
     * // Delete one WithdrawalAddresses
     * const WithdrawalAddresses = await prisma.withdrawalAddresses.delete({
     *   where: {
     *     // ... filter to delete one WithdrawalAddresses
     *   }
     * })
     * 
    **/
    delete<T extends withdrawalAddressesDeleteArgs>(
      args: SelectSubset<T, withdrawalAddressesDeleteArgs>
    ): Prisma__withdrawalAddressesClient<withdrawalAddressesGetPayload<T>>

    /**
     * Update one WithdrawalAddresses.
     * @param {withdrawalAddressesUpdateArgs} args - Arguments to update one WithdrawalAddresses.
     * @example
     * // Update one WithdrawalAddresses
     * const withdrawalAddresses = await prisma.withdrawalAddresses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends withdrawalAddressesUpdateArgs>(
      args: SelectSubset<T, withdrawalAddressesUpdateArgs>
    ): Prisma__withdrawalAddressesClient<withdrawalAddressesGetPayload<T>>

    /**
     * Delete zero or more WithdrawalAddresses.
     * @param {withdrawalAddressesDeleteManyArgs} args - Arguments to filter WithdrawalAddresses to delete.
     * @example
     * // Delete a few WithdrawalAddresses
     * const { count } = await prisma.withdrawalAddresses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends withdrawalAddressesDeleteManyArgs>(
      args?: SelectSubset<T, withdrawalAddressesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more WithdrawalAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {withdrawalAddressesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WithdrawalAddresses
     * const withdrawalAddresses = await prisma.withdrawalAddresses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends withdrawalAddressesUpdateManyArgs>(
      args: SelectSubset<T, withdrawalAddressesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one WithdrawalAddresses.
     * @param {withdrawalAddressesUpsertArgs} args - Arguments to update or create a WithdrawalAddresses.
     * @example
     * // Update or create a WithdrawalAddresses
     * const withdrawalAddresses = await prisma.withdrawalAddresses.upsert({
     *   create: {
     *     // ... data to create a WithdrawalAddresses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WithdrawalAddresses we want to update
     *   }
     * })
    **/
    upsert<T extends withdrawalAddressesUpsertArgs>(
      args: SelectSubset<T, withdrawalAddressesUpsertArgs>
    ): Prisma__withdrawalAddressesClient<withdrawalAddressesGetPayload<T>>

    /**
     * Count the number of WithdrawalAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {withdrawalAddressesCountArgs} args - Arguments to filter WithdrawalAddresses to count.
     * @example
     * // Count the number of WithdrawalAddresses
     * const count = await prisma.withdrawalAddresses.count({
     *   where: {
     *     // ... the filter for the WithdrawalAddresses we want to count
     *   }
     * })
    **/
    count<T extends withdrawalAddressesCountArgs>(
      args?: Subset<T, withdrawalAddressesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WithdrawalAddressesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WithdrawalAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalAddressesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WithdrawalAddressesAggregateArgs>(args: Subset<T, WithdrawalAddressesAggregateArgs>): PrismaPromise<GetWithdrawalAddressesAggregateType<T>>

    /**
     * Group by WithdrawalAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WithdrawalAddressesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WithdrawalAddressesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WithdrawalAddressesGroupByArgs['orderBy'] }
        : { orderBy?: WithdrawalAddressesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WithdrawalAddressesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWithdrawalAddressesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for withdrawalAddresses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__withdrawalAddressesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    transactionPolicies<T extends withdrawalAddresses$transactionPoliciesArgs= {}>(args?: Subset<T, withdrawalAddresses$transactionPoliciesArgs>): PrismaPromise<Array<transactionPoliciesGetPayload<T>>| Null>;

    transactions<T extends withdrawalAddresses$transactionsArgs= {}>(args?: Subset<T, withdrawalAddresses$transactionsArgs>): PrismaPromise<Array<transactionsGetPayload<T>>| Null>;

    assets<T extends assetsArgs= {}>(args?: Subset<T, assetsArgs>): Prisma__assetsClient<assetsGetPayload<T> | Null>;

    organizations<T extends organizationsArgs= {}>(args?: Subset<T, organizationsArgs>): Prisma__organizationsClient<organizationsGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * withdrawalAddresses base type for findUnique actions
   */
  export type withdrawalAddressesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the withdrawalAddresses
     */
    select?: withdrawalAddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: withdrawalAddressesInclude | null
    /**
     * Filter, which withdrawalAddresses to fetch.
     */
    where: withdrawalAddressesWhereUniqueInput
  }

  /**
   * withdrawalAddresses findUnique
   */
  export interface withdrawalAddressesFindUniqueArgs extends withdrawalAddressesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * withdrawalAddresses findUniqueOrThrow
   */
  export type withdrawalAddressesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the withdrawalAddresses
     */
    select?: withdrawalAddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: withdrawalAddressesInclude | null
    /**
     * Filter, which withdrawalAddresses to fetch.
     */
    where: withdrawalAddressesWhereUniqueInput
  }


  /**
   * withdrawalAddresses base type for findFirst actions
   */
  export type withdrawalAddressesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the withdrawalAddresses
     */
    select?: withdrawalAddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: withdrawalAddressesInclude | null
    /**
     * Filter, which withdrawalAddresses to fetch.
     */
    where?: withdrawalAddressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of withdrawalAddresses to fetch.
     */
    orderBy?: Enumerable<withdrawalAddressesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for withdrawalAddresses.
     */
    cursor?: withdrawalAddressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` withdrawalAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` withdrawalAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of withdrawalAddresses.
     */
    distinct?: Enumerable<WithdrawalAddressesScalarFieldEnum>
  }

  /**
   * withdrawalAddresses findFirst
   */
  export interface withdrawalAddressesFindFirstArgs extends withdrawalAddressesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * withdrawalAddresses findFirstOrThrow
   */
  export type withdrawalAddressesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the withdrawalAddresses
     */
    select?: withdrawalAddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: withdrawalAddressesInclude | null
    /**
     * Filter, which withdrawalAddresses to fetch.
     */
    where?: withdrawalAddressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of withdrawalAddresses to fetch.
     */
    orderBy?: Enumerable<withdrawalAddressesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for withdrawalAddresses.
     */
    cursor?: withdrawalAddressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` withdrawalAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` withdrawalAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of withdrawalAddresses.
     */
    distinct?: Enumerable<WithdrawalAddressesScalarFieldEnum>
  }


  /**
   * withdrawalAddresses findMany
   */
  export type withdrawalAddressesFindManyArgs = {
    /**
     * Select specific fields to fetch from the withdrawalAddresses
     */
    select?: withdrawalAddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: withdrawalAddressesInclude | null
    /**
     * Filter, which withdrawalAddresses to fetch.
     */
    where?: withdrawalAddressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of withdrawalAddresses to fetch.
     */
    orderBy?: Enumerable<withdrawalAddressesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing withdrawalAddresses.
     */
    cursor?: withdrawalAddressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` withdrawalAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` withdrawalAddresses.
     */
    skip?: number
    distinct?: Enumerable<WithdrawalAddressesScalarFieldEnum>
  }


  /**
   * withdrawalAddresses create
   */
  export type withdrawalAddressesCreateArgs = {
    /**
     * Select specific fields to fetch from the withdrawalAddresses
     */
    select?: withdrawalAddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: withdrawalAddressesInclude | null
    /**
     * The data needed to create a withdrawalAddresses.
     */
    data: XOR<withdrawalAddressesCreateInput, withdrawalAddressesUncheckedCreateInput>
  }


  /**
   * withdrawalAddresses createMany
   */
  export type withdrawalAddressesCreateManyArgs = {
    /**
     * The data used to create many withdrawalAddresses.
     */
    data: Enumerable<withdrawalAddressesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * withdrawalAddresses update
   */
  export type withdrawalAddressesUpdateArgs = {
    /**
     * Select specific fields to fetch from the withdrawalAddresses
     */
    select?: withdrawalAddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: withdrawalAddressesInclude | null
    /**
     * The data needed to update a withdrawalAddresses.
     */
    data: XOR<withdrawalAddressesUpdateInput, withdrawalAddressesUncheckedUpdateInput>
    /**
     * Choose, which withdrawalAddresses to update.
     */
    where: withdrawalAddressesWhereUniqueInput
  }


  /**
   * withdrawalAddresses updateMany
   */
  export type withdrawalAddressesUpdateManyArgs = {
    /**
     * The data used to update withdrawalAddresses.
     */
    data: XOR<withdrawalAddressesUpdateManyMutationInput, withdrawalAddressesUncheckedUpdateManyInput>
    /**
     * Filter which withdrawalAddresses to update
     */
    where?: withdrawalAddressesWhereInput
  }


  /**
   * withdrawalAddresses upsert
   */
  export type withdrawalAddressesUpsertArgs = {
    /**
     * Select specific fields to fetch from the withdrawalAddresses
     */
    select?: withdrawalAddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: withdrawalAddressesInclude | null
    /**
     * The filter to search for the withdrawalAddresses to update in case it exists.
     */
    where: withdrawalAddressesWhereUniqueInput
    /**
     * In case the withdrawalAddresses found by the `where` argument doesn't exist, create a new withdrawalAddresses with this data.
     */
    create: XOR<withdrawalAddressesCreateInput, withdrawalAddressesUncheckedCreateInput>
    /**
     * In case the withdrawalAddresses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<withdrawalAddressesUpdateInput, withdrawalAddressesUncheckedUpdateInput>
  }


  /**
   * withdrawalAddresses delete
   */
  export type withdrawalAddressesDeleteArgs = {
    /**
     * Select specific fields to fetch from the withdrawalAddresses
     */
    select?: withdrawalAddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: withdrawalAddressesInclude | null
    /**
     * Filter which withdrawalAddresses to delete.
     */
    where: withdrawalAddressesWhereUniqueInput
  }


  /**
   * withdrawalAddresses deleteMany
   */
  export type withdrawalAddressesDeleteManyArgs = {
    /**
     * Filter which withdrawalAddresses to delete
     */
    where?: withdrawalAddressesWhereInput
  }


  /**
   * withdrawalAddresses.transactionPolicies
   */
  export type withdrawalAddresses$transactionPoliciesArgs = {
    /**
     * Select specific fields to fetch from the transactionPolicies
     */
    select?: transactionPoliciesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionPoliciesInclude | null
    where?: transactionPoliciesWhereInput
    orderBy?: Enumerable<transactionPoliciesOrderByWithRelationInput>
    cursor?: transactionPoliciesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TransactionPoliciesScalarFieldEnum>
  }


  /**
   * withdrawalAddresses.transactions
   */
  export type withdrawalAddresses$transactionsArgs = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: transactionsInclude | null
    where?: transactionsWhereInput
    orderBy?: Enumerable<transactionsOrderByWithRelationInput>
    cursor?: transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TransactionsScalarFieldEnum>
  }


  /**
   * withdrawalAddresses without action
   */
  export type withdrawalAddressesArgs = {
    /**
     * Select specific fields to fetch from the withdrawalAddresses
     */
    select?: withdrawalAddressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: withdrawalAddressesInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AssetsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    baseNetworkId: 'baseNetworkId',
    type: 'type',
    ticker: 'ticker',
    fireblocksTicker: 'fireblocksTicker',
    enabled: 'enabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AssetsScalarFieldEnum = (typeof AssetsScalarFieldEnum)[keyof typeof AssetsScalarFieldEnum]


  export const BaseNetworksScalarFieldEnum: {
    id: 'id',
    name: 'name',
    addressUrl: 'addressUrl',
    feeAssetId: 'feeAssetId',
    txUrl: 'txUrl',
    enabled: 'enabled',
    baseBps: 'baseBps',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BaseNetworksScalarFieldEnum = (typeof BaseNetworksScalarFieldEnum)[keyof typeof BaseNetworksScalarFieldEnum]


  export const CustodyEngineEventTypesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustodyEngineEventTypesScalarFieldEnum = (typeof CustodyEngineEventTypesScalarFieldEnum)[keyof typeof CustodyEngineEventTypesScalarFieldEnum]


  export const CustodyEngineEventsScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    custodyEngineEventTypeId: 'custodyEngineEventTypeId',
    event: 'event',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustodyEngineEventsScalarFieldEnum = (typeof CustodyEngineEventsScalarFieldEnum)[keyof typeof CustodyEngineEventsScalarFieldEnum]


  export const CustodyVendorVaultAssetsScalarFieldEnum: {
    id: 'id',
    vendorId: 'vendorId',
    vendorRef: 'vendorRef',
    balance: 'balance',
    vaultAssetId: 'vaultAssetId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustodyVendorVaultAssetsScalarFieldEnum = (typeof CustodyVendorVaultAssetsScalarFieldEnum)[keyof typeof CustodyVendorVaultAssetsScalarFieldEnum]


  export const DepositAddressStatusTypesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepositAddressStatusTypesScalarFieldEnum = (typeof DepositAddressStatusTypesScalarFieldEnum)[keyof typeof DepositAddressStatusTypesScalarFieldEnum]


  export const DepositAddressesScalarFieldEnum: {
    id: 'id',
    vaultAssetId: 'vaultAssetId',
    address: 'address',
    depositAddressStatusId: 'depositAddressStatusId',
    vendorId: 'vendorId',
    vendorRef: 'vendorRef',
    subjectId: 'subjectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepositAddressesScalarFieldEnum = (typeof DepositAddressesScalarFieldEnum)[keyof typeof DepositAddressesScalarFieldEnum]


  export const InstitutionalProductsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    enabled: 'enabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InstitutionalProductsScalarFieldEnum = (typeof InstitutionalProductsScalarFieldEnum)[keyof typeof InstitutionalProductsScalarFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const OrdersScalarFieldEnum: {
    id: 'id',
    quoteId: 'quoteId',
    orderStatus: 'orderStatus',
    userAcceptedPrice: 'userAcceptedPrice',
    userAcceptedQuantity: 'userAcceptedQuantity',
    userAcceptedSide: 'userAcceptedSide',
    userAcceptedTradePair: 'userAcceptedTradePair',
    userAcceptedTimestamp: 'userAcceptedTimestamp',
    orderType: 'orderType',
    orderTimeInForce: 'orderTimeInForce',
    vendorQuoteId: 'vendorQuoteId',
    vendorQuantityRequested: 'vendorQuantityRequested',
    vendorPriceRequested: 'vendorPriceRequested',
    orderQuantityExecuted: 'orderQuantityExecuted',
    orderPriceExecuted: 'orderPriceExecuted',
    orderTimestampExecuted: 'orderTimestampExecuted',
    orderVendorStatus: 'orderVendorStatus',
    allowedSlippage: 'allowedSlippage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrdersScalarFieldEnum = (typeof OrdersScalarFieldEnum)[keyof typeof OrdersScalarFieldEnum]


  export const OrganizationStatusTypesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationStatusTypesScalarFieldEnum = (typeof OrganizationStatusTypesScalarFieldEnum)[keyof typeof OrganizationStatusTypesScalarFieldEnum]


  export const OrganizationsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    primaryEmail: 'primaryEmail',
    pricingPlanId: 'pricingPlanId',
    statusId: 'statusId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationsScalarFieldEnum = (typeof OrganizationsScalarFieldEnum)[keyof typeof OrganizationsScalarFieldEnum]


  export const PricingPlanProfilesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    quoteEngineRps: 'quoteEngineRps',
    custodyEngineRps: 'custodyEngineRps',
    numberOfUsers: 'numberOfUsers',
    sla: 'sla',
    rbac: 'rbac',
    quoteEngineClaims: 'quoteEngineClaims',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PricingPlanProfilesScalarFieldEnum = (typeof PricingPlanProfilesScalarFieldEnum)[keyof typeof PricingPlanProfilesScalarFieldEnum]


  export const PricingPlanSupportsAssetsScalarFieldEnum: {
    id: 'id',
    vendorSupportsAssetId: 'vendorSupportsAssetId',
    pricingPlanId: 'pricingPlanId',
    enabled: 'enabled',
    buyBps: 'buyBps',
    sellBps: 'sellBps',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PricingPlanSupportsAssetsScalarFieldEnum = (typeof PricingPlanSupportsAssetsScalarFieldEnum)[keyof typeof PricingPlanSupportsAssetsScalarFieldEnum]


  export const PricingPlansScalarFieldEnum: {
    id: 'id',
    price: 'price',
    active: 'active',
    pricingPlanProfileId: 'pricingPlanProfileId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PricingPlansScalarFieldEnum = (typeof PricingPlansScalarFieldEnum)[keyof typeof PricingPlansScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const QuoteStatusesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuoteStatusesScalarFieldEnum = (typeof QuoteStatusesScalarFieldEnum)[keyof typeof QuoteStatusesScalarFieldEnum]


  export const QuotesScalarFieldEnum: {
    id: 'id',
    quoteStatusId: 'quoteStatusId',
    sourceAssetId: 'sourceAssetId',
    targetAssetId: 'targetAssetId',
    side: 'side',
    userId: 'userId',
    vendorId: 'vendorId',
    extraData: 'extraData',
    error: 'error',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    fxRequestID: 'fxRequestID',
    buyPrice: 'buyPrice',
    sellPrice: 'sellPrice',
    quantity: 'quantity'
  };

  export type QuotesScalarFieldEnum = (typeof QuotesScalarFieldEnum)[keyof typeof QuotesScalarFieldEnum]


  export const SequelizeDataScalarFieldEnum: {
    name: 'name'
  };

  export type SequelizeDataScalarFieldEnum = (typeof SequelizeDataScalarFieldEnum)[keyof typeof SequelizeDataScalarFieldEnum]


  export const SequelizeMetaScalarFieldEnum: {
    name: 'name'
  };

  export type SequelizeMetaScalarFieldEnum = (typeof SequelizeMetaScalarFieldEnum)[keyof typeof SequelizeMetaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TokenPairsInfoScalarFieldEnum: {
    id: 'id',
    tokenPairId: 'tokenPairId',
    fxRequestID: 'fxRequestID',
    quantity: 'quantity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TokenPairsInfoScalarFieldEnum = (typeof TokenPairsInfoScalarFieldEnum)[keyof typeof TokenPairsInfoScalarFieldEnum]


  export const TokenPairsScalarFieldEnum: {
    id: 'id',
    baseToken: 'baseToken',
    quoteToken: 'quoteToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    vendorId: 'vendorId'
  };

  export type TokenPairsScalarFieldEnum = (typeof TokenPairsScalarFieldEnum)[keyof typeof TokenPairsScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TransactionPoliciesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    transactionTypeId: 'transactionTypeId',
    sourceVaultId: 'sourceVaultId',
    targetVaultId: 'targetVaultId',
    targetWithdrawalAddressId: 'targetWithdrawalAddressId',
    toOneTimeAddresses: 'toOneTimeAddresses',
    greaterThanUSD: 'greaterThanUSD',
    assetId: 'assetId',
    action: 'action',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionPoliciesScalarFieldEnum = (typeof TransactionPoliciesScalarFieldEnum)[keyof typeof TransactionPoliciesScalarFieldEnum]


  export const TransactionStatusTypesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionStatusTypesScalarFieldEnum = (typeof TransactionStatusTypesScalarFieldEnum)[keyof typeof TransactionStatusTypesScalarFieldEnum]


  export const TransactionTypesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionTypesScalarFieldEnum = (typeof TransactionTypesScalarFieldEnum)[keyof typeof TransactionTypesScalarFieldEnum]


  export const TransactionsScalarFieldEnum: {
    id: 'id',
    custodyVendorId: 'custodyVendorId',
    custodyVendorRef: 'custodyVendorRef',
    transactionTypeId: 'transactionTypeId',
    amountAsset: 'amountAsset',
    amountUSD: 'amountUSD',
    assetId: 'assetId',
    transactionStatusTypeId: 'transactionStatusTypeId',
    onChainTxId: 'onChainTxId',
    sourceVaultId: 'sourceVaultId',
    targetVaultId: 'targetVaultId',
    targetWithdrawalAddressId: 'targetWithdrawalAddressId',
    sourceExternalAddress: 'sourceExternalAddress',
    createdByUserId: 'createdByUserId',
    subjectId: 'subjectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionsScalarFieldEnum = (typeof TransactionsScalarFieldEnum)[keyof typeof TransactionsScalarFieldEnum]


  export const UserTypesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    claims: 'claims',
    isServiceAccount: 'isServiceAccount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserTypesScalarFieldEnum = (typeof UserTypesScalarFieldEnum)[keyof typeof UserTypesScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    userTypeId: 'userTypeId',
    primaryEmail: 'primaryEmail',
    firstName: 'firstName',
    lastName: 'lastName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    publicKey: 'publicKey',
    apiKey: 'apiKey'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const VaultAssetsScalarFieldEnum: {
    id: 'id',
    vaultId: 'vaultId',
    assetId: 'assetId',
    balance: 'balance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VaultAssetsScalarFieldEnum = (typeof VaultAssetsScalarFieldEnum)[keyof typeof VaultAssetsScalarFieldEnum]


  export const VaultStatusTypesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VaultStatusTypesScalarFieldEnum = (typeof VaultStatusTypesScalarFieldEnum)[keyof typeof VaultStatusTypesScalarFieldEnum]


  export const VaultsScalarFieldEnum: {
    id: 'id',
    createdByUserId: 'createdByUserId',
    vaultStatusId: 'vaultStatusId',
    vaultName: 'vaultName',
    subjectId: 'subjectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VaultsScalarFieldEnum = (typeof VaultsScalarFieldEnum)[keyof typeof VaultsScalarFieldEnum]


  export const VendorSupportsAssetsScalarFieldEnum: {
    id: 'id',
    assetId: 'assetId',
    vendorId: 'vendorId',
    enabled: 'enabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    theirId: 'theirId'
  };

  export type VendorSupportsAssetsScalarFieldEnum = (typeof VendorSupportsAssetsScalarFieldEnum)[keyof typeof VendorSupportsAssetsScalarFieldEnum]


  export const VendorTypesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VendorTypesScalarFieldEnum = (typeof VendorTypesScalarFieldEnum)[keyof typeof VendorTypesScalarFieldEnum]


  export const VendorsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    identifier: 'identifier',
    vendorTypeId: 'vendorTypeId',
    quoteEngineBaseBps: 'quoteEngineBaseBps',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VendorsScalarFieldEnum = (typeof VendorsScalarFieldEnum)[keyof typeof VendorsScalarFieldEnum]


  export const WebhookRequestsScalarFieldEnum: {
    id: 'id',
    webhookId: 'webhookId',
    institutionalProductId: 'institutionalProductId',
    httpStatusCode: 'httpStatusCode',
    requestPayload: 'requestPayload',
    responsePayload: 'responsePayload',
    custodyEngineEventId: 'custodyEngineEventId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WebhookRequestsScalarFieldEnum = (typeof WebhookRequestsScalarFieldEnum)[keyof typeof WebhookRequestsScalarFieldEnum]


  export const WebhookStatusTypesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WebhookStatusTypesScalarFieldEnum = (typeof WebhookStatusTypesScalarFieldEnum)[keyof typeof WebhookStatusTypesScalarFieldEnum]


  export const WebhooksScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    webhookStatusTypeId: 'webhookStatusTypeId',
    url: 'url',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WebhooksScalarFieldEnum = (typeof WebhooksScalarFieldEnum)[keyof typeof WebhooksScalarFieldEnum]


  export const WithdrawalAddressesScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    assetId: 'assetId',
    nickname: 'nickname',
    address: 'address',
    subjectId: 'subjectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WithdrawalAddressesScalarFieldEnum = (typeof WithdrawalAddressesScalarFieldEnum)[keyof typeof WithdrawalAddressesScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type SequelizeDataWhereInput = {
    AND?: Enumerable<SequelizeDataWhereInput>
    OR?: Enumerable<SequelizeDataWhereInput>
    NOT?: Enumerable<SequelizeDataWhereInput>
    name?: StringFilter | string
  }

  export type SequelizeDataOrderByWithRelationInput = {
    name?: SortOrder
  }

  export type SequelizeDataWhereUniqueInput = {
    name?: string
  }

  export type SequelizeDataOrderByWithAggregationInput = {
    name?: SortOrder
    _count?: SequelizeDataCountOrderByAggregateInput
    _max?: SequelizeDataMaxOrderByAggregateInput
    _min?: SequelizeDataMinOrderByAggregateInput
  }

  export type SequelizeDataScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SequelizeDataScalarWhereWithAggregatesInput>
    OR?: Enumerable<SequelizeDataScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SequelizeDataScalarWhereWithAggregatesInput>
    name?: StringWithAggregatesFilter | string
  }

  export type SequelizeMetaWhereInput = {
    AND?: Enumerable<SequelizeMetaWhereInput>
    OR?: Enumerable<SequelizeMetaWhereInput>
    NOT?: Enumerable<SequelizeMetaWhereInput>
    name?: StringFilter | string
  }

  export type SequelizeMetaOrderByWithRelationInput = {
    name?: SortOrder
  }

  export type SequelizeMetaWhereUniqueInput = {
    name?: string
  }

  export type SequelizeMetaOrderByWithAggregationInput = {
    name?: SortOrder
    _count?: SequelizeMetaCountOrderByAggregateInput
    _max?: SequelizeMetaMaxOrderByAggregateInput
    _min?: SequelizeMetaMinOrderByAggregateInput
  }

  export type SequelizeMetaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SequelizeMetaScalarWhereWithAggregatesInput>
    OR?: Enumerable<SequelizeMetaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SequelizeMetaScalarWhereWithAggregatesInput>
    name?: StringWithAggregatesFilter | string
  }

  export type assetsWhereInput = {
    AND?: Enumerable<assetsWhereInput>
    OR?: Enumerable<assetsWhereInput>
    NOT?: Enumerable<assetsWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringFilter | string
    baseNetworkId?: IntNullableFilter | number | null
    type?: Enumenum_assets_typeFilter | enum_assets_type
    ticker?: StringFilter | string
    fireblocksTicker?: StringNullableFilter | string | null
    enabled?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    baseNetworks?: XOR<BaseNetworksRelationFilter, baseNetworksWhereInput> | null
    quotes_quotes_sourceAssetIdToassets?: QuotesListRelationFilter
    quotes_quotes_targetAssetIdToassets?: QuotesListRelationFilter
    transactionPolicies?: TransactionPoliciesListRelationFilter
    transactions?: TransactionsListRelationFilter
    vaultAssets?: VaultAssetsListRelationFilter
    vendorSupportsAssets?: VendorSupportsAssetsListRelationFilter
    withdrawalAddresses?: WithdrawalAddressesListRelationFilter
  }

  export type assetsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    baseNetworkId?: SortOrder
    type?: SortOrder
    ticker?: SortOrder
    fireblocksTicker?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    baseNetworks?: baseNetworksOrderByWithRelationInput
    quotes_quotes_sourceAssetIdToassets?: quotesOrderByRelationAggregateInput
    quotes_quotes_targetAssetIdToassets?: quotesOrderByRelationAggregateInput
    transactionPolicies?: transactionPoliciesOrderByRelationAggregateInput
    transactions?: transactionsOrderByRelationAggregateInput
    vaultAssets?: vaultAssetsOrderByRelationAggregateInput
    vendorSupportsAssets?: vendorSupportsAssetsOrderByRelationAggregateInput
    withdrawalAddresses?: withdrawalAddressesOrderByRelationAggregateInput
  }

  export type assetsWhereUniqueInput = {
    id?: number
  }

  export type assetsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    baseNetworkId?: SortOrder
    type?: SortOrder
    ticker?: SortOrder
    fireblocksTicker?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: assetsCountOrderByAggregateInput
    _avg?: assetsAvgOrderByAggregateInput
    _max?: assetsMaxOrderByAggregateInput
    _min?: assetsMinOrderByAggregateInput
    _sum?: assetsSumOrderByAggregateInput
  }

  export type assetsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<assetsScalarWhereWithAggregatesInput>
    OR?: Enumerable<assetsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<assetsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    baseNetworkId?: IntNullableWithAggregatesFilter | number | null
    type?: Enumenum_assets_typeWithAggregatesFilter | enum_assets_type
    ticker?: StringWithAggregatesFilter | string
    fireblocksTicker?: StringNullableWithAggregatesFilter | string | null
    enabled?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type baseNetworksWhereInput = {
    AND?: Enumerable<baseNetworksWhereInput>
    OR?: Enumerable<baseNetworksWhereInput>
    NOT?: Enumerable<baseNetworksWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    addressUrl?: StringFilter | string
    feeAssetId?: IntNullableFilter | number | null
    txUrl?: StringFilter | string
    enabled?: BoolFilter | boolean
    baseBps?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    assets?: AssetsListRelationFilter
  }

  export type baseNetworksOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    addressUrl?: SortOrder
    feeAssetId?: SortOrder
    txUrl?: SortOrder
    enabled?: SortOrder
    baseBps?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assets?: assetsOrderByRelationAggregateInput
  }

  export type baseNetworksWhereUniqueInput = {
    id?: number
  }

  export type baseNetworksOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    addressUrl?: SortOrder
    feeAssetId?: SortOrder
    txUrl?: SortOrder
    enabled?: SortOrder
    baseBps?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: baseNetworksCountOrderByAggregateInput
    _avg?: baseNetworksAvgOrderByAggregateInput
    _max?: baseNetworksMaxOrderByAggregateInput
    _min?: baseNetworksMinOrderByAggregateInput
    _sum?: baseNetworksSumOrderByAggregateInput
  }

  export type baseNetworksScalarWhereWithAggregatesInput = {
    AND?: Enumerable<baseNetworksScalarWhereWithAggregatesInput>
    OR?: Enumerable<baseNetworksScalarWhereWithAggregatesInput>
    NOT?: Enumerable<baseNetworksScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    addressUrl?: StringWithAggregatesFilter | string
    feeAssetId?: IntNullableWithAggregatesFilter | number | null
    txUrl?: StringWithAggregatesFilter | string
    enabled?: BoolWithAggregatesFilter | boolean
    baseBps?: FloatWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type quotesWhereInput = {
    AND?: Enumerable<quotesWhereInput>
    OR?: Enumerable<quotesWhereInput>
    NOT?: Enumerable<quotesWhereInput>
    id?: UuidFilter | string
    quoteStatusId?: IntFilter | number
    sourceAssetId?: IntFilter | number
    targetAssetId?: IntFilter | number
    side?: Enumenum_quotes_sideFilter | enum_quotes_side
    userId?: StringFilter | string
    vendorId?: IntNullableFilter | number | null
    extraData?: JsonNullableFilter
    error?: JsonNullableFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    fxRequestID?: UuidNullableFilter | string | null
    buyPrice?: StringFilter | string
    sellPrice?: StringFilter | string
    quantity?: StringFilter | string
    orders?: OrdersListRelationFilter
    tokenPairsInfo?: XOR<TokenPairsInfoRelationFilter, tokenPairsInfoWhereInput> | null
    quoteStatuses?: XOR<QuoteStatusesRelationFilter, quoteStatusesWhereInput>
    assets_quotes_sourceAssetIdToassets?: XOR<AssetsRelationFilter, assetsWhereInput>
    assets_quotes_targetAssetIdToassets?: XOR<AssetsRelationFilter, assetsWhereInput>
    vendors?: XOR<VendorsRelationFilter, vendorsWhereInput> | null
  }

  export type quotesOrderByWithRelationInput = {
    id?: SortOrder
    quoteStatusId?: SortOrder
    sourceAssetId?: SortOrder
    targetAssetId?: SortOrder
    side?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    extraData?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fxRequestID?: SortOrder
    buyPrice?: SortOrder
    sellPrice?: SortOrder
    quantity?: SortOrder
    orders?: ordersOrderByRelationAggregateInput
    tokenPairsInfo?: tokenPairsInfoOrderByWithRelationInput
    quoteStatuses?: quoteStatusesOrderByWithRelationInput
    assets_quotes_sourceAssetIdToassets?: assetsOrderByWithRelationInput
    assets_quotes_targetAssetIdToassets?: assetsOrderByWithRelationInput
    vendors?: vendorsOrderByWithRelationInput
  }

  export type quotesWhereUniqueInput = {
    id?: string
  }

  export type quotesOrderByWithAggregationInput = {
    id?: SortOrder
    quoteStatusId?: SortOrder
    sourceAssetId?: SortOrder
    targetAssetId?: SortOrder
    side?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    extraData?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fxRequestID?: SortOrder
    buyPrice?: SortOrder
    sellPrice?: SortOrder
    quantity?: SortOrder
    _count?: quotesCountOrderByAggregateInput
    _avg?: quotesAvgOrderByAggregateInput
    _max?: quotesMaxOrderByAggregateInput
    _min?: quotesMinOrderByAggregateInput
    _sum?: quotesSumOrderByAggregateInput
  }

  export type quotesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<quotesScalarWhereWithAggregatesInput>
    OR?: Enumerable<quotesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<quotesScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    quoteStatusId?: IntWithAggregatesFilter | number
    sourceAssetId?: IntWithAggregatesFilter | number
    targetAssetId?: IntWithAggregatesFilter | number
    side?: Enumenum_quotes_sideWithAggregatesFilter | enum_quotes_side
    userId?: StringWithAggregatesFilter | string
    vendorId?: IntNullableWithAggregatesFilter | number | null
    extraData?: JsonNullableWithAggregatesFilter
    error?: JsonNullableWithAggregatesFilter
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    fxRequestID?: UuidNullableWithAggregatesFilter | string | null
    buyPrice?: StringWithAggregatesFilter | string
    sellPrice?: StringWithAggregatesFilter | string
    quantity?: StringWithAggregatesFilter | string
  }

  export type transactionStatusTypesWhereInput = {
    AND?: Enumerable<transactionStatusTypesWhereInput>
    OR?: Enumerable<transactionStatusTypesWhereInput>
    NOT?: Enumerable<transactionStatusTypesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    transactions?: TransactionsListRelationFilter
  }

  export type transactionStatusTypesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactions?: transactionsOrderByRelationAggregateInput
  }

  export type transactionStatusTypesWhereUniqueInput = {
    id?: number
  }

  export type transactionStatusTypesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: transactionStatusTypesCountOrderByAggregateInput
    _avg?: transactionStatusTypesAvgOrderByAggregateInput
    _max?: transactionStatusTypesMaxOrderByAggregateInput
    _min?: transactionStatusTypesMinOrderByAggregateInput
    _sum?: transactionStatusTypesSumOrderByAggregateInput
  }

  export type transactionStatusTypesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<transactionStatusTypesScalarWhereWithAggregatesInput>
    OR?: Enumerable<transactionStatusTypesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<transactionStatusTypesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type transactionTypesWhereInput = {
    AND?: Enumerable<transactionTypesWhereInput>
    OR?: Enumerable<transactionTypesWhereInput>
    NOT?: Enumerable<transactionTypesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    transactionPolicies?: TransactionPoliciesListRelationFilter
    transactions?: TransactionsListRelationFilter
  }

  export type transactionTypesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactionPolicies?: transactionPoliciesOrderByRelationAggregateInput
    transactions?: transactionsOrderByRelationAggregateInput
  }

  export type transactionTypesWhereUniqueInput = {
    id?: number
  }

  export type transactionTypesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: transactionTypesCountOrderByAggregateInput
    _avg?: transactionTypesAvgOrderByAggregateInput
    _max?: transactionTypesMaxOrderByAggregateInput
    _min?: transactionTypesMinOrderByAggregateInput
    _sum?: transactionTypesSumOrderByAggregateInput
  }

  export type transactionTypesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<transactionTypesScalarWhereWithAggregatesInput>
    OR?: Enumerable<transactionTypesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<transactionTypesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type transactionsWhereInput = {
    AND?: Enumerable<transactionsWhereInput>
    OR?: Enumerable<transactionsWhereInput>
    NOT?: Enumerable<transactionsWhereInput>
    id?: UuidFilter | string
    custodyVendorId?: IntFilter | number
    custodyVendorRef?: StringFilter | string
    transactionTypeId?: IntFilter | number
    amountAsset?: StringFilter | string
    amountUSD?: StringFilter | string
    assetId?: IntFilter | number
    transactionStatusTypeId?: IntFilter | number
    onChainTxId?: StringNullableFilter | string | null
    sourceVaultId?: UuidNullableFilter | string | null
    targetVaultId?: UuidNullableFilter | string | null
    targetWithdrawalAddressId?: UuidNullableFilter | string | null
    sourceExternalAddress?: StringNullableFilter | string | null
    createdByUserId?: UuidNullableFilter | string | null
    subjectId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    assets?: XOR<AssetsRelationFilter, assetsWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput> | null
    vendors?: XOR<VendorsRelationFilter, vendorsWhereInput>
    vaults_transactions_sourceVaultIdTovaults?: XOR<VaultsRelationFilter, vaultsWhereInput> | null
    vaults_transactions_targetVaultIdTovaults?: XOR<VaultsRelationFilter, vaultsWhereInput> | null
    withdrawalAddresses?: XOR<WithdrawalAddressesRelationFilter, withdrawalAddressesWhereInput> | null
    transactionStatusTypes?: XOR<TransactionStatusTypesRelationFilter, transactionStatusTypesWhereInput>
    transactionTypes?: XOR<TransactionTypesRelationFilter, transactionTypesWhereInput>
  }

  export type transactionsOrderByWithRelationInput = {
    id?: SortOrder
    custodyVendorId?: SortOrder
    custodyVendorRef?: SortOrder
    transactionTypeId?: SortOrder
    amountAsset?: SortOrder
    amountUSD?: SortOrder
    assetId?: SortOrder
    transactionStatusTypeId?: SortOrder
    onChainTxId?: SortOrder
    sourceVaultId?: SortOrder
    targetVaultId?: SortOrder
    targetWithdrawalAddressId?: SortOrder
    sourceExternalAddress?: SortOrder
    createdByUserId?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assets?: assetsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
    vendors?: vendorsOrderByWithRelationInput
    vaults_transactions_sourceVaultIdTovaults?: vaultsOrderByWithRelationInput
    vaults_transactions_targetVaultIdTovaults?: vaultsOrderByWithRelationInput
    withdrawalAddresses?: withdrawalAddressesOrderByWithRelationInput
    transactionStatusTypes?: transactionStatusTypesOrderByWithRelationInput
    transactionTypes?: transactionTypesOrderByWithRelationInput
  }

  export type transactionsWhereUniqueInput = {
    id?: string
  }

  export type transactionsOrderByWithAggregationInput = {
    id?: SortOrder
    custodyVendorId?: SortOrder
    custodyVendorRef?: SortOrder
    transactionTypeId?: SortOrder
    amountAsset?: SortOrder
    amountUSD?: SortOrder
    assetId?: SortOrder
    transactionStatusTypeId?: SortOrder
    onChainTxId?: SortOrder
    sourceVaultId?: SortOrder
    targetVaultId?: SortOrder
    targetWithdrawalAddressId?: SortOrder
    sourceExternalAddress?: SortOrder
    createdByUserId?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: transactionsCountOrderByAggregateInput
    _avg?: transactionsAvgOrderByAggregateInput
    _max?: transactionsMaxOrderByAggregateInput
    _min?: transactionsMinOrderByAggregateInput
    _sum?: transactionsSumOrderByAggregateInput
  }

  export type transactionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<transactionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<transactionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<transactionsScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    custodyVendorId?: IntWithAggregatesFilter | number
    custodyVendorRef?: StringWithAggregatesFilter | string
    transactionTypeId?: IntWithAggregatesFilter | number
    amountAsset?: StringWithAggregatesFilter | string
    amountUSD?: StringWithAggregatesFilter | string
    assetId?: IntWithAggregatesFilter | number
    transactionStatusTypeId?: IntWithAggregatesFilter | number
    onChainTxId?: StringNullableWithAggregatesFilter | string | null
    sourceVaultId?: UuidNullableWithAggregatesFilter | string | null
    targetVaultId?: UuidNullableWithAggregatesFilter | string | null
    targetWithdrawalAddressId?: UuidNullableWithAggregatesFilter | string | null
    sourceExternalAddress?: StringNullableWithAggregatesFilter | string | null
    createdByUserId?: UuidNullableWithAggregatesFilter | string | null
    subjectId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type usersWhereInput = {
    AND?: Enumerable<usersWhereInput>
    OR?: Enumerable<usersWhereInput>
    NOT?: Enumerable<usersWhereInput>
    id?: UuidFilter | string
    organizationId?: IntFilter | number
    userTypeId?: IntFilter | number
    primaryEmail?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    publicKey?: StringNullableFilter | string | null
    apiKey?: StringNullableFilter | string | null
    transactionPolicies?: TransactionPoliciesListRelationFilter
    transactions?: TransactionsListRelationFilter
    organizations?: XOR<OrganizationsRelationFilter, organizationsWhereInput>
    userTypes?: XOR<UserTypesRelationFilter, userTypesWhereInput>
    vaults?: VaultsListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userTypeId?: SortOrder
    primaryEmail?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publicKey?: SortOrder
    apiKey?: SortOrder
    transactionPolicies?: transactionPoliciesOrderByRelationAggregateInput
    transactions?: transactionsOrderByRelationAggregateInput
    organizations?: organizationsOrderByWithRelationInput
    userTypes?: userTypesOrderByWithRelationInput
    vaults?: vaultsOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = {
    id?: string
  }

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userTypeId?: SortOrder
    primaryEmail?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publicKey?: SortOrder
    apiKey?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<usersScalarWhereWithAggregatesInput>
    OR?: Enumerable<usersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<usersScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    organizationId?: IntWithAggregatesFilter | number
    userTypeId?: IntWithAggregatesFilter | number
    primaryEmail?: StringWithAggregatesFilter | string
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    publicKey?: StringNullableWithAggregatesFilter | string | null
    apiKey?: StringNullableWithAggregatesFilter | string | null
  }

  export type vendorTypesWhereInput = {
    AND?: Enumerable<vendorTypesWhereInput>
    OR?: Enumerable<vendorTypesWhereInput>
    NOT?: Enumerable<vendorTypesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    vendors?: VendorsListRelationFilter
  }

  export type vendorTypesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendors?: vendorsOrderByRelationAggregateInput
  }

  export type vendorTypesWhereUniqueInput = {
    id?: number
  }

  export type vendorTypesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: vendorTypesCountOrderByAggregateInput
    _avg?: vendorTypesAvgOrderByAggregateInput
    _max?: vendorTypesMaxOrderByAggregateInput
    _min?: vendorTypesMinOrderByAggregateInput
    _sum?: vendorTypesSumOrderByAggregateInput
  }

  export type vendorTypesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<vendorTypesScalarWhereWithAggregatesInput>
    OR?: Enumerable<vendorTypesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<vendorTypesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type vendorsWhereInput = {
    AND?: Enumerable<vendorsWhereInput>
    OR?: Enumerable<vendorsWhereInput>
    NOT?: Enumerable<vendorsWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    identifier?: StringFilter | string
    vendorTypeId?: IntFilter | number
    quoteEngineBaseBps?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    custodyVendorVaultAssets?: CustodyVendorVaultAssetsListRelationFilter
    depositAddresses?: DepositAddressesListRelationFilter
    quotes?: QuotesListRelationFilter
    tokenPairs?: TokenPairsListRelationFilter
    transactions?: TransactionsListRelationFilter
    vendorSupportsAssets?: VendorSupportsAssetsListRelationFilter
    vendorTypes?: XOR<VendorTypesRelationFilter, vendorTypesWhereInput>
  }

  export type vendorsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    identifier?: SortOrder
    vendorTypeId?: SortOrder
    quoteEngineBaseBps?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    custodyVendorVaultAssets?: custodyVendorVaultAssetsOrderByRelationAggregateInput
    depositAddresses?: depositAddressesOrderByRelationAggregateInput
    quotes?: quotesOrderByRelationAggregateInput
    tokenPairs?: tokenPairsOrderByRelationAggregateInput
    transactions?: transactionsOrderByRelationAggregateInput
    vendorSupportsAssets?: vendorSupportsAssetsOrderByRelationAggregateInput
    vendorTypes?: vendorTypesOrderByWithRelationInput
  }

  export type vendorsWhereUniqueInput = {
    id?: number
  }

  export type vendorsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    identifier?: SortOrder
    vendorTypeId?: SortOrder
    quoteEngineBaseBps?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: vendorsCountOrderByAggregateInput
    _avg?: vendorsAvgOrderByAggregateInput
    _max?: vendorsMaxOrderByAggregateInput
    _min?: vendorsMinOrderByAggregateInput
    _sum?: vendorsSumOrderByAggregateInput
  }

  export type vendorsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<vendorsScalarWhereWithAggregatesInput>
    OR?: Enumerable<vendorsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<vendorsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    identifier?: StringWithAggregatesFilter | string
    vendorTypeId?: IntWithAggregatesFilter | number
    quoteEngineBaseBps?: FloatWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type custodyEngineEventTypesWhereInput = {
    AND?: Enumerable<custodyEngineEventTypesWhereInput>
    OR?: Enumerable<custodyEngineEventTypesWhereInput>
    NOT?: Enumerable<custodyEngineEventTypesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    custodyEngineEvents?: CustodyEngineEventsListRelationFilter
  }

  export type custodyEngineEventTypesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    custodyEngineEvents?: custodyEngineEventsOrderByRelationAggregateInput
  }

  export type custodyEngineEventTypesWhereUniqueInput = {
    id?: number
  }

  export type custodyEngineEventTypesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: custodyEngineEventTypesCountOrderByAggregateInput
    _avg?: custodyEngineEventTypesAvgOrderByAggregateInput
    _max?: custodyEngineEventTypesMaxOrderByAggregateInput
    _min?: custodyEngineEventTypesMinOrderByAggregateInput
    _sum?: custodyEngineEventTypesSumOrderByAggregateInput
  }

  export type custodyEngineEventTypesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<custodyEngineEventTypesScalarWhereWithAggregatesInput>
    OR?: Enumerable<custodyEngineEventTypesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<custodyEngineEventTypesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type custodyEngineEventsWhereInput = {
    AND?: Enumerable<custodyEngineEventsWhereInput>
    OR?: Enumerable<custodyEngineEventsWhereInput>
    NOT?: Enumerable<custodyEngineEventsWhereInput>
    id?: UuidFilter | string
    organizationId?: IntFilter | number
    custodyEngineEventTypeId?: IntFilter | number
    event?: JsonFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    custodyEngineEventTypes?: XOR<CustodyEngineEventTypesRelationFilter, custodyEngineEventTypesWhereInput>
    organizations?: XOR<OrganizationsRelationFilter, organizationsWhereInput>
    webhookRequests?: WebhookRequestsListRelationFilter
  }

  export type custodyEngineEventsOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    custodyEngineEventTypeId?: SortOrder
    event?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    custodyEngineEventTypes?: custodyEngineEventTypesOrderByWithRelationInput
    organizations?: organizationsOrderByWithRelationInput
    webhookRequests?: webhookRequestsOrderByRelationAggregateInput
  }

  export type custodyEngineEventsWhereUniqueInput = {
    id?: string
  }

  export type custodyEngineEventsOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    custodyEngineEventTypeId?: SortOrder
    event?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: custodyEngineEventsCountOrderByAggregateInput
    _avg?: custodyEngineEventsAvgOrderByAggregateInput
    _max?: custodyEngineEventsMaxOrderByAggregateInput
    _min?: custodyEngineEventsMinOrderByAggregateInput
    _sum?: custodyEngineEventsSumOrderByAggregateInput
  }

  export type custodyEngineEventsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<custodyEngineEventsScalarWhereWithAggregatesInput>
    OR?: Enumerable<custodyEngineEventsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<custodyEngineEventsScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    organizationId?: IntWithAggregatesFilter | number
    custodyEngineEventTypeId?: IntWithAggregatesFilter | number
    event?: JsonWithAggregatesFilter
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type custodyVendorVaultAssetsWhereInput = {
    AND?: Enumerable<custodyVendorVaultAssetsWhereInput>
    OR?: Enumerable<custodyVendorVaultAssetsWhereInput>
    NOT?: Enumerable<custodyVendorVaultAssetsWhereInput>
    id?: IntFilter | number
    vendorId?: IntFilter | number
    vendorRef?: StringFilter | string
    balance?: StringFilter | string
    vaultAssetId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    vaultAssets?: XOR<VaultAssetsRelationFilter, vaultAssetsWhereInput>
    vendors?: XOR<VendorsRelationFilter, vendorsWhereInput>
  }

  export type custodyVendorVaultAssetsOrderByWithRelationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    vendorRef?: SortOrder
    balance?: SortOrder
    vaultAssetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vaultAssets?: vaultAssetsOrderByWithRelationInput
    vendors?: vendorsOrderByWithRelationInput
  }

  export type custodyVendorVaultAssetsWhereUniqueInput = {
    id?: number
  }

  export type custodyVendorVaultAssetsOrderByWithAggregationInput = {
    id?: SortOrder
    vendorId?: SortOrder
    vendorRef?: SortOrder
    balance?: SortOrder
    vaultAssetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: custodyVendorVaultAssetsCountOrderByAggregateInput
    _avg?: custodyVendorVaultAssetsAvgOrderByAggregateInput
    _max?: custodyVendorVaultAssetsMaxOrderByAggregateInput
    _min?: custodyVendorVaultAssetsMinOrderByAggregateInput
    _sum?: custodyVendorVaultAssetsSumOrderByAggregateInput
  }

  export type custodyVendorVaultAssetsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<custodyVendorVaultAssetsScalarWhereWithAggregatesInput>
    OR?: Enumerable<custodyVendorVaultAssetsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<custodyVendorVaultAssetsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    vendorId?: IntWithAggregatesFilter | number
    vendorRef?: StringWithAggregatesFilter | string
    balance?: StringWithAggregatesFilter | string
    vaultAssetId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type depositAddressStatusTypesWhereInput = {
    AND?: Enumerable<depositAddressStatusTypesWhereInput>
    OR?: Enumerable<depositAddressStatusTypesWhereInput>
    NOT?: Enumerable<depositAddressStatusTypesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type depositAddressStatusTypesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type depositAddressStatusTypesWhereUniqueInput = {
    id?: number
  }

  export type depositAddressStatusTypesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: depositAddressStatusTypesCountOrderByAggregateInput
    _avg?: depositAddressStatusTypesAvgOrderByAggregateInput
    _max?: depositAddressStatusTypesMaxOrderByAggregateInput
    _min?: depositAddressStatusTypesMinOrderByAggregateInput
    _sum?: depositAddressStatusTypesSumOrderByAggregateInput
  }

  export type depositAddressStatusTypesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<depositAddressStatusTypesScalarWhereWithAggregatesInput>
    OR?: Enumerable<depositAddressStatusTypesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<depositAddressStatusTypesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type depositAddressesWhereInput = {
    AND?: Enumerable<depositAddressesWhereInput>
    OR?: Enumerable<depositAddressesWhereInput>
    NOT?: Enumerable<depositAddressesWhereInput>
    id?: UuidFilter | string
    vaultAssetId?: IntFilter | number
    address?: StringFilter | string
    depositAddressStatusId?: IntNullableFilter | number | null
    vendorId?: IntNullableFilter | number | null
    vendorRef?: StringFilter | string
    subjectId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    vaultAssets?: XOR<VaultAssetsRelationFilter, vaultAssetsWhereInput>
    vendors?: XOR<VendorsRelationFilter, vendorsWhereInput> | null
  }

  export type depositAddressesOrderByWithRelationInput = {
    id?: SortOrder
    vaultAssetId?: SortOrder
    address?: SortOrder
    depositAddressStatusId?: SortOrder
    vendorId?: SortOrder
    vendorRef?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vaultAssets?: vaultAssetsOrderByWithRelationInput
    vendors?: vendorsOrderByWithRelationInput
  }

  export type depositAddressesWhereUniqueInput = {
    id?: string
  }

  export type depositAddressesOrderByWithAggregationInput = {
    id?: SortOrder
    vaultAssetId?: SortOrder
    address?: SortOrder
    depositAddressStatusId?: SortOrder
    vendorId?: SortOrder
    vendorRef?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: depositAddressesCountOrderByAggregateInput
    _avg?: depositAddressesAvgOrderByAggregateInput
    _max?: depositAddressesMaxOrderByAggregateInput
    _min?: depositAddressesMinOrderByAggregateInput
    _sum?: depositAddressesSumOrderByAggregateInput
  }

  export type depositAddressesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<depositAddressesScalarWhereWithAggregatesInput>
    OR?: Enumerable<depositAddressesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<depositAddressesScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    vaultAssetId?: IntWithAggregatesFilter | number
    address?: StringWithAggregatesFilter | string
    depositAddressStatusId?: IntNullableWithAggregatesFilter | number | null
    vendorId?: IntNullableWithAggregatesFilter | number | null
    vendorRef?: StringWithAggregatesFilter | string
    subjectId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type institutionalProductsWhereInput = {
    AND?: Enumerable<institutionalProductsWhereInput>
    OR?: Enumerable<institutionalProductsWhereInput>
    NOT?: Enumerable<institutionalProductsWhereInput>
    id?: UuidFilter | string
    name?: StringFilter | string
    enabled?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    webhookRequests?: WebhookRequestsListRelationFilter
  }

  export type institutionalProductsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    webhookRequests?: webhookRequestsOrderByRelationAggregateInput
  }

  export type institutionalProductsWhereUniqueInput = {
    id?: string
  }

  export type institutionalProductsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: institutionalProductsCountOrderByAggregateInput
    _max?: institutionalProductsMaxOrderByAggregateInput
    _min?: institutionalProductsMinOrderByAggregateInput
  }

  export type institutionalProductsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<institutionalProductsScalarWhereWithAggregatesInput>
    OR?: Enumerable<institutionalProductsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<institutionalProductsScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    enabled?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ordersWhereInput = {
    AND?: Enumerable<ordersWhereInput>
    OR?: Enumerable<ordersWhereInput>
    NOT?: Enumerable<ordersWhereInput>
    id?: UuidFilter | string
    quoteId?: UuidFilter | string
    orderStatus?: StringNullableFilter | string | null
    userAcceptedPrice?: StringFilter | string
    userAcceptedQuantity?: StringFilter | string
    userAcceptedSide?: Enumenum_orders_userAcceptedSideFilter | enum_orders_userAcceptedSide
    userAcceptedTradePair?: JsonFilter
    userAcceptedTimestamp?: DateTimeFilter | Date | string
    orderType?: Enumenum_orders_orderTypeNullableFilter | enum_orders_orderType | null
    orderTimeInForce?: StringNullableFilter | string | null
    vendorQuoteId?: StringNullableFilter | string | null
    vendorQuantityRequested?: StringNullableFilter | string | null
    vendorPriceRequested?: StringNullableFilter | string | null
    orderQuantityExecuted?: StringNullableFilter | string | null
    orderPriceExecuted?: StringNullableFilter | string | null
    orderTimestampExecuted?: DateTimeNullableFilter | Date | string | null
    orderVendorStatus?: StringNullableFilter | string | null
    allowedSlippage?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    quotes?: XOR<QuotesRelationFilter, quotesWhereInput>
  }

  export type ordersOrderByWithRelationInput = {
    id?: SortOrder
    quoteId?: SortOrder
    orderStatus?: SortOrder
    userAcceptedPrice?: SortOrder
    userAcceptedQuantity?: SortOrder
    userAcceptedSide?: SortOrder
    userAcceptedTradePair?: SortOrder
    userAcceptedTimestamp?: SortOrder
    orderType?: SortOrder
    orderTimeInForce?: SortOrder
    vendorQuoteId?: SortOrder
    vendorQuantityRequested?: SortOrder
    vendorPriceRequested?: SortOrder
    orderQuantityExecuted?: SortOrder
    orderPriceExecuted?: SortOrder
    orderTimestampExecuted?: SortOrder
    orderVendorStatus?: SortOrder
    allowedSlippage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quotes?: quotesOrderByWithRelationInput
  }

  export type ordersWhereUniqueInput = {
    id?: string
  }

  export type ordersOrderByWithAggregationInput = {
    id?: SortOrder
    quoteId?: SortOrder
    orderStatus?: SortOrder
    userAcceptedPrice?: SortOrder
    userAcceptedQuantity?: SortOrder
    userAcceptedSide?: SortOrder
    userAcceptedTradePair?: SortOrder
    userAcceptedTimestamp?: SortOrder
    orderType?: SortOrder
    orderTimeInForce?: SortOrder
    vendorQuoteId?: SortOrder
    vendorQuantityRequested?: SortOrder
    vendorPriceRequested?: SortOrder
    orderQuantityExecuted?: SortOrder
    orderPriceExecuted?: SortOrder
    orderTimestampExecuted?: SortOrder
    orderVendorStatus?: SortOrder
    allowedSlippage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ordersCountOrderByAggregateInput
    _max?: ordersMaxOrderByAggregateInput
    _min?: ordersMinOrderByAggregateInput
  }

  export type ordersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ordersScalarWhereWithAggregatesInput>
    OR?: Enumerable<ordersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ordersScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    quoteId?: UuidWithAggregatesFilter | string
    orderStatus?: StringNullableWithAggregatesFilter | string | null
    userAcceptedPrice?: StringWithAggregatesFilter | string
    userAcceptedQuantity?: StringWithAggregatesFilter | string
    userAcceptedSide?: Enumenum_orders_userAcceptedSideWithAggregatesFilter | enum_orders_userAcceptedSide
    userAcceptedTradePair?: JsonWithAggregatesFilter
    userAcceptedTimestamp?: DateTimeWithAggregatesFilter | Date | string
    orderType?: Enumenum_orders_orderTypeNullableWithAggregatesFilter | enum_orders_orderType | null
    orderTimeInForce?: StringNullableWithAggregatesFilter | string | null
    vendorQuoteId?: StringNullableWithAggregatesFilter | string | null
    vendorQuantityRequested?: StringNullableWithAggregatesFilter | string | null
    vendorPriceRequested?: StringNullableWithAggregatesFilter | string | null
    orderQuantityExecuted?: StringNullableWithAggregatesFilter | string | null
    orderPriceExecuted?: StringNullableWithAggregatesFilter | string | null
    orderTimestampExecuted?: DateTimeNullableWithAggregatesFilter | Date | string | null
    orderVendorStatus?: StringNullableWithAggregatesFilter | string | null
    allowedSlippage?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type organizationStatusTypesWhereInput = {
    AND?: Enumerable<organizationStatusTypesWhereInput>
    OR?: Enumerable<organizationStatusTypesWhereInput>
    NOT?: Enumerable<organizationStatusTypesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    organizations?: OrganizationsListRelationFilter
  }

  export type organizationStatusTypesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizations?: organizationsOrderByRelationAggregateInput
  }

  export type organizationStatusTypesWhereUniqueInput = {
    id?: number
  }

  export type organizationStatusTypesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: organizationStatusTypesCountOrderByAggregateInput
    _avg?: organizationStatusTypesAvgOrderByAggregateInput
    _max?: organizationStatusTypesMaxOrderByAggregateInput
    _min?: organizationStatusTypesMinOrderByAggregateInput
    _sum?: organizationStatusTypesSumOrderByAggregateInput
  }

  export type organizationStatusTypesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<organizationStatusTypesScalarWhereWithAggregatesInput>
    OR?: Enumerable<organizationStatusTypesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<organizationStatusTypesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type organizationsWhereInput = {
    AND?: Enumerable<organizationsWhereInput>
    OR?: Enumerable<organizationsWhereInput>
    NOT?: Enumerable<organizationsWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    primaryEmail?: StringFilter | string
    pricingPlanId?: IntFilter | number
    statusId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    custodyEngineEvents?: CustodyEngineEventsListRelationFilter
    pricingPlans?: XOR<PricingPlansRelationFilter, pricingPlansWhereInput>
    organizationStatusTypes?: XOR<OrganizationStatusTypesRelationFilter, organizationStatusTypesWhereInput>
    users?: UsersListRelationFilter
    webhooks?: WebhooksListRelationFilter
    withdrawalAddresses?: WithdrawalAddressesListRelationFilter
  }

  export type organizationsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    primaryEmail?: SortOrder
    pricingPlanId?: SortOrder
    statusId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    custodyEngineEvents?: custodyEngineEventsOrderByRelationAggregateInput
    pricingPlans?: pricingPlansOrderByWithRelationInput
    organizationStatusTypes?: organizationStatusTypesOrderByWithRelationInput
    users?: usersOrderByRelationAggregateInput
    webhooks?: webhooksOrderByRelationAggregateInput
    withdrawalAddresses?: withdrawalAddressesOrderByRelationAggregateInput
  }

  export type organizationsWhereUniqueInput = {
    id?: number
  }

  export type organizationsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    primaryEmail?: SortOrder
    pricingPlanId?: SortOrder
    statusId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: organizationsCountOrderByAggregateInput
    _avg?: organizationsAvgOrderByAggregateInput
    _max?: organizationsMaxOrderByAggregateInput
    _min?: organizationsMinOrderByAggregateInput
    _sum?: organizationsSumOrderByAggregateInput
  }

  export type organizationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<organizationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<organizationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<organizationsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    primaryEmail?: StringWithAggregatesFilter | string
    pricingPlanId?: IntWithAggregatesFilter | number
    statusId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type pricingPlanProfilesWhereInput = {
    AND?: Enumerable<pricingPlanProfilesWhereInput>
    OR?: Enumerable<pricingPlanProfilesWhereInput>
    NOT?: Enumerable<pricingPlanProfilesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    quoteEngineRps?: IntFilter | number
    custodyEngineRps?: IntFilter | number
    numberOfUsers?: IntFilter | number
    sla?: FloatFilter | number
    rbac?: BoolFilter | boolean
    quoteEngineClaims?: JsonFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    pricingPlans?: PricingPlansListRelationFilter
  }

  export type pricingPlanProfilesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    quoteEngineRps?: SortOrder
    custodyEngineRps?: SortOrder
    numberOfUsers?: SortOrder
    sla?: SortOrder
    rbac?: SortOrder
    quoteEngineClaims?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pricingPlans?: pricingPlansOrderByRelationAggregateInput
  }

  export type pricingPlanProfilesWhereUniqueInput = {
    id?: number
  }

  export type pricingPlanProfilesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    quoteEngineRps?: SortOrder
    custodyEngineRps?: SortOrder
    numberOfUsers?: SortOrder
    sla?: SortOrder
    rbac?: SortOrder
    quoteEngineClaims?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: pricingPlanProfilesCountOrderByAggregateInput
    _avg?: pricingPlanProfilesAvgOrderByAggregateInput
    _max?: pricingPlanProfilesMaxOrderByAggregateInput
    _min?: pricingPlanProfilesMinOrderByAggregateInput
    _sum?: pricingPlanProfilesSumOrderByAggregateInput
  }

  export type pricingPlanProfilesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<pricingPlanProfilesScalarWhereWithAggregatesInput>
    OR?: Enumerable<pricingPlanProfilesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<pricingPlanProfilesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    quoteEngineRps?: IntWithAggregatesFilter | number
    custodyEngineRps?: IntWithAggregatesFilter | number
    numberOfUsers?: IntWithAggregatesFilter | number
    sla?: FloatWithAggregatesFilter | number
    rbac?: BoolWithAggregatesFilter | boolean
    quoteEngineClaims?: JsonWithAggregatesFilter
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type pricingPlanSupportsAssetsWhereInput = {
    AND?: Enumerable<pricingPlanSupportsAssetsWhereInput>
    OR?: Enumerable<pricingPlanSupportsAssetsWhereInput>
    NOT?: Enumerable<pricingPlanSupportsAssetsWhereInput>
    id?: IntFilter | number
    vendorSupportsAssetId?: IntFilter | number
    pricingPlanId?: IntFilter | number
    enabled?: BoolFilter | boolean
    buyBps?: FloatFilter | number
    sellBps?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    pricingPlans?: XOR<PricingPlansRelationFilter, pricingPlansWhereInput>
    vendorSupportsAssets?: XOR<VendorSupportsAssetsRelationFilter, vendorSupportsAssetsWhereInput>
  }

  export type pricingPlanSupportsAssetsOrderByWithRelationInput = {
    id?: SortOrder
    vendorSupportsAssetId?: SortOrder
    pricingPlanId?: SortOrder
    enabled?: SortOrder
    buyBps?: SortOrder
    sellBps?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pricingPlans?: pricingPlansOrderByWithRelationInput
    vendorSupportsAssets?: vendorSupportsAssetsOrderByWithRelationInput
  }

  export type pricingPlanSupportsAssetsWhereUniqueInput = {
    id?: number
  }

  export type pricingPlanSupportsAssetsOrderByWithAggregationInput = {
    id?: SortOrder
    vendorSupportsAssetId?: SortOrder
    pricingPlanId?: SortOrder
    enabled?: SortOrder
    buyBps?: SortOrder
    sellBps?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: pricingPlanSupportsAssetsCountOrderByAggregateInput
    _avg?: pricingPlanSupportsAssetsAvgOrderByAggregateInput
    _max?: pricingPlanSupportsAssetsMaxOrderByAggregateInput
    _min?: pricingPlanSupportsAssetsMinOrderByAggregateInput
    _sum?: pricingPlanSupportsAssetsSumOrderByAggregateInput
  }

  export type pricingPlanSupportsAssetsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<pricingPlanSupportsAssetsScalarWhereWithAggregatesInput>
    OR?: Enumerable<pricingPlanSupportsAssetsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<pricingPlanSupportsAssetsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    vendorSupportsAssetId?: IntWithAggregatesFilter | number
    pricingPlanId?: IntWithAggregatesFilter | number
    enabled?: BoolWithAggregatesFilter | boolean
    buyBps?: FloatWithAggregatesFilter | number
    sellBps?: FloatWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type pricingPlansWhereInput = {
    AND?: Enumerable<pricingPlansWhereInput>
    OR?: Enumerable<pricingPlansWhereInput>
    NOT?: Enumerable<pricingPlansWhereInput>
    id?: IntFilter | number
    price?: FloatFilter | number
    active?: BoolFilter | boolean
    pricingPlanProfileId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    organizations?: OrganizationsListRelationFilter
    pricingPlanSupportsAssets?: PricingPlanSupportsAssetsListRelationFilter
    pricingPlanProfiles?: XOR<PricingPlanProfilesRelationFilter, pricingPlanProfilesWhereInput>
  }

  export type pricingPlansOrderByWithRelationInput = {
    id?: SortOrder
    price?: SortOrder
    active?: SortOrder
    pricingPlanProfileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organizations?: organizationsOrderByRelationAggregateInput
    pricingPlanSupportsAssets?: pricingPlanSupportsAssetsOrderByRelationAggregateInput
    pricingPlanProfiles?: pricingPlanProfilesOrderByWithRelationInput
  }

  export type pricingPlansWhereUniqueInput = {
    id?: number
  }

  export type pricingPlansOrderByWithAggregationInput = {
    id?: SortOrder
    price?: SortOrder
    active?: SortOrder
    pricingPlanProfileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: pricingPlansCountOrderByAggregateInput
    _avg?: pricingPlansAvgOrderByAggregateInput
    _max?: pricingPlansMaxOrderByAggregateInput
    _min?: pricingPlansMinOrderByAggregateInput
    _sum?: pricingPlansSumOrderByAggregateInput
  }

  export type pricingPlansScalarWhereWithAggregatesInput = {
    AND?: Enumerable<pricingPlansScalarWhereWithAggregatesInput>
    OR?: Enumerable<pricingPlansScalarWhereWithAggregatesInput>
    NOT?: Enumerable<pricingPlansScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    price?: FloatWithAggregatesFilter | number
    active?: BoolWithAggregatesFilter | boolean
    pricingPlanProfileId?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type quoteStatusesWhereInput = {
    AND?: Enumerable<quoteStatusesWhereInput>
    OR?: Enumerable<quoteStatusesWhereInput>
    NOT?: Enumerable<quoteStatusesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    quotes?: QuotesListRelationFilter
  }

  export type quoteStatusesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quotes?: quotesOrderByRelationAggregateInput
  }

  export type quoteStatusesWhereUniqueInput = {
    id?: number
  }

  export type quoteStatusesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: quoteStatusesCountOrderByAggregateInput
    _avg?: quoteStatusesAvgOrderByAggregateInput
    _max?: quoteStatusesMaxOrderByAggregateInput
    _min?: quoteStatusesMinOrderByAggregateInput
    _sum?: quoteStatusesSumOrderByAggregateInput
  }

  export type quoteStatusesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<quoteStatusesScalarWhereWithAggregatesInput>
    OR?: Enumerable<quoteStatusesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<quoteStatusesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type tokenPairsWhereInput = {
    AND?: Enumerable<tokenPairsWhereInput>
    OR?: Enumerable<tokenPairsWhereInput>
    NOT?: Enumerable<tokenPairsWhereInput>
    id?: IntFilter | number
    baseToken?: StringFilter | string
    quoteToken?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    vendorId?: IntFilter | number
    vendors?: XOR<VendorsRelationFilter, vendorsWhereInput>
    tokenPairsInfo?: TokenPairsInfoListRelationFilter
  }

  export type tokenPairsOrderByWithRelationInput = {
    id?: SortOrder
    baseToken?: SortOrder
    quoteToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendorId?: SortOrder
    vendors?: vendorsOrderByWithRelationInput
    tokenPairsInfo?: tokenPairsInfoOrderByRelationAggregateInput
  }

  export type tokenPairsWhereUniqueInput = {
    id?: number
  }

  export type tokenPairsOrderByWithAggregationInput = {
    id?: SortOrder
    baseToken?: SortOrder
    quoteToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendorId?: SortOrder
    _count?: tokenPairsCountOrderByAggregateInput
    _avg?: tokenPairsAvgOrderByAggregateInput
    _max?: tokenPairsMaxOrderByAggregateInput
    _min?: tokenPairsMinOrderByAggregateInput
    _sum?: tokenPairsSumOrderByAggregateInput
  }

  export type tokenPairsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<tokenPairsScalarWhereWithAggregatesInput>
    OR?: Enumerable<tokenPairsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<tokenPairsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    baseToken?: StringWithAggregatesFilter | string
    quoteToken?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    vendorId?: IntWithAggregatesFilter | number
  }

  export type tokenPairsInfoWhereInput = {
    AND?: Enumerable<tokenPairsInfoWhereInput>
    OR?: Enumerable<tokenPairsInfoWhereInput>
    NOT?: Enumerable<tokenPairsInfoWhereInput>
    id?: IntFilter | number
    tokenPairId?: IntFilter | number
    fxRequestID?: UuidFilter | string
    quantity?: JsonFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    quotes?: QuotesListRelationFilter
    tokenPairs?: XOR<TokenPairsRelationFilter, tokenPairsWhereInput>
  }

  export type tokenPairsInfoOrderByWithRelationInput = {
    id?: SortOrder
    tokenPairId?: SortOrder
    fxRequestID?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quotes?: quotesOrderByRelationAggregateInput
    tokenPairs?: tokenPairsOrderByWithRelationInput
  }

  export type tokenPairsInfoWhereUniqueInput = {
    id?: number
    fxRequestID?: string
  }

  export type tokenPairsInfoOrderByWithAggregationInput = {
    id?: SortOrder
    tokenPairId?: SortOrder
    fxRequestID?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: tokenPairsInfoCountOrderByAggregateInput
    _avg?: tokenPairsInfoAvgOrderByAggregateInput
    _max?: tokenPairsInfoMaxOrderByAggregateInput
    _min?: tokenPairsInfoMinOrderByAggregateInput
    _sum?: tokenPairsInfoSumOrderByAggregateInput
  }

  export type tokenPairsInfoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<tokenPairsInfoScalarWhereWithAggregatesInput>
    OR?: Enumerable<tokenPairsInfoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<tokenPairsInfoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    tokenPairId?: IntWithAggregatesFilter | number
    fxRequestID?: UuidWithAggregatesFilter | string
    quantity?: JsonWithAggregatesFilter
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type transactionPoliciesWhereInput = {
    AND?: Enumerable<transactionPoliciesWhereInput>
    OR?: Enumerable<transactionPoliciesWhereInput>
    NOT?: Enumerable<transactionPoliciesWhereInput>
    id?: UuidFilter | string
    userId?: UuidFilter | string
    transactionTypeId?: IntFilter | number
    sourceVaultId?: UuidFilter | string
    targetVaultId?: UuidNullableFilter | string | null
    targetWithdrawalAddressId?: UuidNullableFilter | string | null
    toOneTimeAddresses?: BoolNullableFilter | boolean | null
    greaterThanUSD?: StringFilter | string
    assetId?: IntFilter | number
    action?: Enumenum_transactionPolicies_actionFilter | enum_transactionPolicies_action
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    assets?: XOR<AssetsRelationFilter, assetsWhereInput>
    vaults_transactionPolicies_sourceVaultIdTovaults?: XOR<VaultsRelationFilter, vaultsWhereInput>
    vaults_transactionPolicies_targetVaultIdTovaults?: XOR<VaultsRelationFilter, vaultsWhereInput> | null
    withdrawalAddresses?: XOR<WithdrawalAddressesRelationFilter, withdrawalAddressesWhereInput> | null
    transactionTypes?: XOR<TransactionTypesRelationFilter, transactionTypesWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type transactionPoliciesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionTypeId?: SortOrder
    sourceVaultId?: SortOrder
    targetVaultId?: SortOrder
    targetWithdrawalAddressId?: SortOrder
    toOneTimeAddresses?: SortOrder
    greaterThanUSD?: SortOrder
    assetId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assets?: assetsOrderByWithRelationInput
    vaults_transactionPolicies_sourceVaultIdTovaults?: vaultsOrderByWithRelationInput
    vaults_transactionPolicies_targetVaultIdTovaults?: vaultsOrderByWithRelationInput
    withdrawalAddresses?: withdrawalAddressesOrderByWithRelationInput
    transactionTypes?: transactionTypesOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type transactionPoliciesWhereUniqueInput = {
    id?: string
  }

  export type transactionPoliciesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionTypeId?: SortOrder
    sourceVaultId?: SortOrder
    targetVaultId?: SortOrder
    targetWithdrawalAddressId?: SortOrder
    toOneTimeAddresses?: SortOrder
    greaterThanUSD?: SortOrder
    assetId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: transactionPoliciesCountOrderByAggregateInput
    _avg?: transactionPoliciesAvgOrderByAggregateInput
    _max?: transactionPoliciesMaxOrderByAggregateInput
    _min?: transactionPoliciesMinOrderByAggregateInput
    _sum?: transactionPoliciesSumOrderByAggregateInput
  }

  export type transactionPoliciesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<transactionPoliciesScalarWhereWithAggregatesInput>
    OR?: Enumerable<transactionPoliciesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<transactionPoliciesScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    userId?: UuidWithAggregatesFilter | string
    transactionTypeId?: IntWithAggregatesFilter | number
    sourceVaultId?: UuidWithAggregatesFilter | string
    targetVaultId?: UuidNullableWithAggregatesFilter | string | null
    targetWithdrawalAddressId?: UuidNullableWithAggregatesFilter | string | null
    toOneTimeAddresses?: BoolNullableWithAggregatesFilter | boolean | null
    greaterThanUSD?: StringWithAggregatesFilter | string
    assetId?: IntWithAggregatesFilter | number
    action?: Enumenum_transactionPolicies_actionWithAggregatesFilter | enum_transactionPolicies_action
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type userTypesWhereInput = {
    AND?: Enumerable<userTypesWhereInput>
    OR?: Enumerable<userTypesWhereInput>
    NOT?: Enumerable<userTypesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringFilter | string
    claims?: JsonFilter
    isServiceAccount?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    users?: UsersListRelationFilter
  }

  export type userTypesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    claims?: SortOrder
    isServiceAccount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: usersOrderByRelationAggregateInput
  }

  export type userTypesWhereUniqueInput = {
    id?: number
  }

  export type userTypesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    claims?: SortOrder
    isServiceAccount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: userTypesCountOrderByAggregateInput
    _avg?: userTypesAvgOrderByAggregateInput
    _max?: userTypesMaxOrderByAggregateInput
    _min?: userTypesMinOrderByAggregateInput
    _sum?: userTypesSumOrderByAggregateInput
  }

  export type userTypesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<userTypesScalarWhereWithAggregatesInput>
    OR?: Enumerable<userTypesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<userTypesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    claims?: JsonWithAggregatesFilter
    isServiceAccount?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type vaultAssetsWhereInput = {
    AND?: Enumerable<vaultAssetsWhereInput>
    OR?: Enumerable<vaultAssetsWhereInput>
    NOT?: Enumerable<vaultAssetsWhereInput>
    id?: IntFilter | number
    vaultId?: UuidFilter | string
    assetId?: IntFilter | number
    balance?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    custodyVendorVaultAssets?: CustodyVendorVaultAssetsListRelationFilter
    depositAddresses?: DepositAddressesListRelationFilter
    assets?: XOR<AssetsRelationFilter, assetsWhereInput>
    vaults?: XOR<VaultsRelationFilter, vaultsWhereInput>
  }

  export type vaultAssetsOrderByWithRelationInput = {
    id?: SortOrder
    vaultId?: SortOrder
    assetId?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    custodyVendorVaultAssets?: custodyVendorVaultAssetsOrderByRelationAggregateInput
    depositAddresses?: depositAddressesOrderByRelationAggregateInput
    assets?: assetsOrderByWithRelationInput
    vaults?: vaultsOrderByWithRelationInput
  }

  export type vaultAssetsWhereUniqueInput = {
    id?: number
  }

  export type vaultAssetsOrderByWithAggregationInput = {
    id?: SortOrder
    vaultId?: SortOrder
    assetId?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: vaultAssetsCountOrderByAggregateInput
    _avg?: vaultAssetsAvgOrderByAggregateInput
    _max?: vaultAssetsMaxOrderByAggregateInput
    _min?: vaultAssetsMinOrderByAggregateInput
    _sum?: vaultAssetsSumOrderByAggregateInput
  }

  export type vaultAssetsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<vaultAssetsScalarWhereWithAggregatesInput>
    OR?: Enumerable<vaultAssetsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<vaultAssetsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    vaultId?: UuidWithAggregatesFilter | string
    assetId?: IntWithAggregatesFilter | number
    balance?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type vaultStatusTypesWhereInput = {
    AND?: Enumerable<vaultStatusTypesWhereInput>
    OR?: Enumerable<vaultStatusTypesWhereInput>
    NOT?: Enumerable<vaultStatusTypesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    vaults?: VaultsListRelationFilter
  }

  export type vaultStatusTypesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vaults?: vaultsOrderByRelationAggregateInput
  }

  export type vaultStatusTypesWhereUniqueInput = {
    id?: number
  }

  export type vaultStatusTypesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: vaultStatusTypesCountOrderByAggregateInput
    _avg?: vaultStatusTypesAvgOrderByAggregateInput
    _max?: vaultStatusTypesMaxOrderByAggregateInput
    _min?: vaultStatusTypesMinOrderByAggregateInput
    _sum?: vaultStatusTypesSumOrderByAggregateInput
  }

  export type vaultStatusTypesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<vaultStatusTypesScalarWhereWithAggregatesInput>
    OR?: Enumerable<vaultStatusTypesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<vaultStatusTypesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type vaultsWhereInput = {
    AND?: Enumerable<vaultsWhereInput>
    OR?: Enumerable<vaultsWhereInput>
    NOT?: Enumerable<vaultsWhereInput>
    id?: UuidFilter | string
    createdByUserId?: UuidFilter | string
    vaultStatusId?: IntNullableFilter | number | null
    vaultName?: StringNullableFilter | string | null
    subjectId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: TransactionPoliciesListRelationFilter
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: TransactionPoliciesListRelationFilter
    transactions_transactions_sourceVaultIdTovaults?: TransactionsListRelationFilter
    transactions_transactions_targetVaultIdTovaults?: TransactionsListRelationFilter
    vaultAssets?: VaultAssetsListRelationFilter
    users?: XOR<UsersRelationFilter, usersWhereInput>
    vaultStatusTypes?: XOR<VaultStatusTypesRelationFilter, vaultStatusTypesWhereInput> | null
  }

  export type vaultsOrderByWithRelationInput = {
    id?: SortOrder
    createdByUserId?: SortOrder
    vaultStatusId?: SortOrder
    vaultName?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesOrderByRelationAggregateInput
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesOrderByRelationAggregateInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsOrderByRelationAggregateInput
    transactions_transactions_targetVaultIdTovaults?: transactionsOrderByRelationAggregateInput
    vaultAssets?: vaultAssetsOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
    vaultStatusTypes?: vaultStatusTypesOrderByWithRelationInput
  }

  export type vaultsWhereUniqueInput = {
    id?: string
  }

  export type vaultsOrderByWithAggregationInput = {
    id?: SortOrder
    createdByUserId?: SortOrder
    vaultStatusId?: SortOrder
    vaultName?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: vaultsCountOrderByAggregateInput
    _avg?: vaultsAvgOrderByAggregateInput
    _max?: vaultsMaxOrderByAggregateInput
    _min?: vaultsMinOrderByAggregateInput
    _sum?: vaultsSumOrderByAggregateInput
  }

  export type vaultsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<vaultsScalarWhereWithAggregatesInput>
    OR?: Enumerable<vaultsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<vaultsScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    createdByUserId?: UuidWithAggregatesFilter | string
    vaultStatusId?: IntNullableWithAggregatesFilter | number | null
    vaultName?: StringNullableWithAggregatesFilter | string | null
    subjectId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type vendorSupportsAssetsWhereInput = {
    AND?: Enumerable<vendorSupportsAssetsWhereInput>
    OR?: Enumerable<vendorSupportsAssetsWhereInput>
    NOT?: Enumerable<vendorSupportsAssetsWhereInput>
    id?: IntFilter | number
    assetId?: IntFilter | number
    vendorId?: IntFilter | number
    enabled?: BoolNullableFilter | boolean | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    theirId?: StringNullableFilter | string | null
    pricingPlanSupportsAssets?: PricingPlanSupportsAssetsListRelationFilter
    assets?: XOR<AssetsRelationFilter, assetsWhereInput>
    vendors?: XOR<VendorsRelationFilter, vendorsWhereInput>
  }

  export type vendorSupportsAssetsOrderByWithRelationInput = {
    id?: SortOrder
    assetId?: SortOrder
    vendorId?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    theirId?: SortOrder
    pricingPlanSupportsAssets?: pricingPlanSupportsAssetsOrderByRelationAggregateInput
    assets?: assetsOrderByWithRelationInput
    vendors?: vendorsOrderByWithRelationInput
  }

  export type vendorSupportsAssetsWhereUniqueInput = {
    id?: number
  }

  export type vendorSupportsAssetsOrderByWithAggregationInput = {
    id?: SortOrder
    assetId?: SortOrder
    vendorId?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    theirId?: SortOrder
    _count?: vendorSupportsAssetsCountOrderByAggregateInput
    _avg?: vendorSupportsAssetsAvgOrderByAggregateInput
    _max?: vendorSupportsAssetsMaxOrderByAggregateInput
    _min?: vendorSupportsAssetsMinOrderByAggregateInput
    _sum?: vendorSupportsAssetsSumOrderByAggregateInput
  }

  export type vendorSupportsAssetsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<vendorSupportsAssetsScalarWhereWithAggregatesInput>
    OR?: Enumerable<vendorSupportsAssetsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<vendorSupportsAssetsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    assetId?: IntWithAggregatesFilter | number
    vendorId?: IntWithAggregatesFilter | number
    enabled?: BoolNullableWithAggregatesFilter | boolean | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    theirId?: StringNullableWithAggregatesFilter | string | null
  }

  export type webhookRequestsWhereInput = {
    AND?: Enumerable<webhookRequestsWhereInput>
    OR?: Enumerable<webhookRequestsWhereInput>
    NOT?: Enumerable<webhookRequestsWhereInput>
    id?: UuidFilter | string
    webhookId?: UuidFilter | string
    institutionalProductId?: UuidNullableFilter | string | null
    httpStatusCode?: IntFilter | number
    requestPayload?: JsonFilter
    responsePayload?: JsonNullableFilter
    custodyEngineEventId?: UuidNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    custodyEngineEvents?: XOR<CustodyEngineEventsRelationFilter, custodyEngineEventsWhereInput> | null
    institutionalProducts?: XOR<InstitutionalProductsRelationFilter, institutionalProductsWhereInput> | null
    webhooks?: XOR<WebhooksRelationFilter, webhooksWhereInput>
  }

  export type webhookRequestsOrderByWithRelationInput = {
    id?: SortOrder
    webhookId?: SortOrder
    institutionalProductId?: SortOrder
    httpStatusCode?: SortOrder
    requestPayload?: SortOrder
    responsePayload?: SortOrder
    custodyEngineEventId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    custodyEngineEvents?: custodyEngineEventsOrderByWithRelationInput
    institutionalProducts?: institutionalProductsOrderByWithRelationInput
    webhooks?: webhooksOrderByWithRelationInput
  }

  export type webhookRequestsWhereUniqueInput = {
    id?: string
  }

  export type webhookRequestsOrderByWithAggregationInput = {
    id?: SortOrder
    webhookId?: SortOrder
    institutionalProductId?: SortOrder
    httpStatusCode?: SortOrder
    requestPayload?: SortOrder
    responsePayload?: SortOrder
    custodyEngineEventId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: webhookRequestsCountOrderByAggregateInput
    _avg?: webhookRequestsAvgOrderByAggregateInput
    _max?: webhookRequestsMaxOrderByAggregateInput
    _min?: webhookRequestsMinOrderByAggregateInput
    _sum?: webhookRequestsSumOrderByAggregateInput
  }

  export type webhookRequestsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<webhookRequestsScalarWhereWithAggregatesInput>
    OR?: Enumerable<webhookRequestsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<webhookRequestsScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    webhookId?: UuidWithAggregatesFilter | string
    institutionalProductId?: UuidNullableWithAggregatesFilter | string | null
    httpStatusCode?: IntWithAggregatesFilter | number
    requestPayload?: JsonWithAggregatesFilter
    responsePayload?: JsonNullableWithAggregatesFilter
    custodyEngineEventId?: UuidNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type webhookStatusTypesWhereInput = {
    AND?: Enumerable<webhookStatusTypesWhereInput>
    OR?: Enumerable<webhookStatusTypesWhereInput>
    NOT?: Enumerable<webhookStatusTypesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    webhooks?: WebhooksListRelationFilter
  }

  export type webhookStatusTypesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    webhooks?: webhooksOrderByRelationAggregateInput
  }

  export type webhookStatusTypesWhereUniqueInput = {
    id?: number
  }

  export type webhookStatusTypesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: webhookStatusTypesCountOrderByAggregateInput
    _avg?: webhookStatusTypesAvgOrderByAggregateInput
    _max?: webhookStatusTypesMaxOrderByAggregateInput
    _min?: webhookStatusTypesMinOrderByAggregateInput
    _sum?: webhookStatusTypesSumOrderByAggregateInput
  }

  export type webhookStatusTypesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<webhookStatusTypesScalarWhereWithAggregatesInput>
    OR?: Enumerable<webhookStatusTypesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<webhookStatusTypesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type webhooksWhereInput = {
    AND?: Enumerable<webhooksWhereInput>
    OR?: Enumerable<webhooksWhereInput>
    NOT?: Enumerable<webhooksWhereInput>
    id?: UuidFilter | string
    organizationId?: IntFilter | number
    webhookStatusTypeId?: IntFilter | number
    url?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    webhookRequests?: WebhookRequestsListRelationFilter
    organizations?: XOR<OrganizationsRelationFilter, organizationsWhereInput>
    webhookStatusTypes?: XOR<WebhookStatusTypesRelationFilter, webhookStatusTypesWhereInput>
  }

  export type webhooksOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    webhookStatusTypeId?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    webhookRequests?: webhookRequestsOrderByRelationAggregateInput
    organizations?: organizationsOrderByWithRelationInput
    webhookStatusTypes?: webhookStatusTypesOrderByWithRelationInput
  }

  export type webhooksWhereUniqueInput = {
    id?: string
  }

  export type webhooksOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    webhookStatusTypeId?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: webhooksCountOrderByAggregateInput
    _avg?: webhooksAvgOrderByAggregateInput
    _max?: webhooksMaxOrderByAggregateInput
    _min?: webhooksMinOrderByAggregateInput
    _sum?: webhooksSumOrderByAggregateInput
  }

  export type webhooksScalarWhereWithAggregatesInput = {
    AND?: Enumerable<webhooksScalarWhereWithAggregatesInput>
    OR?: Enumerable<webhooksScalarWhereWithAggregatesInput>
    NOT?: Enumerable<webhooksScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    organizationId?: IntWithAggregatesFilter | number
    webhookStatusTypeId?: IntWithAggregatesFilter | number
    url?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type withdrawalAddressesWhereInput = {
    AND?: Enumerable<withdrawalAddressesWhereInput>
    OR?: Enumerable<withdrawalAddressesWhereInput>
    NOT?: Enumerable<withdrawalAddressesWhereInput>
    id?: UuidFilter | string
    organizationId?: IntFilter | number
    assetId?: IntFilter | number
    nickname?: StringNullableFilter | string | null
    address?: StringFilter | string
    subjectId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    transactionPolicies?: TransactionPoliciesListRelationFilter
    transactions?: TransactionsListRelationFilter
    assets?: XOR<AssetsRelationFilter, assetsWhereInput>
    organizations?: XOR<OrganizationsRelationFilter, organizationsWhereInput>
  }

  export type withdrawalAddressesOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    assetId?: SortOrder
    nickname?: SortOrder
    address?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactionPolicies?: transactionPoliciesOrderByRelationAggregateInput
    transactions?: transactionsOrderByRelationAggregateInput
    assets?: assetsOrderByWithRelationInput
    organizations?: organizationsOrderByWithRelationInput
  }

  export type withdrawalAddressesWhereUniqueInput = {
    id?: string
  }

  export type withdrawalAddressesOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    assetId?: SortOrder
    nickname?: SortOrder
    address?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: withdrawalAddressesCountOrderByAggregateInput
    _avg?: withdrawalAddressesAvgOrderByAggregateInput
    _max?: withdrawalAddressesMaxOrderByAggregateInput
    _min?: withdrawalAddressesMinOrderByAggregateInput
    _sum?: withdrawalAddressesSumOrderByAggregateInput
  }

  export type withdrawalAddressesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<withdrawalAddressesScalarWhereWithAggregatesInput>
    OR?: Enumerable<withdrawalAddressesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<withdrawalAddressesScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    organizationId?: IntWithAggregatesFilter | number
    assetId?: IntWithAggregatesFilter | number
    nickname?: StringNullableWithAggregatesFilter | string | null
    address?: StringWithAggregatesFilter | string
    subjectId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SequelizeDataCreateInput = {
    name: string
  }

  export type SequelizeDataUncheckedCreateInput = {
    name: string
  }

  export type SequelizeDataUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SequelizeDataUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SequelizeDataCreateManyInput = {
    name: string
  }

  export type SequelizeDataUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SequelizeDataUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SequelizeMetaCreateInput = {
    name: string
  }

  export type SequelizeMetaUncheckedCreateInput = {
    name: string
  }

  export type SequelizeMetaUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SequelizeMetaUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SequelizeMetaCreateManyInput = {
    name: string
  }

  export type SequelizeMetaUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SequelizeMetaUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type assetsCreateInput = {
    name: string
    description: string
    type: enum_assets_type
    ticker: string
    fireblocksTicker?: string | null
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    baseNetworks?: baseNetworksCreateNestedOneWithoutAssetsInput
    quotes_quotes_sourceAssetIdToassets?: quotesCreateNestedManyWithoutAssets_quotes_sourceAssetIdToassetsInput
    quotes_quotes_targetAssetIdToassets?: quotesCreateNestedManyWithoutAssets_quotes_targetAssetIdToassetsInput
    transactionPolicies?: transactionPoliciesCreateNestedManyWithoutAssetsInput
    transactions?: transactionsCreateNestedManyWithoutAssetsInput
    vaultAssets?: vaultAssetsCreateNestedManyWithoutAssetsInput
    vendorSupportsAssets?: vendorSupportsAssetsCreateNestedManyWithoutAssetsInput
    withdrawalAddresses?: withdrawalAddressesCreateNestedManyWithoutAssetsInput
  }

  export type assetsUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    baseNetworkId?: number | null
    type: enum_assets_type
    ticker: string
    fireblocksTicker?: string | null
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes_quotes_sourceAssetIdToassets?: quotesUncheckedCreateNestedManyWithoutAssets_quotes_sourceAssetIdToassetsInput
    quotes_quotes_targetAssetIdToassets?: quotesUncheckedCreateNestedManyWithoutAssets_quotes_targetAssetIdToassetsInput
    transactionPolicies?: transactionPoliciesUncheckedCreateNestedManyWithoutAssetsInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutAssetsInput
    vaultAssets?: vaultAssetsUncheckedCreateNestedManyWithoutAssetsInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedCreateNestedManyWithoutAssetsInput
    withdrawalAddresses?: withdrawalAddressesUncheckedCreateNestedManyWithoutAssetsInput
  }

  export type assetsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: Enumenum_assets_typeFieldUpdateOperationsInput | enum_assets_type
    ticker?: StringFieldUpdateOperationsInput | string
    fireblocksTicker?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseNetworks?: baseNetworksUpdateOneWithoutAssetsNestedInput
    quotes_quotes_sourceAssetIdToassets?: quotesUpdateManyWithoutAssets_quotes_sourceAssetIdToassetsNestedInput
    quotes_quotes_targetAssetIdToassets?: quotesUpdateManyWithoutAssets_quotes_targetAssetIdToassetsNestedInput
    transactionPolicies?: transactionPoliciesUpdateManyWithoutAssetsNestedInput
    transactions?: transactionsUpdateManyWithoutAssetsNestedInput
    vaultAssets?: vaultAssetsUpdateManyWithoutAssetsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUpdateManyWithoutAssetsNestedInput
    withdrawalAddresses?: withdrawalAddressesUpdateManyWithoutAssetsNestedInput
  }

  export type assetsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    baseNetworkId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: Enumenum_assets_typeFieldUpdateOperationsInput | enum_assets_type
    ticker?: StringFieldUpdateOperationsInput | string
    fireblocksTicker?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes_quotes_sourceAssetIdToassets?: quotesUncheckedUpdateManyWithoutAssets_quotes_sourceAssetIdToassetsNestedInput
    quotes_quotes_targetAssetIdToassets?: quotesUncheckedUpdateManyWithoutAssets_quotes_targetAssetIdToassetsNestedInput
    transactionPolicies?: transactionPoliciesUncheckedUpdateManyWithoutAssetsNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutAssetsNestedInput
    vaultAssets?: vaultAssetsUncheckedUpdateManyWithoutAssetsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedUpdateManyWithoutAssetsNestedInput
    withdrawalAddresses?: withdrawalAddressesUncheckedUpdateManyWithoutAssetsNestedInput
  }

  export type assetsCreateManyInput = {
    id?: number
    name: string
    description: string
    baseNetworkId?: number | null
    type: enum_assets_type
    ticker: string
    fireblocksTicker?: string | null
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type assetsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: Enumenum_assets_typeFieldUpdateOperationsInput | enum_assets_type
    ticker?: StringFieldUpdateOperationsInput | string
    fireblocksTicker?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type assetsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    baseNetworkId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: Enumenum_assets_typeFieldUpdateOperationsInput | enum_assets_type
    ticker?: StringFieldUpdateOperationsInput | string
    fireblocksTicker?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type baseNetworksCreateInput = {
    name: string
    addressUrl: string
    feeAssetId?: number | null
    txUrl: string
    enabled: boolean
    baseBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: assetsCreateNestedManyWithoutBaseNetworksInput
  }

  export type baseNetworksUncheckedCreateInput = {
    id?: number
    name: string
    addressUrl: string
    feeAssetId?: number | null
    txUrl: string
    enabled: boolean
    baseBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: assetsUncheckedCreateNestedManyWithoutBaseNetworksInput
  }

  export type baseNetworksUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    addressUrl?: StringFieldUpdateOperationsInput | string
    feeAssetId?: NullableIntFieldUpdateOperationsInput | number | null
    txUrl?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    baseBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: assetsUpdateManyWithoutBaseNetworksNestedInput
  }

  export type baseNetworksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    addressUrl?: StringFieldUpdateOperationsInput | string
    feeAssetId?: NullableIntFieldUpdateOperationsInput | number | null
    txUrl?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    baseBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: assetsUncheckedUpdateManyWithoutBaseNetworksNestedInput
  }

  export type baseNetworksCreateManyInput = {
    id?: number
    name: string
    addressUrl: string
    feeAssetId?: number | null
    txUrl: string
    enabled: boolean
    baseBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type baseNetworksUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    addressUrl?: StringFieldUpdateOperationsInput | string
    feeAssetId?: NullableIntFieldUpdateOperationsInput | number | null
    txUrl?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    baseBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type baseNetworksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    addressUrl?: StringFieldUpdateOperationsInput | string
    feeAssetId?: NullableIntFieldUpdateOperationsInput | number | null
    txUrl?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    baseBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quotesCreateInput = {
    id: string
    side: enum_quotes_side
    userId: string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    buyPrice?: string
    sellPrice?: string
    quantity?: string
    orders?: ordersCreateNestedManyWithoutQuotesInput
    tokenPairsInfo?: tokenPairsInfoCreateNestedOneWithoutQuotesInput
    quoteStatuses: quoteStatusesCreateNestedOneWithoutQuotesInput
    assets_quotes_sourceAssetIdToassets: assetsCreateNestedOneWithoutQuotes_quotes_sourceAssetIdToassetsInput
    assets_quotes_targetAssetIdToassets: assetsCreateNestedOneWithoutQuotes_quotes_targetAssetIdToassetsInput
    vendors?: vendorsCreateNestedOneWithoutQuotesInput
  }

  export type quotesUncheckedCreateInput = {
    id: string
    quoteStatusId: number
    sourceAssetId: number
    targetAssetId: number
    side: enum_quotes_side
    userId: string
    vendorId?: number | null
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    fxRequestID?: string | null
    buyPrice?: string
    sellPrice?: string
    quantity?: string
    orders?: ordersUncheckedCreateNestedManyWithoutQuotesInput
  }

  export type quotesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: Enumenum_quotes_sideFieldUpdateOperationsInput | enum_quotes_side
    userId?: StringFieldUpdateOperationsInput | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buyPrice?: StringFieldUpdateOperationsInput | string
    sellPrice?: StringFieldUpdateOperationsInput | string
    quantity?: StringFieldUpdateOperationsInput | string
    orders?: ordersUpdateManyWithoutQuotesNestedInput
    tokenPairsInfo?: tokenPairsInfoUpdateOneWithoutQuotesNestedInput
    quoteStatuses?: quoteStatusesUpdateOneRequiredWithoutQuotesNestedInput
    assets_quotes_sourceAssetIdToassets?: assetsUpdateOneRequiredWithoutQuotes_quotes_sourceAssetIdToassetsNestedInput
    assets_quotes_targetAssetIdToassets?: assetsUpdateOneRequiredWithoutQuotes_quotes_targetAssetIdToassetsNestedInput
    vendors?: vendorsUpdateOneWithoutQuotesNestedInput
  }

  export type quotesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteStatusId?: IntFieldUpdateOperationsInput | number
    sourceAssetId?: IntFieldUpdateOperationsInput | number
    targetAssetId?: IntFieldUpdateOperationsInput | number
    side?: Enumenum_quotes_sideFieldUpdateOperationsInput | enum_quotes_side
    userId?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fxRequestID?: NullableStringFieldUpdateOperationsInput | string | null
    buyPrice?: StringFieldUpdateOperationsInput | string
    sellPrice?: StringFieldUpdateOperationsInput | string
    quantity?: StringFieldUpdateOperationsInput | string
    orders?: ordersUncheckedUpdateManyWithoutQuotesNestedInput
  }

  export type quotesCreateManyInput = {
    id: string
    quoteStatusId: number
    sourceAssetId: number
    targetAssetId: number
    side: enum_quotes_side
    userId: string
    vendorId?: number | null
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    fxRequestID?: string | null
    buyPrice?: string
    sellPrice?: string
    quantity?: string
  }

  export type quotesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: Enumenum_quotes_sideFieldUpdateOperationsInput | enum_quotes_side
    userId?: StringFieldUpdateOperationsInput | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buyPrice?: StringFieldUpdateOperationsInput | string
    sellPrice?: StringFieldUpdateOperationsInput | string
    quantity?: StringFieldUpdateOperationsInput | string
  }

  export type quotesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteStatusId?: IntFieldUpdateOperationsInput | number
    sourceAssetId?: IntFieldUpdateOperationsInput | number
    targetAssetId?: IntFieldUpdateOperationsInput | number
    side?: Enumenum_quotes_sideFieldUpdateOperationsInput | enum_quotes_side
    userId?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fxRequestID?: NullableStringFieldUpdateOperationsInput | string | null
    buyPrice?: StringFieldUpdateOperationsInput | string
    sellPrice?: StringFieldUpdateOperationsInput | string
    quantity?: StringFieldUpdateOperationsInput | string
  }

  export type transactionStatusTypesCreateInput = {
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: transactionsCreateNestedManyWithoutTransactionStatusTypesInput
  }

  export type transactionStatusTypesUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: transactionsUncheckedCreateNestedManyWithoutTransactionStatusTypesInput
  }

  export type transactionStatusTypesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: transactionsUpdateManyWithoutTransactionStatusTypesNestedInput
  }

  export type transactionStatusTypesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: transactionsUncheckedUpdateManyWithoutTransactionStatusTypesNestedInput
  }

  export type transactionStatusTypesCreateManyInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionStatusTypesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionStatusTypesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionTypesCreateInput = {
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionPolicies?: transactionPoliciesCreateNestedManyWithoutTransactionTypesInput
    transactions?: transactionsCreateNestedManyWithoutTransactionTypesInput
  }

  export type transactionTypesUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionPolicies?: transactionPoliciesUncheckedCreateNestedManyWithoutTransactionTypesInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutTransactionTypesInput
  }

  export type transactionTypesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionPolicies?: transactionPoliciesUpdateManyWithoutTransactionTypesNestedInput
    transactions?: transactionsUpdateManyWithoutTransactionTypesNestedInput
  }

  export type transactionTypesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionPolicies?: transactionPoliciesUncheckedUpdateManyWithoutTransactionTypesNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutTransactionTypesNestedInput
  }

  export type transactionTypesCreateManyInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionTypesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionTypesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionsCreateInput = {
    id: string
    custodyVendorRef: string
    amountAsset: string
    amountUSD: string
    onChainTxId?: string | null
    sourceExternalAddress?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assets: assetsCreateNestedOneWithoutTransactionsInput
    users?: usersCreateNestedOneWithoutTransactionsInput
    vendors: vendorsCreateNestedOneWithoutTransactionsInput
    vaults_transactions_sourceVaultIdTovaults?: vaultsCreateNestedOneWithoutTransactions_transactions_sourceVaultIdTovaultsInput
    vaults_transactions_targetVaultIdTovaults?: vaultsCreateNestedOneWithoutTransactions_transactions_targetVaultIdTovaultsInput
    withdrawalAddresses?: withdrawalAddressesCreateNestedOneWithoutTransactionsInput
    transactionStatusTypes: transactionStatusTypesCreateNestedOneWithoutTransactionsInput
    transactionTypes: transactionTypesCreateNestedOneWithoutTransactionsInput
  }

  export type transactionsUncheckedCreateInput = {
    id: string
    custodyVendorId: number
    custodyVendorRef: string
    transactionTypeId: number
    amountAsset: string
    amountUSD: string
    assetId: number
    transactionStatusTypeId: number
    onChainTxId?: string | null
    sourceVaultId?: string | null
    targetVaultId?: string | null
    targetWithdrawalAddressId?: string | null
    sourceExternalAddress?: string | null
    createdByUserId?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    custodyVendorRef?: StringFieldUpdateOperationsInput | string
    amountAsset?: StringFieldUpdateOperationsInput | string
    amountUSD?: StringFieldUpdateOperationsInput | string
    onChainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceExternalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: assetsUpdateOneRequiredWithoutTransactionsNestedInput
    users?: usersUpdateOneWithoutTransactionsNestedInput
    vendors?: vendorsUpdateOneRequiredWithoutTransactionsNestedInput
    vaults_transactions_sourceVaultIdTovaults?: vaultsUpdateOneWithoutTransactions_transactions_sourceVaultIdTovaultsNestedInput
    vaults_transactions_targetVaultIdTovaults?: vaultsUpdateOneWithoutTransactions_transactions_targetVaultIdTovaultsNestedInput
    withdrawalAddresses?: withdrawalAddressesUpdateOneWithoutTransactionsNestedInput
    transactionStatusTypes?: transactionStatusTypesUpdateOneRequiredWithoutTransactionsNestedInput
    transactionTypes?: transactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    custodyVendorId?: IntFieldUpdateOperationsInput | number
    custodyVendorRef?: StringFieldUpdateOperationsInput | string
    transactionTypeId?: IntFieldUpdateOperationsInput | number
    amountAsset?: StringFieldUpdateOperationsInput | string
    amountUSD?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    transactionStatusTypeId?: IntFieldUpdateOperationsInput | number
    onChainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetWithdrawalAddressId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceExternalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionsCreateManyInput = {
    id: string
    custodyVendorId: number
    custodyVendorRef: string
    transactionTypeId: number
    amountAsset: string
    amountUSD: string
    assetId: number
    transactionStatusTypeId: number
    onChainTxId?: string | null
    sourceVaultId?: string | null
    targetVaultId?: string | null
    targetWithdrawalAddressId?: string | null
    sourceExternalAddress?: string | null
    createdByUserId?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    custodyVendorRef?: StringFieldUpdateOperationsInput | string
    amountAsset?: StringFieldUpdateOperationsInput | string
    amountUSD?: StringFieldUpdateOperationsInput | string
    onChainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceExternalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    custodyVendorId?: IntFieldUpdateOperationsInput | number
    custodyVendorRef?: StringFieldUpdateOperationsInput | string
    transactionTypeId?: IntFieldUpdateOperationsInput | number
    amountAsset?: StringFieldUpdateOperationsInput | string
    amountUSD?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    transactionStatusTypeId?: IntFieldUpdateOperationsInput | number
    onChainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetWithdrawalAddressId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceExternalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateInput = {
    id: string
    primaryEmail: string
    firstName: string
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publicKey?: string | null
    apiKey?: string | null
    transactionPolicies?: transactionPoliciesCreateNestedManyWithoutUsersInput
    transactions?: transactionsCreateNestedManyWithoutUsersInput
    organizations: organizationsCreateNestedOneWithoutUsersInput
    userTypes: userTypesCreateNestedOneWithoutUsersInput
    vaults?: vaultsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id: string
    organizationId: number
    userTypeId: number
    primaryEmail: string
    firstName: string
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publicKey?: string | null
    apiKey?: string | null
    transactionPolicies?: transactionPoliciesUncheckedCreateNestedManyWithoutUsersInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutUsersInput
    vaults?: vaultsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    primaryEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicKey?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    transactionPolicies?: transactionPoliciesUpdateManyWithoutUsersNestedInput
    transactions?: transactionsUpdateManyWithoutUsersNestedInput
    organizations?: organizationsUpdateOneRequiredWithoutUsersNestedInput
    userTypes?: userTypesUpdateOneRequiredWithoutUsersNestedInput
    vaults?: vaultsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    userTypeId?: IntFieldUpdateOperationsInput | number
    primaryEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicKey?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    transactionPolicies?: transactionPoliciesUncheckedUpdateManyWithoutUsersNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutUsersNestedInput
    vaults?: vaultsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    id: string
    organizationId: number
    userTypeId: number
    primaryEmail: string
    firstName: string
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publicKey?: string | null
    apiKey?: string | null
  }

  export type usersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    primaryEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicKey?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    userTypeId?: IntFieldUpdateOperationsInput | number
    primaryEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicKey?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type vendorTypesCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vendors?: vendorsCreateNestedManyWithoutVendorTypesInput
  }

  export type vendorTypesUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vendors?: vendorsUncheckedCreateNestedManyWithoutVendorTypesInput
  }

  export type vendorTypesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendors?: vendorsUpdateManyWithoutVendorTypesNestedInput
  }

  export type vendorTypesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendors?: vendorsUncheckedUpdateManyWithoutVendorTypesNestedInput
  }

  export type vendorTypesCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vendorTypesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vendorTypesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vendorsCreateInput = {
    name: string
    identifier: string
    quoteEngineBaseBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsCreateNestedManyWithoutVendorsInput
    depositAddresses?: depositAddressesCreateNestedManyWithoutVendorsInput
    quotes?: quotesCreateNestedManyWithoutVendorsInput
    tokenPairs?: tokenPairsCreateNestedManyWithoutVendorsInput
    transactions?: transactionsCreateNestedManyWithoutVendorsInput
    vendorSupportsAssets?: vendorSupportsAssetsCreateNestedManyWithoutVendorsInput
    vendorTypes: vendorTypesCreateNestedOneWithoutVendorsInput
  }

  export type vendorsUncheckedCreateInput = {
    id?: number
    name: string
    identifier: string
    vendorTypeId: number
    quoteEngineBaseBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUncheckedCreateNestedManyWithoutVendorsInput
    depositAddresses?: depositAddressesUncheckedCreateNestedManyWithoutVendorsInput
    quotes?: quotesUncheckedCreateNestedManyWithoutVendorsInput
    tokenPairs?: tokenPairsUncheckedCreateNestedManyWithoutVendorsInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutVendorsInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedCreateNestedManyWithoutVendorsInput
  }

  export type vendorsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    quoteEngineBaseBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUpdateManyWithoutVendorsNestedInput
    depositAddresses?: depositAddressesUpdateManyWithoutVendorsNestedInput
    quotes?: quotesUpdateManyWithoutVendorsNestedInput
    tokenPairs?: tokenPairsUpdateManyWithoutVendorsNestedInput
    transactions?: transactionsUpdateManyWithoutVendorsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUpdateManyWithoutVendorsNestedInput
    vendorTypes?: vendorTypesUpdateOneRequiredWithoutVendorsNestedInput
  }

  export type vendorsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    vendorTypeId?: IntFieldUpdateOperationsInput | number
    quoteEngineBaseBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUncheckedUpdateManyWithoutVendorsNestedInput
    depositAddresses?: depositAddressesUncheckedUpdateManyWithoutVendorsNestedInput
    quotes?: quotesUncheckedUpdateManyWithoutVendorsNestedInput
    tokenPairs?: tokenPairsUncheckedUpdateManyWithoutVendorsNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutVendorsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedUpdateManyWithoutVendorsNestedInput
  }

  export type vendorsCreateManyInput = {
    id?: number
    name: string
    identifier: string
    vendorTypeId: number
    quoteEngineBaseBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vendorsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    quoteEngineBaseBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vendorsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    vendorTypeId?: IntFieldUpdateOperationsInput | number
    quoteEngineBaseBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type custodyEngineEventTypesCreateInput = {
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyEngineEvents?: custodyEngineEventsCreateNestedManyWithoutCustodyEngineEventTypesInput
  }

  export type custodyEngineEventTypesUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyEngineEvents?: custodyEngineEventsUncheckedCreateNestedManyWithoutCustodyEngineEventTypesInput
  }

  export type custodyEngineEventTypesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyEngineEvents?: custodyEngineEventsUpdateManyWithoutCustodyEngineEventTypesNestedInput
  }

  export type custodyEngineEventTypesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyEngineEvents?: custodyEngineEventsUncheckedUpdateManyWithoutCustodyEngineEventTypesNestedInput
  }

  export type custodyEngineEventTypesCreateManyInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type custodyEngineEventTypesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type custodyEngineEventTypesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type custodyEngineEventsCreateInput = {
    id: string
    event: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyEngineEventTypes: custodyEngineEventTypesCreateNestedOneWithoutCustodyEngineEventsInput
    organizations: organizationsCreateNestedOneWithoutCustodyEngineEventsInput
    webhookRequests?: webhookRequestsCreateNestedManyWithoutCustodyEngineEventsInput
  }

  export type custodyEngineEventsUncheckedCreateInput = {
    id: string
    organizationId: number
    custodyEngineEventTypeId: number
    event: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    webhookRequests?: webhookRequestsUncheckedCreateNestedManyWithoutCustodyEngineEventsInput
  }

  export type custodyEngineEventsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyEngineEventTypes?: custodyEngineEventTypesUpdateOneRequiredWithoutCustodyEngineEventsNestedInput
    organizations?: organizationsUpdateOneRequiredWithoutCustodyEngineEventsNestedInput
    webhookRequests?: webhookRequestsUpdateManyWithoutCustodyEngineEventsNestedInput
  }

  export type custodyEngineEventsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    custodyEngineEventTypeId?: IntFieldUpdateOperationsInput | number
    event?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    webhookRequests?: webhookRequestsUncheckedUpdateManyWithoutCustodyEngineEventsNestedInput
  }

  export type custodyEngineEventsCreateManyInput = {
    id: string
    organizationId: number
    custodyEngineEventTypeId: number
    event: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type custodyEngineEventsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type custodyEngineEventsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    custodyEngineEventTypeId?: IntFieldUpdateOperationsInput | number
    event?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type custodyVendorVaultAssetsCreateInput = {
    vendorRef: string
    balance: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vaultAssets: vaultAssetsCreateNestedOneWithoutCustodyVendorVaultAssetsInput
    vendors: vendorsCreateNestedOneWithoutCustodyVendorVaultAssetsInput
  }

  export type custodyVendorVaultAssetsUncheckedCreateInput = {
    id?: number
    vendorId: number
    vendorRef: string
    balance: string
    vaultAssetId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type custodyVendorVaultAssetsUpdateInput = {
    vendorRef?: StringFieldUpdateOperationsInput | string
    balance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaultAssets?: vaultAssetsUpdateOneRequiredWithoutCustodyVendorVaultAssetsNestedInput
    vendors?: vendorsUpdateOneRequiredWithoutCustodyVendorVaultAssetsNestedInput
  }

  export type custodyVendorVaultAssetsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    vendorRef?: StringFieldUpdateOperationsInput | string
    balance?: StringFieldUpdateOperationsInput | string
    vaultAssetId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type custodyVendorVaultAssetsCreateManyInput = {
    id?: number
    vendorId: number
    vendorRef: string
    balance: string
    vaultAssetId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type custodyVendorVaultAssetsUpdateManyMutationInput = {
    vendorRef?: StringFieldUpdateOperationsInput | string
    balance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type custodyVendorVaultAssetsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    vendorRef?: StringFieldUpdateOperationsInput | string
    balance?: StringFieldUpdateOperationsInput | string
    vaultAssetId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type depositAddressStatusTypesCreateInput = {
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type depositAddressStatusTypesUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type depositAddressStatusTypesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type depositAddressStatusTypesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type depositAddressStatusTypesCreateManyInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type depositAddressStatusTypesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type depositAddressStatusTypesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type depositAddressesCreateInput = {
    id: string
    address: string
    depositAddressStatusId?: number | null
    vendorRef: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vaultAssets: vaultAssetsCreateNestedOneWithoutDepositAddressesInput
    vendors?: vendorsCreateNestedOneWithoutDepositAddressesInput
  }

  export type depositAddressesUncheckedCreateInput = {
    id: string
    vaultAssetId: number
    address: string
    depositAddressStatusId?: number | null
    vendorId?: number | null
    vendorRef: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type depositAddressesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    depositAddressStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    vendorRef?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaultAssets?: vaultAssetsUpdateOneRequiredWithoutDepositAddressesNestedInput
    vendors?: vendorsUpdateOneWithoutDepositAddressesNestedInput
  }

  export type depositAddressesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaultAssetId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    depositAddressStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    vendorRef?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type depositAddressesCreateManyInput = {
    id: string
    vaultAssetId: number
    address: string
    depositAddressStatusId?: number | null
    vendorId?: number | null
    vendorRef: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type depositAddressesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    depositAddressStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    vendorRef?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type depositAddressesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaultAssetId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    depositAddressStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    vendorRef?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type institutionalProductsCreateInput = {
    id: string
    name: string
    enabled: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    webhookRequests?: webhookRequestsCreateNestedManyWithoutInstitutionalProductsInput
  }

  export type institutionalProductsUncheckedCreateInput = {
    id: string
    name: string
    enabled: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    webhookRequests?: webhookRequestsUncheckedCreateNestedManyWithoutInstitutionalProductsInput
  }

  export type institutionalProductsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    webhookRequests?: webhookRequestsUpdateManyWithoutInstitutionalProductsNestedInput
  }

  export type institutionalProductsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    webhookRequests?: webhookRequestsUncheckedUpdateManyWithoutInstitutionalProductsNestedInput
  }

  export type institutionalProductsCreateManyInput = {
    id: string
    name: string
    enabled: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type institutionalProductsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type institutionalProductsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ordersCreateInput = {
    id: string
    orderStatus?: string | null
    userAcceptedPrice: string
    userAcceptedQuantity: string
    userAcceptedSide: enum_orders_userAcceptedSide
    userAcceptedTradePair: JsonNullValueInput | InputJsonValue
    userAcceptedTimestamp: Date | string
    orderType?: enum_orders_orderType | null
    orderTimeInForce?: string | null
    vendorQuoteId?: string | null
    vendorQuantityRequested?: string | null
    vendorPriceRequested?: string | null
    orderQuantityExecuted?: string | null
    orderPriceExecuted?: string | null
    orderTimestampExecuted?: Date | string | null
    orderVendorStatus?: string | null
    allowedSlippage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes: quotesCreateNestedOneWithoutOrdersInput
  }

  export type ordersUncheckedCreateInput = {
    id: string
    quoteId: string
    orderStatus?: string | null
    userAcceptedPrice: string
    userAcceptedQuantity: string
    userAcceptedSide: enum_orders_userAcceptedSide
    userAcceptedTradePair: JsonNullValueInput | InputJsonValue
    userAcceptedTimestamp: Date | string
    orderType?: enum_orders_orderType | null
    orderTimeInForce?: string | null
    vendorQuoteId?: string | null
    vendorQuantityRequested?: string | null
    vendorPriceRequested?: string | null
    orderQuantityExecuted?: string | null
    orderPriceExecuted?: string | null
    orderTimestampExecuted?: Date | string | null
    orderVendorStatus?: string | null
    allowedSlippage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ordersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderStatus?: NullableStringFieldUpdateOperationsInput | string | null
    userAcceptedPrice?: StringFieldUpdateOperationsInput | string
    userAcceptedQuantity?: StringFieldUpdateOperationsInput | string
    userAcceptedSide?: Enumenum_orders_userAcceptedSideFieldUpdateOperationsInput | enum_orders_userAcceptedSide
    userAcceptedTradePair?: JsonNullValueInput | InputJsonValue
    userAcceptedTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    orderType?: NullableEnumenum_orders_orderTypeFieldUpdateOperationsInput | enum_orders_orderType | null
    orderTimeInForce?: NullableStringFieldUpdateOperationsInput | string | null
    vendorQuoteId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorQuantityRequested?: NullableStringFieldUpdateOperationsInput | string | null
    vendorPriceRequested?: NullableStringFieldUpdateOperationsInput | string | null
    orderQuantityExecuted?: NullableStringFieldUpdateOperationsInput | string | null
    orderPriceExecuted?: NullableStringFieldUpdateOperationsInput | string | null
    orderTimestampExecuted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderVendorStatus?: NullableStringFieldUpdateOperationsInput | string | null
    allowedSlippage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes?: quotesUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type ordersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    orderStatus?: NullableStringFieldUpdateOperationsInput | string | null
    userAcceptedPrice?: StringFieldUpdateOperationsInput | string
    userAcceptedQuantity?: StringFieldUpdateOperationsInput | string
    userAcceptedSide?: Enumenum_orders_userAcceptedSideFieldUpdateOperationsInput | enum_orders_userAcceptedSide
    userAcceptedTradePair?: JsonNullValueInput | InputJsonValue
    userAcceptedTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    orderType?: NullableEnumenum_orders_orderTypeFieldUpdateOperationsInput | enum_orders_orderType | null
    orderTimeInForce?: NullableStringFieldUpdateOperationsInput | string | null
    vendorQuoteId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorQuantityRequested?: NullableStringFieldUpdateOperationsInput | string | null
    vendorPriceRequested?: NullableStringFieldUpdateOperationsInput | string | null
    orderQuantityExecuted?: NullableStringFieldUpdateOperationsInput | string | null
    orderPriceExecuted?: NullableStringFieldUpdateOperationsInput | string | null
    orderTimestampExecuted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderVendorStatus?: NullableStringFieldUpdateOperationsInput | string | null
    allowedSlippage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ordersCreateManyInput = {
    id: string
    quoteId: string
    orderStatus?: string | null
    userAcceptedPrice: string
    userAcceptedQuantity: string
    userAcceptedSide: enum_orders_userAcceptedSide
    userAcceptedTradePair: JsonNullValueInput | InputJsonValue
    userAcceptedTimestamp: Date | string
    orderType?: enum_orders_orderType | null
    orderTimeInForce?: string | null
    vendorQuoteId?: string | null
    vendorQuantityRequested?: string | null
    vendorPriceRequested?: string | null
    orderQuantityExecuted?: string | null
    orderPriceExecuted?: string | null
    orderTimestampExecuted?: Date | string | null
    orderVendorStatus?: string | null
    allowedSlippage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ordersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderStatus?: NullableStringFieldUpdateOperationsInput | string | null
    userAcceptedPrice?: StringFieldUpdateOperationsInput | string
    userAcceptedQuantity?: StringFieldUpdateOperationsInput | string
    userAcceptedSide?: Enumenum_orders_userAcceptedSideFieldUpdateOperationsInput | enum_orders_userAcceptedSide
    userAcceptedTradePair?: JsonNullValueInput | InputJsonValue
    userAcceptedTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    orderType?: NullableEnumenum_orders_orderTypeFieldUpdateOperationsInput | enum_orders_orderType | null
    orderTimeInForce?: NullableStringFieldUpdateOperationsInput | string | null
    vendorQuoteId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorQuantityRequested?: NullableStringFieldUpdateOperationsInput | string | null
    vendorPriceRequested?: NullableStringFieldUpdateOperationsInput | string | null
    orderQuantityExecuted?: NullableStringFieldUpdateOperationsInput | string | null
    orderPriceExecuted?: NullableStringFieldUpdateOperationsInput | string | null
    orderTimestampExecuted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderVendorStatus?: NullableStringFieldUpdateOperationsInput | string | null
    allowedSlippage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ordersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    orderStatus?: NullableStringFieldUpdateOperationsInput | string | null
    userAcceptedPrice?: StringFieldUpdateOperationsInput | string
    userAcceptedQuantity?: StringFieldUpdateOperationsInput | string
    userAcceptedSide?: Enumenum_orders_userAcceptedSideFieldUpdateOperationsInput | enum_orders_userAcceptedSide
    userAcceptedTradePair?: JsonNullValueInput | InputJsonValue
    userAcceptedTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    orderType?: NullableEnumenum_orders_orderTypeFieldUpdateOperationsInput | enum_orders_orderType | null
    orderTimeInForce?: NullableStringFieldUpdateOperationsInput | string | null
    vendorQuoteId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorQuantityRequested?: NullableStringFieldUpdateOperationsInput | string | null
    vendorPriceRequested?: NullableStringFieldUpdateOperationsInput | string | null
    orderQuantityExecuted?: NullableStringFieldUpdateOperationsInput | string | null
    orderPriceExecuted?: NullableStringFieldUpdateOperationsInput | string | null
    orderTimestampExecuted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderVendorStatus?: NullableStringFieldUpdateOperationsInput | string | null
    allowedSlippage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type organizationStatusTypesCreateInput = {
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organizations?: organizationsCreateNestedManyWithoutOrganizationStatusTypesInput
  }

  export type organizationStatusTypesUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organizations?: organizationsUncheckedCreateNestedManyWithoutOrganizationStatusTypesInput
  }

  export type organizationStatusTypesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizations?: organizationsUpdateManyWithoutOrganizationStatusTypesNestedInput
  }

  export type organizationStatusTypesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizations?: organizationsUncheckedUpdateManyWithoutOrganizationStatusTypesNestedInput
  }

  export type organizationStatusTypesCreateManyInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type organizationStatusTypesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type organizationStatusTypesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type organizationsCreateInput = {
    name: string
    primaryEmail: string
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyEngineEvents?: custodyEngineEventsCreateNestedManyWithoutOrganizationsInput
    pricingPlans?: pricingPlansCreateNestedOneWithoutOrganizationsInput
    organizationStatusTypes: organizationStatusTypesCreateNestedOneWithoutOrganizationsInput
    users?: usersCreateNestedManyWithoutOrganizationsInput
    webhooks?: webhooksCreateNestedManyWithoutOrganizationsInput
    withdrawalAddresses?: withdrawalAddressesCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateInput = {
    id?: number
    name: string
    primaryEmail: string
    pricingPlanId?: number
    statusId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyEngineEvents?: custodyEngineEventsUncheckedCreateNestedManyWithoutOrganizationsInput
    users?: usersUncheckedCreateNestedManyWithoutOrganizationsInput
    webhooks?: webhooksUncheckedCreateNestedManyWithoutOrganizationsInput
    withdrawalAddresses?: withdrawalAddressesUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    primaryEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyEngineEvents?: custodyEngineEventsUpdateManyWithoutOrganizationsNestedInput
    pricingPlans?: pricingPlansUpdateOneRequiredWithoutOrganizationsNestedInput
    organizationStatusTypes?: organizationStatusTypesUpdateOneRequiredWithoutOrganizationsNestedInput
    users?: usersUpdateManyWithoutOrganizationsNestedInput
    webhooks?: webhooksUpdateManyWithoutOrganizationsNestedInput
    withdrawalAddresses?: withdrawalAddressesUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    primaryEmail?: StringFieldUpdateOperationsInput | string
    pricingPlanId?: IntFieldUpdateOperationsInput | number
    statusId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyEngineEvents?: custodyEngineEventsUncheckedUpdateManyWithoutOrganizationsNestedInput
    users?: usersUncheckedUpdateManyWithoutOrganizationsNestedInput
    webhooks?: webhooksUncheckedUpdateManyWithoutOrganizationsNestedInput
    withdrawalAddresses?: withdrawalAddressesUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsCreateManyInput = {
    id?: number
    name: string
    primaryEmail: string
    pricingPlanId?: number
    statusId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type organizationsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    primaryEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type organizationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    primaryEmail?: StringFieldUpdateOperationsInput | string
    pricingPlanId?: IntFieldUpdateOperationsInput | number
    statusId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pricingPlanProfilesCreateInput = {
    name: string
    quoteEngineRps: number
    custodyEngineRps: number
    numberOfUsers: number
    sla: number
    rbac: boolean
    quoteEngineClaims: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    pricingPlans?: pricingPlansCreateNestedManyWithoutPricingPlanProfilesInput
  }

  export type pricingPlanProfilesUncheckedCreateInput = {
    id?: number
    name: string
    quoteEngineRps: number
    custodyEngineRps: number
    numberOfUsers: number
    sla: number
    rbac: boolean
    quoteEngineClaims: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    pricingPlans?: pricingPlansUncheckedCreateNestedManyWithoutPricingPlanProfilesInput
  }

  export type pricingPlanProfilesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    quoteEngineRps?: IntFieldUpdateOperationsInput | number
    custodyEngineRps?: IntFieldUpdateOperationsInput | number
    numberOfUsers?: IntFieldUpdateOperationsInput | number
    sla?: FloatFieldUpdateOperationsInput | number
    rbac?: BoolFieldUpdateOperationsInput | boolean
    quoteEngineClaims?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingPlans?: pricingPlansUpdateManyWithoutPricingPlanProfilesNestedInput
  }

  export type pricingPlanProfilesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    quoteEngineRps?: IntFieldUpdateOperationsInput | number
    custodyEngineRps?: IntFieldUpdateOperationsInput | number
    numberOfUsers?: IntFieldUpdateOperationsInput | number
    sla?: FloatFieldUpdateOperationsInput | number
    rbac?: BoolFieldUpdateOperationsInput | boolean
    quoteEngineClaims?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingPlans?: pricingPlansUncheckedUpdateManyWithoutPricingPlanProfilesNestedInput
  }

  export type pricingPlanProfilesCreateManyInput = {
    id?: number
    name: string
    quoteEngineRps: number
    custodyEngineRps: number
    numberOfUsers: number
    sla: number
    rbac: boolean
    quoteEngineClaims: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pricingPlanProfilesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    quoteEngineRps?: IntFieldUpdateOperationsInput | number
    custodyEngineRps?: IntFieldUpdateOperationsInput | number
    numberOfUsers?: IntFieldUpdateOperationsInput | number
    sla?: FloatFieldUpdateOperationsInput | number
    rbac?: BoolFieldUpdateOperationsInput | boolean
    quoteEngineClaims?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pricingPlanProfilesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    quoteEngineRps?: IntFieldUpdateOperationsInput | number
    custodyEngineRps?: IntFieldUpdateOperationsInput | number
    numberOfUsers?: IntFieldUpdateOperationsInput | number
    sla?: FloatFieldUpdateOperationsInput | number
    rbac?: BoolFieldUpdateOperationsInput | boolean
    quoteEngineClaims?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pricingPlanSupportsAssetsCreateInput = {
    enabled?: boolean
    buyBps: number
    sellBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pricingPlans: pricingPlansCreateNestedOneWithoutPricingPlanSupportsAssetsInput
    vendorSupportsAssets: vendorSupportsAssetsCreateNestedOneWithoutPricingPlanSupportsAssetsInput
  }

  export type pricingPlanSupportsAssetsUncheckedCreateInput = {
    id?: number
    vendorSupportsAssetId: number
    pricingPlanId: number
    enabled?: boolean
    buyBps: number
    sellBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pricingPlanSupportsAssetsUpdateInput = {
    enabled?: BoolFieldUpdateOperationsInput | boolean
    buyBps?: FloatFieldUpdateOperationsInput | number
    sellBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingPlans?: pricingPlansUpdateOneRequiredWithoutPricingPlanSupportsAssetsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUpdateOneRequiredWithoutPricingPlanSupportsAssetsNestedInput
  }

  export type pricingPlanSupportsAssetsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorSupportsAssetId?: IntFieldUpdateOperationsInput | number
    pricingPlanId?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    buyBps?: FloatFieldUpdateOperationsInput | number
    sellBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pricingPlanSupportsAssetsCreateManyInput = {
    id?: number
    vendorSupportsAssetId: number
    pricingPlanId: number
    enabled?: boolean
    buyBps: number
    sellBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pricingPlanSupportsAssetsUpdateManyMutationInput = {
    enabled?: BoolFieldUpdateOperationsInput | boolean
    buyBps?: FloatFieldUpdateOperationsInput | number
    sellBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pricingPlanSupportsAssetsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorSupportsAssetId?: IntFieldUpdateOperationsInput | number
    pricingPlanId?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    buyBps?: FloatFieldUpdateOperationsInput | number
    sellBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pricingPlansCreateInput = {
    price: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organizations?: organizationsCreateNestedManyWithoutPricingPlansInput
    pricingPlanSupportsAssets?: pricingPlanSupportsAssetsCreateNestedManyWithoutPricingPlansInput
    pricingPlanProfiles: pricingPlanProfilesCreateNestedOneWithoutPricingPlansInput
  }

  export type pricingPlansUncheckedCreateInput = {
    id?: number
    price: number
    active?: boolean
    pricingPlanProfileId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    organizations?: organizationsUncheckedCreateNestedManyWithoutPricingPlansInput
    pricingPlanSupportsAssets?: pricingPlanSupportsAssetsUncheckedCreateNestedManyWithoutPricingPlansInput
  }

  export type pricingPlansUpdateInput = {
    price?: FloatFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizations?: organizationsUpdateManyWithoutPricingPlansNestedInput
    pricingPlanSupportsAssets?: pricingPlanSupportsAssetsUpdateManyWithoutPricingPlansNestedInput
    pricingPlanProfiles?: pricingPlanProfilesUpdateOneRequiredWithoutPricingPlansNestedInput
  }

  export type pricingPlansUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    pricingPlanProfileId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizations?: organizationsUncheckedUpdateManyWithoutPricingPlansNestedInput
    pricingPlanSupportsAssets?: pricingPlanSupportsAssetsUncheckedUpdateManyWithoutPricingPlansNestedInput
  }

  export type pricingPlansCreateManyInput = {
    id?: number
    price: number
    active?: boolean
    pricingPlanProfileId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pricingPlansUpdateManyMutationInput = {
    price?: FloatFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pricingPlansUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    pricingPlanProfileId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quoteStatusesCreateInput = {
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes?: quotesCreateNestedManyWithoutQuoteStatusesInput
  }

  export type quoteStatusesUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes?: quotesUncheckedCreateNestedManyWithoutQuoteStatusesInput
  }

  export type quoteStatusesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes?: quotesUpdateManyWithoutQuoteStatusesNestedInput
  }

  export type quoteStatusesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes?: quotesUncheckedUpdateManyWithoutQuoteStatusesNestedInput
  }

  export type quoteStatusesCreateManyInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type quoteStatusesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quoteStatusesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokenPairsCreateInput = {
    baseToken: string
    quoteToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vendors: vendorsCreateNestedOneWithoutTokenPairsInput
    tokenPairsInfo?: tokenPairsInfoCreateNestedManyWithoutTokenPairsInput
  }

  export type tokenPairsUncheckedCreateInput = {
    id?: number
    baseToken: string
    quoteToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorId: number
    tokenPairsInfo?: tokenPairsInfoUncheckedCreateNestedManyWithoutTokenPairsInput
  }

  export type tokenPairsUpdateInput = {
    baseToken?: StringFieldUpdateOperationsInput | string
    quoteToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendors?: vendorsUpdateOneRequiredWithoutTokenPairsNestedInput
    tokenPairsInfo?: tokenPairsInfoUpdateManyWithoutTokenPairsNestedInput
  }

  export type tokenPairsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    baseToken?: StringFieldUpdateOperationsInput | string
    quoteToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: IntFieldUpdateOperationsInput | number
    tokenPairsInfo?: tokenPairsInfoUncheckedUpdateManyWithoutTokenPairsNestedInput
  }

  export type tokenPairsCreateManyInput = {
    id?: number
    baseToken: string
    quoteToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorId: number
  }

  export type tokenPairsUpdateManyMutationInput = {
    baseToken?: StringFieldUpdateOperationsInput | string
    quoteToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokenPairsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    baseToken?: StringFieldUpdateOperationsInput | string
    quoteToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: IntFieldUpdateOperationsInput | number
  }

  export type tokenPairsInfoCreateInput = {
    fxRequestID: string
    quantity: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes?: quotesCreateNestedManyWithoutTokenPairsInfoInput
    tokenPairs: tokenPairsCreateNestedOneWithoutTokenPairsInfoInput
  }

  export type tokenPairsInfoUncheckedCreateInput = {
    id?: number
    tokenPairId: number
    fxRequestID: string
    quantity: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes?: quotesUncheckedCreateNestedManyWithoutTokenPairsInfoInput
  }

  export type tokenPairsInfoUpdateInput = {
    fxRequestID?: StringFieldUpdateOperationsInput | string
    quantity?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes?: quotesUpdateManyWithoutTokenPairsInfoNestedInput
    tokenPairs?: tokenPairsUpdateOneRequiredWithoutTokenPairsInfoNestedInput
  }

  export type tokenPairsInfoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenPairId?: IntFieldUpdateOperationsInput | number
    fxRequestID?: StringFieldUpdateOperationsInput | string
    quantity?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes?: quotesUncheckedUpdateManyWithoutTokenPairsInfoNestedInput
  }

  export type tokenPairsInfoCreateManyInput = {
    id?: number
    tokenPairId: number
    fxRequestID: string
    quantity: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type tokenPairsInfoUpdateManyMutationInput = {
    fxRequestID?: StringFieldUpdateOperationsInput | string
    quantity?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokenPairsInfoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenPairId?: IntFieldUpdateOperationsInput | number
    fxRequestID?: StringFieldUpdateOperationsInput | string
    quantity?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionPoliciesCreateInput = {
    id: string
    toOneTimeAddresses?: boolean | null
    greaterThanUSD: string
    action: enum_transactionPolicies_action
    createdAt?: Date | string
    updatedAt?: Date | string
    assets: assetsCreateNestedOneWithoutTransactionPoliciesInput
    vaults_transactionPolicies_sourceVaultIdTovaults: vaultsCreateNestedOneWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput
    vaults_transactionPolicies_targetVaultIdTovaults?: vaultsCreateNestedOneWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput
    withdrawalAddresses?: withdrawalAddressesCreateNestedOneWithoutTransactionPoliciesInput
    transactionTypes: transactionTypesCreateNestedOneWithoutTransactionPoliciesInput
    users: usersCreateNestedOneWithoutTransactionPoliciesInput
  }

  export type transactionPoliciesUncheckedCreateInput = {
    id: string
    userId: string
    transactionTypeId: number
    sourceVaultId: string
    targetVaultId?: string | null
    targetWithdrawalAddressId?: string | null
    toOneTimeAddresses?: boolean | null
    greaterThanUSD: string
    assetId: number
    action: enum_transactionPolicies_action
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionPoliciesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    toOneTimeAddresses?: NullableBoolFieldUpdateOperationsInput | boolean | null
    greaterThanUSD?: StringFieldUpdateOperationsInput | string
    action?: Enumenum_transactionPolicies_actionFieldUpdateOperationsInput | enum_transactionPolicies_action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: assetsUpdateOneRequiredWithoutTransactionPoliciesNestedInput
    vaults_transactionPolicies_sourceVaultIdTovaults?: vaultsUpdateOneRequiredWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsNestedInput
    vaults_transactionPolicies_targetVaultIdTovaults?: vaultsUpdateOneWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsNestedInput
    withdrawalAddresses?: withdrawalAddressesUpdateOneWithoutTransactionPoliciesNestedInput
    transactionTypes?: transactionTypesUpdateOneRequiredWithoutTransactionPoliciesNestedInput
    users?: usersUpdateOneRequiredWithoutTransactionPoliciesNestedInput
  }

  export type transactionPoliciesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionTypeId?: IntFieldUpdateOperationsInput | number
    sourceVaultId?: StringFieldUpdateOperationsInput | string
    targetVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetWithdrawalAddressId?: NullableStringFieldUpdateOperationsInput | string | null
    toOneTimeAddresses?: NullableBoolFieldUpdateOperationsInput | boolean | null
    greaterThanUSD?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    action?: Enumenum_transactionPolicies_actionFieldUpdateOperationsInput | enum_transactionPolicies_action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionPoliciesCreateManyInput = {
    id: string
    userId: string
    transactionTypeId: number
    sourceVaultId: string
    targetVaultId?: string | null
    targetWithdrawalAddressId?: string | null
    toOneTimeAddresses?: boolean | null
    greaterThanUSD: string
    assetId: number
    action: enum_transactionPolicies_action
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionPoliciesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    toOneTimeAddresses?: NullableBoolFieldUpdateOperationsInput | boolean | null
    greaterThanUSD?: StringFieldUpdateOperationsInput | string
    action?: Enumenum_transactionPolicies_actionFieldUpdateOperationsInput | enum_transactionPolicies_action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionPoliciesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionTypeId?: IntFieldUpdateOperationsInput | number
    sourceVaultId?: StringFieldUpdateOperationsInput | string
    targetVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetWithdrawalAddressId?: NullableStringFieldUpdateOperationsInput | string | null
    toOneTimeAddresses?: NullableBoolFieldUpdateOperationsInput | boolean | null
    greaterThanUSD?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    action?: Enumenum_transactionPolicies_actionFieldUpdateOperationsInput | enum_transactionPolicies_action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userTypesCreateInput = {
    name: string
    description: string
    claims: JsonNullValueInput | InputJsonValue
    isServiceAccount?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: usersCreateNestedManyWithoutUserTypesInput
  }

  export type userTypesUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    claims: JsonNullValueInput | InputJsonValue
    isServiceAccount?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: usersUncheckedCreateNestedManyWithoutUserTypesInput
  }

  export type userTypesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    claims?: JsonNullValueInput | InputJsonValue
    isServiceAccount?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateManyWithoutUserTypesNestedInput
  }

  export type userTypesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    claims?: JsonNullValueInput | InputJsonValue
    isServiceAccount?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUncheckedUpdateManyWithoutUserTypesNestedInput
  }

  export type userTypesCreateManyInput = {
    id?: number
    name: string
    description: string
    claims: JsonNullValueInput | InputJsonValue
    isServiceAccount?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type userTypesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    claims?: JsonNullValueInput | InputJsonValue
    isServiceAccount?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userTypesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    claims?: JsonNullValueInput | InputJsonValue
    isServiceAccount?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vaultAssetsCreateInput = {
    balance: string
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsCreateNestedManyWithoutVaultAssetsInput
    depositAddresses?: depositAddressesCreateNestedManyWithoutVaultAssetsInput
    assets: assetsCreateNestedOneWithoutVaultAssetsInput
    vaults: vaultsCreateNestedOneWithoutVaultAssetsInput
  }

  export type vaultAssetsUncheckedCreateInput = {
    id?: number
    vaultId: string
    assetId: number
    balance: string
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUncheckedCreateNestedManyWithoutVaultAssetsInput
    depositAddresses?: depositAddressesUncheckedCreateNestedManyWithoutVaultAssetsInput
  }

  export type vaultAssetsUpdateInput = {
    balance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUpdateManyWithoutVaultAssetsNestedInput
    depositAddresses?: depositAddressesUpdateManyWithoutVaultAssetsNestedInput
    assets?: assetsUpdateOneRequiredWithoutVaultAssetsNestedInput
    vaults?: vaultsUpdateOneRequiredWithoutVaultAssetsNestedInput
  }

  export type vaultAssetsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vaultId?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    balance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUncheckedUpdateManyWithoutVaultAssetsNestedInput
    depositAddresses?: depositAddressesUncheckedUpdateManyWithoutVaultAssetsNestedInput
  }

  export type vaultAssetsCreateManyInput = {
    id?: number
    vaultId: string
    assetId: number
    balance: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vaultAssetsUpdateManyMutationInput = {
    balance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vaultAssetsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    vaultId?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    balance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vaultStatusTypesCreateInput = {
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vaults?: vaultsCreateNestedManyWithoutVaultStatusTypesInput
  }

  export type vaultStatusTypesUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vaults?: vaultsUncheckedCreateNestedManyWithoutVaultStatusTypesInput
  }

  export type vaultStatusTypesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaults?: vaultsUpdateManyWithoutVaultStatusTypesNestedInput
  }

  export type vaultStatusTypesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaults?: vaultsUncheckedUpdateManyWithoutVaultStatusTypesNestedInput
  }

  export type vaultStatusTypesCreateManyInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vaultStatusTypesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vaultStatusTypesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vaultsCreateInput = {
    id: string
    vaultName?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesCreateNestedManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesCreateNestedManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsCreateNestedManyWithoutVaults_transactions_sourceVaultIdTovaultsInput
    transactions_transactions_targetVaultIdTovaults?: transactionsCreateNestedManyWithoutVaults_transactions_targetVaultIdTovaultsInput
    vaultAssets?: vaultAssetsCreateNestedManyWithoutVaultsInput
    users: usersCreateNestedOneWithoutVaultsInput
    vaultStatusTypes?: vaultStatusTypesCreateNestedOneWithoutVaultsInput
  }

  export type vaultsUncheckedCreateInput = {
    id: string
    createdByUserId: string
    vaultStatusId?: number | null
    vaultName?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesUncheckedCreateNestedManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesUncheckedCreateNestedManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsUncheckedCreateNestedManyWithoutVaults_transactions_sourceVaultIdTovaultsInput
    transactions_transactions_targetVaultIdTovaults?: transactionsUncheckedCreateNestedManyWithoutVaults_transactions_targetVaultIdTovaultsInput
    vaultAssets?: vaultAssetsUncheckedCreateNestedManyWithoutVaultsInput
  }

  export type vaultsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaultName?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesUpdateManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsNestedInput
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesUpdateManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsNestedInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsUpdateManyWithoutVaults_transactions_sourceVaultIdTovaultsNestedInput
    transactions_transactions_targetVaultIdTovaults?: transactionsUpdateManyWithoutVaults_transactions_targetVaultIdTovaultsNestedInput
    vaultAssets?: vaultAssetsUpdateManyWithoutVaultsNestedInput
    users?: usersUpdateOneRequiredWithoutVaultsNestedInput
    vaultStatusTypes?: vaultStatusTypesUpdateOneWithoutVaultsNestedInput
  }

  export type vaultsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    vaultStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    vaultName?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesUncheckedUpdateManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsNestedInput
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesUncheckedUpdateManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsNestedInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsUncheckedUpdateManyWithoutVaults_transactions_sourceVaultIdTovaultsNestedInput
    transactions_transactions_targetVaultIdTovaults?: transactionsUncheckedUpdateManyWithoutVaults_transactions_targetVaultIdTovaultsNestedInput
    vaultAssets?: vaultAssetsUncheckedUpdateManyWithoutVaultsNestedInput
  }

  export type vaultsCreateManyInput = {
    id: string
    createdByUserId: string
    vaultStatusId?: number | null
    vaultName?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vaultsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaultName?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vaultsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    vaultStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    vaultName?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vendorSupportsAssetsCreateInput = {
    enabled?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    theirId?: string | null
    pricingPlanSupportsAssets?: pricingPlanSupportsAssetsCreateNestedManyWithoutVendorSupportsAssetsInput
    assets: assetsCreateNestedOneWithoutVendorSupportsAssetsInput
    vendors: vendorsCreateNestedOneWithoutVendorSupportsAssetsInput
  }

  export type vendorSupportsAssetsUncheckedCreateInput = {
    id?: number
    assetId: number
    vendorId: number
    enabled?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    theirId?: string | null
    pricingPlanSupportsAssets?: pricingPlanSupportsAssetsUncheckedCreateNestedManyWithoutVendorSupportsAssetsInput
  }

  export type vendorSupportsAssetsUpdateInput = {
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    theirId?: NullableStringFieldUpdateOperationsInput | string | null
    pricingPlanSupportsAssets?: pricingPlanSupportsAssetsUpdateManyWithoutVendorSupportsAssetsNestedInput
    assets?: assetsUpdateOneRequiredWithoutVendorSupportsAssetsNestedInput
    vendors?: vendorsUpdateOneRequiredWithoutVendorSupportsAssetsNestedInput
  }

  export type vendorSupportsAssetsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    theirId?: NullableStringFieldUpdateOperationsInput | string | null
    pricingPlanSupportsAssets?: pricingPlanSupportsAssetsUncheckedUpdateManyWithoutVendorSupportsAssetsNestedInput
  }

  export type vendorSupportsAssetsCreateManyInput = {
    id?: number
    assetId: number
    vendorId: number
    enabled?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    theirId?: string | null
  }

  export type vendorSupportsAssetsUpdateManyMutationInput = {
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    theirId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type vendorSupportsAssetsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    theirId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type webhookRequestsCreateInput = {
    id: string
    httpStatusCode: number
    requestPayload: JsonNullValueInput | InputJsonValue
    responsePayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyEngineEvents?: custodyEngineEventsCreateNestedOneWithoutWebhookRequestsInput
    institutionalProducts?: institutionalProductsCreateNestedOneWithoutWebhookRequestsInput
    webhooks: webhooksCreateNestedOneWithoutWebhookRequestsInput
  }

  export type webhookRequestsUncheckedCreateInput = {
    id: string
    webhookId: string
    institutionalProductId?: string | null
    httpStatusCode: number
    requestPayload: JsonNullValueInput | InputJsonValue
    responsePayload?: NullableJsonNullValueInput | InputJsonValue
    custodyEngineEventId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type webhookRequestsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    httpStatusCode?: IntFieldUpdateOperationsInput | number
    requestPayload?: JsonNullValueInput | InputJsonValue
    responsePayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyEngineEvents?: custodyEngineEventsUpdateOneWithoutWebhookRequestsNestedInput
    institutionalProducts?: institutionalProductsUpdateOneWithoutWebhookRequestsNestedInput
    webhooks?: webhooksUpdateOneRequiredWithoutWebhookRequestsNestedInput
  }

  export type webhookRequestsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    webhookId?: StringFieldUpdateOperationsInput | string
    institutionalProductId?: NullableStringFieldUpdateOperationsInput | string | null
    httpStatusCode?: IntFieldUpdateOperationsInput | number
    requestPayload?: JsonNullValueInput | InputJsonValue
    responsePayload?: NullableJsonNullValueInput | InputJsonValue
    custodyEngineEventId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type webhookRequestsCreateManyInput = {
    id: string
    webhookId: string
    institutionalProductId?: string | null
    httpStatusCode: number
    requestPayload: JsonNullValueInput | InputJsonValue
    responsePayload?: NullableJsonNullValueInput | InputJsonValue
    custodyEngineEventId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type webhookRequestsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    httpStatusCode?: IntFieldUpdateOperationsInput | number
    requestPayload?: JsonNullValueInput | InputJsonValue
    responsePayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type webhookRequestsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    webhookId?: StringFieldUpdateOperationsInput | string
    institutionalProductId?: NullableStringFieldUpdateOperationsInput | string | null
    httpStatusCode?: IntFieldUpdateOperationsInput | number
    requestPayload?: JsonNullValueInput | InputJsonValue
    responsePayload?: NullableJsonNullValueInput | InputJsonValue
    custodyEngineEventId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type webhookStatusTypesCreateInput = {
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    webhooks?: webhooksCreateNestedManyWithoutWebhookStatusTypesInput
  }

  export type webhookStatusTypesUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    webhooks?: webhooksUncheckedCreateNestedManyWithoutWebhookStatusTypesInput
  }

  export type webhookStatusTypesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    webhooks?: webhooksUpdateManyWithoutWebhookStatusTypesNestedInput
  }

  export type webhookStatusTypesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    webhooks?: webhooksUncheckedUpdateManyWithoutWebhookStatusTypesNestedInput
  }

  export type webhookStatusTypesCreateManyInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type webhookStatusTypesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type webhookStatusTypesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type webhooksCreateInput = {
    id: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    webhookRequests?: webhookRequestsCreateNestedManyWithoutWebhooksInput
    organizations: organizationsCreateNestedOneWithoutWebhooksInput
    webhookStatusTypes: webhookStatusTypesCreateNestedOneWithoutWebhooksInput
  }

  export type webhooksUncheckedCreateInput = {
    id: string
    organizationId: number
    webhookStatusTypeId: number
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    webhookRequests?: webhookRequestsUncheckedCreateNestedManyWithoutWebhooksInput
  }

  export type webhooksUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    webhookRequests?: webhookRequestsUpdateManyWithoutWebhooksNestedInput
    organizations?: organizationsUpdateOneRequiredWithoutWebhooksNestedInput
    webhookStatusTypes?: webhookStatusTypesUpdateOneRequiredWithoutWebhooksNestedInput
  }

  export type webhooksUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    webhookStatusTypeId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    webhookRequests?: webhookRequestsUncheckedUpdateManyWithoutWebhooksNestedInput
  }

  export type webhooksCreateManyInput = {
    id: string
    organizationId: number
    webhookStatusTypeId: number
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type webhooksUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type webhooksUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    webhookStatusTypeId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type withdrawalAddressesCreateInput = {
    id: string
    nickname?: string | null
    address: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionPolicies?: transactionPoliciesCreateNestedManyWithoutWithdrawalAddressesInput
    transactions?: transactionsCreateNestedManyWithoutWithdrawalAddressesInput
    assets: assetsCreateNestedOneWithoutWithdrawalAddressesInput
    organizations: organizationsCreateNestedOneWithoutWithdrawalAddressesInput
  }

  export type withdrawalAddressesUncheckedCreateInput = {
    id: string
    organizationId: number
    assetId: number
    nickname?: string | null
    address: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionPolicies?: transactionPoliciesUncheckedCreateNestedManyWithoutWithdrawalAddressesInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutWithdrawalAddressesInput
  }

  export type withdrawalAddressesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionPolicies?: transactionPoliciesUpdateManyWithoutWithdrawalAddressesNestedInput
    transactions?: transactionsUpdateManyWithoutWithdrawalAddressesNestedInput
    assets?: assetsUpdateOneRequiredWithoutWithdrawalAddressesNestedInput
    organizations?: organizationsUpdateOneRequiredWithoutWithdrawalAddressesNestedInput
  }

  export type withdrawalAddressesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionPolicies?: transactionPoliciesUncheckedUpdateManyWithoutWithdrawalAddressesNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutWithdrawalAddressesNestedInput
  }

  export type withdrawalAddressesCreateManyInput = {
    id: string
    organizationId: number
    assetId: number
    nickname?: string | null
    address: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type withdrawalAddressesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type withdrawalAddressesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type SequelizeDataCountOrderByAggregateInput = {
    name?: SortOrder
  }

  export type SequelizeDataMaxOrderByAggregateInput = {
    name?: SortOrder
  }

  export type SequelizeDataMinOrderByAggregateInput = {
    name?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type SequelizeMetaCountOrderByAggregateInput = {
    name?: SortOrder
  }

  export type SequelizeMetaMaxOrderByAggregateInput = {
    name?: SortOrder
  }

  export type SequelizeMetaMinOrderByAggregateInput = {
    name?: SortOrder
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type Enumenum_assets_typeFilter = {
    equals?: enum_assets_type
    in?: Enumerable<enum_assets_type>
    notIn?: Enumerable<enum_assets_type>
    not?: NestedEnumenum_assets_typeFilter | enum_assets_type
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type BaseNetworksRelationFilter = {
    is?: baseNetworksWhereInput | null
    isNot?: baseNetworksWhereInput | null
  }

  export type QuotesListRelationFilter = {
    every?: quotesWhereInput
    some?: quotesWhereInput
    none?: quotesWhereInput
  }

  export type TransactionPoliciesListRelationFilter = {
    every?: transactionPoliciesWhereInput
    some?: transactionPoliciesWhereInput
    none?: transactionPoliciesWhereInput
  }

  export type TransactionsListRelationFilter = {
    every?: transactionsWhereInput
    some?: transactionsWhereInput
    none?: transactionsWhereInput
  }

  export type VaultAssetsListRelationFilter = {
    every?: vaultAssetsWhereInput
    some?: vaultAssetsWhereInput
    none?: vaultAssetsWhereInput
  }

  export type VendorSupportsAssetsListRelationFilter = {
    every?: vendorSupportsAssetsWhereInput
    some?: vendorSupportsAssetsWhereInput
    none?: vendorSupportsAssetsWhereInput
  }

  export type WithdrawalAddressesListRelationFilter = {
    every?: withdrawalAddressesWhereInput
    some?: withdrawalAddressesWhereInput
    none?: withdrawalAddressesWhereInput
  }

  export type quotesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type transactionPoliciesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type transactionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type vaultAssetsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type vendorSupportsAssetsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type withdrawalAddressesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type assetsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    baseNetworkId?: SortOrder
    type?: SortOrder
    ticker?: SortOrder
    fireblocksTicker?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type assetsAvgOrderByAggregateInput = {
    id?: SortOrder
    baseNetworkId?: SortOrder
  }

  export type assetsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    baseNetworkId?: SortOrder
    type?: SortOrder
    ticker?: SortOrder
    fireblocksTicker?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type assetsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    baseNetworkId?: SortOrder
    type?: SortOrder
    ticker?: SortOrder
    fireblocksTicker?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type assetsSumOrderByAggregateInput = {
    id?: SortOrder
    baseNetworkId?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type Enumenum_assets_typeWithAggregatesFilter = {
    equals?: enum_assets_type
    in?: Enumerable<enum_assets_type>
    notIn?: Enumerable<enum_assets_type>
    not?: NestedEnumenum_assets_typeWithAggregatesFilter | enum_assets_type
    _count?: NestedIntFilter
    _min?: NestedEnumenum_assets_typeFilter
    _max?: NestedEnumenum_assets_typeFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type AssetsListRelationFilter = {
    every?: assetsWhereInput
    some?: assetsWhereInput
    none?: assetsWhereInput
  }

  export type assetsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type baseNetworksCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    addressUrl?: SortOrder
    feeAssetId?: SortOrder
    txUrl?: SortOrder
    enabled?: SortOrder
    baseBps?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type baseNetworksAvgOrderByAggregateInput = {
    id?: SortOrder
    feeAssetId?: SortOrder
    baseBps?: SortOrder
  }

  export type baseNetworksMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    addressUrl?: SortOrder
    feeAssetId?: SortOrder
    txUrl?: SortOrder
    enabled?: SortOrder
    baseBps?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type baseNetworksMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    addressUrl?: SortOrder
    feeAssetId?: SortOrder
    txUrl?: SortOrder
    enabled?: SortOrder
    baseBps?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type baseNetworksSumOrderByAggregateInput = {
    id?: SortOrder
    feeAssetId?: SortOrder
    baseBps?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type UuidFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    mode?: QueryMode
    not?: NestedUuidFilter | string
  }

  export type Enumenum_quotes_sideFilter = {
    equals?: enum_quotes_side
    in?: Enumerable<enum_quotes_side>
    notIn?: Enumerable<enum_quotes_side>
    not?: NestedEnumenum_quotes_sideFilter | enum_quotes_side
  }
  export type JsonNullableFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase>, Exclude<keyof Required<JsonNullableFilterBase>, 'path'>>,
        Required<JsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase>, 'path'>>

  export type JsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type UuidNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    mode?: QueryMode
    not?: NestedUuidNullableFilter | string | null
  }

  export type OrdersListRelationFilter = {
    every?: ordersWhereInput
    some?: ordersWhereInput
    none?: ordersWhereInput
  }

  export type TokenPairsInfoRelationFilter = {
    is?: tokenPairsInfoWhereInput | null
    isNot?: tokenPairsInfoWhereInput | null
  }

  export type QuoteStatusesRelationFilter = {
    is?: quoteStatusesWhereInput
    isNot?: quoteStatusesWhereInput
  }

  export type AssetsRelationFilter = {
    is?: assetsWhereInput
    isNot?: assetsWhereInput
  }

  export type VendorsRelationFilter = {
    is?: vendorsWhereInput | null
    isNot?: vendorsWhereInput | null
  }

  export type ordersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type quotesCountOrderByAggregateInput = {
    id?: SortOrder
    quoteStatusId?: SortOrder
    sourceAssetId?: SortOrder
    targetAssetId?: SortOrder
    side?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    extraData?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fxRequestID?: SortOrder
    buyPrice?: SortOrder
    sellPrice?: SortOrder
    quantity?: SortOrder
  }

  export type quotesAvgOrderByAggregateInput = {
    quoteStatusId?: SortOrder
    sourceAssetId?: SortOrder
    targetAssetId?: SortOrder
    vendorId?: SortOrder
  }

  export type quotesMaxOrderByAggregateInput = {
    id?: SortOrder
    quoteStatusId?: SortOrder
    sourceAssetId?: SortOrder
    targetAssetId?: SortOrder
    side?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fxRequestID?: SortOrder
    buyPrice?: SortOrder
    sellPrice?: SortOrder
    quantity?: SortOrder
  }

  export type quotesMinOrderByAggregateInput = {
    id?: SortOrder
    quoteStatusId?: SortOrder
    sourceAssetId?: SortOrder
    targetAssetId?: SortOrder
    side?: SortOrder
    userId?: SortOrder
    vendorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fxRequestID?: SortOrder
    buyPrice?: SortOrder
    sellPrice?: SortOrder
    quantity?: SortOrder
  }

  export type quotesSumOrderByAggregateInput = {
    quoteStatusId?: SortOrder
    sourceAssetId?: SortOrder
    targetAssetId?: SortOrder
    vendorId?: SortOrder
  }

  export type UuidWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type Enumenum_quotes_sideWithAggregatesFilter = {
    equals?: enum_quotes_side
    in?: Enumerable<enum_quotes_side>
    notIn?: Enumerable<enum_quotes_side>
    not?: NestedEnumenum_quotes_sideWithAggregatesFilter | enum_quotes_side
    _count?: NestedIntFilter
    _min?: NestedEnumenum_quotes_sideFilter
    _max?: NestedEnumenum_quotes_sideFilter
  }
  export type JsonNullableWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntNullableFilter
    _min?: NestedJsonNullableFilter
    _max?: NestedJsonNullableFilter
  }

  export type UuidNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type transactionStatusTypesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type transactionStatusTypesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type transactionStatusTypesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type transactionStatusTypesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type transactionStatusTypesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type transactionTypesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type transactionTypesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type transactionTypesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type transactionTypesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type transactionTypesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsersRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type VaultsRelationFilter = {
    is?: vaultsWhereInput | null
    isNot?: vaultsWhereInput | null
  }

  export type WithdrawalAddressesRelationFilter = {
    is?: withdrawalAddressesWhereInput | null
    isNot?: withdrawalAddressesWhereInput | null
  }

  export type TransactionStatusTypesRelationFilter = {
    is?: transactionStatusTypesWhereInput
    isNot?: transactionStatusTypesWhereInput
  }

  export type TransactionTypesRelationFilter = {
    is?: transactionTypesWhereInput
    isNot?: transactionTypesWhereInput
  }

  export type transactionsCountOrderByAggregateInput = {
    id?: SortOrder
    custodyVendorId?: SortOrder
    custodyVendorRef?: SortOrder
    transactionTypeId?: SortOrder
    amountAsset?: SortOrder
    amountUSD?: SortOrder
    assetId?: SortOrder
    transactionStatusTypeId?: SortOrder
    onChainTxId?: SortOrder
    sourceVaultId?: SortOrder
    targetVaultId?: SortOrder
    targetWithdrawalAddressId?: SortOrder
    sourceExternalAddress?: SortOrder
    createdByUserId?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type transactionsAvgOrderByAggregateInput = {
    custodyVendorId?: SortOrder
    transactionTypeId?: SortOrder
    assetId?: SortOrder
    transactionStatusTypeId?: SortOrder
  }

  export type transactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    custodyVendorId?: SortOrder
    custodyVendorRef?: SortOrder
    transactionTypeId?: SortOrder
    amountAsset?: SortOrder
    amountUSD?: SortOrder
    assetId?: SortOrder
    transactionStatusTypeId?: SortOrder
    onChainTxId?: SortOrder
    sourceVaultId?: SortOrder
    targetVaultId?: SortOrder
    targetWithdrawalAddressId?: SortOrder
    sourceExternalAddress?: SortOrder
    createdByUserId?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type transactionsMinOrderByAggregateInput = {
    id?: SortOrder
    custodyVendorId?: SortOrder
    custodyVendorRef?: SortOrder
    transactionTypeId?: SortOrder
    amountAsset?: SortOrder
    amountUSD?: SortOrder
    assetId?: SortOrder
    transactionStatusTypeId?: SortOrder
    onChainTxId?: SortOrder
    sourceVaultId?: SortOrder
    targetVaultId?: SortOrder
    targetWithdrawalAddressId?: SortOrder
    sourceExternalAddress?: SortOrder
    createdByUserId?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type transactionsSumOrderByAggregateInput = {
    custodyVendorId?: SortOrder
    transactionTypeId?: SortOrder
    assetId?: SortOrder
    transactionStatusTypeId?: SortOrder
  }

  export type OrganizationsRelationFilter = {
    is?: organizationsWhereInput
    isNot?: organizationsWhereInput
  }

  export type UserTypesRelationFilter = {
    is?: userTypesWhereInput
    isNot?: userTypesWhereInput
  }

  export type VaultsListRelationFilter = {
    every?: vaultsWhereInput
    some?: vaultsWhereInput
    none?: vaultsWhereInput
  }

  export type vaultsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userTypeId?: SortOrder
    primaryEmail?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publicKey?: SortOrder
    apiKey?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    organizationId?: SortOrder
    userTypeId?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userTypeId?: SortOrder
    primaryEmail?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publicKey?: SortOrder
    apiKey?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userTypeId?: SortOrder
    primaryEmail?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publicKey?: SortOrder
    apiKey?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    organizationId?: SortOrder
    userTypeId?: SortOrder
  }

  export type VendorsListRelationFilter = {
    every?: vendorsWhereInput
    some?: vendorsWhereInput
    none?: vendorsWhereInput
  }

  export type vendorsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type vendorTypesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vendorTypesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type vendorTypesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vendorTypesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vendorTypesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CustodyVendorVaultAssetsListRelationFilter = {
    every?: custodyVendorVaultAssetsWhereInput
    some?: custodyVendorVaultAssetsWhereInput
    none?: custodyVendorVaultAssetsWhereInput
  }

  export type DepositAddressesListRelationFilter = {
    every?: depositAddressesWhereInput
    some?: depositAddressesWhereInput
    none?: depositAddressesWhereInput
  }

  export type TokenPairsListRelationFilter = {
    every?: tokenPairsWhereInput
    some?: tokenPairsWhereInput
    none?: tokenPairsWhereInput
  }

  export type VendorTypesRelationFilter = {
    is?: vendorTypesWhereInput
    isNot?: vendorTypesWhereInput
  }

  export type custodyVendorVaultAssetsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type depositAddressesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tokenPairsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type vendorsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    identifier?: SortOrder
    vendorTypeId?: SortOrder
    quoteEngineBaseBps?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vendorsAvgOrderByAggregateInput = {
    id?: SortOrder
    vendorTypeId?: SortOrder
    quoteEngineBaseBps?: SortOrder
  }

  export type vendorsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    identifier?: SortOrder
    vendorTypeId?: SortOrder
    quoteEngineBaseBps?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vendorsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    identifier?: SortOrder
    vendorTypeId?: SortOrder
    quoteEngineBaseBps?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vendorsSumOrderByAggregateInput = {
    id?: SortOrder
    vendorTypeId?: SortOrder
    quoteEngineBaseBps?: SortOrder
  }

  export type CustodyEngineEventsListRelationFilter = {
    every?: custodyEngineEventsWhereInput
    some?: custodyEngineEventsWhereInput
    none?: custodyEngineEventsWhereInput
  }

  export type custodyEngineEventsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type custodyEngineEventTypesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type custodyEngineEventTypesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type custodyEngineEventTypesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type custodyEngineEventTypesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type custodyEngineEventTypesSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonFilter = 
    | PatchUndefined<
        Either<Required<JsonFilterBase>, Exclude<keyof Required<JsonFilterBase>, 'path'>>,
        Required<JsonFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase>, 'path'>>

  export type JsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type CustodyEngineEventTypesRelationFilter = {
    is?: custodyEngineEventTypesWhereInput
    isNot?: custodyEngineEventTypesWhereInput
  }

  export type WebhookRequestsListRelationFilter = {
    every?: webhookRequestsWhereInput
    some?: webhookRequestsWhereInput
    none?: webhookRequestsWhereInput
  }

  export type webhookRequestsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type custodyEngineEventsCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    custodyEngineEventTypeId?: SortOrder
    event?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type custodyEngineEventsAvgOrderByAggregateInput = {
    organizationId?: SortOrder
    custodyEngineEventTypeId?: SortOrder
  }

  export type custodyEngineEventsMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    custodyEngineEventTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type custodyEngineEventsMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    custodyEngineEventTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type custodyEngineEventsSumOrderByAggregateInput = {
    organizationId?: SortOrder
    custodyEngineEventTypeId?: SortOrder
  }
  export type JsonWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase>, Exclude<keyof Required<JsonWithAggregatesFilterBase>, 'path'>>,
        Required<JsonWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase>, 'path'>>

  export type JsonWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntFilter
    _min?: NestedJsonFilter
    _max?: NestedJsonFilter
  }

  export type VaultAssetsRelationFilter = {
    is?: vaultAssetsWhereInput
    isNot?: vaultAssetsWhereInput
  }

  export type custodyVendorVaultAssetsCountOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    vendorRef?: SortOrder
    balance?: SortOrder
    vaultAssetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type custodyVendorVaultAssetsAvgOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    vaultAssetId?: SortOrder
  }

  export type custodyVendorVaultAssetsMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    vendorRef?: SortOrder
    balance?: SortOrder
    vaultAssetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type custodyVendorVaultAssetsMinOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    vendorRef?: SortOrder
    balance?: SortOrder
    vaultAssetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type custodyVendorVaultAssetsSumOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
    vaultAssetId?: SortOrder
  }

  export type depositAddressStatusTypesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type depositAddressStatusTypesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type depositAddressStatusTypesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type depositAddressStatusTypesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type depositAddressStatusTypesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type depositAddressesCountOrderByAggregateInput = {
    id?: SortOrder
    vaultAssetId?: SortOrder
    address?: SortOrder
    depositAddressStatusId?: SortOrder
    vendorId?: SortOrder
    vendorRef?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type depositAddressesAvgOrderByAggregateInput = {
    vaultAssetId?: SortOrder
    depositAddressStatusId?: SortOrder
    vendorId?: SortOrder
  }

  export type depositAddressesMaxOrderByAggregateInput = {
    id?: SortOrder
    vaultAssetId?: SortOrder
    address?: SortOrder
    depositAddressStatusId?: SortOrder
    vendorId?: SortOrder
    vendorRef?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type depositAddressesMinOrderByAggregateInput = {
    id?: SortOrder
    vaultAssetId?: SortOrder
    address?: SortOrder
    depositAddressStatusId?: SortOrder
    vendorId?: SortOrder
    vendorRef?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type depositAddressesSumOrderByAggregateInput = {
    vaultAssetId?: SortOrder
    depositAddressStatusId?: SortOrder
    vendorId?: SortOrder
  }

  export type institutionalProductsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type institutionalProductsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type institutionalProductsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Enumenum_orders_userAcceptedSideFilter = {
    equals?: enum_orders_userAcceptedSide
    in?: Enumerable<enum_orders_userAcceptedSide>
    notIn?: Enumerable<enum_orders_userAcceptedSide>
    not?: NestedEnumenum_orders_userAcceptedSideFilter | enum_orders_userAcceptedSide
  }

  export type Enumenum_orders_orderTypeNullableFilter = {
    equals?: enum_orders_orderType | null
    in?: Enumerable<enum_orders_orderType> | null
    notIn?: Enumerable<enum_orders_orderType> | null
    not?: NestedEnumenum_orders_orderTypeNullableFilter | enum_orders_orderType | null
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type QuotesRelationFilter = {
    is?: quotesWhereInput
    isNot?: quotesWhereInput
  }

  export type ordersCountOrderByAggregateInput = {
    id?: SortOrder
    quoteId?: SortOrder
    orderStatus?: SortOrder
    userAcceptedPrice?: SortOrder
    userAcceptedQuantity?: SortOrder
    userAcceptedSide?: SortOrder
    userAcceptedTradePair?: SortOrder
    userAcceptedTimestamp?: SortOrder
    orderType?: SortOrder
    orderTimeInForce?: SortOrder
    vendorQuoteId?: SortOrder
    vendorQuantityRequested?: SortOrder
    vendorPriceRequested?: SortOrder
    orderQuantityExecuted?: SortOrder
    orderPriceExecuted?: SortOrder
    orderTimestampExecuted?: SortOrder
    orderVendorStatus?: SortOrder
    allowedSlippage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ordersMaxOrderByAggregateInput = {
    id?: SortOrder
    quoteId?: SortOrder
    orderStatus?: SortOrder
    userAcceptedPrice?: SortOrder
    userAcceptedQuantity?: SortOrder
    userAcceptedSide?: SortOrder
    userAcceptedTimestamp?: SortOrder
    orderType?: SortOrder
    orderTimeInForce?: SortOrder
    vendorQuoteId?: SortOrder
    vendorQuantityRequested?: SortOrder
    vendorPriceRequested?: SortOrder
    orderQuantityExecuted?: SortOrder
    orderPriceExecuted?: SortOrder
    orderTimestampExecuted?: SortOrder
    orderVendorStatus?: SortOrder
    allowedSlippage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ordersMinOrderByAggregateInput = {
    id?: SortOrder
    quoteId?: SortOrder
    orderStatus?: SortOrder
    userAcceptedPrice?: SortOrder
    userAcceptedQuantity?: SortOrder
    userAcceptedSide?: SortOrder
    userAcceptedTimestamp?: SortOrder
    orderType?: SortOrder
    orderTimeInForce?: SortOrder
    vendorQuoteId?: SortOrder
    vendorQuantityRequested?: SortOrder
    vendorPriceRequested?: SortOrder
    orderQuantityExecuted?: SortOrder
    orderPriceExecuted?: SortOrder
    orderTimestampExecuted?: SortOrder
    orderVendorStatus?: SortOrder
    allowedSlippage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Enumenum_orders_userAcceptedSideWithAggregatesFilter = {
    equals?: enum_orders_userAcceptedSide
    in?: Enumerable<enum_orders_userAcceptedSide>
    notIn?: Enumerable<enum_orders_userAcceptedSide>
    not?: NestedEnumenum_orders_userAcceptedSideWithAggregatesFilter | enum_orders_userAcceptedSide
    _count?: NestedIntFilter
    _min?: NestedEnumenum_orders_userAcceptedSideFilter
    _max?: NestedEnumenum_orders_userAcceptedSideFilter
  }

  export type Enumenum_orders_orderTypeNullableWithAggregatesFilter = {
    equals?: enum_orders_orderType | null
    in?: Enumerable<enum_orders_orderType> | null
    notIn?: Enumerable<enum_orders_orderType> | null
    not?: NestedEnumenum_orders_orderTypeNullableWithAggregatesFilter | enum_orders_orderType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumenum_orders_orderTypeNullableFilter
    _max?: NestedEnumenum_orders_orderTypeNullableFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type OrganizationsListRelationFilter = {
    every?: organizationsWhereInput
    some?: organizationsWhereInput
    none?: organizationsWhereInput
  }

  export type organizationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type organizationStatusTypesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type organizationStatusTypesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type organizationStatusTypesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type organizationStatusTypesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type organizationStatusTypesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PricingPlansRelationFilter = {
    is?: pricingPlansWhereInput
    isNot?: pricingPlansWhereInput
  }

  export type OrganizationStatusTypesRelationFilter = {
    is?: organizationStatusTypesWhereInput
    isNot?: organizationStatusTypesWhereInput
  }

  export type UsersListRelationFilter = {
    every?: usersWhereInput
    some?: usersWhereInput
    none?: usersWhereInput
  }

  export type WebhooksListRelationFilter = {
    every?: webhooksWhereInput
    some?: webhooksWhereInput
    none?: webhooksWhereInput
  }

  export type usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type webhooksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type organizationsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    primaryEmail?: SortOrder
    pricingPlanId?: SortOrder
    statusId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type organizationsAvgOrderByAggregateInput = {
    id?: SortOrder
    pricingPlanId?: SortOrder
    statusId?: SortOrder
  }

  export type organizationsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    primaryEmail?: SortOrder
    pricingPlanId?: SortOrder
    statusId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type organizationsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    primaryEmail?: SortOrder
    pricingPlanId?: SortOrder
    statusId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type organizationsSumOrderByAggregateInput = {
    id?: SortOrder
    pricingPlanId?: SortOrder
    statusId?: SortOrder
  }

  export type PricingPlansListRelationFilter = {
    every?: pricingPlansWhereInput
    some?: pricingPlansWhereInput
    none?: pricingPlansWhereInput
  }

  export type pricingPlansOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pricingPlanProfilesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    quoteEngineRps?: SortOrder
    custodyEngineRps?: SortOrder
    numberOfUsers?: SortOrder
    sla?: SortOrder
    rbac?: SortOrder
    quoteEngineClaims?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pricingPlanProfilesAvgOrderByAggregateInput = {
    id?: SortOrder
    quoteEngineRps?: SortOrder
    custodyEngineRps?: SortOrder
    numberOfUsers?: SortOrder
    sla?: SortOrder
  }

  export type pricingPlanProfilesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    quoteEngineRps?: SortOrder
    custodyEngineRps?: SortOrder
    numberOfUsers?: SortOrder
    sla?: SortOrder
    rbac?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pricingPlanProfilesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    quoteEngineRps?: SortOrder
    custodyEngineRps?: SortOrder
    numberOfUsers?: SortOrder
    sla?: SortOrder
    rbac?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pricingPlanProfilesSumOrderByAggregateInput = {
    id?: SortOrder
    quoteEngineRps?: SortOrder
    custodyEngineRps?: SortOrder
    numberOfUsers?: SortOrder
    sla?: SortOrder
  }

  export type VendorSupportsAssetsRelationFilter = {
    is?: vendorSupportsAssetsWhereInput
    isNot?: vendorSupportsAssetsWhereInput
  }

  export type pricingPlanSupportsAssetsCountOrderByAggregateInput = {
    id?: SortOrder
    vendorSupportsAssetId?: SortOrder
    pricingPlanId?: SortOrder
    enabled?: SortOrder
    buyBps?: SortOrder
    sellBps?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pricingPlanSupportsAssetsAvgOrderByAggregateInput = {
    id?: SortOrder
    vendorSupportsAssetId?: SortOrder
    pricingPlanId?: SortOrder
    buyBps?: SortOrder
    sellBps?: SortOrder
  }

  export type pricingPlanSupportsAssetsMaxOrderByAggregateInput = {
    id?: SortOrder
    vendorSupportsAssetId?: SortOrder
    pricingPlanId?: SortOrder
    enabled?: SortOrder
    buyBps?: SortOrder
    sellBps?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pricingPlanSupportsAssetsMinOrderByAggregateInput = {
    id?: SortOrder
    vendorSupportsAssetId?: SortOrder
    pricingPlanId?: SortOrder
    enabled?: SortOrder
    buyBps?: SortOrder
    sellBps?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pricingPlanSupportsAssetsSumOrderByAggregateInput = {
    id?: SortOrder
    vendorSupportsAssetId?: SortOrder
    pricingPlanId?: SortOrder
    buyBps?: SortOrder
    sellBps?: SortOrder
  }

  export type PricingPlanSupportsAssetsListRelationFilter = {
    every?: pricingPlanSupportsAssetsWhereInput
    some?: pricingPlanSupportsAssetsWhereInput
    none?: pricingPlanSupportsAssetsWhereInput
  }

  export type PricingPlanProfilesRelationFilter = {
    is?: pricingPlanProfilesWhereInput
    isNot?: pricingPlanProfilesWhereInput
  }

  export type pricingPlanSupportsAssetsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pricingPlansCountOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    active?: SortOrder
    pricingPlanProfileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pricingPlansAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    pricingPlanProfileId?: SortOrder
  }

  export type pricingPlansMaxOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    active?: SortOrder
    pricingPlanProfileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pricingPlansMinOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    active?: SortOrder
    pricingPlanProfileId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type pricingPlansSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    pricingPlanProfileId?: SortOrder
  }

  export type quoteStatusesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type quoteStatusesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type quoteStatusesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type quoteStatusesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type quoteStatusesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TokenPairsInfoListRelationFilter = {
    every?: tokenPairsInfoWhereInput
    some?: tokenPairsInfoWhereInput
    none?: tokenPairsInfoWhereInput
  }

  export type tokenPairsInfoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tokenPairsCountOrderByAggregateInput = {
    id?: SortOrder
    baseToken?: SortOrder
    quoteToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendorId?: SortOrder
  }

  export type tokenPairsAvgOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
  }

  export type tokenPairsMaxOrderByAggregateInput = {
    id?: SortOrder
    baseToken?: SortOrder
    quoteToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendorId?: SortOrder
  }

  export type tokenPairsMinOrderByAggregateInput = {
    id?: SortOrder
    baseToken?: SortOrder
    quoteToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendorId?: SortOrder
  }

  export type tokenPairsSumOrderByAggregateInput = {
    id?: SortOrder
    vendorId?: SortOrder
  }

  export type TokenPairsRelationFilter = {
    is?: tokenPairsWhereInput
    isNot?: tokenPairsWhereInput
  }

  export type tokenPairsInfoCountOrderByAggregateInput = {
    id?: SortOrder
    tokenPairId?: SortOrder
    fxRequestID?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tokenPairsInfoAvgOrderByAggregateInput = {
    id?: SortOrder
    tokenPairId?: SortOrder
  }

  export type tokenPairsInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    tokenPairId?: SortOrder
    fxRequestID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tokenPairsInfoMinOrderByAggregateInput = {
    id?: SortOrder
    tokenPairId?: SortOrder
    fxRequestID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tokenPairsInfoSumOrderByAggregateInput = {
    id?: SortOrder
    tokenPairId?: SortOrder
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type Enumenum_transactionPolicies_actionFilter = {
    equals?: enum_transactionPolicies_action
    in?: Enumerable<enum_transactionPolicies_action>
    notIn?: Enumerable<enum_transactionPolicies_action>
    not?: NestedEnumenum_transactionPolicies_actionFilter | enum_transactionPolicies_action
  }

  export type transactionPoliciesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionTypeId?: SortOrder
    sourceVaultId?: SortOrder
    targetVaultId?: SortOrder
    targetWithdrawalAddressId?: SortOrder
    toOneTimeAddresses?: SortOrder
    greaterThanUSD?: SortOrder
    assetId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type transactionPoliciesAvgOrderByAggregateInput = {
    transactionTypeId?: SortOrder
    assetId?: SortOrder
  }

  export type transactionPoliciesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionTypeId?: SortOrder
    sourceVaultId?: SortOrder
    targetVaultId?: SortOrder
    targetWithdrawalAddressId?: SortOrder
    toOneTimeAddresses?: SortOrder
    greaterThanUSD?: SortOrder
    assetId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type transactionPoliciesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionTypeId?: SortOrder
    sourceVaultId?: SortOrder
    targetVaultId?: SortOrder
    targetWithdrawalAddressId?: SortOrder
    toOneTimeAddresses?: SortOrder
    greaterThanUSD?: SortOrder
    assetId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type transactionPoliciesSumOrderByAggregateInput = {
    transactionTypeId?: SortOrder
    assetId?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type Enumenum_transactionPolicies_actionWithAggregatesFilter = {
    equals?: enum_transactionPolicies_action
    in?: Enumerable<enum_transactionPolicies_action>
    notIn?: Enumerable<enum_transactionPolicies_action>
    not?: NestedEnumenum_transactionPolicies_actionWithAggregatesFilter | enum_transactionPolicies_action
    _count?: NestedIntFilter
    _min?: NestedEnumenum_transactionPolicies_actionFilter
    _max?: NestedEnumenum_transactionPolicies_actionFilter
  }

  export type userTypesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    claims?: SortOrder
    isServiceAccount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userTypesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type userTypesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isServiceAccount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userTypesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isServiceAccount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userTypesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type vaultAssetsCountOrderByAggregateInput = {
    id?: SortOrder
    vaultId?: SortOrder
    assetId?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vaultAssetsAvgOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
  }

  export type vaultAssetsMaxOrderByAggregateInput = {
    id?: SortOrder
    vaultId?: SortOrder
    assetId?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vaultAssetsMinOrderByAggregateInput = {
    id?: SortOrder
    vaultId?: SortOrder
    assetId?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vaultAssetsSumOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
  }

  export type vaultStatusTypesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vaultStatusTypesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type vaultStatusTypesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vaultStatusTypesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vaultStatusTypesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VaultStatusTypesRelationFilter = {
    is?: vaultStatusTypesWhereInput | null
    isNot?: vaultStatusTypesWhereInput | null
  }

  export type vaultsCountOrderByAggregateInput = {
    id?: SortOrder
    createdByUserId?: SortOrder
    vaultStatusId?: SortOrder
    vaultName?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vaultsAvgOrderByAggregateInput = {
    vaultStatusId?: SortOrder
  }

  export type vaultsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdByUserId?: SortOrder
    vaultStatusId?: SortOrder
    vaultName?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vaultsMinOrderByAggregateInput = {
    id?: SortOrder
    createdByUserId?: SortOrder
    vaultStatusId?: SortOrder
    vaultName?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vaultsSumOrderByAggregateInput = {
    vaultStatusId?: SortOrder
  }

  export type vendorSupportsAssetsCountOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    vendorId?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    theirId?: SortOrder
  }

  export type vendorSupportsAssetsAvgOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    vendorId?: SortOrder
  }

  export type vendorSupportsAssetsMaxOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    vendorId?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    theirId?: SortOrder
  }

  export type vendorSupportsAssetsMinOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    vendorId?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    theirId?: SortOrder
  }

  export type vendorSupportsAssetsSumOrderByAggregateInput = {
    id?: SortOrder
    assetId?: SortOrder
    vendorId?: SortOrder
  }

  export type CustodyEngineEventsRelationFilter = {
    is?: custodyEngineEventsWhereInput | null
    isNot?: custodyEngineEventsWhereInput | null
  }

  export type InstitutionalProductsRelationFilter = {
    is?: institutionalProductsWhereInput | null
    isNot?: institutionalProductsWhereInput | null
  }

  export type WebhooksRelationFilter = {
    is?: webhooksWhereInput
    isNot?: webhooksWhereInput
  }

  export type webhookRequestsCountOrderByAggregateInput = {
    id?: SortOrder
    webhookId?: SortOrder
    institutionalProductId?: SortOrder
    httpStatusCode?: SortOrder
    requestPayload?: SortOrder
    responsePayload?: SortOrder
    custodyEngineEventId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type webhookRequestsAvgOrderByAggregateInput = {
    httpStatusCode?: SortOrder
  }

  export type webhookRequestsMaxOrderByAggregateInput = {
    id?: SortOrder
    webhookId?: SortOrder
    institutionalProductId?: SortOrder
    httpStatusCode?: SortOrder
    custodyEngineEventId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type webhookRequestsMinOrderByAggregateInput = {
    id?: SortOrder
    webhookId?: SortOrder
    institutionalProductId?: SortOrder
    httpStatusCode?: SortOrder
    custodyEngineEventId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type webhookRequestsSumOrderByAggregateInput = {
    httpStatusCode?: SortOrder
  }

  export type webhookStatusTypesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type webhookStatusTypesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type webhookStatusTypesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type webhookStatusTypesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type webhookStatusTypesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WebhookStatusTypesRelationFilter = {
    is?: webhookStatusTypesWhereInput
    isNot?: webhookStatusTypesWhereInput
  }

  export type webhooksCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    webhookStatusTypeId?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type webhooksAvgOrderByAggregateInput = {
    organizationId?: SortOrder
    webhookStatusTypeId?: SortOrder
  }

  export type webhooksMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    webhookStatusTypeId?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type webhooksMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    webhookStatusTypeId?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type webhooksSumOrderByAggregateInput = {
    organizationId?: SortOrder
    webhookStatusTypeId?: SortOrder
  }

  export type withdrawalAddressesCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    assetId?: SortOrder
    nickname?: SortOrder
    address?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type withdrawalAddressesAvgOrderByAggregateInput = {
    organizationId?: SortOrder
    assetId?: SortOrder
  }

  export type withdrawalAddressesMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    assetId?: SortOrder
    nickname?: SortOrder
    address?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type withdrawalAddressesMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    assetId?: SortOrder
    nickname?: SortOrder
    address?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type withdrawalAddressesSumOrderByAggregateInput = {
    organizationId?: SortOrder
    assetId?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type baseNetworksCreateNestedOneWithoutAssetsInput = {
    create?: XOR<baseNetworksCreateWithoutAssetsInput, baseNetworksUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: baseNetworksCreateOrConnectWithoutAssetsInput
    connect?: baseNetworksWhereUniqueInput
  }

  export type quotesCreateNestedManyWithoutAssets_quotes_sourceAssetIdToassetsInput = {
    create?: XOR<Enumerable<quotesCreateWithoutAssets_quotes_sourceAssetIdToassetsInput>, Enumerable<quotesUncheckedCreateWithoutAssets_quotes_sourceAssetIdToassetsInput>>
    connectOrCreate?: Enumerable<quotesCreateOrConnectWithoutAssets_quotes_sourceAssetIdToassetsInput>
    createMany?: quotesCreateManyAssets_quotes_sourceAssetIdToassetsInputEnvelope
    connect?: Enumerable<quotesWhereUniqueInput>
  }

  export type quotesCreateNestedManyWithoutAssets_quotes_targetAssetIdToassetsInput = {
    create?: XOR<Enumerable<quotesCreateWithoutAssets_quotes_targetAssetIdToassetsInput>, Enumerable<quotesUncheckedCreateWithoutAssets_quotes_targetAssetIdToassetsInput>>
    connectOrCreate?: Enumerable<quotesCreateOrConnectWithoutAssets_quotes_targetAssetIdToassetsInput>
    createMany?: quotesCreateManyAssets_quotes_targetAssetIdToassetsInputEnvelope
    connect?: Enumerable<quotesWhereUniqueInput>
  }

  export type transactionPoliciesCreateNestedManyWithoutAssetsInput = {
    create?: XOR<Enumerable<transactionPoliciesCreateWithoutAssetsInput>, Enumerable<transactionPoliciesUncheckedCreateWithoutAssetsInput>>
    connectOrCreate?: Enumerable<transactionPoliciesCreateOrConnectWithoutAssetsInput>
    createMany?: transactionPoliciesCreateManyAssetsInputEnvelope
    connect?: Enumerable<transactionPoliciesWhereUniqueInput>
  }

  export type transactionsCreateNestedManyWithoutAssetsInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutAssetsInput>, Enumerable<transactionsUncheckedCreateWithoutAssetsInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutAssetsInput>
    createMany?: transactionsCreateManyAssetsInputEnvelope
    connect?: Enumerable<transactionsWhereUniqueInput>
  }

  export type vaultAssetsCreateNestedManyWithoutAssetsInput = {
    create?: XOR<Enumerable<vaultAssetsCreateWithoutAssetsInput>, Enumerable<vaultAssetsUncheckedCreateWithoutAssetsInput>>
    connectOrCreate?: Enumerable<vaultAssetsCreateOrConnectWithoutAssetsInput>
    createMany?: vaultAssetsCreateManyAssetsInputEnvelope
    connect?: Enumerable<vaultAssetsWhereUniqueInput>
  }

  export type vendorSupportsAssetsCreateNestedManyWithoutAssetsInput = {
    create?: XOR<Enumerable<vendorSupportsAssetsCreateWithoutAssetsInput>, Enumerable<vendorSupportsAssetsUncheckedCreateWithoutAssetsInput>>
    connectOrCreate?: Enumerable<vendorSupportsAssetsCreateOrConnectWithoutAssetsInput>
    createMany?: vendorSupportsAssetsCreateManyAssetsInputEnvelope
    connect?: Enumerable<vendorSupportsAssetsWhereUniqueInput>
  }

  export type withdrawalAddressesCreateNestedManyWithoutAssetsInput = {
    create?: XOR<Enumerable<withdrawalAddressesCreateWithoutAssetsInput>, Enumerable<withdrawalAddressesUncheckedCreateWithoutAssetsInput>>
    connectOrCreate?: Enumerable<withdrawalAddressesCreateOrConnectWithoutAssetsInput>
    createMany?: withdrawalAddressesCreateManyAssetsInputEnvelope
    connect?: Enumerable<withdrawalAddressesWhereUniqueInput>
  }

  export type quotesUncheckedCreateNestedManyWithoutAssets_quotes_sourceAssetIdToassetsInput = {
    create?: XOR<Enumerable<quotesCreateWithoutAssets_quotes_sourceAssetIdToassetsInput>, Enumerable<quotesUncheckedCreateWithoutAssets_quotes_sourceAssetIdToassetsInput>>
    connectOrCreate?: Enumerable<quotesCreateOrConnectWithoutAssets_quotes_sourceAssetIdToassetsInput>
    createMany?: quotesCreateManyAssets_quotes_sourceAssetIdToassetsInputEnvelope
    connect?: Enumerable<quotesWhereUniqueInput>
  }

  export type quotesUncheckedCreateNestedManyWithoutAssets_quotes_targetAssetIdToassetsInput = {
    create?: XOR<Enumerable<quotesCreateWithoutAssets_quotes_targetAssetIdToassetsInput>, Enumerable<quotesUncheckedCreateWithoutAssets_quotes_targetAssetIdToassetsInput>>
    connectOrCreate?: Enumerable<quotesCreateOrConnectWithoutAssets_quotes_targetAssetIdToassetsInput>
    createMany?: quotesCreateManyAssets_quotes_targetAssetIdToassetsInputEnvelope
    connect?: Enumerable<quotesWhereUniqueInput>
  }

  export type transactionPoliciesUncheckedCreateNestedManyWithoutAssetsInput = {
    create?: XOR<Enumerable<transactionPoliciesCreateWithoutAssetsInput>, Enumerable<transactionPoliciesUncheckedCreateWithoutAssetsInput>>
    connectOrCreate?: Enumerable<transactionPoliciesCreateOrConnectWithoutAssetsInput>
    createMany?: transactionPoliciesCreateManyAssetsInputEnvelope
    connect?: Enumerable<transactionPoliciesWhereUniqueInput>
  }

  export type transactionsUncheckedCreateNestedManyWithoutAssetsInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutAssetsInput>, Enumerable<transactionsUncheckedCreateWithoutAssetsInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutAssetsInput>
    createMany?: transactionsCreateManyAssetsInputEnvelope
    connect?: Enumerable<transactionsWhereUniqueInput>
  }

  export type vaultAssetsUncheckedCreateNestedManyWithoutAssetsInput = {
    create?: XOR<Enumerable<vaultAssetsCreateWithoutAssetsInput>, Enumerable<vaultAssetsUncheckedCreateWithoutAssetsInput>>
    connectOrCreate?: Enumerable<vaultAssetsCreateOrConnectWithoutAssetsInput>
    createMany?: vaultAssetsCreateManyAssetsInputEnvelope
    connect?: Enumerable<vaultAssetsWhereUniqueInput>
  }

  export type vendorSupportsAssetsUncheckedCreateNestedManyWithoutAssetsInput = {
    create?: XOR<Enumerable<vendorSupportsAssetsCreateWithoutAssetsInput>, Enumerable<vendorSupportsAssetsUncheckedCreateWithoutAssetsInput>>
    connectOrCreate?: Enumerable<vendorSupportsAssetsCreateOrConnectWithoutAssetsInput>
    createMany?: vendorSupportsAssetsCreateManyAssetsInputEnvelope
    connect?: Enumerable<vendorSupportsAssetsWhereUniqueInput>
  }

  export type withdrawalAddressesUncheckedCreateNestedManyWithoutAssetsInput = {
    create?: XOR<Enumerable<withdrawalAddressesCreateWithoutAssetsInput>, Enumerable<withdrawalAddressesUncheckedCreateWithoutAssetsInput>>
    connectOrCreate?: Enumerable<withdrawalAddressesCreateOrConnectWithoutAssetsInput>
    createMany?: withdrawalAddressesCreateManyAssetsInputEnvelope
    connect?: Enumerable<withdrawalAddressesWhereUniqueInput>
  }

  export type Enumenum_assets_typeFieldUpdateOperationsInput = {
    set?: enum_assets_type
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type baseNetworksUpdateOneWithoutAssetsNestedInput = {
    create?: XOR<baseNetworksCreateWithoutAssetsInput, baseNetworksUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: baseNetworksCreateOrConnectWithoutAssetsInput
    upsert?: baseNetworksUpsertWithoutAssetsInput
    disconnect?: boolean
    delete?: boolean
    connect?: baseNetworksWhereUniqueInput
    update?: XOR<baseNetworksUpdateWithoutAssetsInput, baseNetworksUncheckedUpdateWithoutAssetsInput>
  }

  export type quotesUpdateManyWithoutAssets_quotes_sourceAssetIdToassetsNestedInput = {
    create?: XOR<Enumerable<quotesCreateWithoutAssets_quotes_sourceAssetIdToassetsInput>, Enumerable<quotesUncheckedCreateWithoutAssets_quotes_sourceAssetIdToassetsInput>>
    connectOrCreate?: Enumerable<quotesCreateOrConnectWithoutAssets_quotes_sourceAssetIdToassetsInput>
    upsert?: Enumerable<quotesUpsertWithWhereUniqueWithoutAssets_quotes_sourceAssetIdToassetsInput>
    createMany?: quotesCreateManyAssets_quotes_sourceAssetIdToassetsInputEnvelope
    set?: Enumerable<quotesWhereUniqueInput>
    disconnect?: Enumerable<quotesWhereUniqueInput>
    delete?: Enumerable<quotesWhereUniqueInput>
    connect?: Enumerable<quotesWhereUniqueInput>
    update?: Enumerable<quotesUpdateWithWhereUniqueWithoutAssets_quotes_sourceAssetIdToassetsInput>
    updateMany?: Enumerable<quotesUpdateManyWithWhereWithoutAssets_quotes_sourceAssetIdToassetsInput>
    deleteMany?: Enumerable<quotesScalarWhereInput>
  }

  export type quotesUpdateManyWithoutAssets_quotes_targetAssetIdToassetsNestedInput = {
    create?: XOR<Enumerable<quotesCreateWithoutAssets_quotes_targetAssetIdToassetsInput>, Enumerable<quotesUncheckedCreateWithoutAssets_quotes_targetAssetIdToassetsInput>>
    connectOrCreate?: Enumerable<quotesCreateOrConnectWithoutAssets_quotes_targetAssetIdToassetsInput>
    upsert?: Enumerable<quotesUpsertWithWhereUniqueWithoutAssets_quotes_targetAssetIdToassetsInput>
    createMany?: quotesCreateManyAssets_quotes_targetAssetIdToassetsInputEnvelope
    set?: Enumerable<quotesWhereUniqueInput>
    disconnect?: Enumerable<quotesWhereUniqueInput>
    delete?: Enumerable<quotesWhereUniqueInput>
    connect?: Enumerable<quotesWhereUniqueInput>
    update?: Enumerable<quotesUpdateWithWhereUniqueWithoutAssets_quotes_targetAssetIdToassetsInput>
    updateMany?: Enumerable<quotesUpdateManyWithWhereWithoutAssets_quotes_targetAssetIdToassetsInput>
    deleteMany?: Enumerable<quotesScalarWhereInput>
  }

  export type transactionPoliciesUpdateManyWithoutAssetsNestedInput = {
    create?: XOR<Enumerable<transactionPoliciesCreateWithoutAssetsInput>, Enumerable<transactionPoliciesUncheckedCreateWithoutAssetsInput>>
    connectOrCreate?: Enumerable<transactionPoliciesCreateOrConnectWithoutAssetsInput>
    upsert?: Enumerable<transactionPoliciesUpsertWithWhereUniqueWithoutAssetsInput>
    createMany?: transactionPoliciesCreateManyAssetsInputEnvelope
    set?: Enumerable<transactionPoliciesWhereUniqueInput>
    disconnect?: Enumerable<transactionPoliciesWhereUniqueInput>
    delete?: Enumerable<transactionPoliciesWhereUniqueInput>
    connect?: Enumerable<transactionPoliciesWhereUniqueInput>
    update?: Enumerable<transactionPoliciesUpdateWithWhereUniqueWithoutAssetsInput>
    updateMany?: Enumerable<transactionPoliciesUpdateManyWithWhereWithoutAssetsInput>
    deleteMany?: Enumerable<transactionPoliciesScalarWhereInput>
  }

  export type transactionsUpdateManyWithoutAssetsNestedInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutAssetsInput>, Enumerable<transactionsUncheckedCreateWithoutAssetsInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutAssetsInput>
    upsert?: Enumerable<transactionsUpsertWithWhereUniqueWithoutAssetsInput>
    createMany?: transactionsCreateManyAssetsInputEnvelope
    set?: Enumerable<transactionsWhereUniqueInput>
    disconnect?: Enumerable<transactionsWhereUniqueInput>
    delete?: Enumerable<transactionsWhereUniqueInput>
    connect?: Enumerable<transactionsWhereUniqueInput>
    update?: Enumerable<transactionsUpdateWithWhereUniqueWithoutAssetsInput>
    updateMany?: Enumerable<transactionsUpdateManyWithWhereWithoutAssetsInput>
    deleteMany?: Enumerable<transactionsScalarWhereInput>
  }

  export type vaultAssetsUpdateManyWithoutAssetsNestedInput = {
    create?: XOR<Enumerable<vaultAssetsCreateWithoutAssetsInput>, Enumerable<vaultAssetsUncheckedCreateWithoutAssetsInput>>
    connectOrCreate?: Enumerable<vaultAssetsCreateOrConnectWithoutAssetsInput>
    upsert?: Enumerable<vaultAssetsUpsertWithWhereUniqueWithoutAssetsInput>
    createMany?: vaultAssetsCreateManyAssetsInputEnvelope
    set?: Enumerable<vaultAssetsWhereUniqueInput>
    disconnect?: Enumerable<vaultAssetsWhereUniqueInput>
    delete?: Enumerable<vaultAssetsWhereUniqueInput>
    connect?: Enumerable<vaultAssetsWhereUniqueInput>
    update?: Enumerable<vaultAssetsUpdateWithWhereUniqueWithoutAssetsInput>
    updateMany?: Enumerable<vaultAssetsUpdateManyWithWhereWithoutAssetsInput>
    deleteMany?: Enumerable<vaultAssetsScalarWhereInput>
  }

  export type vendorSupportsAssetsUpdateManyWithoutAssetsNestedInput = {
    create?: XOR<Enumerable<vendorSupportsAssetsCreateWithoutAssetsInput>, Enumerable<vendorSupportsAssetsUncheckedCreateWithoutAssetsInput>>
    connectOrCreate?: Enumerable<vendorSupportsAssetsCreateOrConnectWithoutAssetsInput>
    upsert?: Enumerable<vendorSupportsAssetsUpsertWithWhereUniqueWithoutAssetsInput>
    createMany?: vendorSupportsAssetsCreateManyAssetsInputEnvelope
    set?: Enumerable<vendorSupportsAssetsWhereUniqueInput>
    disconnect?: Enumerable<vendorSupportsAssetsWhereUniqueInput>
    delete?: Enumerable<vendorSupportsAssetsWhereUniqueInput>
    connect?: Enumerable<vendorSupportsAssetsWhereUniqueInput>
    update?: Enumerable<vendorSupportsAssetsUpdateWithWhereUniqueWithoutAssetsInput>
    updateMany?: Enumerable<vendorSupportsAssetsUpdateManyWithWhereWithoutAssetsInput>
    deleteMany?: Enumerable<vendorSupportsAssetsScalarWhereInput>
  }

  export type withdrawalAddressesUpdateManyWithoutAssetsNestedInput = {
    create?: XOR<Enumerable<withdrawalAddressesCreateWithoutAssetsInput>, Enumerable<withdrawalAddressesUncheckedCreateWithoutAssetsInput>>
    connectOrCreate?: Enumerable<withdrawalAddressesCreateOrConnectWithoutAssetsInput>
    upsert?: Enumerable<withdrawalAddressesUpsertWithWhereUniqueWithoutAssetsInput>
    createMany?: withdrawalAddressesCreateManyAssetsInputEnvelope
    set?: Enumerable<withdrawalAddressesWhereUniqueInput>
    disconnect?: Enumerable<withdrawalAddressesWhereUniqueInput>
    delete?: Enumerable<withdrawalAddressesWhereUniqueInput>
    connect?: Enumerable<withdrawalAddressesWhereUniqueInput>
    update?: Enumerable<withdrawalAddressesUpdateWithWhereUniqueWithoutAssetsInput>
    updateMany?: Enumerable<withdrawalAddressesUpdateManyWithWhereWithoutAssetsInput>
    deleteMany?: Enumerable<withdrawalAddressesScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type quotesUncheckedUpdateManyWithoutAssets_quotes_sourceAssetIdToassetsNestedInput = {
    create?: XOR<Enumerable<quotesCreateWithoutAssets_quotes_sourceAssetIdToassetsInput>, Enumerable<quotesUncheckedCreateWithoutAssets_quotes_sourceAssetIdToassetsInput>>
    connectOrCreate?: Enumerable<quotesCreateOrConnectWithoutAssets_quotes_sourceAssetIdToassetsInput>
    upsert?: Enumerable<quotesUpsertWithWhereUniqueWithoutAssets_quotes_sourceAssetIdToassetsInput>
    createMany?: quotesCreateManyAssets_quotes_sourceAssetIdToassetsInputEnvelope
    set?: Enumerable<quotesWhereUniqueInput>
    disconnect?: Enumerable<quotesWhereUniqueInput>
    delete?: Enumerable<quotesWhereUniqueInput>
    connect?: Enumerable<quotesWhereUniqueInput>
    update?: Enumerable<quotesUpdateWithWhereUniqueWithoutAssets_quotes_sourceAssetIdToassetsInput>
    updateMany?: Enumerable<quotesUpdateManyWithWhereWithoutAssets_quotes_sourceAssetIdToassetsInput>
    deleteMany?: Enumerable<quotesScalarWhereInput>
  }

  export type quotesUncheckedUpdateManyWithoutAssets_quotes_targetAssetIdToassetsNestedInput = {
    create?: XOR<Enumerable<quotesCreateWithoutAssets_quotes_targetAssetIdToassetsInput>, Enumerable<quotesUncheckedCreateWithoutAssets_quotes_targetAssetIdToassetsInput>>
    connectOrCreate?: Enumerable<quotesCreateOrConnectWithoutAssets_quotes_targetAssetIdToassetsInput>
    upsert?: Enumerable<quotesUpsertWithWhereUniqueWithoutAssets_quotes_targetAssetIdToassetsInput>
    createMany?: quotesCreateManyAssets_quotes_targetAssetIdToassetsInputEnvelope
    set?: Enumerable<quotesWhereUniqueInput>
    disconnect?: Enumerable<quotesWhereUniqueInput>
    delete?: Enumerable<quotesWhereUniqueInput>
    connect?: Enumerable<quotesWhereUniqueInput>
    update?: Enumerable<quotesUpdateWithWhereUniqueWithoutAssets_quotes_targetAssetIdToassetsInput>
    updateMany?: Enumerable<quotesUpdateManyWithWhereWithoutAssets_quotes_targetAssetIdToassetsInput>
    deleteMany?: Enumerable<quotesScalarWhereInput>
  }

  export type transactionPoliciesUncheckedUpdateManyWithoutAssetsNestedInput = {
    create?: XOR<Enumerable<transactionPoliciesCreateWithoutAssetsInput>, Enumerable<transactionPoliciesUncheckedCreateWithoutAssetsInput>>
    connectOrCreate?: Enumerable<transactionPoliciesCreateOrConnectWithoutAssetsInput>
    upsert?: Enumerable<transactionPoliciesUpsertWithWhereUniqueWithoutAssetsInput>
    createMany?: transactionPoliciesCreateManyAssetsInputEnvelope
    set?: Enumerable<transactionPoliciesWhereUniqueInput>
    disconnect?: Enumerable<transactionPoliciesWhereUniqueInput>
    delete?: Enumerable<transactionPoliciesWhereUniqueInput>
    connect?: Enumerable<transactionPoliciesWhereUniqueInput>
    update?: Enumerable<transactionPoliciesUpdateWithWhereUniqueWithoutAssetsInput>
    updateMany?: Enumerable<transactionPoliciesUpdateManyWithWhereWithoutAssetsInput>
    deleteMany?: Enumerable<transactionPoliciesScalarWhereInput>
  }

  export type transactionsUncheckedUpdateManyWithoutAssetsNestedInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutAssetsInput>, Enumerable<transactionsUncheckedCreateWithoutAssetsInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutAssetsInput>
    upsert?: Enumerable<transactionsUpsertWithWhereUniqueWithoutAssetsInput>
    createMany?: transactionsCreateManyAssetsInputEnvelope
    set?: Enumerable<transactionsWhereUniqueInput>
    disconnect?: Enumerable<transactionsWhereUniqueInput>
    delete?: Enumerable<transactionsWhereUniqueInput>
    connect?: Enumerable<transactionsWhereUniqueInput>
    update?: Enumerable<transactionsUpdateWithWhereUniqueWithoutAssetsInput>
    updateMany?: Enumerable<transactionsUpdateManyWithWhereWithoutAssetsInput>
    deleteMany?: Enumerable<transactionsScalarWhereInput>
  }

  export type vaultAssetsUncheckedUpdateManyWithoutAssetsNestedInput = {
    create?: XOR<Enumerable<vaultAssetsCreateWithoutAssetsInput>, Enumerable<vaultAssetsUncheckedCreateWithoutAssetsInput>>
    connectOrCreate?: Enumerable<vaultAssetsCreateOrConnectWithoutAssetsInput>
    upsert?: Enumerable<vaultAssetsUpsertWithWhereUniqueWithoutAssetsInput>
    createMany?: vaultAssetsCreateManyAssetsInputEnvelope
    set?: Enumerable<vaultAssetsWhereUniqueInput>
    disconnect?: Enumerable<vaultAssetsWhereUniqueInput>
    delete?: Enumerable<vaultAssetsWhereUniqueInput>
    connect?: Enumerable<vaultAssetsWhereUniqueInput>
    update?: Enumerable<vaultAssetsUpdateWithWhereUniqueWithoutAssetsInput>
    updateMany?: Enumerable<vaultAssetsUpdateManyWithWhereWithoutAssetsInput>
    deleteMany?: Enumerable<vaultAssetsScalarWhereInput>
  }

  export type vendorSupportsAssetsUncheckedUpdateManyWithoutAssetsNestedInput = {
    create?: XOR<Enumerable<vendorSupportsAssetsCreateWithoutAssetsInput>, Enumerable<vendorSupportsAssetsUncheckedCreateWithoutAssetsInput>>
    connectOrCreate?: Enumerable<vendorSupportsAssetsCreateOrConnectWithoutAssetsInput>
    upsert?: Enumerable<vendorSupportsAssetsUpsertWithWhereUniqueWithoutAssetsInput>
    createMany?: vendorSupportsAssetsCreateManyAssetsInputEnvelope
    set?: Enumerable<vendorSupportsAssetsWhereUniqueInput>
    disconnect?: Enumerable<vendorSupportsAssetsWhereUniqueInput>
    delete?: Enumerable<vendorSupportsAssetsWhereUniqueInput>
    connect?: Enumerable<vendorSupportsAssetsWhereUniqueInput>
    update?: Enumerable<vendorSupportsAssetsUpdateWithWhereUniqueWithoutAssetsInput>
    updateMany?: Enumerable<vendorSupportsAssetsUpdateManyWithWhereWithoutAssetsInput>
    deleteMany?: Enumerable<vendorSupportsAssetsScalarWhereInput>
  }

  export type withdrawalAddressesUncheckedUpdateManyWithoutAssetsNestedInput = {
    create?: XOR<Enumerable<withdrawalAddressesCreateWithoutAssetsInput>, Enumerable<withdrawalAddressesUncheckedCreateWithoutAssetsInput>>
    connectOrCreate?: Enumerable<withdrawalAddressesCreateOrConnectWithoutAssetsInput>
    upsert?: Enumerable<withdrawalAddressesUpsertWithWhereUniqueWithoutAssetsInput>
    createMany?: withdrawalAddressesCreateManyAssetsInputEnvelope
    set?: Enumerable<withdrawalAddressesWhereUniqueInput>
    disconnect?: Enumerable<withdrawalAddressesWhereUniqueInput>
    delete?: Enumerable<withdrawalAddressesWhereUniqueInput>
    connect?: Enumerable<withdrawalAddressesWhereUniqueInput>
    update?: Enumerable<withdrawalAddressesUpdateWithWhereUniqueWithoutAssetsInput>
    updateMany?: Enumerable<withdrawalAddressesUpdateManyWithWhereWithoutAssetsInput>
    deleteMany?: Enumerable<withdrawalAddressesScalarWhereInput>
  }

  export type assetsCreateNestedManyWithoutBaseNetworksInput = {
    create?: XOR<Enumerable<assetsCreateWithoutBaseNetworksInput>, Enumerable<assetsUncheckedCreateWithoutBaseNetworksInput>>
    connectOrCreate?: Enumerable<assetsCreateOrConnectWithoutBaseNetworksInput>
    createMany?: assetsCreateManyBaseNetworksInputEnvelope
    connect?: Enumerable<assetsWhereUniqueInput>
  }

  export type assetsUncheckedCreateNestedManyWithoutBaseNetworksInput = {
    create?: XOR<Enumerable<assetsCreateWithoutBaseNetworksInput>, Enumerable<assetsUncheckedCreateWithoutBaseNetworksInput>>
    connectOrCreate?: Enumerable<assetsCreateOrConnectWithoutBaseNetworksInput>
    createMany?: assetsCreateManyBaseNetworksInputEnvelope
    connect?: Enumerable<assetsWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type assetsUpdateManyWithoutBaseNetworksNestedInput = {
    create?: XOR<Enumerable<assetsCreateWithoutBaseNetworksInput>, Enumerable<assetsUncheckedCreateWithoutBaseNetworksInput>>
    connectOrCreate?: Enumerable<assetsCreateOrConnectWithoutBaseNetworksInput>
    upsert?: Enumerable<assetsUpsertWithWhereUniqueWithoutBaseNetworksInput>
    createMany?: assetsCreateManyBaseNetworksInputEnvelope
    set?: Enumerable<assetsWhereUniqueInput>
    disconnect?: Enumerable<assetsWhereUniqueInput>
    delete?: Enumerable<assetsWhereUniqueInput>
    connect?: Enumerable<assetsWhereUniqueInput>
    update?: Enumerable<assetsUpdateWithWhereUniqueWithoutBaseNetworksInput>
    updateMany?: Enumerable<assetsUpdateManyWithWhereWithoutBaseNetworksInput>
    deleteMany?: Enumerable<assetsScalarWhereInput>
  }

  export type assetsUncheckedUpdateManyWithoutBaseNetworksNestedInput = {
    create?: XOR<Enumerable<assetsCreateWithoutBaseNetworksInput>, Enumerable<assetsUncheckedCreateWithoutBaseNetworksInput>>
    connectOrCreate?: Enumerable<assetsCreateOrConnectWithoutBaseNetworksInput>
    upsert?: Enumerable<assetsUpsertWithWhereUniqueWithoutBaseNetworksInput>
    createMany?: assetsCreateManyBaseNetworksInputEnvelope
    set?: Enumerable<assetsWhereUniqueInput>
    disconnect?: Enumerable<assetsWhereUniqueInput>
    delete?: Enumerable<assetsWhereUniqueInput>
    connect?: Enumerable<assetsWhereUniqueInput>
    update?: Enumerable<assetsUpdateWithWhereUniqueWithoutBaseNetworksInput>
    updateMany?: Enumerable<assetsUpdateManyWithWhereWithoutBaseNetworksInput>
    deleteMany?: Enumerable<assetsScalarWhereInput>
  }

  export type ordersCreateNestedManyWithoutQuotesInput = {
    create?: XOR<Enumerable<ordersCreateWithoutQuotesInput>, Enumerable<ordersUncheckedCreateWithoutQuotesInput>>
    connectOrCreate?: Enumerable<ordersCreateOrConnectWithoutQuotesInput>
    createMany?: ordersCreateManyQuotesInputEnvelope
    connect?: Enumerable<ordersWhereUniqueInput>
  }

  export type tokenPairsInfoCreateNestedOneWithoutQuotesInput = {
    create?: XOR<tokenPairsInfoCreateWithoutQuotesInput, tokenPairsInfoUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: tokenPairsInfoCreateOrConnectWithoutQuotesInput
    connect?: tokenPairsInfoWhereUniqueInput
  }

  export type quoteStatusesCreateNestedOneWithoutQuotesInput = {
    create?: XOR<quoteStatusesCreateWithoutQuotesInput, quoteStatusesUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: quoteStatusesCreateOrConnectWithoutQuotesInput
    connect?: quoteStatusesWhereUniqueInput
  }

  export type assetsCreateNestedOneWithoutQuotes_quotes_sourceAssetIdToassetsInput = {
    create?: XOR<assetsCreateWithoutQuotes_quotes_sourceAssetIdToassetsInput, assetsUncheckedCreateWithoutQuotes_quotes_sourceAssetIdToassetsInput>
    connectOrCreate?: assetsCreateOrConnectWithoutQuotes_quotes_sourceAssetIdToassetsInput
    connect?: assetsWhereUniqueInput
  }

  export type assetsCreateNestedOneWithoutQuotes_quotes_targetAssetIdToassetsInput = {
    create?: XOR<assetsCreateWithoutQuotes_quotes_targetAssetIdToassetsInput, assetsUncheckedCreateWithoutQuotes_quotes_targetAssetIdToassetsInput>
    connectOrCreate?: assetsCreateOrConnectWithoutQuotes_quotes_targetAssetIdToassetsInput
    connect?: assetsWhereUniqueInput
  }

  export type vendorsCreateNestedOneWithoutQuotesInput = {
    create?: XOR<vendorsCreateWithoutQuotesInput, vendorsUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: vendorsCreateOrConnectWithoutQuotesInput
    connect?: vendorsWhereUniqueInput
  }

  export type ordersUncheckedCreateNestedManyWithoutQuotesInput = {
    create?: XOR<Enumerable<ordersCreateWithoutQuotesInput>, Enumerable<ordersUncheckedCreateWithoutQuotesInput>>
    connectOrCreate?: Enumerable<ordersCreateOrConnectWithoutQuotesInput>
    createMany?: ordersCreateManyQuotesInputEnvelope
    connect?: Enumerable<ordersWhereUniqueInput>
  }

  export type Enumenum_quotes_sideFieldUpdateOperationsInput = {
    set?: enum_quotes_side
  }

  export type ordersUpdateManyWithoutQuotesNestedInput = {
    create?: XOR<Enumerable<ordersCreateWithoutQuotesInput>, Enumerable<ordersUncheckedCreateWithoutQuotesInput>>
    connectOrCreate?: Enumerable<ordersCreateOrConnectWithoutQuotesInput>
    upsert?: Enumerable<ordersUpsertWithWhereUniqueWithoutQuotesInput>
    createMany?: ordersCreateManyQuotesInputEnvelope
    set?: Enumerable<ordersWhereUniqueInput>
    disconnect?: Enumerable<ordersWhereUniqueInput>
    delete?: Enumerable<ordersWhereUniqueInput>
    connect?: Enumerable<ordersWhereUniqueInput>
    update?: Enumerable<ordersUpdateWithWhereUniqueWithoutQuotesInput>
    updateMany?: Enumerable<ordersUpdateManyWithWhereWithoutQuotesInput>
    deleteMany?: Enumerable<ordersScalarWhereInput>
  }

  export type tokenPairsInfoUpdateOneWithoutQuotesNestedInput = {
    create?: XOR<tokenPairsInfoCreateWithoutQuotesInput, tokenPairsInfoUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: tokenPairsInfoCreateOrConnectWithoutQuotesInput
    upsert?: tokenPairsInfoUpsertWithoutQuotesInput
    disconnect?: boolean
    delete?: boolean
    connect?: tokenPairsInfoWhereUniqueInput
    update?: XOR<tokenPairsInfoUpdateWithoutQuotesInput, tokenPairsInfoUncheckedUpdateWithoutQuotesInput>
  }

  export type quoteStatusesUpdateOneRequiredWithoutQuotesNestedInput = {
    create?: XOR<quoteStatusesCreateWithoutQuotesInput, quoteStatusesUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: quoteStatusesCreateOrConnectWithoutQuotesInput
    upsert?: quoteStatusesUpsertWithoutQuotesInput
    connect?: quoteStatusesWhereUniqueInput
    update?: XOR<quoteStatusesUpdateWithoutQuotesInput, quoteStatusesUncheckedUpdateWithoutQuotesInput>
  }

  export type assetsUpdateOneRequiredWithoutQuotes_quotes_sourceAssetIdToassetsNestedInput = {
    create?: XOR<assetsCreateWithoutQuotes_quotes_sourceAssetIdToassetsInput, assetsUncheckedCreateWithoutQuotes_quotes_sourceAssetIdToassetsInput>
    connectOrCreate?: assetsCreateOrConnectWithoutQuotes_quotes_sourceAssetIdToassetsInput
    upsert?: assetsUpsertWithoutQuotes_quotes_sourceAssetIdToassetsInput
    connect?: assetsWhereUniqueInput
    update?: XOR<assetsUpdateWithoutQuotes_quotes_sourceAssetIdToassetsInput, assetsUncheckedUpdateWithoutQuotes_quotes_sourceAssetIdToassetsInput>
  }

  export type assetsUpdateOneRequiredWithoutQuotes_quotes_targetAssetIdToassetsNestedInput = {
    create?: XOR<assetsCreateWithoutQuotes_quotes_targetAssetIdToassetsInput, assetsUncheckedCreateWithoutQuotes_quotes_targetAssetIdToassetsInput>
    connectOrCreate?: assetsCreateOrConnectWithoutQuotes_quotes_targetAssetIdToassetsInput
    upsert?: assetsUpsertWithoutQuotes_quotes_targetAssetIdToassetsInput
    connect?: assetsWhereUniqueInput
    update?: XOR<assetsUpdateWithoutQuotes_quotes_targetAssetIdToassetsInput, assetsUncheckedUpdateWithoutQuotes_quotes_targetAssetIdToassetsInput>
  }

  export type vendorsUpdateOneWithoutQuotesNestedInput = {
    create?: XOR<vendorsCreateWithoutQuotesInput, vendorsUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: vendorsCreateOrConnectWithoutQuotesInput
    upsert?: vendorsUpsertWithoutQuotesInput
    disconnect?: boolean
    delete?: boolean
    connect?: vendorsWhereUniqueInput
    update?: XOR<vendorsUpdateWithoutQuotesInput, vendorsUncheckedUpdateWithoutQuotesInput>
  }

  export type ordersUncheckedUpdateManyWithoutQuotesNestedInput = {
    create?: XOR<Enumerable<ordersCreateWithoutQuotesInput>, Enumerable<ordersUncheckedCreateWithoutQuotesInput>>
    connectOrCreate?: Enumerable<ordersCreateOrConnectWithoutQuotesInput>
    upsert?: Enumerable<ordersUpsertWithWhereUniqueWithoutQuotesInput>
    createMany?: ordersCreateManyQuotesInputEnvelope
    set?: Enumerable<ordersWhereUniqueInput>
    disconnect?: Enumerable<ordersWhereUniqueInput>
    delete?: Enumerable<ordersWhereUniqueInput>
    connect?: Enumerable<ordersWhereUniqueInput>
    update?: Enumerable<ordersUpdateWithWhereUniqueWithoutQuotesInput>
    updateMany?: Enumerable<ordersUpdateManyWithWhereWithoutQuotesInput>
    deleteMany?: Enumerable<ordersScalarWhereInput>
  }

  export type transactionsCreateNestedManyWithoutTransactionStatusTypesInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutTransactionStatusTypesInput>, Enumerable<transactionsUncheckedCreateWithoutTransactionStatusTypesInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutTransactionStatusTypesInput>
    createMany?: transactionsCreateManyTransactionStatusTypesInputEnvelope
    connect?: Enumerable<transactionsWhereUniqueInput>
  }

  export type transactionsUncheckedCreateNestedManyWithoutTransactionStatusTypesInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutTransactionStatusTypesInput>, Enumerable<transactionsUncheckedCreateWithoutTransactionStatusTypesInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutTransactionStatusTypesInput>
    createMany?: transactionsCreateManyTransactionStatusTypesInputEnvelope
    connect?: Enumerable<transactionsWhereUniqueInput>
  }

  export type transactionsUpdateManyWithoutTransactionStatusTypesNestedInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutTransactionStatusTypesInput>, Enumerable<transactionsUncheckedCreateWithoutTransactionStatusTypesInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutTransactionStatusTypesInput>
    upsert?: Enumerable<transactionsUpsertWithWhereUniqueWithoutTransactionStatusTypesInput>
    createMany?: transactionsCreateManyTransactionStatusTypesInputEnvelope
    set?: Enumerable<transactionsWhereUniqueInput>
    disconnect?: Enumerable<transactionsWhereUniqueInput>
    delete?: Enumerable<transactionsWhereUniqueInput>
    connect?: Enumerable<transactionsWhereUniqueInput>
    update?: Enumerable<transactionsUpdateWithWhereUniqueWithoutTransactionStatusTypesInput>
    updateMany?: Enumerable<transactionsUpdateManyWithWhereWithoutTransactionStatusTypesInput>
    deleteMany?: Enumerable<transactionsScalarWhereInput>
  }

  export type transactionsUncheckedUpdateManyWithoutTransactionStatusTypesNestedInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutTransactionStatusTypesInput>, Enumerable<transactionsUncheckedCreateWithoutTransactionStatusTypesInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutTransactionStatusTypesInput>
    upsert?: Enumerable<transactionsUpsertWithWhereUniqueWithoutTransactionStatusTypesInput>
    createMany?: transactionsCreateManyTransactionStatusTypesInputEnvelope
    set?: Enumerable<transactionsWhereUniqueInput>
    disconnect?: Enumerable<transactionsWhereUniqueInput>
    delete?: Enumerable<transactionsWhereUniqueInput>
    connect?: Enumerable<transactionsWhereUniqueInput>
    update?: Enumerable<transactionsUpdateWithWhereUniqueWithoutTransactionStatusTypesInput>
    updateMany?: Enumerable<transactionsUpdateManyWithWhereWithoutTransactionStatusTypesInput>
    deleteMany?: Enumerable<transactionsScalarWhereInput>
  }

  export type transactionPoliciesCreateNestedManyWithoutTransactionTypesInput = {
    create?: XOR<Enumerable<transactionPoliciesCreateWithoutTransactionTypesInput>, Enumerable<transactionPoliciesUncheckedCreateWithoutTransactionTypesInput>>
    connectOrCreate?: Enumerable<transactionPoliciesCreateOrConnectWithoutTransactionTypesInput>
    createMany?: transactionPoliciesCreateManyTransactionTypesInputEnvelope
    connect?: Enumerable<transactionPoliciesWhereUniqueInput>
  }

  export type transactionsCreateNestedManyWithoutTransactionTypesInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutTransactionTypesInput>, Enumerable<transactionsUncheckedCreateWithoutTransactionTypesInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutTransactionTypesInput>
    createMany?: transactionsCreateManyTransactionTypesInputEnvelope
    connect?: Enumerable<transactionsWhereUniqueInput>
  }

  export type transactionPoliciesUncheckedCreateNestedManyWithoutTransactionTypesInput = {
    create?: XOR<Enumerable<transactionPoliciesCreateWithoutTransactionTypesInput>, Enumerable<transactionPoliciesUncheckedCreateWithoutTransactionTypesInput>>
    connectOrCreate?: Enumerable<transactionPoliciesCreateOrConnectWithoutTransactionTypesInput>
    createMany?: transactionPoliciesCreateManyTransactionTypesInputEnvelope
    connect?: Enumerable<transactionPoliciesWhereUniqueInput>
  }

  export type transactionsUncheckedCreateNestedManyWithoutTransactionTypesInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutTransactionTypesInput>, Enumerable<transactionsUncheckedCreateWithoutTransactionTypesInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutTransactionTypesInput>
    createMany?: transactionsCreateManyTransactionTypesInputEnvelope
    connect?: Enumerable<transactionsWhereUniqueInput>
  }

  export type transactionPoliciesUpdateManyWithoutTransactionTypesNestedInput = {
    create?: XOR<Enumerable<transactionPoliciesCreateWithoutTransactionTypesInput>, Enumerable<transactionPoliciesUncheckedCreateWithoutTransactionTypesInput>>
    connectOrCreate?: Enumerable<transactionPoliciesCreateOrConnectWithoutTransactionTypesInput>
    upsert?: Enumerable<transactionPoliciesUpsertWithWhereUniqueWithoutTransactionTypesInput>
    createMany?: transactionPoliciesCreateManyTransactionTypesInputEnvelope
    set?: Enumerable<transactionPoliciesWhereUniqueInput>
    disconnect?: Enumerable<transactionPoliciesWhereUniqueInput>
    delete?: Enumerable<transactionPoliciesWhereUniqueInput>
    connect?: Enumerable<transactionPoliciesWhereUniqueInput>
    update?: Enumerable<transactionPoliciesUpdateWithWhereUniqueWithoutTransactionTypesInput>
    updateMany?: Enumerable<transactionPoliciesUpdateManyWithWhereWithoutTransactionTypesInput>
    deleteMany?: Enumerable<transactionPoliciesScalarWhereInput>
  }

  export type transactionsUpdateManyWithoutTransactionTypesNestedInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutTransactionTypesInput>, Enumerable<transactionsUncheckedCreateWithoutTransactionTypesInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutTransactionTypesInput>
    upsert?: Enumerable<transactionsUpsertWithWhereUniqueWithoutTransactionTypesInput>
    createMany?: transactionsCreateManyTransactionTypesInputEnvelope
    set?: Enumerable<transactionsWhereUniqueInput>
    disconnect?: Enumerable<transactionsWhereUniqueInput>
    delete?: Enumerable<transactionsWhereUniqueInput>
    connect?: Enumerable<transactionsWhereUniqueInput>
    update?: Enumerable<transactionsUpdateWithWhereUniqueWithoutTransactionTypesInput>
    updateMany?: Enumerable<transactionsUpdateManyWithWhereWithoutTransactionTypesInput>
    deleteMany?: Enumerable<transactionsScalarWhereInput>
  }

  export type transactionPoliciesUncheckedUpdateManyWithoutTransactionTypesNestedInput = {
    create?: XOR<Enumerable<transactionPoliciesCreateWithoutTransactionTypesInput>, Enumerable<transactionPoliciesUncheckedCreateWithoutTransactionTypesInput>>
    connectOrCreate?: Enumerable<transactionPoliciesCreateOrConnectWithoutTransactionTypesInput>
    upsert?: Enumerable<transactionPoliciesUpsertWithWhereUniqueWithoutTransactionTypesInput>
    createMany?: transactionPoliciesCreateManyTransactionTypesInputEnvelope
    set?: Enumerable<transactionPoliciesWhereUniqueInput>
    disconnect?: Enumerable<transactionPoliciesWhereUniqueInput>
    delete?: Enumerable<transactionPoliciesWhereUniqueInput>
    connect?: Enumerable<transactionPoliciesWhereUniqueInput>
    update?: Enumerable<transactionPoliciesUpdateWithWhereUniqueWithoutTransactionTypesInput>
    updateMany?: Enumerable<transactionPoliciesUpdateManyWithWhereWithoutTransactionTypesInput>
    deleteMany?: Enumerable<transactionPoliciesScalarWhereInput>
  }

  export type transactionsUncheckedUpdateManyWithoutTransactionTypesNestedInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutTransactionTypesInput>, Enumerable<transactionsUncheckedCreateWithoutTransactionTypesInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutTransactionTypesInput>
    upsert?: Enumerable<transactionsUpsertWithWhereUniqueWithoutTransactionTypesInput>
    createMany?: transactionsCreateManyTransactionTypesInputEnvelope
    set?: Enumerable<transactionsWhereUniqueInput>
    disconnect?: Enumerable<transactionsWhereUniqueInput>
    delete?: Enumerable<transactionsWhereUniqueInput>
    connect?: Enumerable<transactionsWhereUniqueInput>
    update?: Enumerable<transactionsUpdateWithWhereUniqueWithoutTransactionTypesInput>
    updateMany?: Enumerable<transactionsUpdateManyWithWhereWithoutTransactionTypesInput>
    deleteMany?: Enumerable<transactionsScalarWhereInput>
  }

  export type assetsCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<assetsCreateWithoutTransactionsInput, assetsUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: assetsCreateOrConnectWithoutTransactionsInput
    connect?: assetsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<usersCreateWithoutTransactionsInput, usersUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutTransactionsInput
    connect?: usersWhereUniqueInput
  }

  export type vendorsCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<vendorsCreateWithoutTransactionsInput, vendorsUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: vendorsCreateOrConnectWithoutTransactionsInput
    connect?: vendorsWhereUniqueInput
  }

  export type vaultsCreateNestedOneWithoutTransactions_transactions_sourceVaultIdTovaultsInput = {
    create?: XOR<vaultsCreateWithoutTransactions_transactions_sourceVaultIdTovaultsInput, vaultsUncheckedCreateWithoutTransactions_transactions_sourceVaultIdTovaultsInput>
    connectOrCreate?: vaultsCreateOrConnectWithoutTransactions_transactions_sourceVaultIdTovaultsInput
    connect?: vaultsWhereUniqueInput
  }

  export type vaultsCreateNestedOneWithoutTransactions_transactions_targetVaultIdTovaultsInput = {
    create?: XOR<vaultsCreateWithoutTransactions_transactions_targetVaultIdTovaultsInput, vaultsUncheckedCreateWithoutTransactions_transactions_targetVaultIdTovaultsInput>
    connectOrCreate?: vaultsCreateOrConnectWithoutTransactions_transactions_targetVaultIdTovaultsInput
    connect?: vaultsWhereUniqueInput
  }

  export type withdrawalAddressesCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<withdrawalAddressesCreateWithoutTransactionsInput, withdrawalAddressesUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: withdrawalAddressesCreateOrConnectWithoutTransactionsInput
    connect?: withdrawalAddressesWhereUniqueInput
  }

  export type transactionStatusTypesCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<transactionStatusTypesCreateWithoutTransactionsInput, transactionStatusTypesUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: transactionStatusTypesCreateOrConnectWithoutTransactionsInput
    connect?: transactionStatusTypesWhereUniqueInput
  }

  export type transactionTypesCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<transactionTypesCreateWithoutTransactionsInput, transactionTypesUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: transactionTypesCreateOrConnectWithoutTransactionsInput
    connect?: transactionTypesWhereUniqueInput
  }

  export type assetsUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<assetsCreateWithoutTransactionsInput, assetsUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: assetsCreateOrConnectWithoutTransactionsInput
    upsert?: assetsUpsertWithoutTransactionsInput
    connect?: assetsWhereUniqueInput
    update?: XOR<assetsUpdateWithoutTransactionsInput, assetsUncheckedUpdateWithoutTransactionsInput>
  }

  export type usersUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<usersCreateWithoutTransactionsInput, usersUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutTransactionsInput
    upsert?: usersUpsertWithoutTransactionsInput
    disconnect?: boolean
    delete?: boolean
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutTransactionsInput, usersUncheckedUpdateWithoutTransactionsInput>
  }

  export type vendorsUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<vendorsCreateWithoutTransactionsInput, vendorsUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: vendorsCreateOrConnectWithoutTransactionsInput
    upsert?: vendorsUpsertWithoutTransactionsInput
    connect?: vendorsWhereUniqueInput
    update?: XOR<vendorsUpdateWithoutTransactionsInput, vendorsUncheckedUpdateWithoutTransactionsInput>
  }

  export type vaultsUpdateOneWithoutTransactions_transactions_sourceVaultIdTovaultsNestedInput = {
    create?: XOR<vaultsCreateWithoutTransactions_transactions_sourceVaultIdTovaultsInput, vaultsUncheckedCreateWithoutTransactions_transactions_sourceVaultIdTovaultsInput>
    connectOrCreate?: vaultsCreateOrConnectWithoutTransactions_transactions_sourceVaultIdTovaultsInput
    upsert?: vaultsUpsertWithoutTransactions_transactions_sourceVaultIdTovaultsInput
    disconnect?: boolean
    delete?: boolean
    connect?: vaultsWhereUniqueInput
    update?: XOR<vaultsUpdateWithoutTransactions_transactions_sourceVaultIdTovaultsInput, vaultsUncheckedUpdateWithoutTransactions_transactions_sourceVaultIdTovaultsInput>
  }

  export type vaultsUpdateOneWithoutTransactions_transactions_targetVaultIdTovaultsNestedInput = {
    create?: XOR<vaultsCreateWithoutTransactions_transactions_targetVaultIdTovaultsInput, vaultsUncheckedCreateWithoutTransactions_transactions_targetVaultIdTovaultsInput>
    connectOrCreate?: vaultsCreateOrConnectWithoutTransactions_transactions_targetVaultIdTovaultsInput
    upsert?: vaultsUpsertWithoutTransactions_transactions_targetVaultIdTovaultsInput
    disconnect?: boolean
    delete?: boolean
    connect?: vaultsWhereUniqueInput
    update?: XOR<vaultsUpdateWithoutTransactions_transactions_targetVaultIdTovaultsInput, vaultsUncheckedUpdateWithoutTransactions_transactions_targetVaultIdTovaultsInput>
  }

  export type withdrawalAddressesUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<withdrawalAddressesCreateWithoutTransactionsInput, withdrawalAddressesUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: withdrawalAddressesCreateOrConnectWithoutTransactionsInput
    upsert?: withdrawalAddressesUpsertWithoutTransactionsInput
    disconnect?: boolean
    delete?: boolean
    connect?: withdrawalAddressesWhereUniqueInput
    update?: XOR<withdrawalAddressesUpdateWithoutTransactionsInput, withdrawalAddressesUncheckedUpdateWithoutTransactionsInput>
  }

  export type transactionStatusTypesUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<transactionStatusTypesCreateWithoutTransactionsInput, transactionStatusTypesUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: transactionStatusTypesCreateOrConnectWithoutTransactionsInput
    upsert?: transactionStatusTypesUpsertWithoutTransactionsInput
    connect?: transactionStatusTypesWhereUniqueInput
    update?: XOR<transactionStatusTypesUpdateWithoutTransactionsInput, transactionStatusTypesUncheckedUpdateWithoutTransactionsInput>
  }

  export type transactionTypesUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<transactionTypesCreateWithoutTransactionsInput, transactionTypesUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: transactionTypesCreateOrConnectWithoutTransactionsInput
    upsert?: transactionTypesUpsertWithoutTransactionsInput
    connect?: transactionTypesWhereUniqueInput
    update?: XOR<transactionTypesUpdateWithoutTransactionsInput, transactionTypesUncheckedUpdateWithoutTransactionsInput>
  }

  export type transactionPoliciesCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<transactionPoliciesCreateWithoutUsersInput>, Enumerable<transactionPoliciesUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<transactionPoliciesCreateOrConnectWithoutUsersInput>
    createMany?: transactionPoliciesCreateManyUsersInputEnvelope
    connect?: Enumerable<transactionPoliciesWhereUniqueInput>
  }

  export type transactionsCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutUsersInput>, Enumerable<transactionsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutUsersInput>
    createMany?: transactionsCreateManyUsersInputEnvelope
    connect?: Enumerable<transactionsWhereUniqueInput>
  }

  export type organizationsCreateNestedOneWithoutUsersInput = {
    create?: XOR<organizationsCreateWithoutUsersInput, organizationsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutUsersInput
    connect?: organizationsWhereUniqueInput
  }

  export type userTypesCreateNestedOneWithoutUsersInput = {
    create?: XOR<userTypesCreateWithoutUsersInput, userTypesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: userTypesCreateOrConnectWithoutUsersInput
    connect?: userTypesWhereUniqueInput
  }

  export type vaultsCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<vaultsCreateWithoutUsersInput>, Enumerable<vaultsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<vaultsCreateOrConnectWithoutUsersInput>
    createMany?: vaultsCreateManyUsersInputEnvelope
    connect?: Enumerable<vaultsWhereUniqueInput>
  }

  export type transactionPoliciesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<transactionPoliciesCreateWithoutUsersInput>, Enumerable<transactionPoliciesUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<transactionPoliciesCreateOrConnectWithoutUsersInput>
    createMany?: transactionPoliciesCreateManyUsersInputEnvelope
    connect?: Enumerable<transactionPoliciesWhereUniqueInput>
  }

  export type transactionsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutUsersInput>, Enumerable<transactionsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutUsersInput>
    createMany?: transactionsCreateManyUsersInputEnvelope
    connect?: Enumerable<transactionsWhereUniqueInput>
  }

  export type vaultsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<vaultsCreateWithoutUsersInput>, Enumerable<vaultsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<vaultsCreateOrConnectWithoutUsersInput>
    createMany?: vaultsCreateManyUsersInputEnvelope
    connect?: Enumerable<vaultsWhereUniqueInput>
  }

  export type transactionPoliciesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<transactionPoliciesCreateWithoutUsersInput>, Enumerable<transactionPoliciesUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<transactionPoliciesCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<transactionPoliciesUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: transactionPoliciesCreateManyUsersInputEnvelope
    set?: Enumerable<transactionPoliciesWhereUniqueInput>
    disconnect?: Enumerable<transactionPoliciesWhereUniqueInput>
    delete?: Enumerable<transactionPoliciesWhereUniqueInput>
    connect?: Enumerable<transactionPoliciesWhereUniqueInput>
    update?: Enumerable<transactionPoliciesUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<transactionPoliciesUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<transactionPoliciesScalarWhereInput>
  }

  export type transactionsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutUsersInput>, Enumerable<transactionsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<transactionsUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: transactionsCreateManyUsersInputEnvelope
    set?: Enumerable<transactionsWhereUniqueInput>
    disconnect?: Enumerable<transactionsWhereUniqueInput>
    delete?: Enumerable<transactionsWhereUniqueInput>
    connect?: Enumerable<transactionsWhereUniqueInput>
    update?: Enumerable<transactionsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<transactionsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<transactionsScalarWhereInput>
  }

  export type organizationsUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<organizationsCreateWithoutUsersInput, organizationsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutUsersInput
    upsert?: organizationsUpsertWithoutUsersInput
    connect?: organizationsWhereUniqueInput
    update?: XOR<organizationsUpdateWithoutUsersInput, organizationsUncheckedUpdateWithoutUsersInput>
  }

  export type userTypesUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<userTypesCreateWithoutUsersInput, userTypesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: userTypesCreateOrConnectWithoutUsersInput
    upsert?: userTypesUpsertWithoutUsersInput
    connect?: userTypesWhereUniqueInput
    update?: XOR<userTypesUpdateWithoutUsersInput, userTypesUncheckedUpdateWithoutUsersInput>
  }

  export type vaultsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<vaultsCreateWithoutUsersInput>, Enumerable<vaultsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<vaultsCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<vaultsUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: vaultsCreateManyUsersInputEnvelope
    set?: Enumerable<vaultsWhereUniqueInput>
    disconnect?: Enumerable<vaultsWhereUniqueInput>
    delete?: Enumerable<vaultsWhereUniqueInput>
    connect?: Enumerable<vaultsWhereUniqueInput>
    update?: Enumerable<vaultsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<vaultsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<vaultsScalarWhereInput>
  }

  export type transactionPoliciesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<transactionPoliciesCreateWithoutUsersInput>, Enumerable<transactionPoliciesUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<transactionPoliciesCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<transactionPoliciesUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: transactionPoliciesCreateManyUsersInputEnvelope
    set?: Enumerable<transactionPoliciesWhereUniqueInput>
    disconnect?: Enumerable<transactionPoliciesWhereUniqueInput>
    delete?: Enumerable<transactionPoliciesWhereUniqueInput>
    connect?: Enumerable<transactionPoliciesWhereUniqueInput>
    update?: Enumerable<transactionPoliciesUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<transactionPoliciesUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<transactionPoliciesScalarWhereInput>
  }

  export type transactionsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutUsersInput>, Enumerable<transactionsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<transactionsUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: transactionsCreateManyUsersInputEnvelope
    set?: Enumerable<transactionsWhereUniqueInput>
    disconnect?: Enumerable<transactionsWhereUniqueInput>
    delete?: Enumerable<transactionsWhereUniqueInput>
    connect?: Enumerable<transactionsWhereUniqueInput>
    update?: Enumerable<transactionsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<transactionsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<transactionsScalarWhereInput>
  }

  export type vaultsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<vaultsCreateWithoutUsersInput>, Enumerable<vaultsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<vaultsCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<vaultsUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: vaultsCreateManyUsersInputEnvelope
    set?: Enumerable<vaultsWhereUniqueInput>
    disconnect?: Enumerable<vaultsWhereUniqueInput>
    delete?: Enumerable<vaultsWhereUniqueInput>
    connect?: Enumerable<vaultsWhereUniqueInput>
    update?: Enumerable<vaultsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<vaultsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<vaultsScalarWhereInput>
  }

  export type vendorsCreateNestedManyWithoutVendorTypesInput = {
    create?: XOR<Enumerable<vendorsCreateWithoutVendorTypesInput>, Enumerable<vendorsUncheckedCreateWithoutVendorTypesInput>>
    connectOrCreate?: Enumerable<vendorsCreateOrConnectWithoutVendorTypesInput>
    createMany?: vendorsCreateManyVendorTypesInputEnvelope
    connect?: Enumerable<vendorsWhereUniqueInput>
  }

  export type vendorsUncheckedCreateNestedManyWithoutVendorTypesInput = {
    create?: XOR<Enumerable<vendorsCreateWithoutVendorTypesInput>, Enumerable<vendorsUncheckedCreateWithoutVendorTypesInput>>
    connectOrCreate?: Enumerable<vendorsCreateOrConnectWithoutVendorTypesInput>
    createMany?: vendorsCreateManyVendorTypesInputEnvelope
    connect?: Enumerable<vendorsWhereUniqueInput>
  }

  export type vendorsUpdateManyWithoutVendorTypesNestedInput = {
    create?: XOR<Enumerable<vendorsCreateWithoutVendorTypesInput>, Enumerable<vendorsUncheckedCreateWithoutVendorTypesInput>>
    connectOrCreate?: Enumerable<vendorsCreateOrConnectWithoutVendorTypesInput>
    upsert?: Enumerable<vendorsUpsertWithWhereUniqueWithoutVendorTypesInput>
    createMany?: vendorsCreateManyVendorTypesInputEnvelope
    set?: Enumerable<vendorsWhereUniqueInput>
    disconnect?: Enumerable<vendorsWhereUniqueInput>
    delete?: Enumerable<vendorsWhereUniqueInput>
    connect?: Enumerable<vendorsWhereUniqueInput>
    update?: Enumerable<vendorsUpdateWithWhereUniqueWithoutVendorTypesInput>
    updateMany?: Enumerable<vendorsUpdateManyWithWhereWithoutVendorTypesInput>
    deleteMany?: Enumerable<vendorsScalarWhereInput>
  }

  export type vendorsUncheckedUpdateManyWithoutVendorTypesNestedInput = {
    create?: XOR<Enumerable<vendorsCreateWithoutVendorTypesInput>, Enumerable<vendorsUncheckedCreateWithoutVendorTypesInput>>
    connectOrCreate?: Enumerable<vendorsCreateOrConnectWithoutVendorTypesInput>
    upsert?: Enumerable<vendorsUpsertWithWhereUniqueWithoutVendorTypesInput>
    createMany?: vendorsCreateManyVendorTypesInputEnvelope
    set?: Enumerable<vendorsWhereUniqueInput>
    disconnect?: Enumerable<vendorsWhereUniqueInput>
    delete?: Enumerable<vendorsWhereUniqueInput>
    connect?: Enumerable<vendorsWhereUniqueInput>
    update?: Enumerable<vendorsUpdateWithWhereUniqueWithoutVendorTypesInput>
    updateMany?: Enumerable<vendorsUpdateManyWithWhereWithoutVendorTypesInput>
    deleteMany?: Enumerable<vendorsScalarWhereInput>
  }

  export type custodyVendorVaultAssetsCreateNestedManyWithoutVendorsInput = {
    create?: XOR<Enumerable<custodyVendorVaultAssetsCreateWithoutVendorsInput>, Enumerable<custodyVendorVaultAssetsUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<custodyVendorVaultAssetsCreateOrConnectWithoutVendorsInput>
    createMany?: custodyVendorVaultAssetsCreateManyVendorsInputEnvelope
    connect?: Enumerable<custodyVendorVaultAssetsWhereUniqueInput>
  }

  export type depositAddressesCreateNestedManyWithoutVendorsInput = {
    create?: XOR<Enumerable<depositAddressesCreateWithoutVendorsInput>, Enumerable<depositAddressesUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<depositAddressesCreateOrConnectWithoutVendorsInput>
    createMany?: depositAddressesCreateManyVendorsInputEnvelope
    connect?: Enumerable<depositAddressesWhereUniqueInput>
  }

  export type quotesCreateNestedManyWithoutVendorsInput = {
    create?: XOR<Enumerable<quotesCreateWithoutVendorsInput>, Enumerable<quotesUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<quotesCreateOrConnectWithoutVendorsInput>
    createMany?: quotesCreateManyVendorsInputEnvelope
    connect?: Enumerable<quotesWhereUniqueInput>
  }

  export type tokenPairsCreateNestedManyWithoutVendorsInput = {
    create?: XOR<Enumerable<tokenPairsCreateWithoutVendorsInput>, Enumerable<tokenPairsUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<tokenPairsCreateOrConnectWithoutVendorsInput>
    createMany?: tokenPairsCreateManyVendorsInputEnvelope
    connect?: Enumerable<tokenPairsWhereUniqueInput>
  }

  export type transactionsCreateNestedManyWithoutVendorsInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutVendorsInput>, Enumerable<transactionsUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutVendorsInput>
    createMany?: transactionsCreateManyVendorsInputEnvelope
    connect?: Enumerable<transactionsWhereUniqueInput>
  }

  export type vendorSupportsAssetsCreateNestedManyWithoutVendorsInput = {
    create?: XOR<Enumerable<vendorSupportsAssetsCreateWithoutVendorsInput>, Enumerable<vendorSupportsAssetsUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<vendorSupportsAssetsCreateOrConnectWithoutVendorsInput>
    createMany?: vendorSupportsAssetsCreateManyVendorsInputEnvelope
    connect?: Enumerable<vendorSupportsAssetsWhereUniqueInput>
  }

  export type vendorTypesCreateNestedOneWithoutVendorsInput = {
    create?: XOR<vendorTypesCreateWithoutVendorsInput, vendorTypesUncheckedCreateWithoutVendorsInput>
    connectOrCreate?: vendorTypesCreateOrConnectWithoutVendorsInput
    connect?: vendorTypesWhereUniqueInput
  }

  export type custodyVendorVaultAssetsUncheckedCreateNestedManyWithoutVendorsInput = {
    create?: XOR<Enumerable<custodyVendorVaultAssetsCreateWithoutVendorsInput>, Enumerable<custodyVendorVaultAssetsUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<custodyVendorVaultAssetsCreateOrConnectWithoutVendorsInput>
    createMany?: custodyVendorVaultAssetsCreateManyVendorsInputEnvelope
    connect?: Enumerable<custodyVendorVaultAssetsWhereUniqueInput>
  }

  export type depositAddressesUncheckedCreateNestedManyWithoutVendorsInput = {
    create?: XOR<Enumerable<depositAddressesCreateWithoutVendorsInput>, Enumerable<depositAddressesUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<depositAddressesCreateOrConnectWithoutVendorsInput>
    createMany?: depositAddressesCreateManyVendorsInputEnvelope
    connect?: Enumerable<depositAddressesWhereUniqueInput>
  }

  export type quotesUncheckedCreateNestedManyWithoutVendorsInput = {
    create?: XOR<Enumerable<quotesCreateWithoutVendorsInput>, Enumerable<quotesUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<quotesCreateOrConnectWithoutVendorsInput>
    createMany?: quotesCreateManyVendorsInputEnvelope
    connect?: Enumerable<quotesWhereUniqueInput>
  }

  export type tokenPairsUncheckedCreateNestedManyWithoutVendorsInput = {
    create?: XOR<Enumerable<tokenPairsCreateWithoutVendorsInput>, Enumerable<tokenPairsUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<tokenPairsCreateOrConnectWithoutVendorsInput>
    createMany?: tokenPairsCreateManyVendorsInputEnvelope
    connect?: Enumerable<tokenPairsWhereUniqueInput>
  }

  export type transactionsUncheckedCreateNestedManyWithoutVendorsInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutVendorsInput>, Enumerable<transactionsUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutVendorsInput>
    createMany?: transactionsCreateManyVendorsInputEnvelope
    connect?: Enumerable<transactionsWhereUniqueInput>
  }

  export type vendorSupportsAssetsUncheckedCreateNestedManyWithoutVendorsInput = {
    create?: XOR<Enumerable<vendorSupportsAssetsCreateWithoutVendorsInput>, Enumerable<vendorSupportsAssetsUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<vendorSupportsAssetsCreateOrConnectWithoutVendorsInput>
    createMany?: vendorSupportsAssetsCreateManyVendorsInputEnvelope
    connect?: Enumerable<vendorSupportsAssetsWhereUniqueInput>
  }

  export type custodyVendorVaultAssetsUpdateManyWithoutVendorsNestedInput = {
    create?: XOR<Enumerable<custodyVendorVaultAssetsCreateWithoutVendorsInput>, Enumerable<custodyVendorVaultAssetsUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<custodyVendorVaultAssetsCreateOrConnectWithoutVendorsInput>
    upsert?: Enumerable<custodyVendorVaultAssetsUpsertWithWhereUniqueWithoutVendorsInput>
    createMany?: custodyVendorVaultAssetsCreateManyVendorsInputEnvelope
    set?: Enumerable<custodyVendorVaultAssetsWhereUniqueInput>
    disconnect?: Enumerable<custodyVendorVaultAssetsWhereUniqueInput>
    delete?: Enumerable<custodyVendorVaultAssetsWhereUniqueInput>
    connect?: Enumerable<custodyVendorVaultAssetsWhereUniqueInput>
    update?: Enumerable<custodyVendorVaultAssetsUpdateWithWhereUniqueWithoutVendorsInput>
    updateMany?: Enumerable<custodyVendorVaultAssetsUpdateManyWithWhereWithoutVendorsInput>
    deleteMany?: Enumerable<custodyVendorVaultAssetsScalarWhereInput>
  }

  export type depositAddressesUpdateManyWithoutVendorsNestedInput = {
    create?: XOR<Enumerable<depositAddressesCreateWithoutVendorsInput>, Enumerable<depositAddressesUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<depositAddressesCreateOrConnectWithoutVendorsInput>
    upsert?: Enumerable<depositAddressesUpsertWithWhereUniqueWithoutVendorsInput>
    createMany?: depositAddressesCreateManyVendorsInputEnvelope
    set?: Enumerable<depositAddressesWhereUniqueInput>
    disconnect?: Enumerable<depositAddressesWhereUniqueInput>
    delete?: Enumerable<depositAddressesWhereUniqueInput>
    connect?: Enumerable<depositAddressesWhereUniqueInput>
    update?: Enumerable<depositAddressesUpdateWithWhereUniqueWithoutVendorsInput>
    updateMany?: Enumerable<depositAddressesUpdateManyWithWhereWithoutVendorsInput>
    deleteMany?: Enumerable<depositAddressesScalarWhereInput>
  }

  export type quotesUpdateManyWithoutVendorsNestedInput = {
    create?: XOR<Enumerable<quotesCreateWithoutVendorsInput>, Enumerable<quotesUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<quotesCreateOrConnectWithoutVendorsInput>
    upsert?: Enumerable<quotesUpsertWithWhereUniqueWithoutVendorsInput>
    createMany?: quotesCreateManyVendorsInputEnvelope
    set?: Enumerable<quotesWhereUniqueInput>
    disconnect?: Enumerable<quotesWhereUniqueInput>
    delete?: Enumerable<quotesWhereUniqueInput>
    connect?: Enumerable<quotesWhereUniqueInput>
    update?: Enumerable<quotesUpdateWithWhereUniqueWithoutVendorsInput>
    updateMany?: Enumerable<quotesUpdateManyWithWhereWithoutVendorsInput>
    deleteMany?: Enumerable<quotesScalarWhereInput>
  }

  export type tokenPairsUpdateManyWithoutVendorsNestedInput = {
    create?: XOR<Enumerable<tokenPairsCreateWithoutVendorsInput>, Enumerable<tokenPairsUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<tokenPairsCreateOrConnectWithoutVendorsInput>
    upsert?: Enumerable<tokenPairsUpsertWithWhereUniqueWithoutVendorsInput>
    createMany?: tokenPairsCreateManyVendorsInputEnvelope
    set?: Enumerable<tokenPairsWhereUniqueInput>
    disconnect?: Enumerable<tokenPairsWhereUniqueInput>
    delete?: Enumerable<tokenPairsWhereUniqueInput>
    connect?: Enumerable<tokenPairsWhereUniqueInput>
    update?: Enumerable<tokenPairsUpdateWithWhereUniqueWithoutVendorsInput>
    updateMany?: Enumerable<tokenPairsUpdateManyWithWhereWithoutVendorsInput>
    deleteMany?: Enumerable<tokenPairsScalarWhereInput>
  }

  export type transactionsUpdateManyWithoutVendorsNestedInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutVendorsInput>, Enumerable<transactionsUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutVendorsInput>
    upsert?: Enumerable<transactionsUpsertWithWhereUniqueWithoutVendorsInput>
    createMany?: transactionsCreateManyVendorsInputEnvelope
    set?: Enumerable<transactionsWhereUniqueInput>
    disconnect?: Enumerable<transactionsWhereUniqueInput>
    delete?: Enumerable<transactionsWhereUniqueInput>
    connect?: Enumerable<transactionsWhereUniqueInput>
    update?: Enumerable<transactionsUpdateWithWhereUniqueWithoutVendorsInput>
    updateMany?: Enumerable<transactionsUpdateManyWithWhereWithoutVendorsInput>
    deleteMany?: Enumerable<transactionsScalarWhereInput>
  }

  export type vendorSupportsAssetsUpdateManyWithoutVendorsNestedInput = {
    create?: XOR<Enumerable<vendorSupportsAssetsCreateWithoutVendorsInput>, Enumerable<vendorSupportsAssetsUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<vendorSupportsAssetsCreateOrConnectWithoutVendorsInput>
    upsert?: Enumerable<vendorSupportsAssetsUpsertWithWhereUniqueWithoutVendorsInput>
    createMany?: vendorSupportsAssetsCreateManyVendorsInputEnvelope
    set?: Enumerable<vendorSupportsAssetsWhereUniqueInput>
    disconnect?: Enumerable<vendorSupportsAssetsWhereUniqueInput>
    delete?: Enumerable<vendorSupportsAssetsWhereUniqueInput>
    connect?: Enumerable<vendorSupportsAssetsWhereUniqueInput>
    update?: Enumerable<vendorSupportsAssetsUpdateWithWhereUniqueWithoutVendorsInput>
    updateMany?: Enumerable<vendorSupportsAssetsUpdateManyWithWhereWithoutVendorsInput>
    deleteMany?: Enumerable<vendorSupportsAssetsScalarWhereInput>
  }

  export type vendorTypesUpdateOneRequiredWithoutVendorsNestedInput = {
    create?: XOR<vendorTypesCreateWithoutVendorsInput, vendorTypesUncheckedCreateWithoutVendorsInput>
    connectOrCreate?: vendorTypesCreateOrConnectWithoutVendorsInput
    upsert?: vendorTypesUpsertWithoutVendorsInput
    connect?: vendorTypesWhereUniqueInput
    update?: XOR<vendorTypesUpdateWithoutVendorsInput, vendorTypesUncheckedUpdateWithoutVendorsInput>
  }

  export type custodyVendorVaultAssetsUncheckedUpdateManyWithoutVendorsNestedInput = {
    create?: XOR<Enumerable<custodyVendorVaultAssetsCreateWithoutVendorsInput>, Enumerable<custodyVendorVaultAssetsUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<custodyVendorVaultAssetsCreateOrConnectWithoutVendorsInput>
    upsert?: Enumerable<custodyVendorVaultAssetsUpsertWithWhereUniqueWithoutVendorsInput>
    createMany?: custodyVendorVaultAssetsCreateManyVendorsInputEnvelope
    set?: Enumerable<custodyVendorVaultAssetsWhereUniqueInput>
    disconnect?: Enumerable<custodyVendorVaultAssetsWhereUniqueInput>
    delete?: Enumerable<custodyVendorVaultAssetsWhereUniqueInput>
    connect?: Enumerable<custodyVendorVaultAssetsWhereUniqueInput>
    update?: Enumerable<custodyVendorVaultAssetsUpdateWithWhereUniqueWithoutVendorsInput>
    updateMany?: Enumerable<custodyVendorVaultAssetsUpdateManyWithWhereWithoutVendorsInput>
    deleteMany?: Enumerable<custodyVendorVaultAssetsScalarWhereInput>
  }

  export type depositAddressesUncheckedUpdateManyWithoutVendorsNestedInput = {
    create?: XOR<Enumerable<depositAddressesCreateWithoutVendorsInput>, Enumerable<depositAddressesUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<depositAddressesCreateOrConnectWithoutVendorsInput>
    upsert?: Enumerable<depositAddressesUpsertWithWhereUniqueWithoutVendorsInput>
    createMany?: depositAddressesCreateManyVendorsInputEnvelope
    set?: Enumerable<depositAddressesWhereUniqueInput>
    disconnect?: Enumerable<depositAddressesWhereUniqueInput>
    delete?: Enumerable<depositAddressesWhereUniqueInput>
    connect?: Enumerable<depositAddressesWhereUniqueInput>
    update?: Enumerable<depositAddressesUpdateWithWhereUniqueWithoutVendorsInput>
    updateMany?: Enumerable<depositAddressesUpdateManyWithWhereWithoutVendorsInput>
    deleteMany?: Enumerable<depositAddressesScalarWhereInput>
  }

  export type quotesUncheckedUpdateManyWithoutVendorsNestedInput = {
    create?: XOR<Enumerable<quotesCreateWithoutVendorsInput>, Enumerable<quotesUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<quotesCreateOrConnectWithoutVendorsInput>
    upsert?: Enumerable<quotesUpsertWithWhereUniqueWithoutVendorsInput>
    createMany?: quotesCreateManyVendorsInputEnvelope
    set?: Enumerable<quotesWhereUniqueInput>
    disconnect?: Enumerable<quotesWhereUniqueInput>
    delete?: Enumerable<quotesWhereUniqueInput>
    connect?: Enumerable<quotesWhereUniqueInput>
    update?: Enumerable<quotesUpdateWithWhereUniqueWithoutVendorsInput>
    updateMany?: Enumerable<quotesUpdateManyWithWhereWithoutVendorsInput>
    deleteMany?: Enumerable<quotesScalarWhereInput>
  }

  export type tokenPairsUncheckedUpdateManyWithoutVendorsNestedInput = {
    create?: XOR<Enumerable<tokenPairsCreateWithoutVendorsInput>, Enumerable<tokenPairsUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<tokenPairsCreateOrConnectWithoutVendorsInput>
    upsert?: Enumerable<tokenPairsUpsertWithWhereUniqueWithoutVendorsInput>
    createMany?: tokenPairsCreateManyVendorsInputEnvelope
    set?: Enumerable<tokenPairsWhereUniqueInput>
    disconnect?: Enumerable<tokenPairsWhereUniqueInput>
    delete?: Enumerable<tokenPairsWhereUniqueInput>
    connect?: Enumerable<tokenPairsWhereUniqueInput>
    update?: Enumerable<tokenPairsUpdateWithWhereUniqueWithoutVendorsInput>
    updateMany?: Enumerable<tokenPairsUpdateManyWithWhereWithoutVendorsInput>
    deleteMany?: Enumerable<tokenPairsScalarWhereInput>
  }

  export type transactionsUncheckedUpdateManyWithoutVendorsNestedInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutVendorsInput>, Enumerable<transactionsUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutVendorsInput>
    upsert?: Enumerable<transactionsUpsertWithWhereUniqueWithoutVendorsInput>
    createMany?: transactionsCreateManyVendorsInputEnvelope
    set?: Enumerable<transactionsWhereUniqueInput>
    disconnect?: Enumerable<transactionsWhereUniqueInput>
    delete?: Enumerable<transactionsWhereUniqueInput>
    connect?: Enumerable<transactionsWhereUniqueInput>
    update?: Enumerable<transactionsUpdateWithWhereUniqueWithoutVendorsInput>
    updateMany?: Enumerable<transactionsUpdateManyWithWhereWithoutVendorsInput>
    deleteMany?: Enumerable<transactionsScalarWhereInput>
  }

  export type vendorSupportsAssetsUncheckedUpdateManyWithoutVendorsNestedInput = {
    create?: XOR<Enumerable<vendorSupportsAssetsCreateWithoutVendorsInput>, Enumerable<vendorSupportsAssetsUncheckedCreateWithoutVendorsInput>>
    connectOrCreate?: Enumerable<vendorSupportsAssetsCreateOrConnectWithoutVendorsInput>
    upsert?: Enumerable<vendorSupportsAssetsUpsertWithWhereUniqueWithoutVendorsInput>
    createMany?: vendorSupportsAssetsCreateManyVendorsInputEnvelope
    set?: Enumerable<vendorSupportsAssetsWhereUniqueInput>
    disconnect?: Enumerable<vendorSupportsAssetsWhereUniqueInput>
    delete?: Enumerable<vendorSupportsAssetsWhereUniqueInput>
    connect?: Enumerable<vendorSupportsAssetsWhereUniqueInput>
    update?: Enumerable<vendorSupportsAssetsUpdateWithWhereUniqueWithoutVendorsInput>
    updateMany?: Enumerable<vendorSupportsAssetsUpdateManyWithWhereWithoutVendorsInput>
    deleteMany?: Enumerable<vendorSupportsAssetsScalarWhereInput>
  }

  export type custodyEngineEventsCreateNestedManyWithoutCustodyEngineEventTypesInput = {
    create?: XOR<Enumerable<custodyEngineEventsCreateWithoutCustodyEngineEventTypesInput>, Enumerable<custodyEngineEventsUncheckedCreateWithoutCustodyEngineEventTypesInput>>
    connectOrCreate?: Enumerable<custodyEngineEventsCreateOrConnectWithoutCustodyEngineEventTypesInput>
    createMany?: custodyEngineEventsCreateManyCustodyEngineEventTypesInputEnvelope
    connect?: Enumerable<custodyEngineEventsWhereUniqueInput>
  }

  export type custodyEngineEventsUncheckedCreateNestedManyWithoutCustodyEngineEventTypesInput = {
    create?: XOR<Enumerable<custodyEngineEventsCreateWithoutCustodyEngineEventTypesInput>, Enumerable<custodyEngineEventsUncheckedCreateWithoutCustodyEngineEventTypesInput>>
    connectOrCreate?: Enumerable<custodyEngineEventsCreateOrConnectWithoutCustodyEngineEventTypesInput>
    createMany?: custodyEngineEventsCreateManyCustodyEngineEventTypesInputEnvelope
    connect?: Enumerable<custodyEngineEventsWhereUniqueInput>
  }

  export type custodyEngineEventsUpdateManyWithoutCustodyEngineEventTypesNestedInput = {
    create?: XOR<Enumerable<custodyEngineEventsCreateWithoutCustodyEngineEventTypesInput>, Enumerable<custodyEngineEventsUncheckedCreateWithoutCustodyEngineEventTypesInput>>
    connectOrCreate?: Enumerable<custodyEngineEventsCreateOrConnectWithoutCustodyEngineEventTypesInput>
    upsert?: Enumerable<custodyEngineEventsUpsertWithWhereUniqueWithoutCustodyEngineEventTypesInput>
    createMany?: custodyEngineEventsCreateManyCustodyEngineEventTypesInputEnvelope
    set?: Enumerable<custodyEngineEventsWhereUniqueInput>
    disconnect?: Enumerable<custodyEngineEventsWhereUniqueInput>
    delete?: Enumerable<custodyEngineEventsWhereUniqueInput>
    connect?: Enumerable<custodyEngineEventsWhereUniqueInput>
    update?: Enumerable<custodyEngineEventsUpdateWithWhereUniqueWithoutCustodyEngineEventTypesInput>
    updateMany?: Enumerable<custodyEngineEventsUpdateManyWithWhereWithoutCustodyEngineEventTypesInput>
    deleteMany?: Enumerable<custodyEngineEventsScalarWhereInput>
  }

  export type custodyEngineEventsUncheckedUpdateManyWithoutCustodyEngineEventTypesNestedInput = {
    create?: XOR<Enumerable<custodyEngineEventsCreateWithoutCustodyEngineEventTypesInput>, Enumerable<custodyEngineEventsUncheckedCreateWithoutCustodyEngineEventTypesInput>>
    connectOrCreate?: Enumerable<custodyEngineEventsCreateOrConnectWithoutCustodyEngineEventTypesInput>
    upsert?: Enumerable<custodyEngineEventsUpsertWithWhereUniqueWithoutCustodyEngineEventTypesInput>
    createMany?: custodyEngineEventsCreateManyCustodyEngineEventTypesInputEnvelope
    set?: Enumerable<custodyEngineEventsWhereUniqueInput>
    disconnect?: Enumerable<custodyEngineEventsWhereUniqueInput>
    delete?: Enumerable<custodyEngineEventsWhereUniqueInput>
    connect?: Enumerable<custodyEngineEventsWhereUniqueInput>
    update?: Enumerable<custodyEngineEventsUpdateWithWhereUniqueWithoutCustodyEngineEventTypesInput>
    updateMany?: Enumerable<custodyEngineEventsUpdateManyWithWhereWithoutCustodyEngineEventTypesInput>
    deleteMany?: Enumerable<custodyEngineEventsScalarWhereInput>
  }

  export type custodyEngineEventTypesCreateNestedOneWithoutCustodyEngineEventsInput = {
    create?: XOR<custodyEngineEventTypesCreateWithoutCustodyEngineEventsInput, custodyEngineEventTypesUncheckedCreateWithoutCustodyEngineEventsInput>
    connectOrCreate?: custodyEngineEventTypesCreateOrConnectWithoutCustodyEngineEventsInput
    connect?: custodyEngineEventTypesWhereUniqueInput
  }

  export type organizationsCreateNestedOneWithoutCustodyEngineEventsInput = {
    create?: XOR<organizationsCreateWithoutCustodyEngineEventsInput, organizationsUncheckedCreateWithoutCustodyEngineEventsInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutCustodyEngineEventsInput
    connect?: organizationsWhereUniqueInput
  }

  export type webhookRequestsCreateNestedManyWithoutCustodyEngineEventsInput = {
    create?: XOR<Enumerable<webhookRequestsCreateWithoutCustodyEngineEventsInput>, Enumerable<webhookRequestsUncheckedCreateWithoutCustodyEngineEventsInput>>
    connectOrCreate?: Enumerable<webhookRequestsCreateOrConnectWithoutCustodyEngineEventsInput>
    createMany?: webhookRequestsCreateManyCustodyEngineEventsInputEnvelope
    connect?: Enumerable<webhookRequestsWhereUniqueInput>
  }

  export type webhookRequestsUncheckedCreateNestedManyWithoutCustodyEngineEventsInput = {
    create?: XOR<Enumerable<webhookRequestsCreateWithoutCustodyEngineEventsInput>, Enumerable<webhookRequestsUncheckedCreateWithoutCustodyEngineEventsInput>>
    connectOrCreate?: Enumerable<webhookRequestsCreateOrConnectWithoutCustodyEngineEventsInput>
    createMany?: webhookRequestsCreateManyCustodyEngineEventsInputEnvelope
    connect?: Enumerable<webhookRequestsWhereUniqueInput>
  }

  export type custodyEngineEventTypesUpdateOneRequiredWithoutCustodyEngineEventsNestedInput = {
    create?: XOR<custodyEngineEventTypesCreateWithoutCustodyEngineEventsInput, custodyEngineEventTypesUncheckedCreateWithoutCustodyEngineEventsInput>
    connectOrCreate?: custodyEngineEventTypesCreateOrConnectWithoutCustodyEngineEventsInput
    upsert?: custodyEngineEventTypesUpsertWithoutCustodyEngineEventsInput
    connect?: custodyEngineEventTypesWhereUniqueInput
    update?: XOR<custodyEngineEventTypesUpdateWithoutCustodyEngineEventsInput, custodyEngineEventTypesUncheckedUpdateWithoutCustodyEngineEventsInput>
  }

  export type organizationsUpdateOneRequiredWithoutCustodyEngineEventsNestedInput = {
    create?: XOR<organizationsCreateWithoutCustodyEngineEventsInput, organizationsUncheckedCreateWithoutCustodyEngineEventsInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutCustodyEngineEventsInput
    upsert?: organizationsUpsertWithoutCustodyEngineEventsInput
    connect?: organizationsWhereUniqueInput
    update?: XOR<organizationsUpdateWithoutCustodyEngineEventsInput, organizationsUncheckedUpdateWithoutCustodyEngineEventsInput>
  }

  export type webhookRequestsUpdateManyWithoutCustodyEngineEventsNestedInput = {
    create?: XOR<Enumerable<webhookRequestsCreateWithoutCustodyEngineEventsInput>, Enumerable<webhookRequestsUncheckedCreateWithoutCustodyEngineEventsInput>>
    connectOrCreate?: Enumerable<webhookRequestsCreateOrConnectWithoutCustodyEngineEventsInput>
    upsert?: Enumerable<webhookRequestsUpsertWithWhereUniqueWithoutCustodyEngineEventsInput>
    createMany?: webhookRequestsCreateManyCustodyEngineEventsInputEnvelope
    set?: Enumerable<webhookRequestsWhereUniqueInput>
    disconnect?: Enumerable<webhookRequestsWhereUniqueInput>
    delete?: Enumerable<webhookRequestsWhereUniqueInput>
    connect?: Enumerable<webhookRequestsWhereUniqueInput>
    update?: Enumerable<webhookRequestsUpdateWithWhereUniqueWithoutCustodyEngineEventsInput>
    updateMany?: Enumerable<webhookRequestsUpdateManyWithWhereWithoutCustodyEngineEventsInput>
    deleteMany?: Enumerable<webhookRequestsScalarWhereInput>
  }

  export type webhookRequestsUncheckedUpdateManyWithoutCustodyEngineEventsNestedInput = {
    create?: XOR<Enumerable<webhookRequestsCreateWithoutCustodyEngineEventsInput>, Enumerable<webhookRequestsUncheckedCreateWithoutCustodyEngineEventsInput>>
    connectOrCreate?: Enumerable<webhookRequestsCreateOrConnectWithoutCustodyEngineEventsInput>
    upsert?: Enumerable<webhookRequestsUpsertWithWhereUniqueWithoutCustodyEngineEventsInput>
    createMany?: webhookRequestsCreateManyCustodyEngineEventsInputEnvelope
    set?: Enumerable<webhookRequestsWhereUniqueInput>
    disconnect?: Enumerable<webhookRequestsWhereUniqueInput>
    delete?: Enumerable<webhookRequestsWhereUniqueInput>
    connect?: Enumerable<webhookRequestsWhereUniqueInput>
    update?: Enumerable<webhookRequestsUpdateWithWhereUniqueWithoutCustodyEngineEventsInput>
    updateMany?: Enumerable<webhookRequestsUpdateManyWithWhereWithoutCustodyEngineEventsInput>
    deleteMany?: Enumerable<webhookRequestsScalarWhereInput>
  }

  export type vaultAssetsCreateNestedOneWithoutCustodyVendorVaultAssetsInput = {
    create?: XOR<vaultAssetsCreateWithoutCustodyVendorVaultAssetsInput, vaultAssetsUncheckedCreateWithoutCustodyVendorVaultAssetsInput>
    connectOrCreate?: vaultAssetsCreateOrConnectWithoutCustodyVendorVaultAssetsInput
    connect?: vaultAssetsWhereUniqueInput
  }

  export type vendorsCreateNestedOneWithoutCustodyVendorVaultAssetsInput = {
    create?: XOR<vendorsCreateWithoutCustodyVendorVaultAssetsInput, vendorsUncheckedCreateWithoutCustodyVendorVaultAssetsInput>
    connectOrCreate?: vendorsCreateOrConnectWithoutCustodyVendorVaultAssetsInput
    connect?: vendorsWhereUniqueInput
  }

  export type vaultAssetsUpdateOneRequiredWithoutCustodyVendorVaultAssetsNestedInput = {
    create?: XOR<vaultAssetsCreateWithoutCustodyVendorVaultAssetsInput, vaultAssetsUncheckedCreateWithoutCustodyVendorVaultAssetsInput>
    connectOrCreate?: vaultAssetsCreateOrConnectWithoutCustodyVendorVaultAssetsInput
    upsert?: vaultAssetsUpsertWithoutCustodyVendorVaultAssetsInput
    connect?: vaultAssetsWhereUniqueInput
    update?: XOR<vaultAssetsUpdateWithoutCustodyVendorVaultAssetsInput, vaultAssetsUncheckedUpdateWithoutCustodyVendorVaultAssetsInput>
  }

  export type vendorsUpdateOneRequiredWithoutCustodyVendorVaultAssetsNestedInput = {
    create?: XOR<vendorsCreateWithoutCustodyVendorVaultAssetsInput, vendorsUncheckedCreateWithoutCustodyVendorVaultAssetsInput>
    connectOrCreate?: vendorsCreateOrConnectWithoutCustodyVendorVaultAssetsInput
    upsert?: vendorsUpsertWithoutCustodyVendorVaultAssetsInput
    connect?: vendorsWhereUniqueInput
    update?: XOR<vendorsUpdateWithoutCustodyVendorVaultAssetsInput, vendorsUncheckedUpdateWithoutCustodyVendorVaultAssetsInput>
  }

  export type vaultAssetsCreateNestedOneWithoutDepositAddressesInput = {
    create?: XOR<vaultAssetsCreateWithoutDepositAddressesInput, vaultAssetsUncheckedCreateWithoutDepositAddressesInput>
    connectOrCreate?: vaultAssetsCreateOrConnectWithoutDepositAddressesInput
    connect?: vaultAssetsWhereUniqueInput
  }

  export type vendorsCreateNestedOneWithoutDepositAddressesInput = {
    create?: XOR<vendorsCreateWithoutDepositAddressesInput, vendorsUncheckedCreateWithoutDepositAddressesInput>
    connectOrCreate?: vendorsCreateOrConnectWithoutDepositAddressesInput
    connect?: vendorsWhereUniqueInput
  }

  export type vaultAssetsUpdateOneRequiredWithoutDepositAddressesNestedInput = {
    create?: XOR<vaultAssetsCreateWithoutDepositAddressesInput, vaultAssetsUncheckedCreateWithoutDepositAddressesInput>
    connectOrCreate?: vaultAssetsCreateOrConnectWithoutDepositAddressesInput
    upsert?: vaultAssetsUpsertWithoutDepositAddressesInput
    connect?: vaultAssetsWhereUniqueInput
    update?: XOR<vaultAssetsUpdateWithoutDepositAddressesInput, vaultAssetsUncheckedUpdateWithoutDepositAddressesInput>
  }

  export type vendorsUpdateOneWithoutDepositAddressesNestedInput = {
    create?: XOR<vendorsCreateWithoutDepositAddressesInput, vendorsUncheckedCreateWithoutDepositAddressesInput>
    connectOrCreate?: vendorsCreateOrConnectWithoutDepositAddressesInput
    upsert?: vendorsUpsertWithoutDepositAddressesInput
    disconnect?: boolean
    delete?: boolean
    connect?: vendorsWhereUniqueInput
    update?: XOR<vendorsUpdateWithoutDepositAddressesInput, vendorsUncheckedUpdateWithoutDepositAddressesInput>
  }

  export type webhookRequestsCreateNestedManyWithoutInstitutionalProductsInput = {
    create?: XOR<Enumerable<webhookRequestsCreateWithoutInstitutionalProductsInput>, Enumerable<webhookRequestsUncheckedCreateWithoutInstitutionalProductsInput>>
    connectOrCreate?: Enumerable<webhookRequestsCreateOrConnectWithoutInstitutionalProductsInput>
    createMany?: webhookRequestsCreateManyInstitutionalProductsInputEnvelope
    connect?: Enumerable<webhookRequestsWhereUniqueInput>
  }

  export type webhookRequestsUncheckedCreateNestedManyWithoutInstitutionalProductsInput = {
    create?: XOR<Enumerable<webhookRequestsCreateWithoutInstitutionalProductsInput>, Enumerable<webhookRequestsUncheckedCreateWithoutInstitutionalProductsInput>>
    connectOrCreate?: Enumerable<webhookRequestsCreateOrConnectWithoutInstitutionalProductsInput>
    createMany?: webhookRequestsCreateManyInstitutionalProductsInputEnvelope
    connect?: Enumerable<webhookRequestsWhereUniqueInput>
  }

  export type webhookRequestsUpdateManyWithoutInstitutionalProductsNestedInput = {
    create?: XOR<Enumerable<webhookRequestsCreateWithoutInstitutionalProductsInput>, Enumerable<webhookRequestsUncheckedCreateWithoutInstitutionalProductsInput>>
    connectOrCreate?: Enumerable<webhookRequestsCreateOrConnectWithoutInstitutionalProductsInput>
    upsert?: Enumerable<webhookRequestsUpsertWithWhereUniqueWithoutInstitutionalProductsInput>
    createMany?: webhookRequestsCreateManyInstitutionalProductsInputEnvelope
    set?: Enumerable<webhookRequestsWhereUniqueInput>
    disconnect?: Enumerable<webhookRequestsWhereUniqueInput>
    delete?: Enumerable<webhookRequestsWhereUniqueInput>
    connect?: Enumerable<webhookRequestsWhereUniqueInput>
    update?: Enumerable<webhookRequestsUpdateWithWhereUniqueWithoutInstitutionalProductsInput>
    updateMany?: Enumerable<webhookRequestsUpdateManyWithWhereWithoutInstitutionalProductsInput>
    deleteMany?: Enumerable<webhookRequestsScalarWhereInput>
  }

  export type webhookRequestsUncheckedUpdateManyWithoutInstitutionalProductsNestedInput = {
    create?: XOR<Enumerable<webhookRequestsCreateWithoutInstitutionalProductsInput>, Enumerable<webhookRequestsUncheckedCreateWithoutInstitutionalProductsInput>>
    connectOrCreate?: Enumerable<webhookRequestsCreateOrConnectWithoutInstitutionalProductsInput>
    upsert?: Enumerable<webhookRequestsUpsertWithWhereUniqueWithoutInstitutionalProductsInput>
    createMany?: webhookRequestsCreateManyInstitutionalProductsInputEnvelope
    set?: Enumerable<webhookRequestsWhereUniqueInput>
    disconnect?: Enumerable<webhookRequestsWhereUniqueInput>
    delete?: Enumerable<webhookRequestsWhereUniqueInput>
    connect?: Enumerable<webhookRequestsWhereUniqueInput>
    update?: Enumerable<webhookRequestsUpdateWithWhereUniqueWithoutInstitutionalProductsInput>
    updateMany?: Enumerable<webhookRequestsUpdateManyWithWhereWithoutInstitutionalProductsInput>
    deleteMany?: Enumerable<webhookRequestsScalarWhereInput>
  }

  export type quotesCreateNestedOneWithoutOrdersInput = {
    create?: XOR<quotesCreateWithoutOrdersInput, quotesUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: quotesCreateOrConnectWithoutOrdersInput
    connect?: quotesWhereUniqueInput
  }

  export type Enumenum_orders_userAcceptedSideFieldUpdateOperationsInput = {
    set?: enum_orders_userAcceptedSide
  }

  export type NullableEnumenum_orders_orderTypeFieldUpdateOperationsInput = {
    set?: enum_orders_orderType | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type quotesUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<quotesCreateWithoutOrdersInput, quotesUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: quotesCreateOrConnectWithoutOrdersInput
    upsert?: quotesUpsertWithoutOrdersInput
    connect?: quotesWhereUniqueInput
    update?: XOR<quotesUpdateWithoutOrdersInput, quotesUncheckedUpdateWithoutOrdersInput>
  }

  export type organizationsCreateNestedManyWithoutOrganizationStatusTypesInput = {
    create?: XOR<Enumerable<organizationsCreateWithoutOrganizationStatusTypesInput>, Enumerable<organizationsUncheckedCreateWithoutOrganizationStatusTypesInput>>
    connectOrCreate?: Enumerable<organizationsCreateOrConnectWithoutOrganizationStatusTypesInput>
    createMany?: organizationsCreateManyOrganizationStatusTypesInputEnvelope
    connect?: Enumerable<organizationsWhereUniqueInput>
  }

  export type organizationsUncheckedCreateNestedManyWithoutOrganizationStatusTypesInput = {
    create?: XOR<Enumerable<organizationsCreateWithoutOrganizationStatusTypesInput>, Enumerable<organizationsUncheckedCreateWithoutOrganizationStatusTypesInput>>
    connectOrCreate?: Enumerable<organizationsCreateOrConnectWithoutOrganizationStatusTypesInput>
    createMany?: organizationsCreateManyOrganizationStatusTypesInputEnvelope
    connect?: Enumerable<organizationsWhereUniqueInput>
  }

  export type organizationsUpdateManyWithoutOrganizationStatusTypesNestedInput = {
    create?: XOR<Enumerable<organizationsCreateWithoutOrganizationStatusTypesInput>, Enumerable<organizationsUncheckedCreateWithoutOrganizationStatusTypesInput>>
    connectOrCreate?: Enumerable<organizationsCreateOrConnectWithoutOrganizationStatusTypesInput>
    upsert?: Enumerable<organizationsUpsertWithWhereUniqueWithoutOrganizationStatusTypesInput>
    createMany?: organizationsCreateManyOrganizationStatusTypesInputEnvelope
    set?: Enumerable<organizationsWhereUniqueInput>
    disconnect?: Enumerable<organizationsWhereUniqueInput>
    delete?: Enumerable<organizationsWhereUniqueInput>
    connect?: Enumerable<organizationsWhereUniqueInput>
    update?: Enumerable<organizationsUpdateWithWhereUniqueWithoutOrganizationStatusTypesInput>
    updateMany?: Enumerable<organizationsUpdateManyWithWhereWithoutOrganizationStatusTypesInput>
    deleteMany?: Enumerable<organizationsScalarWhereInput>
  }

  export type organizationsUncheckedUpdateManyWithoutOrganizationStatusTypesNestedInput = {
    create?: XOR<Enumerable<organizationsCreateWithoutOrganizationStatusTypesInput>, Enumerable<organizationsUncheckedCreateWithoutOrganizationStatusTypesInput>>
    connectOrCreate?: Enumerable<organizationsCreateOrConnectWithoutOrganizationStatusTypesInput>
    upsert?: Enumerable<organizationsUpsertWithWhereUniqueWithoutOrganizationStatusTypesInput>
    createMany?: organizationsCreateManyOrganizationStatusTypesInputEnvelope
    set?: Enumerable<organizationsWhereUniqueInput>
    disconnect?: Enumerable<organizationsWhereUniqueInput>
    delete?: Enumerable<organizationsWhereUniqueInput>
    connect?: Enumerable<organizationsWhereUniqueInput>
    update?: Enumerable<organizationsUpdateWithWhereUniqueWithoutOrganizationStatusTypesInput>
    updateMany?: Enumerable<organizationsUpdateManyWithWhereWithoutOrganizationStatusTypesInput>
    deleteMany?: Enumerable<organizationsScalarWhereInput>
  }

  export type custodyEngineEventsCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<Enumerable<custodyEngineEventsCreateWithoutOrganizationsInput>, Enumerable<custodyEngineEventsUncheckedCreateWithoutOrganizationsInput>>
    connectOrCreate?: Enumerable<custodyEngineEventsCreateOrConnectWithoutOrganizationsInput>
    createMany?: custodyEngineEventsCreateManyOrganizationsInputEnvelope
    connect?: Enumerable<custodyEngineEventsWhereUniqueInput>
  }

  export type pricingPlansCreateNestedOneWithoutOrganizationsInput = {
    create?: XOR<pricingPlansCreateWithoutOrganizationsInput, pricingPlansUncheckedCreateWithoutOrganizationsInput>
    connectOrCreate?: pricingPlansCreateOrConnectWithoutOrganizationsInput
    connect?: pricingPlansWhereUniqueInput
  }

  export type organizationStatusTypesCreateNestedOneWithoutOrganizationsInput = {
    create?: XOR<organizationStatusTypesCreateWithoutOrganizationsInput, organizationStatusTypesUncheckedCreateWithoutOrganizationsInput>
    connectOrCreate?: organizationStatusTypesCreateOrConnectWithoutOrganizationsInput
    connect?: organizationStatusTypesWhereUniqueInput
  }

  export type usersCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<Enumerable<usersCreateWithoutOrganizationsInput>, Enumerable<usersUncheckedCreateWithoutOrganizationsInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutOrganizationsInput>
    createMany?: usersCreateManyOrganizationsInputEnvelope
    connect?: Enumerable<usersWhereUniqueInput>
  }

  export type webhooksCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<Enumerable<webhooksCreateWithoutOrganizationsInput>, Enumerable<webhooksUncheckedCreateWithoutOrganizationsInput>>
    connectOrCreate?: Enumerable<webhooksCreateOrConnectWithoutOrganizationsInput>
    createMany?: webhooksCreateManyOrganizationsInputEnvelope
    connect?: Enumerable<webhooksWhereUniqueInput>
  }

  export type withdrawalAddressesCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<Enumerable<withdrawalAddressesCreateWithoutOrganizationsInput>, Enumerable<withdrawalAddressesUncheckedCreateWithoutOrganizationsInput>>
    connectOrCreate?: Enumerable<withdrawalAddressesCreateOrConnectWithoutOrganizationsInput>
    createMany?: withdrawalAddressesCreateManyOrganizationsInputEnvelope
    connect?: Enumerable<withdrawalAddressesWhereUniqueInput>
  }

  export type custodyEngineEventsUncheckedCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<Enumerable<custodyEngineEventsCreateWithoutOrganizationsInput>, Enumerable<custodyEngineEventsUncheckedCreateWithoutOrganizationsInput>>
    connectOrCreate?: Enumerable<custodyEngineEventsCreateOrConnectWithoutOrganizationsInput>
    createMany?: custodyEngineEventsCreateManyOrganizationsInputEnvelope
    connect?: Enumerable<custodyEngineEventsWhereUniqueInput>
  }

  export type usersUncheckedCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<Enumerable<usersCreateWithoutOrganizationsInput>, Enumerable<usersUncheckedCreateWithoutOrganizationsInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutOrganizationsInput>
    createMany?: usersCreateManyOrganizationsInputEnvelope
    connect?: Enumerable<usersWhereUniqueInput>
  }

  export type webhooksUncheckedCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<Enumerable<webhooksCreateWithoutOrganizationsInput>, Enumerable<webhooksUncheckedCreateWithoutOrganizationsInput>>
    connectOrCreate?: Enumerable<webhooksCreateOrConnectWithoutOrganizationsInput>
    createMany?: webhooksCreateManyOrganizationsInputEnvelope
    connect?: Enumerable<webhooksWhereUniqueInput>
  }

  export type withdrawalAddressesUncheckedCreateNestedManyWithoutOrganizationsInput = {
    create?: XOR<Enumerable<withdrawalAddressesCreateWithoutOrganizationsInput>, Enumerable<withdrawalAddressesUncheckedCreateWithoutOrganizationsInput>>
    connectOrCreate?: Enumerable<withdrawalAddressesCreateOrConnectWithoutOrganizationsInput>
    createMany?: withdrawalAddressesCreateManyOrganizationsInputEnvelope
    connect?: Enumerable<withdrawalAddressesWhereUniqueInput>
  }

  export type custodyEngineEventsUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<Enumerable<custodyEngineEventsCreateWithoutOrganizationsInput>, Enumerable<custodyEngineEventsUncheckedCreateWithoutOrganizationsInput>>
    connectOrCreate?: Enumerable<custodyEngineEventsCreateOrConnectWithoutOrganizationsInput>
    upsert?: Enumerable<custodyEngineEventsUpsertWithWhereUniqueWithoutOrganizationsInput>
    createMany?: custodyEngineEventsCreateManyOrganizationsInputEnvelope
    set?: Enumerable<custodyEngineEventsWhereUniqueInput>
    disconnect?: Enumerable<custodyEngineEventsWhereUniqueInput>
    delete?: Enumerable<custodyEngineEventsWhereUniqueInput>
    connect?: Enumerable<custodyEngineEventsWhereUniqueInput>
    update?: Enumerable<custodyEngineEventsUpdateWithWhereUniqueWithoutOrganizationsInput>
    updateMany?: Enumerable<custodyEngineEventsUpdateManyWithWhereWithoutOrganizationsInput>
    deleteMany?: Enumerable<custodyEngineEventsScalarWhereInput>
  }

  export type pricingPlansUpdateOneRequiredWithoutOrganizationsNestedInput = {
    create?: XOR<pricingPlansCreateWithoutOrganizationsInput, pricingPlansUncheckedCreateWithoutOrganizationsInput>
    connectOrCreate?: pricingPlansCreateOrConnectWithoutOrganizationsInput
    upsert?: pricingPlansUpsertWithoutOrganizationsInput
    connect?: pricingPlansWhereUniqueInput
    update?: XOR<pricingPlansUpdateWithoutOrganizationsInput, pricingPlansUncheckedUpdateWithoutOrganizationsInput>
  }

  export type organizationStatusTypesUpdateOneRequiredWithoutOrganizationsNestedInput = {
    create?: XOR<organizationStatusTypesCreateWithoutOrganizationsInput, organizationStatusTypesUncheckedCreateWithoutOrganizationsInput>
    connectOrCreate?: organizationStatusTypesCreateOrConnectWithoutOrganizationsInput
    upsert?: organizationStatusTypesUpsertWithoutOrganizationsInput
    connect?: organizationStatusTypesWhereUniqueInput
    update?: XOR<organizationStatusTypesUpdateWithoutOrganizationsInput, organizationStatusTypesUncheckedUpdateWithoutOrganizationsInput>
  }

  export type usersUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<Enumerable<usersCreateWithoutOrganizationsInput>, Enumerable<usersUncheckedCreateWithoutOrganizationsInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutOrganizationsInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutOrganizationsInput>
    createMany?: usersCreateManyOrganizationsInputEnvelope
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    connect?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutOrganizationsInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutOrganizationsInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
  }

  export type webhooksUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<Enumerable<webhooksCreateWithoutOrganizationsInput>, Enumerable<webhooksUncheckedCreateWithoutOrganizationsInput>>
    connectOrCreate?: Enumerable<webhooksCreateOrConnectWithoutOrganizationsInput>
    upsert?: Enumerable<webhooksUpsertWithWhereUniqueWithoutOrganizationsInput>
    createMany?: webhooksCreateManyOrganizationsInputEnvelope
    set?: Enumerable<webhooksWhereUniqueInput>
    disconnect?: Enumerable<webhooksWhereUniqueInput>
    delete?: Enumerable<webhooksWhereUniqueInput>
    connect?: Enumerable<webhooksWhereUniqueInput>
    update?: Enumerable<webhooksUpdateWithWhereUniqueWithoutOrganizationsInput>
    updateMany?: Enumerable<webhooksUpdateManyWithWhereWithoutOrganizationsInput>
    deleteMany?: Enumerable<webhooksScalarWhereInput>
  }

  export type withdrawalAddressesUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<Enumerable<withdrawalAddressesCreateWithoutOrganizationsInput>, Enumerable<withdrawalAddressesUncheckedCreateWithoutOrganizationsInput>>
    connectOrCreate?: Enumerable<withdrawalAddressesCreateOrConnectWithoutOrganizationsInput>
    upsert?: Enumerable<withdrawalAddressesUpsertWithWhereUniqueWithoutOrganizationsInput>
    createMany?: withdrawalAddressesCreateManyOrganizationsInputEnvelope
    set?: Enumerable<withdrawalAddressesWhereUniqueInput>
    disconnect?: Enumerable<withdrawalAddressesWhereUniqueInput>
    delete?: Enumerable<withdrawalAddressesWhereUniqueInput>
    connect?: Enumerable<withdrawalAddressesWhereUniqueInput>
    update?: Enumerable<withdrawalAddressesUpdateWithWhereUniqueWithoutOrganizationsInput>
    updateMany?: Enumerable<withdrawalAddressesUpdateManyWithWhereWithoutOrganizationsInput>
    deleteMany?: Enumerable<withdrawalAddressesScalarWhereInput>
  }

  export type custodyEngineEventsUncheckedUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<Enumerable<custodyEngineEventsCreateWithoutOrganizationsInput>, Enumerable<custodyEngineEventsUncheckedCreateWithoutOrganizationsInput>>
    connectOrCreate?: Enumerable<custodyEngineEventsCreateOrConnectWithoutOrganizationsInput>
    upsert?: Enumerable<custodyEngineEventsUpsertWithWhereUniqueWithoutOrganizationsInput>
    createMany?: custodyEngineEventsCreateManyOrganizationsInputEnvelope
    set?: Enumerable<custodyEngineEventsWhereUniqueInput>
    disconnect?: Enumerable<custodyEngineEventsWhereUniqueInput>
    delete?: Enumerable<custodyEngineEventsWhereUniqueInput>
    connect?: Enumerable<custodyEngineEventsWhereUniqueInput>
    update?: Enumerable<custodyEngineEventsUpdateWithWhereUniqueWithoutOrganizationsInput>
    updateMany?: Enumerable<custodyEngineEventsUpdateManyWithWhereWithoutOrganizationsInput>
    deleteMany?: Enumerable<custodyEngineEventsScalarWhereInput>
  }

  export type usersUncheckedUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<Enumerable<usersCreateWithoutOrganizationsInput>, Enumerable<usersUncheckedCreateWithoutOrganizationsInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutOrganizationsInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutOrganizationsInput>
    createMany?: usersCreateManyOrganizationsInputEnvelope
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    connect?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutOrganizationsInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutOrganizationsInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
  }

  export type webhooksUncheckedUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<Enumerable<webhooksCreateWithoutOrganizationsInput>, Enumerable<webhooksUncheckedCreateWithoutOrganizationsInput>>
    connectOrCreate?: Enumerable<webhooksCreateOrConnectWithoutOrganizationsInput>
    upsert?: Enumerable<webhooksUpsertWithWhereUniqueWithoutOrganizationsInput>
    createMany?: webhooksCreateManyOrganizationsInputEnvelope
    set?: Enumerable<webhooksWhereUniqueInput>
    disconnect?: Enumerable<webhooksWhereUniqueInput>
    delete?: Enumerable<webhooksWhereUniqueInput>
    connect?: Enumerable<webhooksWhereUniqueInput>
    update?: Enumerable<webhooksUpdateWithWhereUniqueWithoutOrganizationsInput>
    updateMany?: Enumerable<webhooksUpdateManyWithWhereWithoutOrganizationsInput>
    deleteMany?: Enumerable<webhooksScalarWhereInput>
  }

  export type withdrawalAddressesUncheckedUpdateManyWithoutOrganizationsNestedInput = {
    create?: XOR<Enumerable<withdrawalAddressesCreateWithoutOrganizationsInput>, Enumerable<withdrawalAddressesUncheckedCreateWithoutOrganizationsInput>>
    connectOrCreate?: Enumerable<withdrawalAddressesCreateOrConnectWithoutOrganizationsInput>
    upsert?: Enumerable<withdrawalAddressesUpsertWithWhereUniqueWithoutOrganizationsInput>
    createMany?: withdrawalAddressesCreateManyOrganizationsInputEnvelope
    set?: Enumerable<withdrawalAddressesWhereUniqueInput>
    disconnect?: Enumerable<withdrawalAddressesWhereUniqueInput>
    delete?: Enumerable<withdrawalAddressesWhereUniqueInput>
    connect?: Enumerable<withdrawalAddressesWhereUniqueInput>
    update?: Enumerable<withdrawalAddressesUpdateWithWhereUniqueWithoutOrganizationsInput>
    updateMany?: Enumerable<withdrawalAddressesUpdateManyWithWhereWithoutOrganizationsInput>
    deleteMany?: Enumerable<withdrawalAddressesScalarWhereInput>
  }

  export type pricingPlansCreateNestedManyWithoutPricingPlanProfilesInput = {
    create?: XOR<Enumerable<pricingPlansCreateWithoutPricingPlanProfilesInput>, Enumerable<pricingPlansUncheckedCreateWithoutPricingPlanProfilesInput>>
    connectOrCreate?: Enumerable<pricingPlansCreateOrConnectWithoutPricingPlanProfilesInput>
    createMany?: pricingPlansCreateManyPricingPlanProfilesInputEnvelope
    connect?: Enumerable<pricingPlansWhereUniqueInput>
  }

  export type pricingPlansUncheckedCreateNestedManyWithoutPricingPlanProfilesInput = {
    create?: XOR<Enumerable<pricingPlansCreateWithoutPricingPlanProfilesInput>, Enumerable<pricingPlansUncheckedCreateWithoutPricingPlanProfilesInput>>
    connectOrCreate?: Enumerable<pricingPlansCreateOrConnectWithoutPricingPlanProfilesInput>
    createMany?: pricingPlansCreateManyPricingPlanProfilesInputEnvelope
    connect?: Enumerable<pricingPlansWhereUniqueInput>
  }

  export type pricingPlansUpdateManyWithoutPricingPlanProfilesNestedInput = {
    create?: XOR<Enumerable<pricingPlansCreateWithoutPricingPlanProfilesInput>, Enumerable<pricingPlansUncheckedCreateWithoutPricingPlanProfilesInput>>
    connectOrCreate?: Enumerable<pricingPlansCreateOrConnectWithoutPricingPlanProfilesInput>
    upsert?: Enumerable<pricingPlansUpsertWithWhereUniqueWithoutPricingPlanProfilesInput>
    createMany?: pricingPlansCreateManyPricingPlanProfilesInputEnvelope
    set?: Enumerable<pricingPlansWhereUniqueInput>
    disconnect?: Enumerable<pricingPlansWhereUniqueInput>
    delete?: Enumerable<pricingPlansWhereUniqueInput>
    connect?: Enumerable<pricingPlansWhereUniqueInput>
    update?: Enumerable<pricingPlansUpdateWithWhereUniqueWithoutPricingPlanProfilesInput>
    updateMany?: Enumerable<pricingPlansUpdateManyWithWhereWithoutPricingPlanProfilesInput>
    deleteMany?: Enumerable<pricingPlansScalarWhereInput>
  }

  export type pricingPlansUncheckedUpdateManyWithoutPricingPlanProfilesNestedInput = {
    create?: XOR<Enumerable<pricingPlansCreateWithoutPricingPlanProfilesInput>, Enumerable<pricingPlansUncheckedCreateWithoutPricingPlanProfilesInput>>
    connectOrCreate?: Enumerable<pricingPlansCreateOrConnectWithoutPricingPlanProfilesInput>
    upsert?: Enumerable<pricingPlansUpsertWithWhereUniqueWithoutPricingPlanProfilesInput>
    createMany?: pricingPlansCreateManyPricingPlanProfilesInputEnvelope
    set?: Enumerable<pricingPlansWhereUniqueInput>
    disconnect?: Enumerable<pricingPlansWhereUniqueInput>
    delete?: Enumerable<pricingPlansWhereUniqueInput>
    connect?: Enumerable<pricingPlansWhereUniqueInput>
    update?: Enumerable<pricingPlansUpdateWithWhereUniqueWithoutPricingPlanProfilesInput>
    updateMany?: Enumerable<pricingPlansUpdateManyWithWhereWithoutPricingPlanProfilesInput>
    deleteMany?: Enumerable<pricingPlansScalarWhereInput>
  }

  export type pricingPlansCreateNestedOneWithoutPricingPlanSupportsAssetsInput = {
    create?: XOR<pricingPlansCreateWithoutPricingPlanSupportsAssetsInput, pricingPlansUncheckedCreateWithoutPricingPlanSupportsAssetsInput>
    connectOrCreate?: pricingPlansCreateOrConnectWithoutPricingPlanSupportsAssetsInput
    connect?: pricingPlansWhereUniqueInput
  }

  export type vendorSupportsAssetsCreateNestedOneWithoutPricingPlanSupportsAssetsInput = {
    create?: XOR<vendorSupportsAssetsCreateWithoutPricingPlanSupportsAssetsInput, vendorSupportsAssetsUncheckedCreateWithoutPricingPlanSupportsAssetsInput>
    connectOrCreate?: vendorSupportsAssetsCreateOrConnectWithoutPricingPlanSupportsAssetsInput
    connect?: vendorSupportsAssetsWhereUniqueInput
  }

  export type pricingPlansUpdateOneRequiredWithoutPricingPlanSupportsAssetsNestedInput = {
    create?: XOR<pricingPlansCreateWithoutPricingPlanSupportsAssetsInput, pricingPlansUncheckedCreateWithoutPricingPlanSupportsAssetsInput>
    connectOrCreate?: pricingPlansCreateOrConnectWithoutPricingPlanSupportsAssetsInput
    upsert?: pricingPlansUpsertWithoutPricingPlanSupportsAssetsInput
    connect?: pricingPlansWhereUniqueInput
    update?: XOR<pricingPlansUpdateWithoutPricingPlanSupportsAssetsInput, pricingPlansUncheckedUpdateWithoutPricingPlanSupportsAssetsInput>
  }

  export type vendorSupportsAssetsUpdateOneRequiredWithoutPricingPlanSupportsAssetsNestedInput = {
    create?: XOR<vendorSupportsAssetsCreateWithoutPricingPlanSupportsAssetsInput, vendorSupportsAssetsUncheckedCreateWithoutPricingPlanSupportsAssetsInput>
    connectOrCreate?: vendorSupportsAssetsCreateOrConnectWithoutPricingPlanSupportsAssetsInput
    upsert?: vendorSupportsAssetsUpsertWithoutPricingPlanSupportsAssetsInput
    connect?: vendorSupportsAssetsWhereUniqueInput
    update?: XOR<vendorSupportsAssetsUpdateWithoutPricingPlanSupportsAssetsInput, vendorSupportsAssetsUncheckedUpdateWithoutPricingPlanSupportsAssetsInput>
  }

  export type organizationsCreateNestedManyWithoutPricingPlansInput = {
    create?: XOR<Enumerable<organizationsCreateWithoutPricingPlansInput>, Enumerable<organizationsUncheckedCreateWithoutPricingPlansInput>>
    connectOrCreate?: Enumerable<organizationsCreateOrConnectWithoutPricingPlansInput>
    createMany?: organizationsCreateManyPricingPlansInputEnvelope
    connect?: Enumerable<organizationsWhereUniqueInput>
  }

  export type pricingPlanSupportsAssetsCreateNestedManyWithoutPricingPlansInput = {
    create?: XOR<Enumerable<pricingPlanSupportsAssetsCreateWithoutPricingPlansInput>, Enumerable<pricingPlanSupportsAssetsUncheckedCreateWithoutPricingPlansInput>>
    connectOrCreate?: Enumerable<pricingPlanSupportsAssetsCreateOrConnectWithoutPricingPlansInput>
    createMany?: pricingPlanSupportsAssetsCreateManyPricingPlansInputEnvelope
    connect?: Enumerable<pricingPlanSupportsAssetsWhereUniqueInput>
  }

  export type pricingPlanProfilesCreateNestedOneWithoutPricingPlansInput = {
    create?: XOR<pricingPlanProfilesCreateWithoutPricingPlansInput, pricingPlanProfilesUncheckedCreateWithoutPricingPlansInput>
    connectOrCreate?: pricingPlanProfilesCreateOrConnectWithoutPricingPlansInput
    connect?: pricingPlanProfilesWhereUniqueInput
  }

  export type organizationsUncheckedCreateNestedManyWithoutPricingPlansInput = {
    create?: XOR<Enumerable<organizationsCreateWithoutPricingPlansInput>, Enumerable<organizationsUncheckedCreateWithoutPricingPlansInput>>
    connectOrCreate?: Enumerable<organizationsCreateOrConnectWithoutPricingPlansInput>
    createMany?: organizationsCreateManyPricingPlansInputEnvelope
    connect?: Enumerable<organizationsWhereUniqueInput>
  }

  export type pricingPlanSupportsAssetsUncheckedCreateNestedManyWithoutPricingPlansInput = {
    create?: XOR<Enumerable<pricingPlanSupportsAssetsCreateWithoutPricingPlansInput>, Enumerable<pricingPlanSupportsAssetsUncheckedCreateWithoutPricingPlansInput>>
    connectOrCreate?: Enumerable<pricingPlanSupportsAssetsCreateOrConnectWithoutPricingPlansInput>
    createMany?: pricingPlanSupportsAssetsCreateManyPricingPlansInputEnvelope
    connect?: Enumerable<pricingPlanSupportsAssetsWhereUniqueInput>
  }

  export type organizationsUpdateManyWithoutPricingPlansNestedInput = {
    create?: XOR<Enumerable<organizationsCreateWithoutPricingPlansInput>, Enumerable<organizationsUncheckedCreateWithoutPricingPlansInput>>
    connectOrCreate?: Enumerable<organizationsCreateOrConnectWithoutPricingPlansInput>
    upsert?: Enumerable<organizationsUpsertWithWhereUniqueWithoutPricingPlansInput>
    createMany?: organizationsCreateManyPricingPlansInputEnvelope
    set?: Enumerable<organizationsWhereUniqueInput>
    disconnect?: Enumerable<organizationsWhereUniqueInput>
    delete?: Enumerable<organizationsWhereUniqueInput>
    connect?: Enumerable<organizationsWhereUniqueInput>
    update?: Enumerable<organizationsUpdateWithWhereUniqueWithoutPricingPlansInput>
    updateMany?: Enumerable<organizationsUpdateManyWithWhereWithoutPricingPlansInput>
    deleteMany?: Enumerable<organizationsScalarWhereInput>
  }

  export type pricingPlanSupportsAssetsUpdateManyWithoutPricingPlansNestedInput = {
    create?: XOR<Enumerable<pricingPlanSupportsAssetsCreateWithoutPricingPlansInput>, Enumerable<pricingPlanSupportsAssetsUncheckedCreateWithoutPricingPlansInput>>
    connectOrCreate?: Enumerable<pricingPlanSupportsAssetsCreateOrConnectWithoutPricingPlansInput>
    upsert?: Enumerable<pricingPlanSupportsAssetsUpsertWithWhereUniqueWithoutPricingPlansInput>
    createMany?: pricingPlanSupportsAssetsCreateManyPricingPlansInputEnvelope
    set?: Enumerable<pricingPlanSupportsAssetsWhereUniqueInput>
    disconnect?: Enumerable<pricingPlanSupportsAssetsWhereUniqueInput>
    delete?: Enumerable<pricingPlanSupportsAssetsWhereUniqueInput>
    connect?: Enumerable<pricingPlanSupportsAssetsWhereUniqueInput>
    update?: Enumerable<pricingPlanSupportsAssetsUpdateWithWhereUniqueWithoutPricingPlansInput>
    updateMany?: Enumerable<pricingPlanSupportsAssetsUpdateManyWithWhereWithoutPricingPlansInput>
    deleteMany?: Enumerable<pricingPlanSupportsAssetsScalarWhereInput>
  }

  export type pricingPlanProfilesUpdateOneRequiredWithoutPricingPlansNestedInput = {
    create?: XOR<pricingPlanProfilesCreateWithoutPricingPlansInput, pricingPlanProfilesUncheckedCreateWithoutPricingPlansInput>
    connectOrCreate?: pricingPlanProfilesCreateOrConnectWithoutPricingPlansInput
    upsert?: pricingPlanProfilesUpsertWithoutPricingPlansInput
    connect?: pricingPlanProfilesWhereUniqueInput
    update?: XOR<pricingPlanProfilesUpdateWithoutPricingPlansInput, pricingPlanProfilesUncheckedUpdateWithoutPricingPlansInput>
  }

  export type organizationsUncheckedUpdateManyWithoutPricingPlansNestedInput = {
    create?: XOR<Enumerable<organizationsCreateWithoutPricingPlansInput>, Enumerable<organizationsUncheckedCreateWithoutPricingPlansInput>>
    connectOrCreate?: Enumerable<organizationsCreateOrConnectWithoutPricingPlansInput>
    upsert?: Enumerable<organizationsUpsertWithWhereUniqueWithoutPricingPlansInput>
    createMany?: organizationsCreateManyPricingPlansInputEnvelope
    set?: Enumerable<organizationsWhereUniqueInput>
    disconnect?: Enumerable<organizationsWhereUniqueInput>
    delete?: Enumerable<organizationsWhereUniqueInput>
    connect?: Enumerable<organizationsWhereUniqueInput>
    update?: Enumerable<organizationsUpdateWithWhereUniqueWithoutPricingPlansInput>
    updateMany?: Enumerable<organizationsUpdateManyWithWhereWithoutPricingPlansInput>
    deleteMany?: Enumerable<organizationsScalarWhereInput>
  }

  export type pricingPlanSupportsAssetsUncheckedUpdateManyWithoutPricingPlansNestedInput = {
    create?: XOR<Enumerable<pricingPlanSupportsAssetsCreateWithoutPricingPlansInput>, Enumerable<pricingPlanSupportsAssetsUncheckedCreateWithoutPricingPlansInput>>
    connectOrCreate?: Enumerable<pricingPlanSupportsAssetsCreateOrConnectWithoutPricingPlansInput>
    upsert?: Enumerable<pricingPlanSupportsAssetsUpsertWithWhereUniqueWithoutPricingPlansInput>
    createMany?: pricingPlanSupportsAssetsCreateManyPricingPlansInputEnvelope
    set?: Enumerable<pricingPlanSupportsAssetsWhereUniqueInput>
    disconnect?: Enumerable<pricingPlanSupportsAssetsWhereUniqueInput>
    delete?: Enumerable<pricingPlanSupportsAssetsWhereUniqueInput>
    connect?: Enumerable<pricingPlanSupportsAssetsWhereUniqueInput>
    update?: Enumerable<pricingPlanSupportsAssetsUpdateWithWhereUniqueWithoutPricingPlansInput>
    updateMany?: Enumerable<pricingPlanSupportsAssetsUpdateManyWithWhereWithoutPricingPlansInput>
    deleteMany?: Enumerable<pricingPlanSupportsAssetsScalarWhereInput>
  }

  export type quotesCreateNestedManyWithoutQuoteStatusesInput = {
    create?: XOR<Enumerable<quotesCreateWithoutQuoteStatusesInput>, Enumerable<quotesUncheckedCreateWithoutQuoteStatusesInput>>
    connectOrCreate?: Enumerable<quotesCreateOrConnectWithoutQuoteStatusesInput>
    createMany?: quotesCreateManyQuoteStatusesInputEnvelope
    connect?: Enumerable<quotesWhereUniqueInput>
  }

  export type quotesUncheckedCreateNestedManyWithoutQuoteStatusesInput = {
    create?: XOR<Enumerable<quotesCreateWithoutQuoteStatusesInput>, Enumerable<quotesUncheckedCreateWithoutQuoteStatusesInput>>
    connectOrCreate?: Enumerable<quotesCreateOrConnectWithoutQuoteStatusesInput>
    createMany?: quotesCreateManyQuoteStatusesInputEnvelope
    connect?: Enumerable<quotesWhereUniqueInput>
  }

  export type quotesUpdateManyWithoutQuoteStatusesNestedInput = {
    create?: XOR<Enumerable<quotesCreateWithoutQuoteStatusesInput>, Enumerable<quotesUncheckedCreateWithoutQuoteStatusesInput>>
    connectOrCreate?: Enumerable<quotesCreateOrConnectWithoutQuoteStatusesInput>
    upsert?: Enumerable<quotesUpsertWithWhereUniqueWithoutQuoteStatusesInput>
    createMany?: quotesCreateManyQuoteStatusesInputEnvelope
    set?: Enumerable<quotesWhereUniqueInput>
    disconnect?: Enumerable<quotesWhereUniqueInput>
    delete?: Enumerable<quotesWhereUniqueInput>
    connect?: Enumerable<quotesWhereUniqueInput>
    update?: Enumerable<quotesUpdateWithWhereUniqueWithoutQuoteStatusesInput>
    updateMany?: Enumerable<quotesUpdateManyWithWhereWithoutQuoteStatusesInput>
    deleteMany?: Enumerable<quotesScalarWhereInput>
  }

  export type quotesUncheckedUpdateManyWithoutQuoteStatusesNestedInput = {
    create?: XOR<Enumerable<quotesCreateWithoutQuoteStatusesInput>, Enumerable<quotesUncheckedCreateWithoutQuoteStatusesInput>>
    connectOrCreate?: Enumerable<quotesCreateOrConnectWithoutQuoteStatusesInput>
    upsert?: Enumerable<quotesUpsertWithWhereUniqueWithoutQuoteStatusesInput>
    createMany?: quotesCreateManyQuoteStatusesInputEnvelope
    set?: Enumerable<quotesWhereUniqueInput>
    disconnect?: Enumerable<quotesWhereUniqueInput>
    delete?: Enumerable<quotesWhereUniqueInput>
    connect?: Enumerable<quotesWhereUniqueInput>
    update?: Enumerable<quotesUpdateWithWhereUniqueWithoutQuoteStatusesInput>
    updateMany?: Enumerable<quotesUpdateManyWithWhereWithoutQuoteStatusesInput>
    deleteMany?: Enumerable<quotesScalarWhereInput>
  }

  export type vendorsCreateNestedOneWithoutTokenPairsInput = {
    create?: XOR<vendorsCreateWithoutTokenPairsInput, vendorsUncheckedCreateWithoutTokenPairsInput>
    connectOrCreate?: vendorsCreateOrConnectWithoutTokenPairsInput
    connect?: vendorsWhereUniqueInput
  }

  export type tokenPairsInfoCreateNestedManyWithoutTokenPairsInput = {
    create?: XOR<Enumerable<tokenPairsInfoCreateWithoutTokenPairsInput>, Enumerable<tokenPairsInfoUncheckedCreateWithoutTokenPairsInput>>
    connectOrCreate?: Enumerable<tokenPairsInfoCreateOrConnectWithoutTokenPairsInput>
    createMany?: tokenPairsInfoCreateManyTokenPairsInputEnvelope
    connect?: Enumerable<tokenPairsInfoWhereUniqueInput>
  }

  export type tokenPairsInfoUncheckedCreateNestedManyWithoutTokenPairsInput = {
    create?: XOR<Enumerable<tokenPairsInfoCreateWithoutTokenPairsInput>, Enumerable<tokenPairsInfoUncheckedCreateWithoutTokenPairsInput>>
    connectOrCreate?: Enumerable<tokenPairsInfoCreateOrConnectWithoutTokenPairsInput>
    createMany?: tokenPairsInfoCreateManyTokenPairsInputEnvelope
    connect?: Enumerable<tokenPairsInfoWhereUniqueInput>
  }

  export type vendorsUpdateOneRequiredWithoutTokenPairsNestedInput = {
    create?: XOR<vendorsCreateWithoutTokenPairsInput, vendorsUncheckedCreateWithoutTokenPairsInput>
    connectOrCreate?: vendorsCreateOrConnectWithoutTokenPairsInput
    upsert?: vendorsUpsertWithoutTokenPairsInput
    connect?: vendorsWhereUniqueInput
    update?: XOR<vendorsUpdateWithoutTokenPairsInput, vendorsUncheckedUpdateWithoutTokenPairsInput>
  }

  export type tokenPairsInfoUpdateManyWithoutTokenPairsNestedInput = {
    create?: XOR<Enumerable<tokenPairsInfoCreateWithoutTokenPairsInput>, Enumerable<tokenPairsInfoUncheckedCreateWithoutTokenPairsInput>>
    connectOrCreate?: Enumerable<tokenPairsInfoCreateOrConnectWithoutTokenPairsInput>
    upsert?: Enumerable<tokenPairsInfoUpsertWithWhereUniqueWithoutTokenPairsInput>
    createMany?: tokenPairsInfoCreateManyTokenPairsInputEnvelope
    set?: Enumerable<tokenPairsInfoWhereUniqueInput>
    disconnect?: Enumerable<tokenPairsInfoWhereUniqueInput>
    delete?: Enumerable<tokenPairsInfoWhereUniqueInput>
    connect?: Enumerable<tokenPairsInfoWhereUniqueInput>
    update?: Enumerable<tokenPairsInfoUpdateWithWhereUniqueWithoutTokenPairsInput>
    updateMany?: Enumerable<tokenPairsInfoUpdateManyWithWhereWithoutTokenPairsInput>
    deleteMany?: Enumerable<tokenPairsInfoScalarWhereInput>
  }

  export type tokenPairsInfoUncheckedUpdateManyWithoutTokenPairsNestedInput = {
    create?: XOR<Enumerable<tokenPairsInfoCreateWithoutTokenPairsInput>, Enumerable<tokenPairsInfoUncheckedCreateWithoutTokenPairsInput>>
    connectOrCreate?: Enumerable<tokenPairsInfoCreateOrConnectWithoutTokenPairsInput>
    upsert?: Enumerable<tokenPairsInfoUpsertWithWhereUniqueWithoutTokenPairsInput>
    createMany?: tokenPairsInfoCreateManyTokenPairsInputEnvelope
    set?: Enumerable<tokenPairsInfoWhereUniqueInput>
    disconnect?: Enumerable<tokenPairsInfoWhereUniqueInput>
    delete?: Enumerable<tokenPairsInfoWhereUniqueInput>
    connect?: Enumerable<tokenPairsInfoWhereUniqueInput>
    update?: Enumerable<tokenPairsInfoUpdateWithWhereUniqueWithoutTokenPairsInput>
    updateMany?: Enumerable<tokenPairsInfoUpdateManyWithWhereWithoutTokenPairsInput>
    deleteMany?: Enumerable<tokenPairsInfoScalarWhereInput>
  }

  export type quotesCreateNestedManyWithoutTokenPairsInfoInput = {
    create?: XOR<Enumerable<quotesCreateWithoutTokenPairsInfoInput>, Enumerable<quotesUncheckedCreateWithoutTokenPairsInfoInput>>
    connectOrCreate?: Enumerable<quotesCreateOrConnectWithoutTokenPairsInfoInput>
    createMany?: quotesCreateManyTokenPairsInfoInputEnvelope
    connect?: Enumerable<quotesWhereUniqueInput>
  }

  export type tokenPairsCreateNestedOneWithoutTokenPairsInfoInput = {
    create?: XOR<tokenPairsCreateWithoutTokenPairsInfoInput, tokenPairsUncheckedCreateWithoutTokenPairsInfoInput>
    connectOrCreate?: tokenPairsCreateOrConnectWithoutTokenPairsInfoInput
    connect?: tokenPairsWhereUniqueInput
  }

  export type quotesUncheckedCreateNestedManyWithoutTokenPairsInfoInput = {
    create?: XOR<Enumerable<quotesCreateWithoutTokenPairsInfoInput>, Enumerable<quotesUncheckedCreateWithoutTokenPairsInfoInput>>
    connectOrCreate?: Enumerable<quotesCreateOrConnectWithoutTokenPairsInfoInput>
    createMany?: quotesCreateManyTokenPairsInfoInputEnvelope
    connect?: Enumerable<quotesWhereUniqueInput>
  }

  export type quotesUpdateManyWithoutTokenPairsInfoNestedInput = {
    create?: XOR<Enumerable<quotesCreateWithoutTokenPairsInfoInput>, Enumerable<quotesUncheckedCreateWithoutTokenPairsInfoInput>>
    connectOrCreate?: Enumerable<quotesCreateOrConnectWithoutTokenPairsInfoInput>
    upsert?: Enumerable<quotesUpsertWithWhereUniqueWithoutTokenPairsInfoInput>
    createMany?: quotesCreateManyTokenPairsInfoInputEnvelope
    set?: Enumerable<quotesWhereUniqueInput>
    disconnect?: Enumerable<quotesWhereUniqueInput>
    delete?: Enumerable<quotesWhereUniqueInput>
    connect?: Enumerable<quotesWhereUniqueInput>
    update?: Enumerable<quotesUpdateWithWhereUniqueWithoutTokenPairsInfoInput>
    updateMany?: Enumerable<quotesUpdateManyWithWhereWithoutTokenPairsInfoInput>
    deleteMany?: Enumerable<quotesScalarWhereInput>
  }

  export type tokenPairsUpdateOneRequiredWithoutTokenPairsInfoNestedInput = {
    create?: XOR<tokenPairsCreateWithoutTokenPairsInfoInput, tokenPairsUncheckedCreateWithoutTokenPairsInfoInput>
    connectOrCreate?: tokenPairsCreateOrConnectWithoutTokenPairsInfoInput
    upsert?: tokenPairsUpsertWithoutTokenPairsInfoInput
    connect?: tokenPairsWhereUniqueInput
    update?: XOR<tokenPairsUpdateWithoutTokenPairsInfoInput, tokenPairsUncheckedUpdateWithoutTokenPairsInfoInput>
  }

  export type quotesUncheckedUpdateManyWithoutTokenPairsInfoNestedInput = {
    create?: XOR<Enumerable<quotesCreateWithoutTokenPairsInfoInput>, Enumerable<quotesUncheckedCreateWithoutTokenPairsInfoInput>>
    connectOrCreate?: Enumerable<quotesCreateOrConnectWithoutTokenPairsInfoInput>
    upsert?: Enumerable<quotesUpsertWithWhereUniqueWithoutTokenPairsInfoInput>
    createMany?: quotesCreateManyTokenPairsInfoInputEnvelope
    set?: Enumerable<quotesWhereUniqueInput>
    disconnect?: Enumerable<quotesWhereUniqueInput>
    delete?: Enumerable<quotesWhereUniqueInput>
    connect?: Enumerable<quotesWhereUniqueInput>
    update?: Enumerable<quotesUpdateWithWhereUniqueWithoutTokenPairsInfoInput>
    updateMany?: Enumerable<quotesUpdateManyWithWhereWithoutTokenPairsInfoInput>
    deleteMany?: Enumerable<quotesScalarWhereInput>
  }

  export type assetsCreateNestedOneWithoutTransactionPoliciesInput = {
    create?: XOR<assetsCreateWithoutTransactionPoliciesInput, assetsUncheckedCreateWithoutTransactionPoliciesInput>
    connectOrCreate?: assetsCreateOrConnectWithoutTransactionPoliciesInput
    connect?: assetsWhereUniqueInput
  }

  export type vaultsCreateNestedOneWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput = {
    create?: XOR<vaultsCreateWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput, vaultsUncheckedCreateWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput>
    connectOrCreate?: vaultsCreateOrConnectWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput
    connect?: vaultsWhereUniqueInput
  }

  export type vaultsCreateNestedOneWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput = {
    create?: XOR<vaultsCreateWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput, vaultsUncheckedCreateWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput>
    connectOrCreate?: vaultsCreateOrConnectWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput
    connect?: vaultsWhereUniqueInput
  }

  export type withdrawalAddressesCreateNestedOneWithoutTransactionPoliciesInput = {
    create?: XOR<withdrawalAddressesCreateWithoutTransactionPoliciesInput, withdrawalAddressesUncheckedCreateWithoutTransactionPoliciesInput>
    connectOrCreate?: withdrawalAddressesCreateOrConnectWithoutTransactionPoliciesInput
    connect?: withdrawalAddressesWhereUniqueInput
  }

  export type transactionTypesCreateNestedOneWithoutTransactionPoliciesInput = {
    create?: XOR<transactionTypesCreateWithoutTransactionPoliciesInput, transactionTypesUncheckedCreateWithoutTransactionPoliciesInput>
    connectOrCreate?: transactionTypesCreateOrConnectWithoutTransactionPoliciesInput
    connect?: transactionTypesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutTransactionPoliciesInput = {
    create?: XOR<usersCreateWithoutTransactionPoliciesInput, usersUncheckedCreateWithoutTransactionPoliciesInput>
    connectOrCreate?: usersCreateOrConnectWithoutTransactionPoliciesInput
    connect?: usersWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type Enumenum_transactionPolicies_actionFieldUpdateOperationsInput = {
    set?: enum_transactionPolicies_action
  }

  export type assetsUpdateOneRequiredWithoutTransactionPoliciesNestedInput = {
    create?: XOR<assetsCreateWithoutTransactionPoliciesInput, assetsUncheckedCreateWithoutTransactionPoliciesInput>
    connectOrCreate?: assetsCreateOrConnectWithoutTransactionPoliciesInput
    upsert?: assetsUpsertWithoutTransactionPoliciesInput
    connect?: assetsWhereUniqueInput
    update?: XOR<assetsUpdateWithoutTransactionPoliciesInput, assetsUncheckedUpdateWithoutTransactionPoliciesInput>
  }

  export type vaultsUpdateOneRequiredWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsNestedInput = {
    create?: XOR<vaultsCreateWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput, vaultsUncheckedCreateWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput>
    connectOrCreate?: vaultsCreateOrConnectWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput
    upsert?: vaultsUpsertWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput
    connect?: vaultsWhereUniqueInput
    update?: XOR<vaultsUpdateWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput, vaultsUncheckedUpdateWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput>
  }

  export type vaultsUpdateOneWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsNestedInput = {
    create?: XOR<vaultsCreateWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput, vaultsUncheckedCreateWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput>
    connectOrCreate?: vaultsCreateOrConnectWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput
    upsert?: vaultsUpsertWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput
    disconnect?: boolean
    delete?: boolean
    connect?: vaultsWhereUniqueInput
    update?: XOR<vaultsUpdateWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput, vaultsUncheckedUpdateWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput>
  }

  export type withdrawalAddressesUpdateOneWithoutTransactionPoliciesNestedInput = {
    create?: XOR<withdrawalAddressesCreateWithoutTransactionPoliciesInput, withdrawalAddressesUncheckedCreateWithoutTransactionPoliciesInput>
    connectOrCreate?: withdrawalAddressesCreateOrConnectWithoutTransactionPoliciesInput
    upsert?: withdrawalAddressesUpsertWithoutTransactionPoliciesInput
    disconnect?: boolean
    delete?: boolean
    connect?: withdrawalAddressesWhereUniqueInput
    update?: XOR<withdrawalAddressesUpdateWithoutTransactionPoliciesInput, withdrawalAddressesUncheckedUpdateWithoutTransactionPoliciesInput>
  }

  export type transactionTypesUpdateOneRequiredWithoutTransactionPoliciesNestedInput = {
    create?: XOR<transactionTypesCreateWithoutTransactionPoliciesInput, transactionTypesUncheckedCreateWithoutTransactionPoliciesInput>
    connectOrCreate?: transactionTypesCreateOrConnectWithoutTransactionPoliciesInput
    upsert?: transactionTypesUpsertWithoutTransactionPoliciesInput
    connect?: transactionTypesWhereUniqueInput
    update?: XOR<transactionTypesUpdateWithoutTransactionPoliciesInput, transactionTypesUncheckedUpdateWithoutTransactionPoliciesInput>
  }

  export type usersUpdateOneRequiredWithoutTransactionPoliciesNestedInput = {
    create?: XOR<usersCreateWithoutTransactionPoliciesInput, usersUncheckedCreateWithoutTransactionPoliciesInput>
    connectOrCreate?: usersCreateOrConnectWithoutTransactionPoliciesInput
    upsert?: usersUpsertWithoutTransactionPoliciesInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutTransactionPoliciesInput, usersUncheckedUpdateWithoutTransactionPoliciesInput>
  }

  export type usersCreateNestedManyWithoutUserTypesInput = {
    create?: XOR<Enumerable<usersCreateWithoutUserTypesInput>, Enumerable<usersUncheckedCreateWithoutUserTypesInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutUserTypesInput>
    createMany?: usersCreateManyUserTypesInputEnvelope
    connect?: Enumerable<usersWhereUniqueInput>
  }

  export type usersUncheckedCreateNestedManyWithoutUserTypesInput = {
    create?: XOR<Enumerable<usersCreateWithoutUserTypesInput>, Enumerable<usersUncheckedCreateWithoutUserTypesInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutUserTypesInput>
    createMany?: usersCreateManyUserTypesInputEnvelope
    connect?: Enumerable<usersWhereUniqueInput>
  }

  export type usersUpdateManyWithoutUserTypesNestedInput = {
    create?: XOR<Enumerable<usersCreateWithoutUserTypesInput>, Enumerable<usersUncheckedCreateWithoutUserTypesInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutUserTypesInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutUserTypesInput>
    createMany?: usersCreateManyUserTypesInputEnvelope
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    connect?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutUserTypesInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutUserTypesInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
  }

  export type usersUncheckedUpdateManyWithoutUserTypesNestedInput = {
    create?: XOR<Enumerable<usersCreateWithoutUserTypesInput>, Enumerable<usersUncheckedCreateWithoutUserTypesInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutUserTypesInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutUserTypesInput>
    createMany?: usersCreateManyUserTypesInputEnvelope
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    connect?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutUserTypesInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutUserTypesInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
  }

  export type custodyVendorVaultAssetsCreateNestedManyWithoutVaultAssetsInput = {
    create?: XOR<Enumerable<custodyVendorVaultAssetsCreateWithoutVaultAssetsInput>, Enumerable<custodyVendorVaultAssetsUncheckedCreateWithoutVaultAssetsInput>>
    connectOrCreate?: Enumerable<custodyVendorVaultAssetsCreateOrConnectWithoutVaultAssetsInput>
    createMany?: custodyVendorVaultAssetsCreateManyVaultAssetsInputEnvelope
    connect?: Enumerable<custodyVendorVaultAssetsWhereUniqueInput>
  }

  export type depositAddressesCreateNestedManyWithoutVaultAssetsInput = {
    create?: XOR<Enumerable<depositAddressesCreateWithoutVaultAssetsInput>, Enumerable<depositAddressesUncheckedCreateWithoutVaultAssetsInput>>
    connectOrCreate?: Enumerable<depositAddressesCreateOrConnectWithoutVaultAssetsInput>
    createMany?: depositAddressesCreateManyVaultAssetsInputEnvelope
    connect?: Enumerable<depositAddressesWhereUniqueInput>
  }

  export type assetsCreateNestedOneWithoutVaultAssetsInput = {
    create?: XOR<assetsCreateWithoutVaultAssetsInput, assetsUncheckedCreateWithoutVaultAssetsInput>
    connectOrCreate?: assetsCreateOrConnectWithoutVaultAssetsInput
    connect?: assetsWhereUniqueInput
  }

  export type vaultsCreateNestedOneWithoutVaultAssetsInput = {
    create?: XOR<vaultsCreateWithoutVaultAssetsInput, vaultsUncheckedCreateWithoutVaultAssetsInput>
    connectOrCreate?: vaultsCreateOrConnectWithoutVaultAssetsInput
    connect?: vaultsWhereUniqueInput
  }

  export type custodyVendorVaultAssetsUncheckedCreateNestedManyWithoutVaultAssetsInput = {
    create?: XOR<Enumerable<custodyVendorVaultAssetsCreateWithoutVaultAssetsInput>, Enumerable<custodyVendorVaultAssetsUncheckedCreateWithoutVaultAssetsInput>>
    connectOrCreate?: Enumerable<custodyVendorVaultAssetsCreateOrConnectWithoutVaultAssetsInput>
    createMany?: custodyVendorVaultAssetsCreateManyVaultAssetsInputEnvelope
    connect?: Enumerable<custodyVendorVaultAssetsWhereUniqueInput>
  }

  export type depositAddressesUncheckedCreateNestedManyWithoutVaultAssetsInput = {
    create?: XOR<Enumerable<depositAddressesCreateWithoutVaultAssetsInput>, Enumerable<depositAddressesUncheckedCreateWithoutVaultAssetsInput>>
    connectOrCreate?: Enumerable<depositAddressesCreateOrConnectWithoutVaultAssetsInput>
    createMany?: depositAddressesCreateManyVaultAssetsInputEnvelope
    connect?: Enumerable<depositAddressesWhereUniqueInput>
  }

  export type custodyVendorVaultAssetsUpdateManyWithoutVaultAssetsNestedInput = {
    create?: XOR<Enumerable<custodyVendorVaultAssetsCreateWithoutVaultAssetsInput>, Enumerable<custodyVendorVaultAssetsUncheckedCreateWithoutVaultAssetsInput>>
    connectOrCreate?: Enumerable<custodyVendorVaultAssetsCreateOrConnectWithoutVaultAssetsInput>
    upsert?: Enumerable<custodyVendorVaultAssetsUpsertWithWhereUniqueWithoutVaultAssetsInput>
    createMany?: custodyVendorVaultAssetsCreateManyVaultAssetsInputEnvelope
    set?: Enumerable<custodyVendorVaultAssetsWhereUniqueInput>
    disconnect?: Enumerable<custodyVendorVaultAssetsWhereUniqueInput>
    delete?: Enumerable<custodyVendorVaultAssetsWhereUniqueInput>
    connect?: Enumerable<custodyVendorVaultAssetsWhereUniqueInput>
    update?: Enumerable<custodyVendorVaultAssetsUpdateWithWhereUniqueWithoutVaultAssetsInput>
    updateMany?: Enumerable<custodyVendorVaultAssetsUpdateManyWithWhereWithoutVaultAssetsInput>
    deleteMany?: Enumerable<custodyVendorVaultAssetsScalarWhereInput>
  }

  export type depositAddressesUpdateManyWithoutVaultAssetsNestedInput = {
    create?: XOR<Enumerable<depositAddressesCreateWithoutVaultAssetsInput>, Enumerable<depositAddressesUncheckedCreateWithoutVaultAssetsInput>>
    connectOrCreate?: Enumerable<depositAddressesCreateOrConnectWithoutVaultAssetsInput>
    upsert?: Enumerable<depositAddressesUpsertWithWhereUniqueWithoutVaultAssetsInput>
    createMany?: depositAddressesCreateManyVaultAssetsInputEnvelope
    set?: Enumerable<depositAddressesWhereUniqueInput>
    disconnect?: Enumerable<depositAddressesWhereUniqueInput>
    delete?: Enumerable<depositAddressesWhereUniqueInput>
    connect?: Enumerable<depositAddressesWhereUniqueInput>
    update?: Enumerable<depositAddressesUpdateWithWhereUniqueWithoutVaultAssetsInput>
    updateMany?: Enumerable<depositAddressesUpdateManyWithWhereWithoutVaultAssetsInput>
    deleteMany?: Enumerable<depositAddressesScalarWhereInput>
  }

  export type assetsUpdateOneRequiredWithoutVaultAssetsNestedInput = {
    create?: XOR<assetsCreateWithoutVaultAssetsInput, assetsUncheckedCreateWithoutVaultAssetsInput>
    connectOrCreate?: assetsCreateOrConnectWithoutVaultAssetsInput
    upsert?: assetsUpsertWithoutVaultAssetsInput
    connect?: assetsWhereUniqueInput
    update?: XOR<assetsUpdateWithoutVaultAssetsInput, assetsUncheckedUpdateWithoutVaultAssetsInput>
  }

  export type vaultsUpdateOneRequiredWithoutVaultAssetsNestedInput = {
    create?: XOR<vaultsCreateWithoutVaultAssetsInput, vaultsUncheckedCreateWithoutVaultAssetsInput>
    connectOrCreate?: vaultsCreateOrConnectWithoutVaultAssetsInput
    upsert?: vaultsUpsertWithoutVaultAssetsInput
    connect?: vaultsWhereUniqueInput
    update?: XOR<vaultsUpdateWithoutVaultAssetsInput, vaultsUncheckedUpdateWithoutVaultAssetsInput>
  }

  export type custodyVendorVaultAssetsUncheckedUpdateManyWithoutVaultAssetsNestedInput = {
    create?: XOR<Enumerable<custodyVendorVaultAssetsCreateWithoutVaultAssetsInput>, Enumerable<custodyVendorVaultAssetsUncheckedCreateWithoutVaultAssetsInput>>
    connectOrCreate?: Enumerable<custodyVendorVaultAssetsCreateOrConnectWithoutVaultAssetsInput>
    upsert?: Enumerable<custodyVendorVaultAssetsUpsertWithWhereUniqueWithoutVaultAssetsInput>
    createMany?: custodyVendorVaultAssetsCreateManyVaultAssetsInputEnvelope
    set?: Enumerable<custodyVendorVaultAssetsWhereUniqueInput>
    disconnect?: Enumerable<custodyVendorVaultAssetsWhereUniqueInput>
    delete?: Enumerable<custodyVendorVaultAssetsWhereUniqueInput>
    connect?: Enumerable<custodyVendorVaultAssetsWhereUniqueInput>
    update?: Enumerable<custodyVendorVaultAssetsUpdateWithWhereUniqueWithoutVaultAssetsInput>
    updateMany?: Enumerable<custodyVendorVaultAssetsUpdateManyWithWhereWithoutVaultAssetsInput>
    deleteMany?: Enumerable<custodyVendorVaultAssetsScalarWhereInput>
  }

  export type depositAddressesUncheckedUpdateManyWithoutVaultAssetsNestedInput = {
    create?: XOR<Enumerable<depositAddressesCreateWithoutVaultAssetsInput>, Enumerable<depositAddressesUncheckedCreateWithoutVaultAssetsInput>>
    connectOrCreate?: Enumerable<depositAddressesCreateOrConnectWithoutVaultAssetsInput>
    upsert?: Enumerable<depositAddressesUpsertWithWhereUniqueWithoutVaultAssetsInput>
    createMany?: depositAddressesCreateManyVaultAssetsInputEnvelope
    set?: Enumerable<depositAddressesWhereUniqueInput>
    disconnect?: Enumerable<depositAddressesWhereUniqueInput>
    delete?: Enumerable<depositAddressesWhereUniqueInput>
    connect?: Enumerable<depositAddressesWhereUniqueInput>
    update?: Enumerable<depositAddressesUpdateWithWhereUniqueWithoutVaultAssetsInput>
    updateMany?: Enumerable<depositAddressesUpdateManyWithWhereWithoutVaultAssetsInput>
    deleteMany?: Enumerable<depositAddressesScalarWhereInput>
  }

  export type vaultsCreateNestedManyWithoutVaultStatusTypesInput = {
    create?: XOR<Enumerable<vaultsCreateWithoutVaultStatusTypesInput>, Enumerable<vaultsUncheckedCreateWithoutVaultStatusTypesInput>>
    connectOrCreate?: Enumerable<vaultsCreateOrConnectWithoutVaultStatusTypesInput>
    createMany?: vaultsCreateManyVaultStatusTypesInputEnvelope
    connect?: Enumerable<vaultsWhereUniqueInput>
  }

  export type vaultsUncheckedCreateNestedManyWithoutVaultStatusTypesInput = {
    create?: XOR<Enumerable<vaultsCreateWithoutVaultStatusTypesInput>, Enumerable<vaultsUncheckedCreateWithoutVaultStatusTypesInput>>
    connectOrCreate?: Enumerable<vaultsCreateOrConnectWithoutVaultStatusTypesInput>
    createMany?: vaultsCreateManyVaultStatusTypesInputEnvelope
    connect?: Enumerable<vaultsWhereUniqueInput>
  }

  export type vaultsUpdateManyWithoutVaultStatusTypesNestedInput = {
    create?: XOR<Enumerable<vaultsCreateWithoutVaultStatusTypesInput>, Enumerable<vaultsUncheckedCreateWithoutVaultStatusTypesInput>>
    connectOrCreate?: Enumerable<vaultsCreateOrConnectWithoutVaultStatusTypesInput>
    upsert?: Enumerable<vaultsUpsertWithWhereUniqueWithoutVaultStatusTypesInput>
    createMany?: vaultsCreateManyVaultStatusTypesInputEnvelope
    set?: Enumerable<vaultsWhereUniqueInput>
    disconnect?: Enumerable<vaultsWhereUniqueInput>
    delete?: Enumerable<vaultsWhereUniqueInput>
    connect?: Enumerable<vaultsWhereUniqueInput>
    update?: Enumerable<vaultsUpdateWithWhereUniqueWithoutVaultStatusTypesInput>
    updateMany?: Enumerable<vaultsUpdateManyWithWhereWithoutVaultStatusTypesInput>
    deleteMany?: Enumerable<vaultsScalarWhereInput>
  }

  export type vaultsUncheckedUpdateManyWithoutVaultStatusTypesNestedInput = {
    create?: XOR<Enumerable<vaultsCreateWithoutVaultStatusTypesInput>, Enumerable<vaultsUncheckedCreateWithoutVaultStatusTypesInput>>
    connectOrCreate?: Enumerable<vaultsCreateOrConnectWithoutVaultStatusTypesInput>
    upsert?: Enumerable<vaultsUpsertWithWhereUniqueWithoutVaultStatusTypesInput>
    createMany?: vaultsCreateManyVaultStatusTypesInputEnvelope
    set?: Enumerable<vaultsWhereUniqueInput>
    disconnect?: Enumerable<vaultsWhereUniqueInput>
    delete?: Enumerable<vaultsWhereUniqueInput>
    connect?: Enumerable<vaultsWhereUniqueInput>
    update?: Enumerable<vaultsUpdateWithWhereUniqueWithoutVaultStatusTypesInput>
    updateMany?: Enumerable<vaultsUpdateManyWithWhereWithoutVaultStatusTypesInput>
    deleteMany?: Enumerable<vaultsScalarWhereInput>
  }

  export type transactionPoliciesCreateNestedManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput = {
    create?: XOR<Enumerable<transactionPoliciesCreateWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput>, Enumerable<transactionPoliciesUncheckedCreateWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput>>
    connectOrCreate?: Enumerable<transactionPoliciesCreateOrConnectWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput>
    createMany?: transactionPoliciesCreateManyVaults_transactionPolicies_sourceVaultIdTovaultsInputEnvelope
    connect?: Enumerable<transactionPoliciesWhereUniqueInput>
  }

  export type transactionPoliciesCreateNestedManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput = {
    create?: XOR<Enumerable<transactionPoliciesCreateWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput>, Enumerable<transactionPoliciesUncheckedCreateWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput>>
    connectOrCreate?: Enumerable<transactionPoliciesCreateOrConnectWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput>
    createMany?: transactionPoliciesCreateManyVaults_transactionPolicies_targetVaultIdTovaultsInputEnvelope
    connect?: Enumerable<transactionPoliciesWhereUniqueInput>
  }

  export type transactionsCreateNestedManyWithoutVaults_transactions_sourceVaultIdTovaultsInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutVaults_transactions_sourceVaultIdTovaultsInput>, Enumerable<transactionsUncheckedCreateWithoutVaults_transactions_sourceVaultIdTovaultsInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutVaults_transactions_sourceVaultIdTovaultsInput>
    createMany?: transactionsCreateManyVaults_transactions_sourceVaultIdTovaultsInputEnvelope
    connect?: Enumerable<transactionsWhereUniqueInput>
  }

  export type transactionsCreateNestedManyWithoutVaults_transactions_targetVaultIdTovaultsInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutVaults_transactions_targetVaultIdTovaultsInput>, Enumerable<transactionsUncheckedCreateWithoutVaults_transactions_targetVaultIdTovaultsInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutVaults_transactions_targetVaultIdTovaultsInput>
    createMany?: transactionsCreateManyVaults_transactions_targetVaultIdTovaultsInputEnvelope
    connect?: Enumerable<transactionsWhereUniqueInput>
  }

  export type vaultAssetsCreateNestedManyWithoutVaultsInput = {
    create?: XOR<Enumerable<vaultAssetsCreateWithoutVaultsInput>, Enumerable<vaultAssetsUncheckedCreateWithoutVaultsInput>>
    connectOrCreate?: Enumerable<vaultAssetsCreateOrConnectWithoutVaultsInput>
    createMany?: vaultAssetsCreateManyVaultsInputEnvelope
    connect?: Enumerable<vaultAssetsWhereUniqueInput>
  }

  export type usersCreateNestedOneWithoutVaultsInput = {
    create?: XOR<usersCreateWithoutVaultsInput, usersUncheckedCreateWithoutVaultsInput>
    connectOrCreate?: usersCreateOrConnectWithoutVaultsInput
    connect?: usersWhereUniqueInput
  }

  export type vaultStatusTypesCreateNestedOneWithoutVaultsInput = {
    create?: XOR<vaultStatusTypesCreateWithoutVaultsInput, vaultStatusTypesUncheckedCreateWithoutVaultsInput>
    connectOrCreate?: vaultStatusTypesCreateOrConnectWithoutVaultsInput
    connect?: vaultStatusTypesWhereUniqueInput
  }

  export type transactionPoliciesUncheckedCreateNestedManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput = {
    create?: XOR<Enumerable<transactionPoliciesCreateWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput>, Enumerable<transactionPoliciesUncheckedCreateWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput>>
    connectOrCreate?: Enumerable<transactionPoliciesCreateOrConnectWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput>
    createMany?: transactionPoliciesCreateManyVaults_transactionPolicies_sourceVaultIdTovaultsInputEnvelope
    connect?: Enumerable<transactionPoliciesWhereUniqueInput>
  }

  export type transactionPoliciesUncheckedCreateNestedManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput = {
    create?: XOR<Enumerable<transactionPoliciesCreateWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput>, Enumerable<transactionPoliciesUncheckedCreateWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput>>
    connectOrCreate?: Enumerable<transactionPoliciesCreateOrConnectWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput>
    createMany?: transactionPoliciesCreateManyVaults_transactionPolicies_targetVaultIdTovaultsInputEnvelope
    connect?: Enumerable<transactionPoliciesWhereUniqueInput>
  }

  export type transactionsUncheckedCreateNestedManyWithoutVaults_transactions_sourceVaultIdTovaultsInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutVaults_transactions_sourceVaultIdTovaultsInput>, Enumerable<transactionsUncheckedCreateWithoutVaults_transactions_sourceVaultIdTovaultsInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutVaults_transactions_sourceVaultIdTovaultsInput>
    createMany?: transactionsCreateManyVaults_transactions_sourceVaultIdTovaultsInputEnvelope
    connect?: Enumerable<transactionsWhereUniqueInput>
  }

  export type transactionsUncheckedCreateNestedManyWithoutVaults_transactions_targetVaultIdTovaultsInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutVaults_transactions_targetVaultIdTovaultsInput>, Enumerable<transactionsUncheckedCreateWithoutVaults_transactions_targetVaultIdTovaultsInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutVaults_transactions_targetVaultIdTovaultsInput>
    createMany?: transactionsCreateManyVaults_transactions_targetVaultIdTovaultsInputEnvelope
    connect?: Enumerable<transactionsWhereUniqueInput>
  }

  export type vaultAssetsUncheckedCreateNestedManyWithoutVaultsInput = {
    create?: XOR<Enumerable<vaultAssetsCreateWithoutVaultsInput>, Enumerable<vaultAssetsUncheckedCreateWithoutVaultsInput>>
    connectOrCreate?: Enumerable<vaultAssetsCreateOrConnectWithoutVaultsInput>
    createMany?: vaultAssetsCreateManyVaultsInputEnvelope
    connect?: Enumerable<vaultAssetsWhereUniqueInput>
  }

  export type transactionPoliciesUpdateManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsNestedInput = {
    create?: XOR<Enumerable<transactionPoliciesCreateWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput>, Enumerable<transactionPoliciesUncheckedCreateWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput>>
    connectOrCreate?: Enumerable<transactionPoliciesCreateOrConnectWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput>
    upsert?: Enumerable<transactionPoliciesUpsertWithWhereUniqueWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput>
    createMany?: transactionPoliciesCreateManyVaults_transactionPolicies_sourceVaultIdTovaultsInputEnvelope
    set?: Enumerable<transactionPoliciesWhereUniqueInput>
    disconnect?: Enumerable<transactionPoliciesWhereUniqueInput>
    delete?: Enumerable<transactionPoliciesWhereUniqueInput>
    connect?: Enumerable<transactionPoliciesWhereUniqueInput>
    update?: Enumerable<transactionPoliciesUpdateWithWhereUniqueWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput>
    updateMany?: Enumerable<transactionPoliciesUpdateManyWithWhereWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput>
    deleteMany?: Enumerable<transactionPoliciesScalarWhereInput>
  }

  export type transactionPoliciesUpdateManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsNestedInput = {
    create?: XOR<Enumerable<transactionPoliciesCreateWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput>, Enumerable<transactionPoliciesUncheckedCreateWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput>>
    connectOrCreate?: Enumerable<transactionPoliciesCreateOrConnectWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput>
    upsert?: Enumerable<transactionPoliciesUpsertWithWhereUniqueWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput>
    createMany?: transactionPoliciesCreateManyVaults_transactionPolicies_targetVaultIdTovaultsInputEnvelope
    set?: Enumerable<transactionPoliciesWhereUniqueInput>
    disconnect?: Enumerable<transactionPoliciesWhereUniqueInput>
    delete?: Enumerable<transactionPoliciesWhereUniqueInput>
    connect?: Enumerable<transactionPoliciesWhereUniqueInput>
    update?: Enumerable<transactionPoliciesUpdateWithWhereUniqueWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput>
    updateMany?: Enumerable<transactionPoliciesUpdateManyWithWhereWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput>
    deleteMany?: Enumerable<transactionPoliciesScalarWhereInput>
  }

  export type transactionsUpdateManyWithoutVaults_transactions_sourceVaultIdTovaultsNestedInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutVaults_transactions_sourceVaultIdTovaultsInput>, Enumerable<transactionsUncheckedCreateWithoutVaults_transactions_sourceVaultIdTovaultsInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutVaults_transactions_sourceVaultIdTovaultsInput>
    upsert?: Enumerable<transactionsUpsertWithWhereUniqueWithoutVaults_transactions_sourceVaultIdTovaultsInput>
    createMany?: transactionsCreateManyVaults_transactions_sourceVaultIdTovaultsInputEnvelope
    set?: Enumerable<transactionsWhereUniqueInput>
    disconnect?: Enumerable<transactionsWhereUniqueInput>
    delete?: Enumerable<transactionsWhereUniqueInput>
    connect?: Enumerable<transactionsWhereUniqueInput>
    update?: Enumerable<transactionsUpdateWithWhereUniqueWithoutVaults_transactions_sourceVaultIdTovaultsInput>
    updateMany?: Enumerable<transactionsUpdateManyWithWhereWithoutVaults_transactions_sourceVaultIdTovaultsInput>
    deleteMany?: Enumerable<transactionsScalarWhereInput>
  }

  export type transactionsUpdateManyWithoutVaults_transactions_targetVaultIdTovaultsNestedInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutVaults_transactions_targetVaultIdTovaultsInput>, Enumerable<transactionsUncheckedCreateWithoutVaults_transactions_targetVaultIdTovaultsInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutVaults_transactions_targetVaultIdTovaultsInput>
    upsert?: Enumerable<transactionsUpsertWithWhereUniqueWithoutVaults_transactions_targetVaultIdTovaultsInput>
    createMany?: transactionsCreateManyVaults_transactions_targetVaultIdTovaultsInputEnvelope
    set?: Enumerable<transactionsWhereUniqueInput>
    disconnect?: Enumerable<transactionsWhereUniqueInput>
    delete?: Enumerable<transactionsWhereUniqueInput>
    connect?: Enumerable<transactionsWhereUniqueInput>
    update?: Enumerable<transactionsUpdateWithWhereUniqueWithoutVaults_transactions_targetVaultIdTovaultsInput>
    updateMany?: Enumerable<transactionsUpdateManyWithWhereWithoutVaults_transactions_targetVaultIdTovaultsInput>
    deleteMany?: Enumerable<transactionsScalarWhereInput>
  }

  export type vaultAssetsUpdateManyWithoutVaultsNestedInput = {
    create?: XOR<Enumerable<vaultAssetsCreateWithoutVaultsInput>, Enumerable<vaultAssetsUncheckedCreateWithoutVaultsInput>>
    connectOrCreate?: Enumerable<vaultAssetsCreateOrConnectWithoutVaultsInput>
    upsert?: Enumerable<vaultAssetsUpsertWithWhereUniqueWithoutVaultsInput>
    createMany?: vaultAssetsCreateManyVaultsInputEnvelope
    set?: Enumerable<vaultAssetsWhereUniqueInput>
    disconnect?: Enumerable<vaultAssetsWhereUniqueInput>
    delete?: Enumerable<vaultAssetsWhereUniqueInput>
    connect?: Enumerable<vaultAssetsWhereUniqueInput>
    update?: Enumerable<vaultAssetsUpdateWithWhereUniqueWithoutVaultsInput>
    updateMany?: Enumerable<vaultAssetsUpdateManyWithWhereWithoutVaultsInput>
    deleteMany?: Enumerable<vaultAssetsScalarWhereInput>
  }

  export type usersUpdateOneRequiredWithoutVaultsNestedInput = {
    create?: XOR<usersCreateWithoutVaultsInput, usersUncheckedCreateWithoutVaultsInput>
    connectOrCreate?: usersCreateOrConnectWithoutVaultsInput
    upsert?: usersUpsertWithoutVaultsInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutVaultsInput, usersUncheckedUpdateWithoutVaultsInput>
  }

  export type vaultStatusTypesUpdateOneWithoutVaultsNestedInput = {
    create?: XOR<vaultStatusTypesCreateWithoutVaultsInput, vaultStatusTypesUncheckedCreateWithoutVaultsInput>
    connectOrCreate?: vaultStatusTypesCreateOrConnectWithoutVaultsInput
    upsert?: vaultStatusTypesUpsertWithoutVaultsInput
    disconnect?: boolean
    delete?: boolean
    connect?: vaultStatusTypesWhereUniqueInput
    update?: XOR<vaultStatusTypesUpdateWithoutVaultsInput, vaultStatusTypesUncheckedUpdateWithoutVaultsInput>
  }

  export type transactionPoliciesUncheckedUpdateManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsNestedInput = {
    create?: XOR<Enumerable<transactionPoliciesCreateWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput>, Enumerable<transactionPoliciesUncheckedCreateWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput>>
    connectOrCreate?: Enumerable<transactionPoliciesCreateOrConnectWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput>
    upsert?: Enumerable<transactionPoliciesUpsertWithWhereUniqueWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput>
    createMany?: transactionPoliciesCreateManyVaults_transactionPolicies_sourceVaultIdTovaultsInputEnvelope
    set?: Enumerable<transactionPoliciesWhereUniqueInput>
    disconnect?: Enumerable<transactionPoliciesWhereUniqueInput>
    delete?: Enumerable<transactionPoliciesWhereUniqueInput>
    connect?: Enumerable<transactionPoliciesWhereUniqueInput>
    update?: Enumerable<transactionPoliciesUpdateWithWhereUniqueWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput>
    updateMany?: Enumerable<transactionPoliciesUpdateManyWithWhereWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput>
    deleteMany?: Enumerable<transactionPoliciesScalarWhereInput>
  }

  export type transactionPoliciesUncheckedUpdateManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsNestedInput = {
    create?: XOR<Enumerable<transactionPoliciesCreateWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput>, Enumerable<transactionPoliciesUncheckedCreateWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput>>
    connectOrCreate?: Enumerable<transactionPoliciesCreateOrConnectWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput>
    upsert?: Enumerable<transactionPoliciesUpsertWithWhereUniqueWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput>
    createMany?: transactionPoliciesCreateManyVaults_transactionPolicies_targetVaultIdTovaultsInputEnvelope
    set?: Enumerable<transactionPoliciesWhereUniqueInput>
    disconnect?: Enumerable<transactionPoliciesWhereUniqueInput>
    delete?: Enumerable<transactionPoliciesWhereUniqueInput>
    connect?: Enumerable<transactionPoliciesWhereUniqueInput>
    update?: Enumerable<transactionPoliciesUpdateWithWhereUniqueWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput>
    updateMany?: Enumerable<transactionPoliciesUpdateManyWithWhereWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput>
    deleteMany?: Enumerable<transactionPoliciesScalarWhereInput>
  }

  export type transactionsUncheckedUpdateManyWithoutVaults_transactions_sourceVaultIdTovaultsNestedInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutVaults_transactions_sourceVaultIdTovaultsInput>, Enumerable<transactionsUncheckedCreateWithoutVaults_transactions_sourceVaultIdTovaultsInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutVaults_transactions_sourceVaultIdTovaultsInput>
    upsert?: Enumerable<transactionsUpsertWithWhereUniqueWithoutVaults_transactions_sourceVaultIdTovaultsInput>
    createMany?: transactionsCreateManyVaults_transactions_sourceVaultIdTovaultsInputEnvelope
    set?: Enumerable<transactionsWhereUniqueInput>
    disconnect?: Enumerable<transactionsWhereUniqueInput>
    delete?: Enumerable<transactionsWhereUniqueInput>
    connect?: Enumerable<transactionsWhereUniqueInput>
    update?: Enumerable<transactionsUpdateWithWhereUniqueWithoutVaults_transactions_sourceVaultIdTovaultsInput>
    updateMany?: Enumerable<transactionsUpdateManyWithWhereWithoutVaults_transactions_sourceVaultIdTovaultsInput>
    deleteMany?: Enumerable<transactionsScalarWhereInput>
  }

  export type transactionsUncheckedUpdateManyWithoutVaults_transactions_targetVaultIdTovaultsNestedInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutVaults_transactions_targetVaultIdTovaultsInput>, Enumerable<transactionsUncheckedCreateWithoutVaults_transactions_targetVaultIdTovaultsInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutVaults_transactions_targetVaultIdTovaultsInput>
    upsert?: Enumerable<transactionsUpsertWithWhereUniqueWithoutVaults_transactions_targetVaultIdTovaultsInput>
    createMany?: transactionsCreateManyVaults_transactions_targetVaultIdTovaultsInputEnvelope
    set?: Enumerable<transactionsWhereUniqueInput>
    disconnect?: Enumerable<transactionsWhereUniqueInput>
    delete?: Enumerable<transactionsWhereUniqueInput>
    connect?: Enumerable<transactionsWhereUniqueInput>
    update?: Enumerable<transactionsUpdateWithWhereUniqueWithoutVaults_transactions_targetVaultIdTovaultsInput>
    updateMany?: Enumerable<transactionsUpdateManyWithWhereWithoutVaults_transactions_targetVaultIdTovaultsInput>
    deleteMany?: Enumerable<transactionsScalarWhereInput>
  }

  export type vaultAssetsUncheckedUpdateManyWithoutVaultsNestedInput = {
    create?: XOR<Enumerable<vaultAssetsCreateWithoutVaultsInput>, Enumerable<vaultAssetsUncheckedCreateWithoutVaultsInput>>
    connectOrCreate?: Enumerable<vaultAssetsCreateOrConnectWithoutVaultsInput>
    upsert?: Enumerable<vaultAssetsUpsertWithWhereUniqueWithoutVaultsInput>
    createMany?: vaultAssetsCreateManyVaultsInputEnvelope
    set?: Enumerable<vaultAssetsWhereUniqueInput>
    disconnect?: Enumerable<vaultAssetsWhereUniqueInput>
    delete?: Enumerable<vaultAssetsWhereUniqueInput>
    connect?: Enumerable<vaultAssetsWhereUniqueInput>
    update?: Enumerable<vaultAssetsUpdateWithWhereUniqueWithoutVaultsInput>
    updateMany?: Enumerable<vaultAssetsUpdateManyWithWhereWithoutVaultsInput>
    deleteMany?: Enumerable<vaultAssetsScalarWhereInput>
  }

  export type pricingPlanSupportsAssetsCreateNestedManyWithoutVendorSupportsAssetsInput = {
    create?: XOR<Enumerable<pricingPlanSupportsAssetsCreateWithoutVendorSupportsAssetsInput>, Enumerable<pricingPlanSupportsAssetsUncheckedCreateWithoutVendorSupportsAssetsInput>>
    connectOrCreate?: Enumerable<pricingPlanSupportsAssetsCreateOrConnectWithoutVendorSupportsAssetsInput>
    createMany?: pricingPlanSupportsAssetsCreateManyVendorSupportsAssetsInputEnvelope
    connect?: Enumerable<pricingPlanSupportsAssetsWhereUniqueInput>
  }

  export type assetsCreateNestedOneWithoutVendorSupportsAssetsInput = {
    create?: XOR<assetsCreateWithoutVendorSupportsAssetsInput, assetsUncheckedCreateWithoutVendorSupportsAssetsInput>
    connectOrCreate?: assetsCreateOrConnectWithoutVendorSupportsAssetsInput
    connect?: assetsWhereUniqueInput
  }

  export type vendorsCreateNestedOneWithoutVendorSupportsAssetsInput = {
    create?: XOR<vendorsCreateWithoutVendorSupportsAssetsInput, vendorsUncheckedCreateWithoutVendorSupportsAssetsInput>
    connectOrCreate?: vendorsCreateOrConnectWithoutVendorSupportsAssetsInput
    connect?: vendorsWhereUniqueInput
  }

  export type pricingPlanSupportsAssetsUncheckedCreateNestedManyWithoutVendorSupportsAssetsInput = {
    create?: XOR<Enumerable<pricingPlanSupportsAssetsCreateWithoutVendorSupportsAssetsInput>, Enumerable<pricingPlanSupportsAssetsUncheckedCreateWithoutVendorSupportsAssetsInput>>
    connectOrCreate?: Enumerable<pricingPlanSupportsAssetsCreateOrConnectWithoutVendorSupportsAssetsInput>
    createMany?: pricingPlanSupportsAssetsCreateManyVendorSupportsAssetsInputEnvelope
    connect?: Enumerable<pricingPlanSupportsAssetsWhereUniqueInput>
  }

  export type pricingPlanSupportsAssetsUpdateManyWithoutVendorSupportsAssetsNestedInput = {
    create?: XOR<Enumerable<pricingPlanSupportsAssetsCreateWithoutVendorSupportsAssetsInput>, Enumerable<pricingPlanSupportsAssetsUncheckedCreateWithoutVendorSupportsAssetsInput>>
    connectOrCreate?: Enumerable<pricingPlanSupportsAssetsCreateOrConnectWithoutVendorSupportsAssetsInput>
    upsert?: Enumerable<pricingPlanSupportsAssetsUpsertWithWhereUniqueWithoutVendorSupportsAssetsInput>
    createMany?: pricingPlanSupportsAssetsCreateManyVendorSupportsAssetsInputEnvelope
    set?: Enumerable<pricingPlanSupportsAssetsWhereUniqueInput>
    disconnect?: Enumerable<pricingPlanSupportsAssetsWhereUniqueInput>
    delete?: Enumerable<pricingPlanSupportsAssetsWhereUniqueInput>
    connect?: Enumerable<pricingPlanSupportsAssetsWhereUniqueInput>
    update?: Enumerable<pricingPlanSupportsAssetsUpdateWithWhereUniqueWithoutVendorSupportsAssetsInput>
    updateMany?: Enumerable<pricingPlanSupportsAssetsUpdateManyWithWhereWithoutVendorSupportsAssetsInput>
    deleteMany?: Enumerable<pricingPlanSupportsAssetsScalarWhereInput>
  }

  export type assetsUpdateOneRequiredWithoutVendorSupportsAssetsNestedInput = {
    create?: XOR<assetsCreateWithoutVendorSupportsAssetsInput, assetsUncheckedCreateWithoutVendorSupportsAssetsInput>
    connectOrCreate?: assetsCreateOrConnectWithoutVendorSupportsAssetsInput
    upsert?: assetsUpsertWithoutVendorSupportsAssetsInput
    connect?: assetsWhereUniqueInput
    update?: XOR<assetsUpdateWithoutVendorSupportsAssetsInput, assetsUncheckedUpdateWithoutVendorSupportsAssetsInput>
  }

  export type vendorsUpdateOneRequiredWithoutVendorSupportsAssetsNestedInput = {
    create?: XOR<vendorsCreateWithoutVendorSupportsAssetsInput, vendorsUncheckedCreateWithoutVendorSupportsAssetsInput>
    connectOrCreate?: vendorsCreateOrConnectWithoutVendorSupportsAssetsInput
    upsert?: vendorsUpsertWithoutVendorSupportsAssetsInput
    connect?: vendorsWhereUniqueInput
    update?: XOR<vendorsUpdateWithoutVendorSupportsAssetsInput, vendorsUncheckedUpdateWithoutVendorSupportsAssetsInput>
  }

  export type pricingPlanSupportsAssetsUncheckedUpdateManyWithoutVendorSupportsAssetsNestedInput = {
    create?: XOR<Enumerable<pricingPlanSupportsAssetsCreateWithoutVendorSupportsAssetsInput>, Enumerable<pricingPlanSupportsAssetsUncheckedCreateWithoutVendorSupportsAssetsInput>>
    connectOrCreate?: Enumerable<pricingPlanSupportsAssetsCreateOrConnectWithoutVendorSupportsAssetsInput>
    upsert?: Enumerable<pricingPlanSupportsAssetsUpsertWithWhereUniqueWithoutVendorSupportsAssetsInput>
    createMany?: pricingPlanSupportsAssetsCreateManyVendorSupportsAssetsInputEnvelope
    set?: Enumerable<pricingPlanSupportsAssetsWhereUniqueInput>
    disconnect?: Enumerable<pricingPlanSupportsAssetsWhereUniqueInput>
    delete?: Enumerable<pricingPlanSupportsAssetsWhereUniqueInput>
    connect?: Enumerable<pricingPlanSupportsAssetsWhereUniqueInput>
    update?: Enumerable<pricingPlanSupportsAssetsUpdateWithWhereUniqueWithoutVendorSupportsAssetsInput>
    updateMany?: Enumerable<pricingPlanSupportsAssetsUpdateManyWithWhereWithoutVendorSupportsAssetsInput>
    deleteMany?: Enumerable<pricingPlanSupportsAssetsScalarWhereInput>
  }

  export type custodyEngineEventsCreateNestedOneWithoutWebhookRequestsInput = {
    create?: XOR<custodyEngineEventsCreateWithoutWebhookRequestsInput, custodyEngineEventsUncheckedCreateWithoutWebhookRequestsInput>
    connectOrCreate?: custodyEngineEventsCreateOrConnectWithoutWebhookRequestsInput
    connect?: custodyEngineEventsWhereUniqueInput
  }

  export type institutionalProductsCreateNestedOneWithoutWebhookRequestsInput = {
    create?: XOR<institutionalProductsCreateWithoutWebhookRequestsInput, institutionalProductsUncheckedCreateWithoutWebhookRequestsInput>
    connectOrCreate?: institutionalProductsCreateOrConnectWithoutWebhookRequestsInput
    connect?: institutionalProductsWhereUniqueInput
  }

  export type webhooksCreateNestedOneWithoutWebhookRequestsInput = {
    create?: XOR<webhooksCreateWithoutWebhookRequestsInput, webhooksUncheckedCreateWithoutWebhookRequestsInput>
    connectOrCreate?: webhooksCreateOrConnectWithoutWebhookRequestsInput
    connect?: webhooksWhereUniqueInput
  }

  export type custodyEngineEventsUpdateOneWithoutWebhookRequestsNestedInput = {
    create?: XOR<custodyEngineEventsCreateWithoutWebhookRequestsInput, custodyEngineEventsUncheckedCreateWithoutWebhookRequestsInput>
    connectOrCreate?: custodyEngineEventsCreateOrConnectWithoutWebhookRequestsInput
    upsert?: custodyEngineEventsUpsertWithoutWebhookRequestsInput
    disconnect?: boolean
    delete?: boolean
    connect?: custodyEngineEventsWhereUniqueInput
    update?: XOR<custodyEngineEventsUpdateWithoutWebhookRequestsInput, custodyEngineEventsUncheckedUpdateWithoutWebhookRequestsInput>
  }

  export type institutionalProductsUpdateOneWithoutWebhookRequestsNestedInput = {
    create?: XOR<institutionalProductsCreateWithoutWebhookRequestsInput, institutionalProductsUncheckedCreateWithoutWebhookRequestsInput>
    connectOrCreate?: institutionalProductsCreateOrConnectWithoutWebhookRequestsInput
    upsert?: institutionalProductsUpsertWithoutWebhookRequestsInput
    disconnect?: boolean
    delete?: boolean
    connect?: institutionalProductsWhereUniqueInput
    update?: XOR<institutionalProductsUpdateWithoutWebhookRequestsInput, institutionalProductsUncheckedUpdateWithoutWebhookRequestsInput>
  }

  export type webhooksUpdateOneRequiredWithoutWebhookRequestsNestedInput = {
    create?: XOR<webhooksCreateWithoutWebhookRequestsInput, webhooksUncheckedCreateWithoutWebhookRequestsInput>
    connectOrCreate?: webhooksCreateOrConnectWithoutWebhookRequestsInput
    upsert?: webhooksUpsertWithoutWebhookRequestsInput
    connect?: webhooksWhereUniqueInput
    update?: XOR<webhooksUpdateWithoutWebhookRequestsInput, webhooksUncheckedUpdateWithoutWebhookRequestsInput>
  }

  export type webhooksCreateNestedManyWithoutWebhookStatusTypesInput = {
    create?: XOR<Enumerable<webhooksCreateWithoutWebhookStatusTypesInput>, Enumerable<webhooksUncheckedCreateWithoutWebhookStatusTypesInput>>
    connectOrCreate?: Enumerable<webhooksCreateOrConnectWithoutWebhookStatusTypesInput>
    createMany?: webhooksCreateManyWebhookStatusTypesInputEnvelope
    connect?: Enumerable<webhooksWhereUniqueInput>
  }

  export type webhooksUncheckedCreateNestedManyWithoutWebhookStatusTypesInput = {
    create?: XOR<Enumerable<webhooksCreateWithoutWebhookStatusTypesInput>, Enumerable<webhooksUncheckedCreateWithoutWebhookStatusTypesInput>>
    connectOrCreate?: Enumerable<webhooksCreateOrConnectWithoutWebhookStatusTypesInput>
    createMany?: webhooksCreateManyWebhookStatusTypesInputEnvelope
    connect?: Enumerable<webhooksWhereUniqueInput>
  }

  export type webhooksUpdateManyWithoutWebhookStatusTypesNestedInput = {
    create?: XOR<Enumerable<webhooksCreateWithoutWebhookStatusTypesInput>, Enumerable<webhooksUncheckedCreateWithoutWebhookStatusTypesInput>>
    connectOrCreate?: Enumerable<webhooksCreateOrConnectWithoutWebhookStatusTypesInput>
    upsert?: Enumerable<webhooksUpsertWithWhereUniqueWithoutWebhookStatusTypesInput>
    createMany?: webhooksCreateManyWebhookStatusTypesInputEnvelope
    set?: Enumerable<webhooksWhereUniqueInput>
    disconnect?: Enumerable<webhooksWhereUniqueInput>
    delete?: Enumerable<webhooksWhereUniqueInput>
    connect?: Enumerable<webhooksWhereUniqueInput>
    update?: Enumerable<webhooksUpdateWithWhereUniqueWithoutWebhookStatusTypesInput>
    updateMany?: Enumerable<webhooksUpdateManyWithWhereWithoutWebhookStatusTypesInput>
    deleteMany?: Enumerable<webhooksScalarWhereInput>
  }

  export type webhooksUncheckedUpdateManyWithoutWebhookStatusTypesNestedInput = {
    create?: XOR<Enumerable<webhooksCreateWithoutWebhookStatusTypesInput>, Enumerable<webhooksUncheckedCreateWithoutWebhookStatusTypesInput>>
    connectOrCreate?: Enumerable<webhooksCreateOrConnectWithoutWebhookStatusTypesInput>
    upsert?: Enumerable<webhooksUpsertWithWhereUniqueWithoutWebhookStatusTypesInput>
    createMany?: webhooksCreateManyWebhookStatusTypesInputEnvelope
    set?: Enumerable<webhooksWhereUniqueInput>
    disconnect?: Enumerable<webhooksWhereUniqueInput>
    delete?: Enumerable<webhooksWhereUniqueInput>
    connect?: Enumerable<webhooksWhereUniqueInput>
    update?: Enumerable<webhooksUpdateWithWhereUniqueWithoutWebhookStatusTypesInput>
    updateMany?: Enumerable<webhooksUpdateManyWithWhereWithoutWebhookStatusTypesInput>
    deleteMany?: Enumerable<webhooksScalarWhereInput>
  }

  export type webhookRequestsCreateNestedManyWithoutWebhooksInput = {
    create?: XOR<Enumerable<webhookRequestsCreateWithoutWebhooksInput>, Enumerable<webhookRequestsUncheckedCreateWithoutWebhooksInput>>
    connectOrCreate?: Enumerable<webhookRequestsCreateOrConnectWithoutWebhooksInput>
    createMany?: webhookRequestsCreateManyWebhooksInputEnvelope
    connect?: Enumerable<webhookRequestsWhereUniqueInput>
  }

  export type organizationsCreateNestedOneWithoutWebhooksInput = {
    create?: XOR<organizationsCreateWithoutWebhooksInput, organizationsUncheckedCreateWithoutWebhooksInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutWebhooksInput
    connect?: organizationsWhereUniqueInput
  }

  export type webhookStatusTypesCreateNestedOneWithoutWebhooksInput = {
    create?: XOR<webhookStatusTypesCreateWithoutWebhooksInput, webhookStatusTypesUncheckedCreateWithoutWebhooksInput>
    connectOrCreate?: webhookStatusTypesCreateOrConnectWithoutWebhooksInput
    connect?: webhookStatusTypesWhereUniqueInput
  }

  export type webhookRequestsUncheckedCreateNestedManyWithoutWebhooksInput = {
    create?: XOR<Enumerable<webhookRequestsCreateWithoutWebhooksInput>, Enumerable<webhookRequestsUncheckedCreateWithoutWebhooksInput>>
    connectOrCreate?: Enumerable<webhookRequestsCreateOrConnectWithoutWebhooksInput>
    createMany?: webhookRequestsCreateManyWebhooksInputEnvelope
    connect?: Enumerable<webhookRequestsWhereUniqueInput>
  }

  export type webhookRequestsUpdateManyWithoutWebhooksNestedInput = {
    create?: XOR<Enumerable<webhookRequestsCreateWithoutWebhooksInput>, Enumerable<webhookRequestsUncheckedCreateWithoutWebhooksInput>>
    connectOrCreate?: Enumerable<webhookRequestsCreateOrConnectWithoutWebhooksInput>
    upsert?: Enumerable<webhookRequestsUpsertWithWhereUniqueWithoutWebhooksInput>
    createMany?: webhookRequestsCreateManyWebhooksInputEnvelope
    set?: Enumerable<webhookRequestsWhereUniqueInput>
    disconnect?: Enumerable<webhookRequestsWhereUniqueInput>
    delete?: Enumerable<webhookRequestsWhereUniqueInput>
    connect?: Enumerable<webhookRequestsWhereUniqueInput>
    update?: Enumerable<webhookRequestsUpdateWithWhereUniqueWithoutWebhooksInput>
    updateMany?: Enumerable<webhookRequestsUpdateManyWithWhereWithoutWebhooksInput>
    deleteMany?: Enumerable<webhookRequestsScalarWhereInput>
  }

  export type organizationsUpdateOneRequiredWithoutWebhooksNestedInput = {
    create?: XOR<organizationsCreateWithoutWebhooksInput, organizationsUncheckedCreateWithoutWebhooksInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutWebhooksInput
    upsert?: organizationsUpsertWithoutWebhooksInput
    connect?: organizationsWhereUniqueInput
    update?: XOR<organizationsUpdateWithoutWebhooksInput, organizationsUncheckedUpdateWithoutWebhooksInput>
  }

  export type webhookStatusTypesUpdateOneRequiredWithoutWebhooksNestedInput = {
    create?: XOR<webhookStatusTypesCreateWithoutWebhooksInput, webhookStatusTypesUncheckedCreateWithoutWebhooksInput>
    connectOrCreate?: webhookStatusTypesCreateOrConnectWithoutWebhooksInput
    upsert?: webhookStatusTypesUpsertWithoutWebhooksInput
    connect?: webhookStatusTypesWhereUniqueInput
    update?: XOR<webhookStatusTypesUpdateWithoutWebhooksInput, webhookStatusTypesUncheckedUpdateWithoutWebhooksInput>
  }

  export type webhookRequestsUncheckedUpdateManyWithoutWebhooksNestedInput = {
    create?: XOR<Enumerable<webhookRequestsCreateWithoutWebhooksInput>, Enumerable<webhookRequestsUncheckedCreateWithoutWebhooksInput>>
    connectOrCreate?: Enumerable<webhookRequestsCreateOrConnectWithoutWebhooksInput>
    upsert?: Enumerable<webhookRequestsUpsertWithWhereUniqueWithoutWebhooksInput>
    createMany?: webhookRequestsCreateManyWebhooksInputEnvelope
    set?: Enumerable<webhookRequestsWhereUniqueInput>
    disconnect?: Enumerable<webhookRequestsWhereUniqueInput>
    delete?: Enumerable<webhookRequestsWhereUniqueInput>
    connect?: Enumerable<webhookRequestsWhereUniqueInput>
    update?: Enumerable<webhookRequestsUpdateWithWhereUniqueWithoutWebhooksInput>
    updateMany?: Enumerable<webhookRequestsUpdateManyWithWhereWithoutWebhooksInput>
    deleteMany?: Enumerable<webhookRequestsScalarWhereInput>
  }

  export type transactionPoliciesCreateNestedManyWithoutWithdrawalAddressesInput = {
    create?: XOR<Enumerable<transactionPoliciesCreateWithoutWithdrawalAddressesInput>, Enumerable<transactionPoliciesUncheckedCreateWithoutWithdrawalAddressesInput>>
    connectOrCreate?: Enumerable<transactionPoliciesCreateOrConnectWithoutWithdrawalAddressesInput>
    createMany?: transactionPoliciesCreateManyWithdrawalAddressesInputEnvelope
    connect?: Enumerable<transactionPoliciesWhereUniqueInput>
  }

  export type transactionsCreateNestedManyWithoutWithdrawalAddressesInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutWithdrawalAddressesInput>, Enumerable<transactionsUncheckedCreateWithoutWithdrawalAddressesInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutWithdrawalAddressesInput>
    createMany?: transactionsCreateManyWithdrawalAddressesInputEnvelope
    connect?: Enumerable<transactionsWhereUniqueInput>
  }

  export type assetsCreateNestedOneWithoutWithdrawalAddressesInput = {
    create?: XOR<assetsCreateWithoutWithdrawalAddressesInput, assetsUncheckedCreateWithoutWithdrawalAddressesInput>
    connectOrCreate?: assetsCreateOrConnectWithoutWithdrawalAddressesInput
    connect?: assetsWhereUniqueInput
  }

  export type organizationsCreateNestedOneWithoutWithdrawalAddressesInput = {
    create?: XOR<organizationsCreateWithoutWithdrawalAddressesInput, organizationsUncheckedCreateWithoutWithdrawalAddressesInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutWithdrawalAddressesInput
    connect?: organizationsWhereUniqueInput
  }

  export type transactionPoliciesUncheckedCreateNestedManyWithoutWithdrawalAddressesInput = {
    create?: XOR<Enumerable<transactionPoliciesCreateWithoutWithdrawalAddressesInput>, Enumerable<transactionPoliciesUncheckedCreateWithoutWithdrawalAddressesInput>>
    connectOrCreate?: Enumerable<transactionPoliciesCreateOrConnectWithoutWithdrawalAddressesInput>
    createMany?: transactionPoliciesCreateManyWithdrawalAddressesInputEnvelope
    connect?: Enumerable<transactionPoliciesWhereUniqueInput>
  }

  export type transactionsUncheckedCreateNestedManyWithoutWithdrawalAddressesInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutWithdrawalAddressesInput>, Enumerable<transactionsUncheckedCreateWithoutWithdrawalAddressesInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutWithdrawalAddressesInput>
    createMany?: transactionsCreateManyWithdrawalAddressesInputEnvelope
    connect?: Enumerable<transactionsWhereUniqueInput>
  }

  export type transactionPoliciesUpdateManyWithoutWithdrawalAddressesNestedInput = {
    create?: XOR<Enumerable<transactionPoliciesCreateWithoutWithdrawalAddressesInput>, Enumerable<transactionPoliciesUncheckedCreateWithoutWithdrawalAddressesInput>>
    connectOrCreate?: Enumerable<transactionPoliciesCreateOrConnectWithoutWithdrawalAddressesInput>
    upsert?: Enumerable<transactionPoliciesUpsertWithWhereUniqueWithoutWithdrawalAddressesInput>
    createMany?: transactionPoliciesCreateManyWithdrawalAddressesInputEnvelope
    set?: Enumerable<transactionPoliciesWhereUniqueInput>
    disconnect?: Enumerable<transactionPoliciesWhereUniqueInput>
    delete?: Enumerable<transactionPoliciesWhereUniqueInput>
    connect?: Enumerable<transactionPoliciesWhereUniqueInput>
    update?: Enumerable<transactionPoliciesUpdateWithWhereUniqueWithoutWithdrawalAddressesInput>
    updateMany?: Enumerable<transactionPoliciesUpdateManyWithWhereWithoutWithdrawalAddressesInput>
    deleteMany?: Enumerable<transactionPoliciesScalarWhereInput>
  }

  export type transactionsUpdateManyWithoutWithdrawalAddressesNestedInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutWithdrawalAddressesInput>, Enumerable<transactionsUncheckedCreateWithoutWithdrawalAddressesInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutWithdrawalAddressesInput>
    upsert?: Enumerable<transactionsUpsertWithWhereUniqueWithoutWithdrawalAddressesInput>
    createMany?: transactionsCreateManyWithdrawalAddressesInputEnvelope
    set?: Enumerable<transactionsWhereUniqueInput>
    disconnect?: Enumerable<transactionsWhereUniqueInput>
    delete?: Enumerable<transactionsWhereUniqueInput>
    connect?: Enumerable<transactionsWhereUniqueInput>
    update?: Enumerable<transactionsUpdateWithWhereUniqueWithoutWithdrawalAddressesInput>
    updateMany?: Enumerable<transactionsUpdateManyWithWhereWithoutWithdrawalAddressesInput>
    deleteMany?: Enumerable<transactionsScalarWhereInput>
  }

  export type assetsUpdateOneRequiredWithoutWithdrawalAddressesNestedInput = {
    create?: XOR<assetsCreateWithoutWithdrawalAddressesInput, assetsUncheckedCreateWithoutWithdrawalAddressesInput>
    connectOrCreate?: assetsCreateOrConnectWithoutWithdrawalAddressesInput
    upsert?: assetsUpsertWithoutWithdrawalAddressesInput
    connect?: assetsWhereUniqueInput
    update?: XOR<assetsUpdateWithoutWithdrawalAddressesInput, assetsUncheckedUpdateWithoutWithdrawalAddressesInput>
  }

  export type organizationsUpdateOneRequiredWithoutWithdrawalAddressesNestedInput = {
    create?: XOR<organizationsCreateWithoutWithdrawalAddressesInput, organizationsUncheckedCreateWithoutWithdrawalAddressesInput>
    connectOrCreate?: organizationsCreateOrConnectWithoutWithdrawalAddressesInput
    upsert?: organizationsUpsertWithoutWithdrawalAddressesInput
    connect?: organizationsWhereUniqueInput
    update?: XOR<organizationsUpdateWithoutWithdrawalAddressesInput, organizationsUncheckedUpdateWithoutWithdrawalAddressesInput>
  }

  export type transactionPoliciesUncheckedUpdateManyWithoutWithdrawalAddressesNestedInput = {
    create?: XOR<Enumerable<transactionPoliciesCreateWithoutWithdrawalAddressesInput>, Enumerable<transactionPoliciesUncheckedCreateWithoutWithdrawalAddressesInput>>
    connectOrCreate?: Enumerable<transactionPoliciesCreateOrConnectWithoutWithdrawalAddressesInput>
    upsert?: Enumerable<transactionPoliciesUpsertWithWhereUniqueWithoutWithdrawalAddressesInput>
    createMany?: transactionPoliciesCreateManyWithdrawalAddressesInputEnvelope
    set?: Enumerable<transactionPoliciesWhereUniqueInput>
    disconnect?: Enumerable<transactionPoliciesWhereUniqueInput>
    delete?: Enumerable<transactionPoliciesWhereUniqueInput>
    connect?: Enumerable<transactionPoliciesWhereUniqueInput>
    update?: Enumerable<transactionPoliciesUpdateWithWhereUniqueWithoutWithdrawalAddressesInput>
    updateMany?: Enumerable<transactionPoliciesUpdateManyWithWhereWithoutWithdrawalAddressesInput>
    deleteMany?: Enumerable<transactionPoliciesScalarWhereInput>
  }

  export type transactionsUncheckedUpdateManyWithoutWithdrawalAddressesNestedInput = {
    create?: XOR<Enumerable<transactionsCreateWithoutWithdrawalAddressesInput>, Enumerable<transactionsUncheckedCreateWithoutWithdrawalAddressesInput>>
    connectOrCreate?: Enumerable<transactionsCreateOrConnectWithoutWithdrawalAddressesInput>
    upsert?: Enumerable<transactionsUpsertWithWhereUniqueWithoutWithdrawalAddressesInput>
    createMany?: transactionsCreateManyWithdrawalAddressesInputEnvelope
    set?: Enumerable<transactionsWhereUniqueInput>
    disconnect?: Enumerable<transactionsWhereUniqueInput>
    delete?: Enumerable<transactionsWhereUniqueInput>
    connect?: Enumerable<transactionsWhereUniqueInput>
    update?: Enumerable<transactionsUpdateWithWhereUniqueWithoutWithdrawalAddressesInput>
    updateMany?: Enumerable<transactionsUpdateManyWithWhereWithoutWithdrawalAddressesInput>
    deleteMany?: Enumerable<transactionsScalarWhereInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedEnumenum_assets_typeFilter = {
    equals?: enum_assets_type
    in?: Enumerable<enum_assets_type>
    notIn?: Enumerable<enum_assets_type>
    not?: NestedEnumenum_assets_typeFilter | enum_assets_type
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedEnumenum_assets_typeWithAggregatesFilter = {
    equals?: enum_assets_type
    in?: Enumerable<enum_assets_type>
    notIn?: Enumerable<enum_assets_type>
    not?: NestedEnumenum_assets_typeWithAggregatesFilter | enum_assets_type
    _count?: NestedIntFilter
    _min?: NestedEnumenum_assets_typeFilter
    _max?: NestedEnumenum_assets_typeFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedUuidFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    not?: NestedUuidFilter | string
  }

  export type NestedEnumenum_quotes_sideFilter = {
    equals?: enum_quotes_side
    in?: Enumerable<enum_quotes_side>
    notIn?: Enumerable<enum_quotes_side>
    not?: NestedEnumenum_quotes_sideFilter | enum_quotes_side
  }

  export type NestedUuidNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    not?: NestedUuidNullableFilter | string | null
  }

  export type NestedUuidWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    not?: NestedUuidWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedEnumenum_quotes_sideWithAggregatesFilter = {
    equals?: enum_quotes_side
    in?: Enumerable<enum_quotes_side>
    notIn?: Enumerable<enum_quotes_side>
    not?: NestedEnumenum_quotes_sideWithAggregatesFilter | enum_quotes_side
    _count?: NestedIntFilter
    _min?: NestedEnumenum_quotes_sideFilter
    _max?: NestedEnumenum_quotes_sideFilter
  }
  export type NestedJsonNullableFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase>, Exclude<keyof Required<NestedJsonNullableFilterBase>, 'path'>>,
        Required<NestedJsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase>, 'path'>>

  export type NestedJsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type NestedUuidNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    not?: NestedUuidNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }
  export type NestedJsonFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase>, Exclude<keyof Required<NestedJsonFilterBase>, 'path'>>,
        Required<NestedJsonFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase>, 'path'>>

  export type NestedJsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type NestedEnumenum_orders_userAcceptedSideFilter = {
    equals?: enum_orders_userAcceptedSide
    in?: Enumerable<enum_orders_userAcceptedSide>
    notIn?: Enumerable<enum_orders_userAcceptedSide>
    not?: NestedEnumenum_orders_userAcceptedSideFilter | enum_orders_userAcceptedSide
  }

  export type NestedEnumenum_orders_orderTypeNullableFilter = {
    equals?: enum_orders_orderType | null
    in?: Enumerable<enum_orders_orderType> | null
    notIn?: Enumerable<enum_orders_orderType> | null
    not?: NestedEnumenum_orders_orderTypeNullableFilter | enum_orders_orderType | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedEnumenum_orders_userAcceptedSideWithAggregatesFilter = {
    equals?: enum_orders_userAcceptedSide
    in?: Enumerable<enum_orders_userAcceptedSide>
    notIn?: Enumerable<enum_orders_userAcceptedSide>
    not?: NestedEnumenum_orders_userAcceptedSideWithAggregatesFilter | enum_orders_userAcceptedSide
    _count?: NestedIntFilter
    _min?: NestedEnumenum_orders_userAcceptedSideFilter
    _max?: NestedEnumenum_orders_userAcceptedSideFilter
  }

  export type NestedEnumenum_orders_orderTypeNullableWithAggregatesFilter = {
    equals?: enum_orders_orderType | null
    in?: Enumerable<enum_orders_orderType> | null
    notIn?: Enumerable<enum_orders_orderType> | null
    not?: NestedEnumenum_orders_orderTypeNullableWithAggregatesFilter | enum_orders_orderType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumenum_orders_orderTypeNullableFilter
    _max?: NestedEnumenum_orders_orderTypeNullableFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedEnumenum_transactionPolicies_actionFilter = {
    equals?: enum_transactionPolicies_action
    in?: Enumerable<enum_transactionPolicies_action>
    notIn?: Enumerable<enum_transactionPolicies_action>
    not?: NestedEnumenum_transactionPolicies_actionFilter | enum_transactionPolicies_action
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedEnumenum_transactionPolicies_actionWithAggregatesFilter = {
    equals?: enum_transactionPolicies_action
    in?: Enumerable<enum_transactionPolicies_action>
    notIn?: Enumerable<enum_transactionPolicies_action>
    not?: NestedEnumenum_transactionPolicies_actionWithAggregatesFilter | enum_transactionPolicies_action
    _count?: NestedIntFilter
    _min?: NestedEnumenum_transactionPolicies_actionFilter
    _max?: NestedEnumenum_transactionPolicies_actionFilter
  }

  export type baseNetworksCreateWithoutAssetsInput = {
    name: string
    addressUrl: string
    feeAssetId?: number | null
    txUrl: string
    enabled: boolean
    baseBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type baseNetworksUncheckedCreateWithoutAssetsInput = {
    id?: number
    name: string
    addressUrl: string
    feeAssetId?: number | null
    txUrl: string
    enabled: boolean
    baseBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type baseNetworksCreateOrConnectWithoutAssetsInput = {
    where: baseNetworksWhereUniqueInput
    create: XOR<baseNetworksCreateWithoutAssetsInput, baseNetworksUncheckedCreateWithoutAssetsInput>
  }

  export type quotesCreateWithoutAssets_quotes_sourceAssetIdToassetsInput = {
    id: string
    side: enum_quotes_side
    userId: string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    buyPrice?: string
    sellPrice?: string
    quantity?: string
    orders?: ordersCreateNestedManyWithoutQuotesInput
    tokenPairsInfo?: tokenPairsInfoCreateNestedOneWithoutQuotesInput
    quoteStatuses: quoteStatusesCreateNestedOneWithoutQuotesInput
    assets_quotes_targetAssetIdToassets: assetsCreateNestedOneWithoutQuotes_quotes_targetAssetIdToassetsInput
    vendors?: vendorsCreateNestedOneWithoutQuotesInput
  }

  export type quotesUncheckedCreateWithoutAssets_quotes_sourceAssetIdToassetsInput = {
    id: string
    quoteStatusId: number
    targetAssetId: number
    side: enum_quotes_side
    userId: string
    vendorId?: number | null
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    fxRequestID?: string | null
    buyPrice?: string
    sellPrice?: string
    quantity?: string
    orders?: ordersUncheckedCreateNestedManyWithoutQuotesInput
  }

  export type quotesCreateOrConnectWithoutAssets_quotes_sourceAssetIdToassetsInput = {
    where: quotesWhereUniqueInput
    create: XOR<quotesCreateWithoutAssets_quotes_sourceAssetIdToassetsInput, quotesUncheckedCreateWithoutAssets_quotes_sourceAssetIdToassetsInput>
  }

  export type quotesCreateManyAssets_quotes_sourceAssetIdToassetsInputEnvelope = {
    data: Enumerable<quotesCreateManyAssets_quotes_sourceAssetIdToassetsInput>
    skipDuplicates?: boolean
  }

  export type quotesCreateWithoutAssets_quotes_targetAssetIdToassetsInput = {
    id: string
    side: enum_quotes_side
    userId: string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    buyPrice?: string
    sellPrice?: string
    quantity?: string
    orders?: ordersCreateNestedManyWithoutQuotesInput
    tokenPairsInfo?: tokenPairsInfoCreateNestedOneWithoutQuotesInput
    quoteStatuses: quoteStatusesCreateNestedOneWithoutQuotesInput
    assets_quotes_sourceAssetIdToassets: assetsCreateNestedOneWithoutQuotes_quotes_sourceAssetIdToassetsInput
    vendors?: vendorsCreateNestedOneWithoutQuotesInput
  }

  export type quotesUncheckedCreateWithoutAssets_quotes_targetAssetIdToassetsInput = {
    id: string
    quoteStatusId: number
    sourceAssetId: number
    side: enum_quotes_side
    userId: string
    vendorId?: number | null
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    fxRequestID?: string | null
    buyPrice?: string
    sellPrice?: string
    quantity?: string
    orders?: ordersUncheckedCreateNestedManyWithoutQuotesInput
  }

  export type quotesCreateOrConnectWithoutAssets_quotes_targetAssetIdToassetsInput = {
    where: quotesWhereUniqueInput
    create: XOR<quotesCreateWithoutAssets_quotes_targetAssetIdToassetsInput, quotesUncheckedCreateWithoutAssets_quotes_targetAssetIdToassetsInput>
  }

  export type quotesCreateManyAssets_quotes_targetAssetIdToassetsInputEnvelope = {
    data: Enumerable<quotesCreateManyAssets_quotes_targetAssetIdToassetsInput>
    skipDuplicates?: boolean
  }

  export type transactionPoliciesCreateWithoutAssetsInput = {
    id: string
    toOneTimeAddresses?: boolean | null
    greaterThanUSD: string
    action: enum_transactionPolicies_action
    createdAt?: Date | string
    updatedAt?: Date | string
    vaults_transactionPolicies_sourceVaultIdTovaults: vaultsCreateNestedOneWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput
    vaults_transactionPolicies_targetVaultIdTovaults?: vaultsCreateNestedOneWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput
    withdrawalAddresses?: withdrawalAddressesCreateNestedOneWithoutTransactionPoliciesInput
    transactionTypes: transactionTypesCreateNestedOneWithoutTransactionPoliciesInput
    users: usersCreateNestedOneWithoutTransactionPoliciesInput
  }

  export type transactionPoliciesUncheckedCreateWithoutAssetsInput = {
    id: string
    userId: string
    transactionTypeId: number
    sourceVaultId: string
    targetVaultId?: string | null
    targetWithdrawalAddressId?: string | null
    toOneTimeAddresses?: boolean | null
    greaterThanUSD: string
    action: enum_transactionPolicies_action
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionPoliciesCreateOrConnectWithoutAssetsInput = {
    where: transactionPoliciesWhereUniqueInput
    create: XOR<transactionPoliciesCreateWithoutAssetsInput, transactionPoliciesUncheckedCreateWithoutAssetsInput>
  }

  export type transactionPoliciesCreateManyAssetsInputEnvelope = {
    data: Enumerable<transactionPoliciesCreateManyAssetsInput>
    skipDuplicates?: boolean
  }

  export type transactionsCreateWithoutAssetsInput = {
    id: string
    custodyVendorRef: string
    amountAsset: string
    amountUSD: string
    onChainTxId?: string | null
    sourceExternalAddress?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: usersCreateNestedOneWithoutTransactionsInput
    vendors: vendorsCreateNestedOneWithoutTransactionsInput
    vaults_transactions_sourceVaultIdTovaults?: vaultsCreateNestedOneWithoutTransactions_transactions_sourceVaultIdTovaultsInput
    vaults_transactions_targetVaultIdTovaults?: vaultsCreateNestedOneWithoutTransactions_transactions_targetVaultIdTovaultsInput
    withdrawalAddresses?: withdrawalAddressesCreateNestedOneWithoutTransactionsInput
    transactionStatusTypes: transactionStatusTypesCreateNestedOneWithoutTransactionsInput
    transactionTypes: transactionTypesCreateNestedOneWithoutTransactionsInput
  }

  export type transactionsUncheckedCreateWithoutAssetsInput = {
    id: string
    custodyVendorId: number
    custodyVendorRef: string
    transactionTypeId: number
    amountAsset: string
    amountUSD: string
    transactionStatusTypeId: number
    onChainTxId?: string | null
    sourceVaultId?: string | null
    targetVaultId?: string | null
    targetWithdrawalAddressId?: string | null
    sourceExternalAddress?: string | null
    createdByUserId?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionsCreateOrConnectWithoutAssetsInput = {
    where: transactionsWhereUniqueInput
    create: XOR<transactionsCreateWithoutAssetsInput, transactionsUncheckedCreateWithoutAssetsInput>
  }

  export type transactionsCreateManyAssetsInputEnvelope = {
    data: Enumerable<transactionsCreateManyAssetsInput>
    skipDuplicates?: boolean
  }

  export type vaultAssetsCreateWithoutAssetsInput = {
    balance: string
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsCreateNestedManyWithoutVaultAssetsInput
    depositAddresses?: depositAddressesCreateNestedManyWithoutVaultAssetsInput
    vaults: vaultsCreateNestedOneWithoutVaultAssetsInput
  }

  export type vaultAssetsUncheckedCreateWithoutAssetsInput = {
    id?: number
    vaultId: string
    balance: string
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUncheckedCreateNestedManyWithoutVaultAssetsInput
    depositAddresses?: depositAddressesUncheckedCreateNestedManyWithoutVaultAssetsInput
  }

  export type vaultAssetsCreateOrConnectWithoutAssetsInput = {
    where: vaultAssetsWhereUniqueInput
    create: XOR<vaultAssetsCreateWithoutAssetsInput, vaultAssetsUncheckedCreateWithoutAssetsInput>
  }

  export type vaultAssetsCreateManyAssetsInputEnvelope = {
    data: Enumerable<vaultAssetsCreateManyAssetsInput>
    skipDuplicates?: boolean
  }

  export type vendorSupportsAssetsCreateWithoutAssetsInput = {
    enabled?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    theirId?: string | null
    pricingPlanSupportsAssets?: pricingPlanSupportsAssetsCreateNestedManyWithoutVendorSupportsAssetsInput
    vendors: vendorsCreateNestedOneWithoutVendorSupportsAssetsInput
  }

  export type vendorSupportsAssetsUncheckedCreateWithoutAssetsInput = {
    id?: number
    vendorId: number
    enabled?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    theirId?: string | null
    pricingPlanSupportsAssets?: pricingPlanSupportsAssetsUncheckedCreateNestedManyWithoutVendorSupportsAssetsInput
  }

  export type vendorSupportsAssetsCreateOrConnectWithoutAssetsInput = {
    where: vendorSupportsAssetsWhereUniqueInput
    create: XOR<vendorSupportsAssetsCreateWithoutAssetsInput, vendorSupportsAssetsUncheckedCreateWithoutAssetsInput>
  }

  export type vendorSupportsAssetsCreateManyAssetsInputEnvelope = {
    data: Enumerable<vendorSupportsAssetsCreateManyAssetsInput>
    skipDuplicates?: boolean
  }

  export type withdrawalAddressesCreateWithoutAssetsInput = {
    id: string
    nickname?: string | null
    address: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionPolicies?: transactionPoliciesCreateNestedManyWithoutWithdrawalAddressesInput
    transactions?: transactionsCreateNestedManyWithoutWithdrawalAddressesInput
    organizations: organizationsCreateNestedOneWithoutWithdrawalAddressesInput
  }

  export type withdrawalAddressesUncheckedCreateWithoutAssetsInput = {
    id: string
    organizationId: number
    nickname?: string | null
    address: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionPolicies?: transactionPoliciesUncheckedCreateNestedManyWithoutWithdrawalAddressesInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutWithdrawalAddressesInput
  }

  export type withdrawalAddressesCreateOrConnectWithoutAssetsInput = {
    where: withdrawalAddressesWhereUniqueInput
    create: XOR<withdrawalAddressesCreateWithoutAssetsInput, withdrawalAddressesUncheckedCreateWithoutAssetsInput>
  }

  export type withdrawalAddressesCreateManyAssetsInputEnvelope = {
    data: Enumerable<withdrawalAddressesCreateManyAssetsInput>
    skipDuplicates?: boolean
  }

  export type baseNetworksUpsertWithoutAssetsInput = {
    update: XOR<baseNetworksUpdateWithoutAssetsInput, baseNetworksUncheckedUpdateWithoutAssetsInput>
    create: XOR<baseNetworksCreateWithoutAssetsInput, baseNetworksUncheckedCreateWithoutAssetsInput>
  }

  export type baseNetworksUpdateWithoutAssetsInput = {
    name?: StringFieldUpdateOperationsInput | string
    addressUrl?: StringFieldUpdateOperationsInput | string
    feeAssetId?: NullableIntFieldUpdateOperationsInput | number | null
    txUrl?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    baseBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type baseNetworksUncheckedUpdateWithoutAssetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    addressUrl?: StringFieldUpdateOperationsInput | string
    feeAssetId?: NullableIntFieldUpdateOperationsInput | number | null
    txUrl?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    baseBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quotesUpsertWithWhereUniqueWithoutAssets_quotes_sourceAssetIdToassetsInput = {
    where: quotesWhereUniqueInput
    update: XOR<quotesUpdateWithoutAssets_quotes_sourceAssetIdToassetsInput, quotesUncheckedUpdateWithoutAssets_quotes_sourceAssetIdToassetsInput>
    create: XOR<quotesCreateWithoutAssets_quotes_sourceAssetIdToassetsInput, quotesUncheckedCreateWithoutAssets_quotes_sourceAssetIdToassetsInput>
  }

  export type quotesUpdateWithWhereUniqueWithoutAssets_quotes_sourceAssetIdToassetsInput = {
    where: quotesWhereUniqueInput
    data: XOR<quotesUpdateWithoutAssets_quotes_sourceAssetIdToassetsInput, quotesUncheckedUpdateWithoutAssets_quotes_sourceAssetIdToassetsInput>
  }

  export type quotesUpdateManyWithWhereWithoutAssets_quotes_sourceAssetIdToassetsInput = {
    where: quotesScalarWhereInput
    data: XOR<quotesUpdateManyMutationInput, quotesUncheckedUpdateManyWithoutQuotes_quotes_sourceAssetIdToassetsInput>
  }

  export type quotesScalarWhereInput = {
    AND?: Enumerable<quotesScalarWhereInput>
    OR?: Enumerable<quotesScalarWhereInput>
    NOT?: Enumerable<quotesScalarWhereInput>
    id?: UuidFilter | string
    quoteStatusId?: IntFilter | number
    sourceAssetId?: IntFilter | number
    targetAssetId?: IntFilter | number
    side?: Enumenum_quotes_sideFilter | enum_quotes_side
    userId?: StringFilter | string
    vendorId?: IntNullableFilter | number | null
    extraData?: JsonNullableFilter
    error?: JsonNullableFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    fxRequestID?: UuidNullableFilter | string | null
    buyPrice?: StringFilter | string
    sellPrice?: StringFilter | string
    quantity?: StringFilter | string
  }

  export type quotesUpsertWithWhereUniqueWithoutAssets_quotes_targetAssetIdToassetsInput = {
    where: quotesWhereUniqueInput
    update: XOR<quotesUpdateWithoutAssets_quotes_targetAssetIdToassetsInput, quotesUncheckedUpdateWithoutAssets_quotes_targetAssetIdToassetsInput>
    create: XOR<quotesCreateWithoutAssets_quotes_targetAssetIdToassetsInput, quotesUncheckedCreateWithoutAssets_quotes_targetAssetIdToassetsInput>
  }

  export type quotesUpdateWithWhereUniqueWithoutAssets_quotes_targetAssetIdToassetsInput = {
    where: quotesWhereUniqueInput
    data: XOR<quotesUpdateWithoutAssets_quotes_targetAssetIdToassetsInput, quotesUncheckedUpdateWithoutAssets_quotes_targetAssetIdToassetsInput>
  }

  export type quotesUpdateManyWithWhereWithoutAssets_quotes_targetAssetIdToassetsInput = {
    where: quotesScalarWhereInput
    data: XOR<quotesUpdateManyMutationInput, quotesUncheckedUpdateManyWithoutQuotes_quotes_targetAssetIdToassetsInput>
  }

  export type transactionPoliciesUpsertWithWhereUniqueWithoutAssetsInput = {
    where: transactionPoliciesWhereUniqueInput
    update: XOR<transactionPoliciesUpdateWithoutAssetsInput, transactionPoliciesUncheckedUpdateWithoutAssetsInput>
    create: XOR<transactionPoliciesCreateWithoutAssetsInput, transactionPoliciesUncheckedCreateWithoutAssetsInput>
  }

  export type transactionPoliciesUpdateWithWhereUniqueWithoutAssetsInput = {
    where: transactionPoliciesWhereUniqueInput
    data: XOR<transactionPoliciesUpdateWithoutAssetsInput, transactionPoliciesUncheckedUpdateWithoutAssetsInput>
  }

  export type transactionPoliciesUpdateManyWithWhereWithoutAssetsInput = {
    where: transactionPoliciesScalarWhereInput
    data: XOR<transactionPoliciesUpdateManyMutationInput, transactionPoliciesUncheckedUpdateManyWithoutTransactionPoliciesInput>
  }

  export type transactionPoliciesScalarWhereInput = {
    AND?: Enumerable<transactionPoliciesScalarWhereInput>
    OR?: Enumerable<transactionPoliciesScalarWhereInput>
    NOT?: Enumerable<transactionPoliciesScalarWhereInput>
    id?: UuidFilter | string
    userId?: UuidFilter | string
    transactionTypeId?: IntFilter | number
    sourceVaultId?: UuidFilter | string
    targetVaultId?: UuidNullableFilter | string | null
    targetWithdrawalAddressId?: UuidNullableFilter | string | null
    toOneTimeAddresses?: BoolNullableFilter | boolean | null
    greaterThanUSD?: StringFilter | string
    assetId?: IntFilter | number
    action?: Enumenum_transactionPolicies_actionFilter | enum_transactionPolicies_action
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type transactionsUpsertWithWhereUniqueWithoutAssetsInput = {
    where: transactionsWhereUniqueInput
    update: XOR<transactionsUpdateWithoutAssetsInput, transactionsUncheckedUpdateWithoutAssetsInput>
    create: XOR<transactionsCreateWithoutAssetsInput, transactionsUncheckedCreateWithoutAssetsInput>
  }

  export type transactionsUpdateWithWhereUniqueWithoutAssetsInput = {
    where: transactionsWhereUniqueInput
    data: XOR<transactionsUpdateWithoutAssetsInput, transactionsUncheckedUpdateWithoutAssetsInput>
  }

  export type transactionsUpdateManyWithWhereWithoutAssetsInput = {
    where: transactionsScalarWhereInput
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyWithoutTransactionsInput>
  }

  export type transactionsScalarWhereInput = {
    AND?: Enumerable<transactionsScalarWhereInput>
    OR?: Enumerable<transactionsScalarWhereInput>
    NOT?: Enumerable<transactionsScalarWhereInput>
    id?: UuidFilter | string
    custodyVendorId?: IntFilter | number
    custodyVendorRef?: StringFilter | string
    transactionTypeId?: IntFilter | number
    amountAsset?: StringFilter | string
    amountUSD?: StringFilter | string
    assetId?: IntFilter | number
    transactionStatusTypeId?: IntFilter | number
    onChainTxId?: StringNullableFilter | string | null
    sourceVaultId?: UuidNullableFilter | string | null
    targetVaultId?: UuidNullableFilter | string | null
    targetWithdrawalAddressId?: UuidNullableFilter | string | null
    sourceExternalAddress?: StringNullableFilter | string | null
    createdByUserId?: UuidNullableFilter | string | null
    subjectId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type vaultAssetsUpsertWithWhereUniqueWithoutAssetsInput = {
    where: vaultAssetsWhereUniqueInput
    update: XOR<vaultAssetsUpdateWithoutAssetsInput, vaultAssetsUncheckedUpdateWithoutAssetsInput>
    create: XOR<vaultAssetsCreateWithoutAssetsInput, vaultAssetsUncheckedCreateWithoutAssetsInput>
  }

  export type vaultAssetsUpdateWithWhereUniqueWithoutAssetsInput = {
    where: vaultAssetsWhereUniqueInput
    data: XOR<vaultAssetsUpdateWithoutAssetsInput, vaultAssetsUncheckedUpdateWithoutAssetsInput>
  }

  export type vaultAssetsUpdateManyWithWhereWithoutAssetsInput = {
    where: vaultAssetsScalarWhereInput
    data: XOR<vaultAssetsUpdateManyMutationInput, vaultAssetsUncheckedUpdateManyWithoutVaultAssetsInput>
  }

  export type vaultAssetsScalarWhereInput = {
    AND?: Enumerable<vaultAssetsScalarWhereInput>
    OR?: Enumerable<vaultAssetsScalarWhereInput>
    NOT?: Enumerable<vaultAssetsScalarWhereInput>
    id?: IntFilter | number
    vaultId?: UuidFilter | string
    assetId?: IntFilter | number
    balance?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type vendorSupportsAssetsUpsertWithWhereUniqueWithoutAssetsInput = {
    where: vendorSupportsAssetsWhereUniqueInput
    update: XOR<vendorSupportsAssetsUpdateWithoutAssetsInput, vendorSupportsAssetsUncheckedUpdateWithoutAssetsInput>
    create: XOR<vendorSupportsAssetsCreateWithoutAssetsInput, vendorSupportsAssetsUncheckedCreateWithoutAssetsInput>
  }

  export type vendorSupportsAssetsUpdateWithWhereUniqueWithoutAssetsInput = {
    where: vendorSupportsAssetsWhereUniqueInput
    data: XOR<vendorSupportsAssetsUpdateWithoutAssetsInput, vendorSupportsAssetsUncheckedUpdateWithoutAssetsInput>
  }

  export type vendorSupportsAssetsUpdateManyWithWhereWithoutAssetsInput = {
    where: vendorSupportsAssetsScalarWhereInput
    data: XOR<vendorSupportsAssetsUpdateManyMutationInput, vendorSupportsAssetsUncheckedUpdateManyWithoutVendorSupportsAssetsInput>
  }

  export type vendorSupportsAssetsScalarWhereInput = {
    AND?: Enumerable<vendorSupportsAssetsScalarWhereInput>
    OR?: Enumerable<vendorSupportsAssetsScalarWhereInput>
    NOT?: Enumerable<vendorSupportsAssetsScalarWhereInput>
    id?: IntFilter | number
    assetId?: IntFilter | number
    vendorId?: IntFilter | number
    enabled?: BoolNullableFilter | boolean | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    theirId?: StringNullableFilter | string | null
  }

  export type withdrawalAddressesUpsertWithWhereUniqueWithoutAssetsInput = {
    where: withdrawalAddressesWhereUniqueInput
    update: XOR<withdrawalAddressesUpdateWithoutAssetsInput, withdrawalAddressesUncheckedUpdateWithoutAssetsInput>
    create: XOR<withdrawalAddressesCreateWithoutAssetsInput, withdrawalAddressesUncheckedCreateWithoutAssetsInput>
  }

  export type withdrawalAddressesUpdateWithWhereUniqueWithoutAssetsInput = {
    where: withdrawalAddressesWhereUniqueInput
    data: XOR<withdrawalAddressesUpdateWithoutAssetsInput, withdrawalAddressesUncheckedUpdateWithoutAssetsInput>
  }

  export type withdrawalAddressesUpdateManyWithWhereWithoutAssetsInput = {
    where: withdrawalAddressesScalarWhereInput
    data: XOR<withdrawalAddressesUpdateManyMutationInput, withdrawalAddressesUncheckedUpdateManyWithoutWithdrawalAddressesInput>
  }

  export type withdrawalAddressesScalarWhereInput = {
    AND?: Enumerable<withdrawalAddressesScalarWhereInput>
    OR?: Enumerable<withdrawalAddressesScalarWhereInput>
    NOT?: Enumerable<withdrawalAddressesScalarWhereInput>
    id?: UuidFilter | string
    organizationId?: IntFilter | number
    assetId?: IntFilter | number
    nickname?: StringNullableFilter | string | null
    address?: StringFilter | string
    subjectId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type assetsCreateWithoutBaseNetworksInput = {
    name: string
    description: string
    type: enum_assets_type
    ticker: string
    fireblocksTicker?: string | null
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes_quotes_sourceAssetIdToassets?: quotesCreateNestedManyWithoutAssets_quotes_sourceAssetIdToassetsInput
    quotes_quotes_targetAssetIdToassets?: quotesCreateNestedManyWithoutAssets_quotes_targetAssetIdToassetsInput
    transactionPolicies?: transactionPoliciesCreateNestedManyWithoutAssetsInput
    transactions?: transactionsCreateNestedManyWithoutAssetsInput
    vaultAssets?: vaultAssetsCreateNestedManyWithoutAssetsInput
    vendorSupportsAssets?: vendorSupportsAssetsCreateNestedManyWithoutAssetsInput
    withdrawalAddresses?: withdrawalAddressesCreateNestedManyWithoutAssetsInput
  }

  export type assetsUncheckedCreateWithoutBaseNetworksInput = {
    id?: number
    name: string
    description: string
    type: enum_assets_type
    ticker: string
    fireblocksTicker?: string | null
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes_quotes_sourceAssetIdToassets?: quotesUncheckedCreateNestedManyWithoutAssets_quotes_sourceAssetIdToassetsInput
    quotes_quotes_targetAssetIdToassets?: quotesUncheckedCreateNestedManyWithoutAssets_quotes_targetAssetIdToassetsInput
    transactionPolicies?: transactionPoliciesUncheckedCreateNestedManyWithoutAssetsInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutAssetsInput
    vaultAssets?: vaultAssetsUncheckedCreateNestedManyWithoutAssetsInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedCreateNestedManyWithoutAssetsInput
    withdrawalAddresses?: withdrawalAddressesUncheckedCreateNestedManyWithoutAssetsInput
  }

  export type assetsCreateOrConnectWithoutBaseNetworksInput = {
    where: assetsWhereUniqueInput
    create: XOR<assetsCreateWithoutBaseNetworksInput, assetsUncheckedCreateWithoutBaseNetworksInput>
  }

  export type assetsCreateManyBaseNetworksInputEnvelope = {
    data: Enumerable<assetsCreateManyBaseNetworksInput>
    skipDuplicates?: boolean
  }

  export type assetsUpsertWithWhereUniqueWithoutBaseNetworksInput = {
    where: assetsWhereUniqueInput
    update: XOR<assetsUpdateWithoutBaseNetworksInput, assetsUncheckedUpdateWithoutBaseNetworksInput>
    create: XOR<assetsCreateWithoutBaseNetworksInput, assetsUncheckedCreateWithoutBaseNetworksInput>
  }

  export type assetsUpdateWithWhereUniqueWithoutBaseNetworksInput = {
    where: assetsWhereUniqueInput
    data: XOR<assetsUpdateWithoutBaseNetworksInput, assetsUncheckedUpdateWithoutBaseNetworksInput>
  }

  export type assetsUpdateManyWithWhereWithoutBaseNetworksInput = {
    where: assetsScalarWhereInput
    data: XOR<assetsUpdateManyMutationInput, assetsUncheckedUpdateManyWithoutAssetsInput>
  }

  export type assetsScalarWhereInput = {
    AND?: Enumerable<assetsScalarWhereInput>
    OR?: Enumerable<assetsScalarWhereInput>
    NOT?: Enumerable<assetsScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    description?: StringFilter | string
    baseNetworkId?: IntNullableFilter | number | null
    type?: Enumenum_assets_typeFilter | enum_assets_type
    ticker?: StringFilter | string
    fireblocksTicker?: StringNullableFilter | string | null
    enabled?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ordersCreateWithoutQuotesInput = {
    id: string
    orderStatus?: string | null
    userAcceptedPrice: string
    userAcceptedQuantity: string
    userAcceptedSide: enum_orders_userAcceptedSide
    userAcceptedTradePair: JsonNullValueInput | InputJsonValue
    userAcceptedTimestamp: Date | string
    orderType?: enum_orders_orderType | null
    orderTimeInForce?: string | null
    vendorQuoteId?: string | null
    vendorQuantityRequested?: string | null
    vendorPriceRequested?: string | null
    orderQuantityExecuted?: string | null
    orderPriceExecuted?: string | null
    orderTimestampExecuted?: Date | string | null
    orderVendorStatus?: string | null
    allowedSlippage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ordersUncheckedCreateWithoutQuotesInput = {
    id: string
    orderStatus?: string | null
    userAcceptedPrice: string
    userAcceptedQuantity: string
    userAcceptedSide: enum_orders_userAcceptedSide
    userAcceptedTradePair: JsonNullValueInput | InputJsonValue
    userAcceptedTimestamp: Date | string
    orderType?: enum_orders_orderType | null
    orderTimeInForce?: string | null
    vendorQuoteId?: string | null
    vendorQuantityRequested?: string | null
    vendorPriceRequested?: string | null
    orderQuantityExecuted?: string | null
    orderPriceExecuted?: string | null
    orderTimestampExecuted?: Date | string | null
    orderVendorStatus?: string | null
    allowedSlippage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ordersCreateOrConnectWithoutQuotesInput = {
    where: ordersWhereUniqueInput
    create: XOR<ordersCreateWithoutQuotesInput, ordersUncheckedCreateWithoutQuotesInput>
  }

  export type ordersCreateManyQuotesInputEnvelope = {
    data: Enumerable<ordersCreateManyQuotesInput>
    skipDuplicates?: boolean
  }

  export type tokenPairsInfoCreateWithoutQuotesInput = {
    fxRequestID: string
    quantity: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tokenPairs: tokenPairsCreateNestedOneWithoutTokenPairsInfoInput
  }

  export type tokenPairsInfoUncheckedCreateWithoutQuotesInput = {
    id?: number
    tokenPairId: number
    fxRequestID: string
    quantity: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type tokenPairsInfoCreateOrConnectWithoutQuotesInput = {
    where: tokenPairsInfoWhereUniqueInput
    create: XOR<tokenPairsInfoCreateWithoutQuotesInput, tokenPairsInfoUncheckedCreateWithoutQuotesInput>
  }

  export type quoteStatusesCreateWithoutQuotesInput = {
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type quoteStatusesUncheckedCreateWithoutQuotesInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type quoteStatusesCreateOrConnectWithoutQuotesInput = {
    where: quoteStatusesWhereUniqueInput
    create: XOR<quoteStatusesCreateWithoutQuotesInput, quoteStatusesUncheckedCreateWithoutQuotesInput>
  }

  export type assetsCreateWithoutQuotes_quotes_sourceAssetIdToassetsInput = {
    name: string
    description: string
    type: enum_assets_type
    ticker: string
    fireblocksTicker?: string | null
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    baseNetworks?: baseNetworksCreateNestedOneWithoutAssetsInput
    quotes_quotes_targetAssetIdToassets?: quotesCreateNestedManyWithoutAssets_quotes_targetAssetIdToassetsInput
    transactionPolicies?: transactionPoliciesCreateNestedManyWithoutAssetsInput
    transactions?: transactionsCreateNestedManyWithoutAssetsInput
    vaultAssets?: vaultAssetsCreateNestedManyWithoutAssetsInput
    vendorSupportsAssets?: vendorSupportsAssetsCreateNestedManyWithoutAssetsInput
    withdrawalAddresses?: withdrawalAddressesCreateNestedManyWithoutAssetsInput
  }

  export type assetsUncheckedCreateWithoutQuotes_quotes_sourceAssetIdToassetsInput = {
    id?: number
    name: string
    description: string
    baseNetworkId?: number | null
    type: enum_assets_type
    ticker: string
    fireblocksTicker?: string | null
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes_quotes_targetAssetIdToassets?: quotesUncheckedCreateNestedManyWithoutAssets_quotes_targetAssetIdToassetsInput
    transactionPolicies?: transactionPoliciesUncheckedCreateNestedManyWithoutAssetsInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutAssetsInput
    vaultAssets?: vaultAssetsUncheckedCreateNestedManyWithoutAssetsInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedCreateNestedManyWithoutAssetsInput
    withdrawalAddresses?: withdrawalAddressesUncheckedCreateNestedManyWithoutAssetsInput
  }

  export type assetsCreateOrConnectWithoutQuotes_quotes_sourceAssetIdToassetsInput = {
    where: assetsWhereUniqueInput
    create: XOR<assetsCreateWithoutQuotes_quotes_sourceAssetIdToassetsInput, assetsUncheckedCreateWithoutQuotes_quotes_sourceAssetIdToassetsInput>
  }

  export type assetsCreateWithoutQuotes_quotes_targetAssetIdToassetsInput = {
    name: string
    description: string
    type: enum_assets_type
    ticker: string
    fireblocksTicker?: string | null
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    baseNetworks?: baseNetworksCreateNestedOneWithoutAssetsInput
    quotes_quotes_sourceAssetIdToassets?: quotesCreateNestedManyWithoutAssets_quotes_sourceAssetIdToassetsInput
    transactionPolicies?: transactionPoliciesCreateNestedManyWithoutAssetsInput
    transactions?: transactionsCreateNestedManyWithoutAssetsInput
    vaultAssets?: vaultAssetsCreateNestedManyWithoutAssetsInput
    vendorSupportsAssets?: vendorSupportsAssetsCreateNestedManyWithoutAssetsInput
    withdrawalAddresses?: withdrawalAddressesCreateNestedManyWithoutAssetsInput
  }

  export type assetsUncheckedCreateWithoutQuotes_quotes_targetAssetIdToassetsInput = {
    id?: number
    name: string
    description: string
    baseNetworkId?: number | null
    type: enum_assets_type
    ticker: string
    fireblocksTicker?: string | null
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes_quotes_sourceAssetIdToassets?: quotesUncheckedCreateNestedManyWithoutAssets_quotes_sourceAssetIdToassetsInput
    transactionPolicies?: transactionPoliciesUncheckedCreateNestedManyWithoutAssetsInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutAssetsInput
    vaultAssets?: vaultAssetsUncheckedCreateNestedManyWithoutAssetsInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedCreateNestedManyWithoutAssetsInput
    withdrawalAddresses?: withdrawalAddressesUncheckedCreateNestedManyWithoutAssetsInput
  }

  export type assetsCreateOrConnectWithoutQuotes_quotes_targetAssetIdToassetsInput = {
    where: assetsWhereUniqueInput
    create: XOR<assetsCreateWithoutQuotes_quotes_targetAssetIdToassetsInput, assetsUncheckedCreateWithoutQuotes_quotes_targetAssetIdToassetsInput>
  }

  export type vendorsCreateWithoutQuotesInput = {
    name: string
    identifier: string
    quoteEngineBaseBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsCreateNestedManyWithoutVendorsInput
    depositAddresses?: depositAddressesCreateNestedManyWithoutVendorsInput
    tokenPairs?: tokenPairsCreateNestedManyWithoutVendorsInput
    transactions?: transactionsCreateNestedManyWithoutVendorsInput
    vendorSupportsAssets?: vendorSupportsAssetsCreateNestedManyWithoutVendorsInput
    vendorTypes: vendorTypesCreateNestedOneWithoutVendorsInput
  }

  export type vendorsUncheckedCreateWithoutQuotesInput = {
    id?: number
    name: string
    identifier: string
    vendorTypeId: number
    quoteEngineBaseBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUncheckedCreateNestedManyWithoutVendorsInput
    depositAddresses?: depositAddressesUncheckedCreateNestedManyWithoutVendorsInput
    tokenPairs?: tokenPairsUncheckedCreateNestedManyWithoutVendorsInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutVendorsInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedCreateNestedManyWithoutVendorsInput
  }

  export type vendorsCreateOrConnectWithoutQuotesInput = {
    where: vendorsWhereUniqueInput
    create: XOR<vendorsCreateWithoutQuotesInput, vendorsUncheckedCreateWithoutQuotesInput>
  }

  export type ordersUpsertWithWhereUniqueWithoutQuotesInput = {
    where: ordersWhereUniqueInput
    update: XOR<ordersUpdateWithoutQuotesInput, ordersUncheckedUpdateWithoutQuotesInput>
    create: XOR<ordersCreateWithoutQuotesInput, ordersUncheckedCreateWithoutQuotesInput>
  }

  export type ordersUpdateWithWhereUniqueWithoutQuotesInput = {
    where: ordersWhereUniqueInput
    data: XOR<ordersUpdateWithoutQuotesInput, ordersUncheckedUpdateWithoutQuotesInput>
  }

  export type ordersUpdateManyWithWhereWithoutQuotesInput = {
    where: ordersScalarWhereInput
    data: XOR<ordersUpdateManyMutationInput, ordersUncheckedUpdateManyWithoutOrdersInput>
  }

  export type ordersScalarWhereInput = {
    AND?: Enumerable<ordersScalarWhereInput>
    OR?: Enumerable<ordersScalarWhereInput>
    NOT?: Enumerable<ordersScalarWhereInput>
    id?: UuidFilter | string
    quoteId?: UuidFilter | string
    orderStatus?: StringNullableFilter | string | null
    userAcceptedPrice?: StringFilter | string
    userAcceptedQuantity?: StringFilter | string
    userAcceptedSide?: Enumenum_orders_userAcceptedSideFilter | enum_orders_userAcceptedSide
    userAcceptedTradePair?: JsonFilter
    userAcceptedTimestamp?: DateTimeFilter | Date | string
    orderType?: Enumenum_orders_orderTypeNullableFilter | enum_orders_orderType | null
    orderTimeInForce?: StringNullableFilter | string | null
    vendorQuoteId?: StringNullableFilter | string | null
    vendorQuantityRequested?: StringNullableFilter | string | null
    vendorPriceRequested?: StringNullableFilter | string | null
    orderQuantityExecuted?: StringNullableFilter | string | null
    orderPriceExecuted?: StringNullableFilter | string | null
    orderTimestampExecuted?: DateTimeNullableFilter | Date | string | null
    orderVendorStatus?: StringNullableFilter | string | null
    allowedSlippage?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type tokenPairsInfoUpsertWithoutQuotesInput = {
    update: XOR<tokenPairsInfoUpdateWithoutQuotesInput, tokenPairsInfoUncheckedUpdateWithoutQuotesInput>
    create: XOR<tokenPairsInfoCreateWithoutQuotesInput, tokenPairsInfoUncheckedCreateWithoutQuotesInput>
  }

  export type tokenPairsInfoUpdateWithoutQuotesInput = {
    fxRequestID?: StringFieldUpdateOperationsInput | string
    quantity?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenPairs?: tokenPairsUpdateOneRequiredWithoutTokenPairsInfoNestedInput
  }

  export type tokenPairsInfoUncheckedUpdateWithoutQuotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenPairId?: IntFieldUpdateOperationsInput | number
    fxRequestID?: StringFieldUpdateOperationsInput | string
    quantity?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quoteStatusesUpsertWithoutQuotesInput = {
    update: XOR<quoteStatusesUpdateWithoutQuotesInput, quoteStatusesUncheckedUpdateWithoutQuotesInput>
    create: XOR<quoteStatusesCreateWithoutQuotesInput, quoteStatusesUncheckedCreateWithoutQuotesInput>
  }

  export type quoteStatusesUpdateWithoutQuotesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quoteStatusesUncheckedUpdateWithoutQuotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type assetsUpsertWithoutQuotes_quotes_sourceAssetIdToassetsInput = {
    update: XOR<assetsUpdateWithoutQuotes_quotes_sourceAssetIdToassetsInput, assetsUncheckedUpdateWithoutQuotes_quotes_sourceAssetIdToassetsInput>
    create: XOR<assetsCreateWithoutQuotes_quotes_sourceAssetIdToassetsInput, assetsUncheckedCreateWithoutQuotes_quotes_sourceAssetIdToassetsInput>
  }

  export type assetsUpdateWithoutQuotes_quotes_sourceAssetIdToassetsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: Enumenum_assets_typeFieldUpdateOperationsInput | enum_assets_type
    ticker?: StringFieldUpdateOperationsInput | string
    fireblocksTicker?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseNetworks?: baseNetworksUpdateOneWithoutAssetsNestedInput
    quotes_quotes_targetAssetIdToassets?: quotesUpdateManyWithoutAssets_quotes_targetAssetIdToassetsNestedInput
    transactionPolicies?: transactionPoliciesUpdateManyWithoutAssetsNestedInput
    transactions?: transactionsUpdateManyWithoutAssetsNestedInput
    vaultAssets?: vaultAssetsUpdateManyWithoutAssetsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUpdateManyWithoutAssetsNestedInput
    withdrawalAddresses?: withdrawalAddressesUpdateManyWithoutAssetsNestedInput
  }

  export type assetsUncheckedUpdateWithoutQuotes_quotes_sourceAssetIdToassetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    baseNetworkId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: Enumenum_assets_typeFieldUpdateOperationsInput | enum_assets_type
    ticker?: StringFieldUpdateOperationsInput | string
    fireblocksTicker?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes_quotes_targetAssetIdToassets?: quotesUncheckedUpdateManyWithoutAssets_quotes_targetAssetIdToassetsNestedInput
    transactionPolicies?: transactionPoliciesUncheckedUpdateManyWithoutAssetsNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutAssetsNestedInput
    vaultAssets?: vaultAssetsUncheckedUpdateManyWithoutAssetsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedUpdateManyWithoutAssetsNestedInput
    withdrawalAddresses?: withdrawalAddressesUncheckedUpdateManyWithoutAssetsNestedInput
  }

  export type assetsUpsertWithoutQuotes_quotes_targetAssetIdToassetsInput = {
    update: XOR<assetsUpdateWithoutQuotes_quotes_targetAssetIdToassetsInput, assetsUncheckedUpdateWithoutQuotes_quotes_targetAssetIdToassetsInput>
    create: XOR<assetsCreateWithoutQuotes_quotes_targetAssetIdToassetsInput, assetsUncheckedCreateWithoutQuotes_quotes_targetAssetIdToassetsInput>
  }

  export type assetsUpdateWithoutQuotes_quotes_targetAssetIdToassetsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: Enumenum_assets_typeFieldUpdateOperationsInput | enum_assets_type
    ticker?: StringFieldUpdateOperationsInput | string
    fireblocksTicker?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseNetworks?: baseNetworksUpdateOneWithoutAssetsNestedInput
    quotes_quotes_sourceAssetIdToassets?: quotesUpdateManyWithoutAssets_quotes_sourceAssetIdToassetsNestedInput
    transactionPolicies?: transactionPoliciesUpdateManyWithoutAssetsNestedInput
    transactions?: transactionsUpdateManyWithoutAssetsNestedInput
    vaultAssets?: vaultAssetsUpdateManyWithoutAssetsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUpdateManyWithoutAssetsNestedInput
    withdrawalAddresses?: withdrawalAddressesUpdateManyWithoutAssetsNestedInput
  }

  export type assetsUncheckedUpdateWithoutQuotes_quotes_targetAssetIdToassetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    baseNetworkId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: Enumenum_assets_typeFieldUpdateOperationsInput | enum_assets_type
    ticker?: StringFieldUpdateOperationsInput | string
    fireblocksTicker?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes_quotes_sourceAssetIdToassets?: quotesUncheckedUpdateManyWithoutAssets_quotes_sourceAssetIdToassetsNestedInput
    transactionPolicies?: transactionPoliciesUncheckedUpdateManyWithoutAssetsNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutAssetsNestedInput
    vaultAssets?: vaultAssetsUncheckedUpdateManyWithoutAssetsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedUpdateManyWithoutAssetsNestedInput
    withdrawalAddresses?: withdrawalAddressesUncheckedUpdateManyWithoutAssetsNestedInput
  }

  export type vendorsUpsertWithoutQuotesInput = {
    update: XOR<vendorsUpdateWithoutQuotesInput, vendorsUncheckedUpdateWithoutQuotesInput>
    create: XOR<vendorsCreateWithoutQuotesInput, vendorsUncheckedCreateWithoutQuotesInput>
  }

  export type vendorsUpdateWithoutQuotesInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    quoteEngineBaseBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUpdateManyWithoutVendorsNestedInput
    depositAddresses?: depositAddressesUpdateManyWithoutVendorsNestedInput
    tokenPairs?: tokenPairsUpdateManyWithoutVendorsNestedInput
    transactions?: transactionsUpdateManyWithoutVendorsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUpdateManyWithoutVendorsNestedInput
    vendorTypes?: vendorTypesUpdateOneRequiredWithoutVendorsNestedInput
  }

  export type vendorsUncheckedUpdateWithoutQuotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    vendorTypeId?: IntFieldUpdateOperationsInput | number
    quoteEngineBaseBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUncheckedUpdateManyWithoutVendorsNestedInput
    depositAddresses?: depositAddressesUncheckedUpdateManyWithoutVendorsNestedInput
    tokenPairs?: tokenPairsUncheckedUpdateManyWithoutVendorsNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutVendorsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedUpdateManyWithoutVendorsNestedInput
  }

  export type transactionsCreateWithoutTransactionStatusTypesInput = {
    id: string
    custodyVendorRef: string
    amountAsset: string
    amountUSD: string
    onChainTxId?: string | null
    sourceExternalAddress?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assets: assetsCreateNestedOneWithoutTransactionsInput
    users?: usersCreateNestedOneWithoutTransactionsInput
    vendors: vendorsCreateNestedOneWithoutTransactionsInput
    vaults_transactions_sourceVaultIdTovaults?: vaultsCreateNestedOneWithoutTransactions_transactions_sourceVaultIdTovaultsInput
    vaults_transactions_targetVaultIdTovaults?: vaultsCreateNestedOneWithoutTransactions_transactions_targetVaultIdTovaultsInput
    withdrawalAddresses?: withdrawalAddressesCreateNestedOneWithoutTransactionsInput
    transactionTypes: transactionTypesCreateNestedOneWithoutTransactionsInput
  }

  export type transactionsUncheckedCreateWithoutTransactionStatusTypesInput = {
    id: string
    custodyVendorId: number
    custodyVendorRef: string
    transactionTypeId: number
    amountAsset: string
    amountUSD: string
    assetId: number
    onChainTxId?: string | null
    sourceVaultId?: string | null
    targetVaultId?: string | null
    targetWithdrawalAddressId?: string | null
    sourceExternalAddress?: string | null
    createdByUserId?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionsCreateOrConnectWithoutTransactionStatusTypesInput = {
    where: transactionsWhereUniqueInput
    create: XOR<transactionsCreateWithoutTransactionStatusTypesInput, transactionsUncheckedCreateWithoutTransactionStatusTypesInput>
  }

  export type transactionsCreateManyTransactionStatusTypesInputEnvelope = {
    data: Enumerable<transactionsCreateManyTransactionStatusTypesInput>
    skipDuplicates?: boolean
  }

  export type transactionsUpsertWithWhereUniqueWithoutTransactionStatusTypesInput = {
    where: transactionsWhereUniqueInput
    update: XOR<transactionsUpdateWithoutTransactionStatusTypesInput, transactionsUncheckedUpdateWithoutTransactionStatusTypesInput>
    create: XOR<transactionsCreateWithoutTransactionStatusTypesInput, transactionsUncheckedCreateWithoutTransactionStatusTypesInput>
  }

  export type transactionsUpdateWithWhereUniqueWithoutTransactionStatusTypesInput = {
    where: transactionsWhereUniqueInput
    data: XOR<transactionsUpdateWithoutTransactionStatusTypesInput, transactionsUncheckedUpdateWithoutTransactionStatusTypesInput>
  }

  export type transactionsUpdateManyWithWhereWithoutTransactionStatusTypesInput = {
    where: transactionsScalarWhereInput
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyWithoutTransactionsInput>
  }

  export type transactionPoliciesCreateWithoutTransactionTypesInput = {
    id: string
    toOneTimeAddresses?: boolean | null
    greaterThanUSD: string
    action: enum_transactionPolicies_action
    createdAt?: Date | string
    updatedAt?: Date | string
    assets: assetsCreateNestedOneWithoutTransactionPoliciesInput
    vaults_transactionPolicies_sourceVaultIdTovaults: vaultsCreateNestedOneWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput
    vaults_transactionPolicies_targetVaultIdTovaults?: vaultsCreateNestedOneWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput
    withdrawalAddresses?: withdrawalAddressesCreateNestedOneWithoutTransactionPoliciesInput
    users: usersCreateNestedOneWithoutTransactionPoliciesInput
  }

  export type transactionPoliciesUncheckedCreateWithoutTransactionTypesInput = {
    id: string
    userId: string
    sourceVaultId: string
    targetVaultId?: string | null
    targetWithdrawalAddressId?: string | null
    toOneTimeAddresses?: boolean | null
    greaterThanUSD: string
    assetId: number
    action: enum_transactionPolicies_action
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionPoliciesCreateOrConnectWithoutTransactionTypesInput = {
    where: transactionPoliciesWhereUniqueInput
    create: XOR<transactionPoliciesCreateWithoutTransactionTypesInput, transactionPoliciesUncheckedCreateWithoutTransactionTypesInput>
  }

  export type transactionPoliciesCreateManyTransactionTypesInputEnvelope = {
    data: Enumerable<transactionPoliciesCreateManyTransactionTypesInput>
    skipDuplicates?: boolean
  }

  export type transactionsCreateWithoutTransactionTypesInput = {
    id: string
    custodyVendorRef: string
    amountAsset: string
    amountUSD: string
    onChainTxId?: string | null
    sourceExternalAddress?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assets: assetsCreateNestedOneWithoutTransactionsInput
    users?: usersCreateNestedOneWithoutTransactionsInput
    vendors: vendorsCreateNestedOneWithoutTransactionsInput
    vaults_transactions_sourceVaultIdTovaults?: vaultsCreateNestedOneWithoutTransactions_transactions_sourceVaultIdTovaultsInput
    vaults_transactions_targetVaultIdTovaults?: vaultsCreateNestedOneWithoutTransactions_transactions_targetVaultIdTovaultsInput
    withdrawalAddresses?: withdrawalAddressesCreateNestedOneWithoutTransactionsInput
    transactionStatusTypes: transactionStatusTypesCreateNestedOneWithoutTransactionsInput
  }

  export type transactionsUncheckedCreateWithoutTransactionTypesInput = {
    id: string
    custodyVendorId: number
    custodyVendorRef: string
    amountAsset: string
    amountUSD: string
    assetId: number
    transactionStatusTypeId: number
    onChainTxId?: string | null
    sourceVaultId?: string | null
    targetVaultId?: string | null
    targetWithdrawalAddressId?: string | null
    sourceExternalAddress?: string | null
    createdByUserId?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionsCreateOrConnectWithoutTransactionTypesInput = {
    where: transactionsWhereUniqueInput
    create: XOR<transactionsCreateWithoutTransactionTypesInput, transactionsUncheckedCreateWithoutTransactionTypesInput>
  }

  export type transactionsCreateManyTransactionTypesInputEnvelope = {
    data: Enumerable<transactionsCreateManyTransactionTypesInput>
    skipDuplicates?: boolean
  }

  export type transactionPoliciesUpsertWithWhereUniqueWithoutTransactionTypesInput = {
    where: transactionPoliciesWhereUniqueInput
    update: XOR<transactionPoliciesUpdateWithoutTransactionTypesInput, transactionPoliciesUncheckedUpdateWithoutTransactionTypesInput>
    create: XOR<transactionPoliciesCreateWithoutTransactionTypesInput, transactionPoliciesUncheckedCreateWithoutTransactionTypesInput>
  }

  export type transactionPoliciesUpdateWithWhereUniqueWithoutTransactionTypesInput = {
    where: transactionPoliciesWhereUniqueInput
    data: XOR<transactionPoliciesUpdateWithoutTransactionTypesInput, transactionPoliciesUncheckedUpdateWithoutTransactionTypesInput>
  }

  export type transactionPoliciesUpdateManyWithWhereWithoutTransactionTypesInput = {
    where: transactionPoliciesScalarWhereInput
    data: XOR<transactionPoliciesUpdateManyMutationInput, transactionPoliciesUncheckedUpdateManyWithoutTransactionPoliciesInput>
  }

  export type transactionsUpsertWithWhereUniqueWithoutTransactionTypesInput = {
    where: transactionsWhereUniqueInput
    update: XOR<transactionsUpdateWithoutTransactionTypesInput, transactionsUncheckedUpdateWithoutTransactionTypesInput>
    create: XOR<transactionsCreateWithoutTransactionTypesInput, transactionsUncheckedCreateWithoutTransactionTypesInput>
  }

  export type transactionsUpdateWithWhereUniqueWithoutTransactionTypesInput = {
    where: transactionsWhereUniqueInput
    data: XOR<transactionsUpdateWithoutTransactionTypesInput, transactionsUncheckedUpdateWithoutTransactionTypesInput>
  }

  export type transactionsUpdateManyWithWhereWithoutTransactionTypesInput = {
    where: transactionsScalarWhereInput
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyWithoutTransactionsInput>
  }

  export type assetsCreateWithoutTransactionsInput = {
    name: string
    description: string
    type: enum_assets_type
    ticker: string
    fireblocksTicker?: string | null
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    baseNetworks?: baseNetworksCreateNestedOneWithoutAssetsInput
    quotes_quotes_sourceAssetIdToassets?: quotesCreateNestedManyWithoutAssets_quotes_sourceAssetIdToassetsInput
    quotes_quotes_targetAssetIdToassets?: quotesCreateNestedManyWithoutAssets_quotes_targetAssetIdToassetsInput
    transactionPolicies?: transactionPoliciesCreateNestedManyWithoutAssetsInput
    vaultAssets?: vaultAssetsCreateNestedManyWithoutAssetsInput
    vendorSupportsAssets?: vendorSupportsAssetsCreateNestedManyWithoutAssetsInput
    withdrawalAddresses?: withdrawalAddressesCreateNestedManyWithoutAssetsInput
  }

  export type assetsUncheckedCreateWithoutTransactionsInput = {
    id?: number
    name: string
    description: string
    baseNetworkId?: number | null
    type: enum_assets_type
    ticker: string
    fireblocksTicker?: string | null
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes_quotes_sourceAssetIdToassets?: quotesUncheckedCreateNestedManyWithoutAssets_quotes_sourceAssetIdToassetsInput
    quotes_quotes_targetAssetIdToassets?: quotesUncheckedCreateNestedManyWithoutAssets_quotes_targetAssetIdToassetsInput
    transactionPolicies?: transactionPoliciesUncheckedCreateNestedManyWithoutAssetsInput
    vaultAssets?: vaultAssetsUncheckedCreateNestedManyWithoutAssetsInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedCreateNestedManyWithoutAssetsInput
    withdrawalAddresses?: withdrawalAddressesUncheckedCreateNestedManyWithoutAssetsInput
  }

  export type assetsCreateOrConnectWithoutTransactionsInput = {
    where: assetsWhereUniqueInput
    create: XOR<assetsCreateWithoutTransactionsInput, assetsUncheckedCreateWithoutTransactionsInput>
  }

  export type usersCreateWithoutTransactionsInput = {
    id: string
    primaryEmail: string
    firstName: string
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publicKey?: string | null
    apiKey?: string | null
    transactionPolicies?: transactionPoliciesCreateNestedManyWithoutUsersInput
    organizations: organizationsCreateNestedOneWithoutUsersInput
    userTypes: userTypesCreateNestedOneWithoutUsersInput
    vaults?: vaultsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutTransactionsInput = {
    id: string
    organizationId: number
    userTypeId: number
    primaryEmail: string
    firstName: string
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publicKey?: string | null
    apiKey?: string | null
    transactionPolicies?: transactionPoliciesUncheckedCreateNestedManyWithoutUsersInput
    vaults?: vaultsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutTransactionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTransactionsInput, usersUncheckedCreateWithoutTransactionsInput>
  }

  export type vendorsCreateWithoutTransactionsInput = {
    name: string
    identifier: string
    quoteEngineBaseBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsCreateNestedManyWithoutVendorsInput
    depositAddresses?: depositAddressesCreateNestedManyWithoutVendorsInput
    quotes?: quotesCreateNestedManyWithoutVendorsInput
    tokenPairs?: tokenPairsCreateNestedManyWithoutVendorsInput
    vendorSupportsAssets?: vendorSupportsAssetsCreateNestedManyWithoutVendorsInput
    vendorTypes: vendorTypesCreateNestedOneWithoutVendorsInput
  }

  export type vendorsUncheckedCreateWithoutTransactionsInput = {
    id?: number
    name: string
    identifier: string
    vendorTypeId: number
    quoteEngineBaseBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUncheckedCreateNestedManyWithoutVendorsInput
    depositAddresses?: depositAddressesUncheckedCreateNestedManyWithoutVendorsInput
    quotes?: quotesUncheckedCreateNestedManyWithoutVendorsInput
    tokenPairs?: tokenPairsUncheckedCreateNestedManyWithoutVendorsInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedCreateNestedManyWithoutVendorsInput
  }

  export type vendorsCreateOrConnectWithoutTransactionsInput = {
    where: vendorsWhereUniqueInput
    create: XOR<vendorsCreateWithoutTransactionsInput, vendorsUncheckedCreateWithoutTransactionsInput>
  }

  export type vaultsCreateWithoutTransactions_transactions_sourceVaultIdTovaultsInput = {
    id: string
    vaultName?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesCreateNestedManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesCreateNestedManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput
    transactions_transactions_targetVaultIdTovaults?: transactionsCreateNestedManyWithoutVaults_transactions_targetVaultIdTovaultsInput
    vaultAssets?: vaultAssetsCreateNestedManyWithoutVaultsInput
    users: usersCreateNestedOneWithoutVaultsInput
    vaultStatusTypes?: vaultStatusTypesCreateNestedOneWithoutVaultsInput
  }

  export type vaultsUncheckedCreateWithoutTransactions_transactions_sourceVaultIdTovaultsInput = {
    id: string
    createdByUserId: string
    vaultStatusId?: number | null
    vaultName?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesUncheckedCreateNestedManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesUncheckedCreateNestedManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput
    transactions_transactions_targetVaultIdTovaults?: transactionsUncheckedCreateNestedManyWithoutVaults_transactions_targetVaultIdTovaultsInput
    vaultAssets?: vaultAssetsUncheckedCreateNestedManyWithoutVaultsInput
  }

  export type vaultsCreateOrConnectWithoutTransactions_transactions_sourceVaultIdTovaultsInput = {
    where: vaultsWhereUniqueInput
    create: XOR<vaultsCreateWithoutTransactions_transactions_sourceVaultIdTovaultsInput, vaultsUncheckedCreateWithoutTransactions_transactions_sourceVaultIdTovaultsInput>
  }

  export type vaultsCreateWithoutTransactions_transactions_targetVaultIdTovaultsInput = {
    id: string
    vaultName?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesCreateNestedManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesCreateNestedManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsCreateNestedManyWithoutVaults_transactions_sourceVaultIdTovaultsInput
    vaultAssets?: vaultAssetsCreateNestedManyWithoutVaultsInput
    users: usersCreateNestedOneWithoutVaultsInput
    vaultStatusTypes?: vaultStatusTypesCreateNestedOneWithoutVaultsInput
  }

  export type vaultsUncheckedCreateWithoutTransactions_transactions_targetVaultIdTovaultsInput = {
    id: string
    createdByUserId: string
    vaultStatusId?: number | null
    vaultName?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesUncheckedCreateNestedManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesUncheckedCreateNestedManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsUncheckedCreateNestedManyWithoutVaults_transactions_sourceVaultIdTovaultsInput
    vaultAssets?: vaultAssetsUncheckedCreateNestedManyWithoutVaultsInput
  }

  export type vaultsCreateOrConnectWithoutTransactions_transactions_targetVaultIdTovaultsInput = {
    where: vaultsWhereUniqueInput
    create: XOR<vaultsCreateWithoutTransactions_transactions_targetVaultIdTovaultsInput, vaultsUncheckedCreateWithoutTransactions_transactions_targetVaultIdTovaultsInput>
  }

  export type withdrawalAddressesCreateWithoutTransactionsInput = {
    id: string
    nickname?: string | null
    address: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionPolicies?: transactionPoliciesCreateNestedManyWithoutWithdrawalAddressesInput
    assets: assetsCreateNestedOneWithoutWithdrawalAddressesInput
    organizations: organizationsCreateNestedOneWithoutWithdrawalAddressesInput
  }

  export type withdrawalAddressesUncheckedCreateWithoutTransactionsInput = {
    id: string
    organizationId: number
    assetId: number
    nickname?: string | null
    address: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionPolicies?: transactionPoliciesUncheckedCreateNestedManyWithoutWithdrawalAddressesInput
  }

  export type withdrawalAddressesCreateOrConnectWithoutTransactionsInput = {
    where: withdrawalAddressesWhereUniqueInput
    create: XOR<withdrawalAddressesCreateWithoutTransactionsInput, withdrawalAddressesUncheckedCreateWithoutTransactionsInput>
  }

  export type transactionStatusTypesCreateWithoutTransactionsInput = {
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionStatusTypesUncheckedCreateWithoutTransactionsInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionStatusTypesCreateOrConnectWithoutTransactionsInput = {
    where: transactionStatusTypesWhereUniqueInput
    create: XOR<transactionStatusTypesCreateWithoutTransactionsInput, transactionStatusTypesUncheckedCreateWithoutTransactionsInput>
  }

  export type transactionTypesCreateWithoutTransactionsInput = {
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionPolicies?: transactionPoliciesCreateNestedManyWithoutTransactionTypesInput
  }

  export type transactionTypesUncheckedCreateWithoutTransactionsInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionPolicies?: transactionPoliciesUncheckedCreateNestedManyWithoutTransactionTypesInput
  }

  export type transactionTypesCreateOrConnectWithoutTransactionsInput = {
    where: transactionTypesWhereUniqueInput
    create: XOR<transactionTypesCreateWithoutTransactionsInput, transactionTypesUncheckedCreateWithoutTransactionsInput>
  }

  export type assetsUpsertWithoutTransactionsInput = {
    update: XOR<assetsUpdateWithoutTransactionsInput, assetsUncheckedUpdateWithoutTransactionsInput>
    create: XOR<assetsCreateWithoutTransactionsInput, assetsUncheckedCreateWithoutTransactionsInput>
  }

  export type assetsUpdateWithoutTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: Enumenum_assets_typeFieldUpdateOperationsInput | enum_assets_type
    ticker?: StringFieldUpdateOperationsInput | string
    fireblocksTicker?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseNetworks?: baseNetworksUpdateOneWithoutAssetsNestedInput
    quotes_quotes_sourceAssetIdToassets?: quotesUpdateManyWithoutAssets_quotes_sourceAssetIdToassetsNestedInput
    quotes_quotes_targetAssetIdToassets?: quotesUpdateManyWithoutAssets_quotes_targetAssetIdToassetsNestedInput
    transactionPolicies?: transactionPoliciesUpdateManyWithoutAssetsNestedInput
    vaultAssets?: vaultAssetsUpdateManyWithoutAssetsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUpdateManyWithoutAssetsNestedInput
    withdrawalAddresses?: withdrawalAddressesUpdateManyWithoutAssetsNestedInput
  }

  export type assetsUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    baseNetworkId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: Enumenum_assets_typeFieldUpdateOperationsInput | enum_assets_type
    ticker?: StringFieldUpdateOperationsInput | string
    fireblocksTicker?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes_quotes_sourceAssetIdToassets?: quotesUncheckedUpdateManyWithoutAssets_quotes_sourceAssetIdToassetsNestedInput
    quotes_quotes_targetAssetIdToassets?: quotesUncheckedUpdateManyWithoutAssets_quotes_targetAssetIdToassetsNestedInput
    transactionPolicies?: transactionPoliciesUncheckedUpdateManyWithoutAssetsNestedInput
    vaultAssets?: vaultAssetsUncheckedUpdateManyWithoutAssetsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedUpdateManyWithoutAssetsNestedInput
    withdrawalAddresses?: withdrawalAddressesUncheckedUpdateManyWithoutAssetsNestedInput
  }

  export type usersUpsertWithoutTransactionsInput = {
    update: XOR<usersUpdateWithoutTransactionsInput, usersUncheckedUpdateWithoutTransactionsInput>
    create: XOR<usersCreateWithoutTransactionsInput, usersUncheckedCreateWithoutTransactionsInput>
  }

  export type usersUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    primaryEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicKey?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    transactionPolicies?: transactionPoliciesUpdateManyWithoutUsersNestedInput
    organizations?: organizationsUpdateOneRequiredWithoutUsersNestedInput
    userTypes?: userTypesUpdateOneRequiredWithoutUsersNestedInput
    vaults?: vaultsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    userTypeId?: IntFieldUpdateOperationsInput | number
    primaryEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicKey?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    transactionPolicies?: transactionPoliciesUncheckedUpdateManyWithoutUsersNestedInput
    vaults?: vaultsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type vendorsUpsertWithoutTransactionsInput = {
    update: XOR<vendorsUpdateWithoutTransactionsInput, vendorsUncheckedUpdateWithoutTransactionsInput>
    create: XOR<vendorsCreateWithoutTransactionsInput, vendorsUncheckedCreateWithoutTransactionsInput>
  }

  export type vendorsUpdateWithoutTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    quoteEngineBaseBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUpdateManyWithoutVendorsNestedInput
    depositAddresses?: depositAddressesUpdateManyWithoutVendorsNestedInput
    quotes?: quotesUpdateManyWithoutVendorsNestedInput
    tokenPairs?: tokenPairsUpdateManyWithoutVendorsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUpdateManyWithoutVendorsNestedInput
    vendorTypes?: vendorTypesUpdateOneRequiredWithoutVendorsNestedInput
  }

  export type vendorsUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    vendorTypeId?: IntFieldUpdateOperationsInput | number
    quoteEngineBaseBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUncheckedUpdateManyWithoutVendorsNestedInput
    depositAddresses?: depositAddressesUncheckedUpdateManyWithoutVendorsNestedInput
    quotes?: quotesUncheckedUpdateManyWithoutVendorsNestedInput
    tokenPairs?: tokenPairsUncheckedUpdateManyWithoutVendorsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedUpdateManyWithoutVendorsNestedInput
  }

  export type vaultsUpsertWithoutTransactions_transactions_sourceVaultIdTovaultsInput = {
    update: XOR<vaultsUpdateWithoutTransactions_transactions_sourceVaultIdTovaultsInput, vaultsUncheckedUpdateWithoutTransactions_transactions_sourceVaultIdTovaultsInput>
    create: XOR<vaultsCreateWithoutTransactions_transactions_sourceVaultIdTovaultsInput, vaultsUncheckedCreateWithoutTransactions_transactions_sourceVaultIdTovaultsInput>
  }

  export type vaultsUpdateWithoutTransactions_transactions_sourceVaultIdTovaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaultName?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesUpdateManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsNestedInput
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesUpdateManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsNestedInput
    transactions_transactions_targetVaultIdTovaults?: transactionsUpdateManyWithoutVaults_transactions_targetVaultIdTovaultsNestedInput
    vaultAssets?: vaultAssetsUpdateManyWithoutVaultsNestedInput
    users?: usersUpdateOneRequiredWithoutVaultsNestedInput
    vaultStatusTypes?: vaultStatusTypesUpdateOneWithoutVaultsNestedInput
  }

  export type vaultsUncheckedUpdateWithoutTransactions_transactions_sourceVaultIdTovaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    vaultStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    vaultName?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesUncheckedUpdateManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsNestedInput
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesUncheckedUpdateManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsNestedInput
    transactions_transactions_targetVaultIdTovaults?: transactionsUncheckedUpdateManyWithoutVaults_transactions_targetVaultIdTovaultsNestedInput
    vaultAssets?: vaultAssetsUncheckedUpdateManyWithoutVaultsNestedInput
  }

  export type vaultsUpsertWithoutTransactions_transactions_targetVaultIdTovaultsInput = {
    update: XOR<vaultsUpdateWithoutTransactions_transactions_targetVaultIdTovaultsInput, vaultsUncheckedUpdateWithoutTransactions_transactions_targetVaultIdTovaultsInput>
    create: XOR<vaultsCreateWithoutTransactions_transactions_targetVaultIdTovaultsInput, vaultsUncheckedCreateWithoutTransactions_transactions_targetVaultIdTovaultsInput>
  }

  export type vaultsUpdateWithoutTransactions_transactions_targetVaultIdTovaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaultName?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesUpdateManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsNestedInput
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesUpdateManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsNestedInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsUpdateManyWithoutVaults_transactions_sourceVaultIdTovaultsNestedInput
    vaultAssets?: vaultAssetsUpdateManyWithoutVaultsNestedInput
    users?: usersUpdateOneRequiredWithoutVaultsNestedInput
    vaultStatusTypes?: vaultStatusTypesUpdateOneWithoutVaultsNestedInput
  }

  export type vaultsUncheckedUpdateWithoutTransactions_transactions_targetVaultIdTovaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    vaultStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    vaultName?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesUncheckedUpdateManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsNestedInput
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesUncheckedUpdateManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsNestedInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsUncheckedUpdateManyWithoutVaults_transactions_sourceVaultIdTovaultsNestedInput
    vaultAssets?: vaultAssetsUncheckedUpdateManyWithoutVaultsNestedInput
  }

  export type withdrawalAddressesUpsertWithoutTransactionsInput = {
    update: XOR<withdrawalAddressesUpdateWithoutTransactionsInput, withdrawalAddressesUncheckedUpdateWithoutTransactionsInput>
    create: XOR<withdrawalAddressesCreateWithoutTransactionsInput, withdrawalAddressesUncheckedCreateWithoutTransactionsInput>
  }

  export type withdrawalAddressesUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionPolicies?: transactionPoliciesUpdateManyWithoutWithdrawalAddressesNestedInput
    assets?: assetsUpdateOneRequiredWithoutWithdrawalAddressesNestedInput
    organizations?: organizationsUpdateOneRequiredWithoutWithdrawalAddressesNestedInput
  }

  export type withdrawalAddressesUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionPolicies?: transactionPoliciesUncheckedUpdateManyWithoutWithdrawalAddressesNestedInput
  }

  export type transactionStatusTypesUpsertWithoutTransactionsInput = {
    update: XOR<transactionStatusTypesUpdateWithoutTransactionsInput, transactionStatusTypesUncheckedUpdateWithoutTransactionsInput>
    create: XOR<transactionStatusTypesCreateWithoutTransactionsInput, transactionStatusTypesUncheckedCreateWithoutTransactionsInput>
  }

  export type transactionStatusTypesUpdateWithoutTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionStatusTypesUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionTypesUpsertWithoutTransactionsInput = {
    update: XOR<transactionTypesUpdateWithoutTransactionsInput, transactionTypesUncheckedUpdateWithoutTransactionsInput>
    create: XOR<transactionTypesCreateWithoutTransactionsInput, transactionTypesUncheckedCreateWithoutTransactionsInput>
  }

  export type transactionTypesUpdateWithoutTransactionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionPolicies?: transactionPoliciesUpdateManyWithoutTransactionTypesNestedInput
  }

  export type transactionTypesUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionPolicies?: transactionPoliciesUncheckedUpdateManyWithoutTransactionTypesNestedInput
  }

  export type transactionPoliciesCreateWithoutUsersInput = {
    id: string
    toOneTimeAddresses?: boolean | null
    greaterThanUSD: string
    action: enum_transactionPolicies_action
    createdAt?: Date | string
    updatedAt?: Date | string
    assets: assetsCreateNestedOneWithoutTransactionPoliciesInput
    vaults_transactionPolicies_sourceVaultIdTovaults: vaultsCreateNestedOneWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput
    vaults_transactionPolicies_targetVaultIdTovaults?: vaultsCreateNestedOneWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput
    withdrawalAddresses?: withdrawalAddressesCreateNestedOneWithoutTransactionPoliciesInput
    transactionTypes: transactionTypesCreateNestedOneWithoutTransactionPoliciesInput
  }

  export type transactionPoliciesUncheckedCreateWithoutUsersInput = {
    id: string
    transactionTypeId: number
    sourceVaultId: string
    targetVaultId?: string | null
    targetWithdrawalAddressId?: string | null
    toOneTimeAddresses?: boolean | null
    greaterThanUSD: string
    assetId: number
    action: enum_transactionPolicies_action
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionPoliciesCreateOrConnectWithoutUsersInput = {
    where: transactionPoliciesWhereUniqueInput
    create: XOR<transactionPoliciesCreateWithoutUsersInput, transactionPoliciesUncheckedCreateWithoutUsersInput>
  }

  export type transactionPoliciesCreateManyUsersInputEnvelope = {
    data: Enumerable<transactionPoliciesCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type transactionsCreateWithoutUsersInput = {
    id: string
    custodyVendorRef: string
    amountAsset: string
    amountUSD: string
    onChainTxId?: string | null
    sourceExternalAddress?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assets: assetsCreateNestedOneWithoutTransactionsInput
    vendors: vendorsCreateNestedOneWithoutTransactionsInput
    vaults_transactions_sourceVaultIdTovaults?: vaultsCreateNestedOneWithoutTransactions_transactions_sourceVaultIdTovaultsInput
    vaults_transactions_targetVaultIdTovaults?: vaultsCreateNestedOneWithoutTransactions_transactions_targetVaultIdTovaultsInput
    withdrawalAddresses?: withdrawalAddressesCreateNestedOneWithoutTransactionsInput
    transactionStatusTypes: transactionStatusTypesCreateNestedOneWithoutTransactionsInput
    transactionTypes: transactionTypesCreateNestedOneWithoutTransactionsInput
  }

  export type transactionsUncheckedCreateWithoutUsersInput = {
    id: string
    custodyVendorId: number
    custodyVendorRef: string
    transactionTypeId: number
    amountAsset: string
    amountUSD: string
    assetId: number
    transactionStatusTypeId: number
    onChainTxId?: string | null
    sourceVaultId?: string | null
    targetVaultId?: string | null
    targetWithdrawalAddressId?: string | null
    sourceExternalAddress?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionsCreateOrConnectWithoutUsersInput = {
    where: transactionsWhereUniqueInput
    create: XOR<transactionsCreateWithoutUsersInput, transactionsUncheckedCreateWithoutUsersInput>
  }

  export type transactionsCreateManyUsersInputEnvelope = {
    data: Enumerable<transactionsCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type organizationsCreateWithoutUsersInput = {
    name: string
    primaryEmail: string
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyEngineEvents?: custodyEngineEventsCreateNestedManyWithoutOrganizationsInput
    pricingPlans?: pricingPlansCreateNestedOneWithoutOrganizationsInput
    organizationStatusTypes: organizationStatusTypesCreateNestedOneWithoutOrganizationsInput
    webhooks?: webhooksCreateNestedManyWithoutOrganizationsInput
    withdrawalAddresses?: withdrawalAddressesCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    primaryEmail: string
    pricingPlanId?: number
    statusId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyEngineEvents?: custodyEngineEventsUncheckedCreateNestedManyWithoutOrganizationsInput
    webhooks?: webhooksUncheckedCreateNestedManyWithoutOrganizationsInput
    withdrawalAddresses?: withdrawalAddressesUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsCreateOrConnectWithoutUsersInput = {
    where: organizationsWhereUniqueInput
    create: XOR<organizationsCreateWithoutUsersInput, organizationsUncheckedCreateWithoutUsersInput>
  }

  export type userTypesCreateWithoutUsersInput = {
    name: string
    description: string
    claims: JsonNullValueInput | InputJsonValue
    isServiceAccount?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type userTypesUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    description: string
    claims: JsonNullValueInput | InputJsonValue
    isServiceAccount?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type userTypesCreateOrConnectWithoutUsersInput = {
    where: userTypesWhereUniqueInput
    create: XOR<userTypesCreateWithoutUsersInput, userTypesUncheckedCreateWithoutUsersInput>
  }

  export type vaultsCreateWithoutUsersInput = {
    id: string
    vaultName?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesCreateNestedManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesCreateNestedManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsCreateNestedManyWithoutVaults_transactions_sourceVaultIdTovaultsInput
    transactions_transactions_targetVaultIdTovaults?: transactionsCreateNestedManyWithoutVaults_transactions_targetVaultIdTovaultsInput
    vaultAssets?: vaultAssetsCreateNestedManyWithoutVaultsInput
    vaultStatusTypes?: vaultStatusTypesCreateNestedOneWithoutVaultsInput
  }

  export type vaultsUncheckedCreateWithoutUsersInput = {
    id: string
    vaultStatusId?: number | null
    vaultName?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesUncheckedCreateNestedManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesUncheckedCreateNestedManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsUncheckedCreateNestedManyWithoutVaults_transactions_sourceVaultIdTovaultsInput
    transactions_transactions_targetVaultIdTovaults?: transactionsUncheckedCreateNestedManyWithoutVaults_transactions_targetVaultIdTovaultsInput
    vaultAssets?: vaultAssetsUncheckedCreateNestedManyWithoutVaultsInput
  }

  export type vaultsCreateOrConnectWithoutUsersInput = {
    where: vaultsWhereUniqueInput
    create: XOR<vaultsCreateWithoutUsersInput, vaultsUncheckedCreateWithoutUsersInput>
  }

  export type vaultsCreateManyUsersInputEnvelope = {
    data: Enumerable<vaultsCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type transactionPoliciesUpsertWithWhereUniqueWithoutUsersInput = {
    where: transactionPoliciesWhereUniqueInput
    update: XOR<transactionPoliciesUpdateWithoutUsersInput, transactionPoliciesUncheckedUpdateWithoutUsersInput>
    create: XOR<transactionPoliciesCreateWithoutUsersInput, transactionPoliciesUncheckedCreateWithoutUsersInput>
  }

  export type transactionPoliciesUpdateWithWhereUniqueWithoutUsersInput = {
    where: transactionPoliciesWhereUniqueInput
    data: XOR<transactionPoliciesUpdateWithoutUsersInput, transactionPoliciesUncheckedUpdateWithoutUsersInput>
  }

  export type transactionPoliciesUpdateManyWithWhereWithoutUsersInput = {
    where: transactionPoliciesScalarWhereInput
    data: XOR<transactionPoliciesUpdateManyMutationInput, transactionPoliciesUncheckedUpdateManyWithoutTransactionPoliciesInput>
  }

  export type transactionsUpsertWithWhereUniqueWithoutUsersInput = {
    where: transactionsWhereUniqueInput
    update: XOR<transactionsUpdateWithoutUsersInput, transactionsUncheckedUpdateWithoutUsersInput>
    create: XOR<transactionsCreateWithoutUsersInput, transactionsUncheckedCreateWithoutUsersInput>
  }

  export type transactionsUpdateWithWhereUniqueWithoutUsersInput = {
    where: transactionsWhereUniqueInput
    data: XOR<transactionsUpdateWithoutUsersInput, transactionsUncheckedUpdateWithoutUsersInput>
  }

  export type transactionsUpdateManyWithWhereWithoutUsersInput = {
    where: transactionsScalarWhereInput
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyWithoutTransactionsInput>
  }

  export type organizationsUpsertWithoutUsersInput = {
    update: XOR<organizationsUpdateWithoutUsersInput, organizationsUncheckedUpdateWithoutUsersInput>
    create: XOR<organizationsCreateWithoutUsersInput, organizationsUncheckedCreateWithoutUsersInput>
  }

  export type organizationsUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    primaryEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyEngineEvents?: custodyEngineEventsUpdateManyWithoutOrganizationsNestedInput
    pricingPlans?: pricingPlansUpdateOneRequiredWithoutOrganizationsNestedInput
    organizationStatusTypes?: organizationStatusTypesUpdateOneRequiredWithoutOrganizationsNestedInput
    webhooks?: webhooksUpdateManyWithoutOrganizationsNestedInput
    withdrawalAddresses?: withdrawalAddressesUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    primaryEmail?: StringFieldUpdateOperationsInput | string
    pricingPlanId?: IntFieldUpdateOperationsInput | number
    statusId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyEngineEvents?: custodyEngineEventsUncheckedUpdateManyWithoutOrganizationsNestedInput
    webhooks?: webhooksUncheckedUpdateManyWithoutOrganizationsNestedInput
    withdrawalAddresses?: withdrawalAddressesUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type userTypesUpsertWithoutUsersInput = {
    update: XOR<userTypesUpdateWithoutUsersInput, userTypesUncheckedUpdateWithoutUsersInput>
    create: XOR<userTypesCreateWithoutUsersInput, userTypesUncheckedCreateWithoutUsersInput>
  }

  export type userTypesUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    claims?: JsonNullValueInput | InputJsonValue
    isServiceAccount?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userTypesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    claims?: JsonNullValueInput | InputJsonValue
    isServiceAccount?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vaultsUpsertWithWhereUniqueWithoutUsersInput = {
    where: vaultsWhereUniqueInput
    update: XOR<vaultsUpdateWithoutUsersInput, vaultsUncheckedUpdateWithoutUsersInput>
    create: XOR<vaultsCreateWithoutUsersInput, vaultsUncheckedCreateWithoutUsersInput>
  }

  export type vaultsUpdateWithWhereUniqueWithoutUsersInput = {
    where: vaultsWhereUniqueInput
    data: XOR<vaultsUpdateWithoutUsersInput, vaultsUncheckedUpdateWithoutUsersInput>
  }

  export type vaultsUpdateManyWithWhereWithoutUsersInput = {
    where: vaultsScalarWhereInput
    data: XOR<vaultsUpdateManyMutationInput, vaultsUncheckedUpdateManyWithoutVaultsInput>
  }

  export type vaultsScalarWhereInput = {
    AND?: Enumerable<vaultsScalarWhereInput>
    OR?: Enumerable<vaultsScalarWhereInput>
    NOT?: Enumerable<vaultsScalarWhereInput>
    id?: UuidFilter | string
    createdByUserId?: UuidFilter | string
    vaultStatusId?: IntNullableFilter | number | null
    vaultName?: StringNullableFilter | string | null
    subjectId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type vendorsCreateWithoutVendorTypesInput = {
    name: string
    identifier: string
    quoteEngineBaseBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsCreateNestedManyWithoutVendorsInput
    depositAddresses?: depositAddressesCreateNestedManyWithoutVendorsInput
    quotes?: quotesCreateNestedManyWithoutVendorsInput
    tokenPairs?: tokenPairsCreateNestedManyWithoutVendorsInput
    transactions?: transactionsCreateNestedManyWithoutVendorsInput
    vendorSupportsAssets?: vendorSupportsAssetsCreateNestedManyWithoutVendorsInput
  }

  export type vendorsUncheckedCreateWithoutVendorTypesInput = {
    id?: number
    name: string
    identifier: string
    quoteEngineBaseBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUncheckedCreateNestedManyWithoutVendorsInput
    depositAddresses?: depositAddressesUncheckedCreateNestedManyWithoutVendorsInput
    quotes?: quotesUncheckedCreateNestedManyWithoutVendorsInput
    tokenPairs?: tokenPairsUncheckedCreateNestedManyWithoutVendorsInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutVendorsInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedCreateNestedManyWithoutVendorsInput
  }

  export type vendorsCreateOrConnectWithoutVendorTypesInput = {
    where: vendorsWhereUniqueInput
    create: XOR<vendorsCreateWithoutVendorTypesInput, vendorsUncheckedCreateWithoutVendorTypesInput>
  }

  export type vendorsCreateManyVendorTypesInputEnvelope = {
    data: Enumerable<vendorsCreateManyVendorTypesInput>
    skipDuplicates?: boolean
  }

  export type vendorsUpsertWithWhereUniqueWithoutVendorTypesInput = {
    where: vendorsWhereUniqueInput
    update: XOR<vendorsUpdateWithoutVendorTypesInput, vendorsUncheckedUpdateWithoutVendorTypesInput>
    create: XOR<vendorsCreateWithoutVendorTypesInput, vendorsUncheckedCreateWithoutVendorTypesInput>
  }

  export type vendorsUpdateWithWhereUniqueWithoutVendorTypesInput = {
    where: vendorsWhereUniqueInput
    data: XOR<vendorsUpdateWithoutVendorTypesInput, vendorsUncheckedUpdateWithoutVendorTypesInput>
  }

  export type vendorsUpdateManyWithWhereWithoutVendorTypesInput = {
    where: vendorsScalarWhereInput
    data: XOR<vendorsUpdateManyMutationInput, vendorsUncheckedUpdateManyWithoutVendorsInput>
  }

  export type vendorsScalarWhereInput = {
    AND?: Enumerable<vendorsScalarWhereInput>
    OR?: Enumerable<vendorsScalarWhereInput>
    NOT?: Enumerable<vendorsScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    identifier?: StringFilter | string
    vendorTypeId?: IntFilter | number
    quoteEngineBaseBps?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type custodyVendorVaultAssetsCreateWithoutVendorsInput = {
    vendorRef: string
    balance: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vaultAssets: vaultAssetsCreateNestedOneWithoutCustodyVendorVaultAssetsInput
  }

  export type custodyVendorVaultAssetsUncheckedCreateWithoutVendorsInput = {
    id?: number
    vendorRef: string
    balance: string
    vaultAssetId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type custodyVendorVaultAssetsCreateOrConnectWithoutVendorsInput = {
    where: custodyVendorVaultAssetsWhereUniqueInput
    create: XOR<custodyVendorVaultAssetsCreateWithoutVendorsInput, custodyVendorVaultAssetsUncheckedCreateWithoutVendorsInput>
  }

  export type custodyVendorVaultAssetsCreateManyVendorsInputEnvelope = {
    data: Enumerable<custodyVendorVaultAssetsCreateManyVendorsInput>
    skipDuplicates?: boolean
  }

  export type depositAddressesCreateWithoutVendorsInput = {
    id: string
    address: string
    depositAddressStatusId?: number | null
    vendorRef: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vaultAssets: vaultAssetsCreateNestedOneWithoutDepositAddressesInput
  }

  export type depositAddressesUncheckedCreateWithoutVendorsInput = {
    id: string
    vaultAssetId: number
    address: string
    depositAddressStatusId?: number | null
    vendorRef: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type depositAddressesCreateOrConnectWithoutVendorsInput = {
    where: depositAddressesWhereUniqueInput
    create: XOR<depositAddressesCreateWithoutVendorsInput, depositAddressesUncheckedCreateWithoutVendorsInput>
  }

  export type depositAddressesCreateManyVendorsInputEnvelope = {
    data: Enumerable<depositAddressesCreateManyVendorsInput>
    skipDuplicates?: boolean
  }

  export type quotesCreateWithoutVendorsInput = {
    id: string
    side: enum_quotes_side
    userId: string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    buyPrice?: string
    sellPrice?: string
    quantity?: string
    orders?: ordersCreateNestedManyWithoutQuotesInput
    tokenPairsInfo?: tokenPairsInfoCreateNestedOneWithoutQuotesInput
    quoteStatuses: quoteStatusesCreateNestedOneWithoutQuotesInput
    assets_quotes_sourceAssetIdToassets: assetsCreateNestedOneWithoutQuotes_quotes_sourceAssetIdToassetsInput
    assets_quotes_targetAssetIdToassets: assetsCreateNestedOneWithoutQuotes_quotes_targetAssetIdToassetsInput
  }

  export type quotesUncheckedCreateWithoutVendorsInput = {
    id: string
    quoteStatusId: number
    sourceAssetId: number
    targetAssetId: number
    side: enum_quotes_side
    userId: string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    fxRequestID?: string | null
    buyPrice?: string
    sellPrice?: string
    quantity?: string
    orders?: ordersUncheckedCreateNestedManyWithoutQuotesInput
  }

  export type quotesCreateOrConnectWithoutVendorsInput = {
    where: quotesWhereUniqueInput
    create: XOR<quotesCreateWithoutVendorsInput, quotesUncheckedCreateWithoutVendorsInput>
  }

  export type quotesCreateManyVendorsInputEnvelope = {
    data: Enumerable<quotesCreateManyVendorsInput>
    skipDuplicates?: boolean
  }

  export type tokenPairsCreateWithoutVendorsInput = {
    baseToken: string
    quoteToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tokenPairsInfo?: tokenPairsInfoCreateNestedManyWithoutTokenPairsInput
  }

  export type tokenPairsUncheckedCreateWithoutVendorsInput = {
    id?: number
    baseToken: string
    quoteToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tokenPairsInfo?: tokenPairsInfoUncheckedCreateNestedManyWithoutTokenPairsInput
  }

  export type tokenPairsCreateOrConnectWithoutVendorsInput = {
    where: tokenPairsWhereUniqueInput
    create: XOR<tokenPairsCreateWithoutVendorsInput, tokenPairsUncheckedCreateWithoutVendorsInput>
  }

  export type tokenPairsCreateManyVendorsInputEnvelope = {
    data: Enumerable<tokenPairsCreateManyVendorsInput>
    skipDuplicates?: boolean
  }

  export type transactionsCreateWithoutVendorsInput = {
    id: string
    custodyVendorRef: string
    amountAsset: string
    amountUSD: string
    onChainTxId?: string | null
    sourceExternalAddress?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assets: assetsCreateNestedOneWithoutTransactionsInput
    users?: usersCreateNestedOneWithoutTransactionsInput
    vaults_transactions_sourceVaultIdTovaults?: vaultsCreateNestedOneWithoutTransactions_transactions_sourceVaultIdTovaultsInput
    vaults_transactions_targetVaultIdTovaults?: vaultsCreateNestedOneWithoutTransactions_transactions_targetVaultIdTovaultsInput
    withdrawalAddresses?: withdrawalAddressesCreateNestedOneWithoutTransactionsInput
    transactionStatusTypes: transactionStatusTypesCreateNestedOneWithoutTransactionsInput
    transactionTypes: transactionTypesCreateNestedOneWithoutTransactionsInput
  }

  export type transactionsUncheckedCreateWithoutVendorsInput = {
    id: string
    custodyVendorRef: string
    transactionTypeId: number
    amountAsset: string
    amountUSD: string
    assetId: number
    transactionStatusTypeId: number
    onChainTxId?: string | null
    sourceVaultId?: string | null
    targetVaultId?: string | null
    targetWithdrawalAddressId?: string | null
    sourceExternalAddress?: string | null
    createdByUserId?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionsCreateOrConnectWithoutVendorsInput = {
    where: transactionsWhereUniqueInput
    create: XOR<transactionsCreateWithoutVendorsInput, transactionsUncheckedCreateWithoutVendorsInput>
  }

  export type transactionsCreateManyVendorsInputEnvelope = {
    data: Enumerable<transactionsCreateManyVendorsInput>
    skipDuplicates?: boolean
  }

  export type vendorSupportsAssetsCreateWithoutVendorsInput = {
    enabled?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    theirId?: string | null
    pricingPlanSupportsAssets?: pricingPlanSupportsAssetsCreateNestedManyWithoutVendorSupportsAssetsInput
    assets: assetsCreateNestedOneWithoutVendorSupportsAssetsInput
  }

  export type vendorSupportsAssetsUncheckedCreateWithoutVendorsInput = {
    id?: number
    assetId: number
    enabled?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    theirId?: string | null
    pricingPlanSupportsAssets?: pricingPlanSupportsAssetsUncheckedCreateNestedManyWithoutVendorSupportsAssetsInput
  }

  export type vendorSupportsAssetsCreateOrConnectWithoutVendorsInput = {
    where: vendorSupportsAssetsWhereUniqueInput
    create: XOR<vendorSupportsAssetsCreateWithoutVendorsInput, vendorSupportsAssetsUncheckedCreateWithoutVendorsInput>
  }

  export type vendorSupportsAssetsCreateManyVendorsInputEnvelope = {
    data: Enumerable<vendorSupportsAssetsCreateManyVendorsInput>
    skipDuplicates?: boolean
  }

  export type vendorTypesCreateWithoutVendorsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vendorTypesUncheckedCreateWithoutVendorsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vendorTypesCreateOrConnectWithoutVendorsInput = {
    where: vendorTypesWhereUniqueInput
    create: XOR<vendorTypesCreateWithoutVendorsInput, vendorTypesUncheckedCreateWithoutVendorsInput>
  }

  export type custodyVendorVaultAssetsUpsertWithWhereUniqueWithoutVendorsInput = {
    where: custodyVendorVaultAssetsWhereUniqueInput
    update: XOR<custodyVendorVaultAssetsUpdateWithoutVendorsInput, custodyVendorVaultAssetsUncheckedUpdateWithoutVendorsInput>
    create: XOR<custodyVendorVaultAssetsCreateWithoutVendorsInput, custodyVendorVaultAssetsUncheckedCreateWithoutVendorsInput>
  }

  export type custodyVendorVaultAssetsUpdateWithWhereUniqueWithoutVendorsInput = {
    where: custodyVendorVaultAssetsWhereUniqueInput
    data: XOR<custodyVendorVaultAssetsUpdateWithoutVendorsInput, custodyVendorVaultAssetsUncheckedUpdateWithoutVendorsInput>
  }

  export type custodyVendorVaultAssetsUpdateManyWithWhereWithoutVendorsInput = {
    where: custodyVendorVaultAssetsScalarWhereInput
    data: XOR<custodyVendorVaultAssetsUpdateManyMutationInput, custodyVendorVaultAssetsUncheckedUpdateManyWithoutCustodyVendorVaultAssetsInput>
  }

  export type custodyVendorVaultAssetsScalarWhereInput = {
    AND?: Enumerable<custodyVendorVaultAssetsScalarWhereInput>
    OR?: Enumerable<custodyVendorVaultAssetsScalarWhereInput>
    NOT?: Enumerable<custodyVendorVaultAssetsScalarWhereInput>
    id?: IntFilter | number
    vendorId?: IntFilter | number
    vendorRef?: StringFilter | string
    balance?: StringFilter | string
    vaultAssetId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type depositAddressesUpsertWithWhereUniqueWithoutVendorsInput = {
    where: depositAddressesWhereUniqueInput
    update: XOR<depositAddressesUpdateWithoutVendorsInput, depositAddressesUncheckedUpdateWithoutVendorsInput>
    create: XOR<depositAddressesCreateWithoutVendorsInput, depositAddressesUncheckedCreateWithoutVendorsInput>
  }

  export type depositAddressesUpdateWithWhereUniqueWithoutVendorsInput = {
    where: depositAddressesWhereUniqueInput
    data: XOR<depositAddressesUpdateWithoutVendorsInput, depositAddressesUncheckedUpdateWithoutVendorsInput>
  }

  export type depositAddressesUpdateManyWithWhereWithoutVendorsInput = {
    where: depositAddressesScalarWhereInput
    data: XOR<depositAddressesUpdateManyMutationInput, depositAddressesUncheckedUpdateManyWithoutDepositAddressesInput>
  }

  export type depositAddressesScalarWhereInput = {
    AND?: Enumerable<depositAddressesScalarWhereInput>
    OR?: Enumerable<depositAddressesScalarWhereInput>
    NOT?: Enumerable<depositAddressesScalarWhereInput>
    id?: UuidFilter | string
    vaultAssetId?: IntFilter | number
    address?: StringFilter | string
    depositAddressStatusId?: IntNullableFilter | number | null
    vendorId?: IntNullableFilter | number | null
    vendorRef?: StringFilter | string
    subjectId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type quotesUpsertWithWhereUniqueWithoutVendorsInput = {
    where: quotesWhereUniqueInput
    update: XOR<quotesUpdateWithoutVendorsInput, quotesUncheckedUpdateWithoutVendorsInput>
    create: XOR<quotesCreateWithoutVendorsInput, quotesUncheckedCreateWithoutVendorsInput>
  }

  export type quotesUpdateWithWhereUniqueWithoutVendorsInput = {
    where: quotesWhereUniqueInput
    data: XOR<quotesUpdateWithoutVendorsInput, quotesUncheckedUpdateWithoutVendorsInput>
  }

  export type quotesUpdateManyWithWhereWithoutVendorsInput = {
    where: quotesScalarWhereInput
    data: XOR<quotesUpdateManyMutationInput, quotesUncheckedUpdateManyWithoutQuotesInput>
  }

  export type tokenPairsUpsertWithWhereUniqueWithoutVendorsInput = {
    where: tokenPairsWhereUniqueInput
    update: XOR<tokenPairsUpdateWithoutVendorsInput, tokenPairsUncheckedUpdateWithoutVendorsInput>
    create: XOR<tokenPairsCreateWithoutVendorsInput, tokenPairsUncheckedCreateWithoutVendorsInput>
  }

  export type tokenPairsUpdateWithWhereUniqueWithoutVendorsInput = {
    where: tokenPairsWhereUniqueInput
    data: XOR<tokenPairsUpdateWithoutVendorsInput, tokenPairsUncheckedUpdateWithoutVendorsInput>
  }

  export type tokenPairsUpdateManyWithWhereWithoutVendorsInput = {
    where: tokenPairsScalarWhereInput
    data: XOR<tokenPairsUpdateManyMutationInput, tokenPairsUncheckedUpdateManyWithoutTokenPairsInput>
  }

  export type tokenPairsScalarWhereInput = {
    AND?: Enumerable<tokenPairsScalarWhereInput>
    OR?: Enumerable<tokenPairsScalarWhereInput>
    NOT?: Enumerable<tokenPairsScalarWhereInput>
    id?: IntFilter | number
    baseToken?: StringFilter | string
    quoteToken?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    vendorId?: IntFilter | number
  }

  export type transactionsUpsertWithWhereUniqueWithoutVendorsInput = {
    where: transactionsWhereUniqueInput
    update: XOR<transactionsUpdateWithoutVendorsInput, transactionsUncheckedUpdateWithoutVendorsInput>
    create: XOR<transactionsCreateWithoutVendorsInput, transactionsUncheckedCreateWithoutVendorsInput>
  }

  export type transactionsUpdateWithWhereUniqueWithoutVendorsInput = {
    where: transactionsWhereUniqueInput
    data: XOR<transactionsUpdateWithoutVendorsInput, transactionsUncheckedUpdateWithoutVendorsInput>
  }

  export type transactionsUpdateManyWithWhereWithoutVendorsInput = {
    where: transactionsScalarWhereInput
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyWithoutTransactionsInput>
  }

  export type vendorSupportsAssetsUpsertWithWhereUniqueWithoutVendorsInput = {
    where: vendorSupportsAssetsWhereUniqueInput
    update: XOR<vendorSupportsAssetsUpdateWithoutVendorsInput, vendorSupportsAssetsUncheckedUpdateWithoutVendorsInput>
    create: XOR<vendorSupportsAssetsCreateWithoutVendorsInput, vendorSupportsAssetsUncheckedCreateWithoutVendorsInput>
  }

  export type vendorSupportsAssetsUpdateWithWhereUniqueWithoutVendorsInput = {
    where: vendorSupportsAssetsWhereUniqueInput
    data: XOR<vendorSupportsAssetsUpdateWithoutVendorsInput, vendorSupportsAssetsUncheckedUpdateWithoutVendorsInput>
  }

  export type vendorSupportsAssetsUpdateManyWithWhereWithoutVendorsInput = {
    where: vendorSupportsAssetsScalarWhereInput
    data: XOR<vendorSupportsAssetsUpdateManyMutationInput, vendorSupportsAssetsUncheckedUpdateManyWithoutVendorSupportsAssetsInput>
  }

  export type vendorTypesUpsertWithoutVendorsInput = {
    update: XOR<vendorTypesUpdateWithoutVendorsInput, vendorTypesUncheckedUpdateWithoutVendorsInput>
    create: XOR<vendorTypesCreateWithoutVendorsInput, vendorTypesUncheckedCreateWithoutVendorsInput>
  }

  export type vendorTypesUpdateWithoutVendorsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vendorTypesUncheckedUpdateWithoutVendorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type custodyEngineEventsCreateWithoutCustodyEngineEventTypesInput = {
    id: string
    event: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    organizations: organizationsCreateNestedOneWithoutCustodyEngineEventsInput
    webhookRequests?: webhookRequestsCreateNestedManyWithoutCustodyEngineEventsInput
  }

  export type custodyEngineEventsUncheckedCreateWithoutCustodyEngineEventTypesInput = {
    id: string
    organizationId: number
    event: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    webhookRequests?: webhookRequestsUncheckedCreateNestedManyWithoutCustodyEngineEventsInput
  }

  export type custodyEngineEventsCreateOrConnectWithoutCustodyEngineEventTypesInput = {
    where: custodyEngineEventsWhereUniqueInput
    create: XOR<custodyEngineEventsCreateWithoutCustodyEngineEventTypesInput, custodyEngineEventsUncheckedCreateWithoutCustodyEngineEventTypesInput>
  }

  export type custodyEngineEventsCreateManyCustodyEngineEventTypesInputEnvelope = {
    data: Enumerable<custodyEngineEventsCreateManyCustodyEngineEventTypesInput>
    skipDuplicates?: boolean
  }

  export type custodyEngineEventsUpsertWithWhereUniqueWithoutCustodyEngineEventTypesInput = {
    where: custodyEngineEventsWhereUniqueInput
    update: XOR<custodyEngineEventsUpdateWithoutCustodyEngineEventTypesInput, custodyEngineEventsUncheckedUpdateWithoutCustodyEngineEventTypesInput>
    create: XOR<custodyEngineEventsCreateWithoutCustodyEngineEventTypesInput, custodyEngineEventsUncheckedCreateWithoutCustodyEngineEventTypesInput>
  }

  export type custodyEngineEventsUpdateWithWhereUniqueWithoutCustodyEngineEventTypesInput = {
    where: custodyEngineEventsWhereUniqueInput
    data: XOR<custodyEngineEventsUpdateWithoutCustodyEngineEventTypesInput, custodyEngineEventsUncheckedUpdateWithoutCustodyEngineEventTypesInput>
  }

  export type custodyEngineEventsUpdateManyWithWhereWithoutCustodyEngineEventTypesInput = {
    where: custodyEngineEventsScalarWhereInput
    data: XOR<custodyEngineEventsUpdateManyMutationInput, custodyEngineEventsUncheckedUpdateManyWithoutCustodyEngineEventsInput>
  }

  export type custodyEngineEventsScalarWhereInput = {
    AND?: Enumerable<custodyEngineEventsScalarWhereInput>
    OR?: Enumerable<custodyEngineEventsScalarWhereInput>
    NOT?: Enumerable<custodyEngineEventsScalarWhereInput>
    id?: UuidFilter | string
    organizationId?: IntFilter | number
    custodyEngineEventTypeId?: IntFilter | number
    event?: JsonFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type custodyEngineEventTypesCreateWithoutCustodyEngineEventsInput = {
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type custodyEngineEventTypesUncheckedCreateWithoutCustodyEngineEventsInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type custodyEngineEventTypesCreateOrConnectWithoutCustodyEngineEventsInput = {
    where: custodyEngineEventTypesWhereUniqueInput
    create: XOR<custodyEngineEventTypesCreateWithoutCustodyEngineEventsInput, custodyEngineEventTypesUncheckedCreateWithoutCustodyEngineEventsInput>
  }

  export type organizationsCreateWithoutCustodyEngineEventsInput = {
    name: string
    primaryEmail: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pricingPlans?: pricingPlansCreateNestedOneWithoutOrganizationsInput
    organizationStatusTypes: organizationStatusTypesCreateNestedOneWithoutOrganizationsInput
    users?: usersCreateNestedManyWithoutOrganizationsInput
    webhooks?: webhooksCreateNestedManyWithoutOrganizationsInput
    withdrawalAddresses?: withdrawalAddressesCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateWithoutCustodyEngineEventsInput = {
    id?: number
    name: string
    primaryEmail: string
    pricingPlanId?: number
    statusId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: usersUncheckedCreateNestedManyWithoutOrganizationsInput
    webhooks?: webhooksUncheckedCreateNestedManyWithoutOrganizationsInput
    withdrawalAddresses?: withdrawalAddressesUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsCreateOrConnectWithoutCustodyEngineEventsInput = {
    where: organizationsWhereUniqueInput
    create: XOR<organizationsCreateWithoutCustodyEngineEventsInput, organizationsUncheckedCreateWithoutCustodyEngineEventsInput>
  }

  export type webhookRequestsCreateWithoutCustodyEngineEventsInput = {
    id: string
    httpStatusCode: number
    requestPayload: JsonNullValueInput | InputJsonValue
    responsePayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    institutionalProducts?: institutionalProductsCreateNestedOneWithoutWebhookRequestsInput
    webhooks: webhooksCreateNestedOneWithoutWebhookRequestsInput
  }

  export type webhookRequestsUncheckedCreateWithoutCustodyEngineEventsInput = {
    id: string
    webhookId: string
    institutionalProductId?: string | null
    httpStatusCode: number
    requestPayload: JsonNullValueInput | InputJsonValue
    responsePayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type webhookRequestsCreateOrConnectWithoutCustodyEngineEventsInput = {
    where: webhookRequestsWhereUniqueInput
    create: XOR<webhookRequestsCreateWithoutCustodyEngineEventsInput, webhookRequestsUncheckedCreateWithoutCustodyEngineEventsInput>
  }

  export type webhookRequestsCreateManyCustodyEngineEventsInputEnvelope = {
    data: Enumerable<webhookRequestsCreateManyCustodyEngineEventsInput>
    skipDuplicates?: boolean
  }

  export type custodyEngineEventTypesUpsertWithoutCustodyEngineEventsInput = {
    update: XOR<custodyEngineEventTypesUpdateWithoutCustodyEngineEventsInput, custodyEngineEventTypesUncheckedUpdateWithoutCustodyEngineEventsInput>
    create: XOR<custodyEngineEventTypesCreateWithoutCustodyEngineEventsInput, custodyEngineEventTypesUncheckedCreateWithoutCustodyEngineEventsInput>
  }

  export type custodyEngineEventTypesUpdateWithoutCustodyEngineEventsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type custodyEngineEventTypesUncheckedUpdateWithoutCustodyEngineEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type organizationsUpsertWithoutCustodyEngineEventsInput = {
    update: XOR<organizationsUpdateWithoutCustodyEngineEventsInput, organizationsUncheckedUpdateWithoutCustodyEngineEventsInput>
    create: XOR<organizationsCreateWithoutCustodyEngineEventsInput, organizationsUncheckedCreateWithoutCustodyEngineEventsInput>
  }

  export type organizationsUpdateWithoutCustodyEngineEventsInput = {
    name?: StringFieldUpdateOperationsInput | string
    primaryEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingPlans?: pricingPlansUpdateOneRequiredWithoutOrganizationsNestedInput
    organizationStatusTypes?: organizationStatusTypesUpdateOneRequiredWithoutOrganizationsNestedInput
    users?: usersUpdateManyWithoutOrganizationsNestedInput
    webhooks?: webhooksUpdateManyWithoutOrganizationsNestedInput
    withdrawalAddresses?: withdrawalAddressesUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateWithoutCustodyEngineEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    primaryEmail?: StringFieldUpdateOperationsInput | string
    pricingPlanId?: IntFieldUpdateOperationsInput | number
    statusId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUncheckedUpdateManyWithoutOrganizationsNestedInput
    webhooks?: webhooksUncheckedUpdateManyWithoutOrganizationsNestedInput
    withdrawalAddresses?: withdrawalAddressesUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type webhookRequestsUpsertWithWhereUniqueWithoutCustodyEngineEventsInput = {
    where: webhookRequestsWhereUniqueInput
    update: XOR<webhookRequestsUpdateWithoutCustodyEngineEventsInput, webhookRequestsUncheckedUpdateWithoutCustodyEngineEventsInput>
    create: XOR<webhookRequestsCreateWithoutCustodyEngineEventsInput, webhookRequestsUncheckedCreateWithoutCustodyEngineEventsInput>
  }

  export type webhookRequestsUpdateWithWhereUniqueWithoutCustodyEngineEventsInput = {
    where: webhookRequestsWhereUniqueInput
    data: XOR<webhookRequestsUpdateWithoutCustodyEngineEventsInput, webhookRequestsUncheckedUpdateWithoutCustodyEngineEventsInput>
  }

  export type webhookRequestsUpdateManyWithWhereWithoutCustodyEngineEventsInput = {
    where: webhookRequestsScalarWhereInput
    data: XOR<webhookRequestsUpdateManyMutationInput, webhookRequestsUncheckedUpdateManyWithoutWebhookRequestsInput>
  }

  export type webhookRequestsScalarWhereInput = {
    AND?: Enumerable<webhookRequestsScalarWhereInput>
    OR?: Enumerable<webhookRequestsScalarWhereInput>
    NOT?: Enumerable<webhookRequestsScalarWhereInput>
    id?: UuidFilter | string
    webhookId?: UuidFilter | string
    institutionalProductId?: UuidNullableFilter | string | null
    httpStatusCode?: IntFilter | number
    requestPayload?: JsonFilter
    responsePayload?: JsonNullableFilter
    custodyEngineEventId?: UuidNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type vaultAssetsCreateWithoutCustodyVendorVaultAssetsInput = {
    balance: string
    createdAt?: Date | string
    updatedAt?: Date | string
    depositAddresses?: depositAddressesCreateNestedManyWithoutVaultAssetsInput
    assets: assetsCreateNestedOneWithoutVaultAssetsInput
    vaults: vaultsCreateNestedOneWithoutVaultAssetsInput
  }

  export type vaultAssetsUncheckedCreateWithoutCustodyVendorVaultAssetsInput = {
    id?: number
    vaultId: string
    assetId: number
    balance: string
    createdAt?: Date | string
    updatedAt?: Date | string
    depositAddresses?: depositAddressesUncheckedCreateNestedManyWithoutVaultAssetsInput
  }

  export type vaultAssetsCreateOrConnectWithoutCustodyVendorVaultAssetsInput = {
    where: vaultAssetsWhereUniqueInput
    create: XOR<vaultAssetsCreateWithoutCustodyVendorVaultAssetsInput, vaultAssetsUncheckedCreateWithoutCustodyVendorVaultAssetsInput>
  }

  export type vendorsCreateWithoutCustodyVendorVaultAssetsInput = {
    name: string
    identifier: string
    quoteEngineBaseBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
    depositAddresses?: depositAddressesCreateNestedManyWithoutVendorsInput
    quotes?: quotesCreateNestedManyWithoutVendorsInput
    tokenPairs?: tokenPairsCreateNestedManyWithoutVendorsInput
    transactions?: transactionsCreateNestedManyWithoutVendorsInput
    vendorSupportsAssets?: vendorSupportsAssetsCreateNestedManyWithoutVendorsInput
    vendorTypes: vendorTypesCreateNestedOneWithoutVendorsInput
  }

  export type vendorsUncheckedCreateWithoutCustodyVendorVaultAssetsInput = {
    id?: number
    name: string
    identifier: string
    vendorTypeId: number
    quoteEngineBaseBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
    depositAddresses?: depositAddressesUncheckedCreateNestedManyWithoutVendorsInput
    quotes?: quotesUncheckedCreateNestedManyWithoutVendorsInput
    tokenPairs?: tokenPairsUncheckedCreateNestedManyWithoutVendorsInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutVendorsInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedCreateNestedManyWithoutVendorsInput
  }

  export type vendorsCreateOrConnectWithoutCustodyVendorVaultAssetsInput = {
    where: vendorsWhereUniqueInput
    create: XOR<vendorsCreateWithoutCustodyVendorVaultAssetsInput, vendorsUncheckedCreateWithoutCustodyVendorVaultAssetsInput>
  }

  export type vaultAssetsUpsertWithoutCustodyVendorVaultAssetsInput = {
    update: XOR<vaultAssetsUpdateWithoutCustodyVendorVaultAssetsInput, vaultAssetsUncheckedUpdateWithoutCustodyVendorVaultAssetsInput>
    create: XOR<vaultAssetsCreateWithoutCustodyVendorVaultAssetsInput, vaultAssetsUncheckedCreateWithoutCustodyVendorVaultAssetsInput>
  }

  export type vaultAssetsUpdateWithoutCustodyVendorVaultAssetsInput = {
    balance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depositAddresses?: depositAddressesUpdateManyWithoutVaultAssetsNestedInput
    assets?: assetsUpdateOneRequiredWithoutVaultAssetsNestedInput
    vaults?: vaultsUpdateOneRequiredWithoutVaultAssetsNestedInput
  }

  export type vaultAssetsUncheckedUpdateWithoutCustodyVendorVaultAssetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    vaultId?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    balance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depositAddresses?: depositAddressesUncheckedUpdateManyWithoutVaultAssetsNestedInput
  }

  export type vendorsUpsertWithoutCustodyVendorVaultAssetsInput = {
    update: XOR<vendorsUpdateWithoutCustodyVendorVaultAssetsInput, vendorsUncheckedUpdateWithoutCustodyVendorVaultAssetsInput>
    create: XOR<vendorsCreateWithoutCustodyVendorVaultAssetsInput, vendorsUncheckedCreateWithoutCustodyVendorVaultAssetsInput>
  }

  export type vendorsUpdateWithoutCustodyVendorVaultAssetsInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    quoteEngineBaseBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depositAddresses?: depositAddressesUpdateManyWithoutVendorsNestedInput
    quotes?: quotesUpdateManyWithoutVendorsNestedInput
    tokenPairs?: tokenPairsUpdateManyWithoutVendorsNestedInput
    transactions?: transactionsUpdateManyWithoutVendorsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUpdateManyWithoutVendorsNestedInput
    vendorTypes?: vendorTypesUpdateOneRequiredWithoutVendorsNestedInput
  }

  export type vendorsUncheckedUpdateWithoutCustodyVendorVaultAssetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    vendorTypeId?: IntFieldUpdateOperationsInput | number
    quoteEngineBaseBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    depositAddresses?: depositAddressesUncheckedUpdateManyWithoutVendorsNestedInput
    quotes?: quotesUncheckedUpdateManyWithoutVendorsNestedInput
    tokenPairs?: tokenPairsUncheckedUpdateManyWithoutVendorsNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutVendorsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedUpdateManyWithoutVendorsNestedInput
  }

  export type vaultAssetsCreateWithoutDepositAddressesInput = {
    balance: string
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsCreateNestedManyWithoutVaultAssetsInput
    assets: assetsCreateNestedOneWithoutVaultAssetsInput
    vaults: vaultsCreateNestedOneWithoutVaultAssetsInput
  }

  export type vaultAssetsUncheckedCreateWithoutDepositAddressesInput = {
    id?: number
    vaultId: string
    assetId: number
    balance: string
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUncheckedCreateNestedManyWithoutVaultAssetsInput
  }

  export type vaultAssetsCreateOrConnectWithoutDepositAddressesInput = {
    where: vaultAssetsWhereUniqueInput
    create: XOR<vaultAssetsCreateWithoutDepositAddressesInput, vaultAssetsUncheckedCreateWithoutDepositAddressesInput>
  }

  export type vendorsCreateWithoutDepositAddressesInput = {
    name: string
    identifier: string
    quoteEngineBaseBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsCreateNestedManyWithoutVendorsInput
    quotes?: quotesCreateNestedManyWithoutVendorsInput
    tokenPairs?: tokenPairsCreateNestedManyWithoutVendorsInput
    transactions?: transactionsCreateNestedManyWithoutVendorsInput
    vendorSupportsAssets?: vendorSupportsAssetsCreateNestedManyWithoutVendorsInput
    vendorTypes: vendorTypesCreateNestedOneWithoutVendorsInput
  }

  export type vendorsUncheckedCreateWithoutDepositAddressesInput = {
    id?: number
    name: string
    identifier: string
    vendorTypeId: number
    quoteEngineBaseBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUncheckedCreateNestedManyWithoutVendorsInput
    quotes?: quotesUncheckedCreateNestedManyWithoutVendorsInput
    tokenPairs?: tokenPairsUncheckedCreateNestedManyWithoutVendorsInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutVendorsInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedCreateNestedManyWithoutVendorsInput
  }

  export type vendorsCreateOrConnectWithoutDepositAddressesInput = {
    where: vendorsWhereUniqueInput
    create: XOR<vendorsCreateWithoutDepositAddressesInput, vendorsUncheckedCreateWithoutDepositAddressesInput>
  }

  export type vaultAssetsUpsertWithoutDepositAddressesInput = {
    update: XOR<vaultAssetsUpdateWithoutDepositAddressesInput, vaultAssetsUncheckedUpdateWithoutDepositAddressesInput>
    create: XOR<vaultAssetsCreateWithoutDepositAddressesInput, vaultAssetsUncheckedCreateWithoutDepositAddressesInput>
  }

  export type vaultAssetsUpdateWithoutDepositAddressesInput = {
    balance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUpdateManyWithoutVaultAssetsNestedInput
    assets?: assetsUpdateOneRequiredWithoutVaultAssetsNestedInput
    vaults?: vaultsUpdateOneRequiredWithoutVaultAssetsNestedInput
  }

  export type vaultAssetsUncheckedUpdateWithoutDepositAddressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    vaultId?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    balance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUncheckedUpdateManyWithoutVaultAssetsNestedInput
  }

  export type vendorsUpsertWithoutDepositAddressesInput = {
    update: XOR<vendorsUpdateWithoutDepositAddressesInput, vendorsUncheckedUpdateWithoutDepositAddressesInput>
    create: XOR<vendorsCreateWithoutDepositAddressesInput, vendorsUncheckedCreateWithoutDepositAddressesInput>
  }

  export type vendorsUpdateWithoutDepositAddressesInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    quoteEngineBaseBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUpdateManyWithoutVendorsNestedInput
    quotes?: quotesUpdateManyWithoutVendorsNestedInput
    tokenPairs?: tokenPairsUpdateManyWithoutVendorsNestedInput
    transactions?: transactionsUpdateManyWithoutVendorsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUpdateManyWithoutVendorsNestedInput
    vendorTypes?: vendorTypesUpdateOneRequiredWithoutVendorsNestedInput
  }

  export type vendorsUncheckedUpdateWithoutDepositAddressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    vendorTypeId?: IntFieldUpdateOperationsInput | number
    quoteEngineBaseBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUncheckedUpdateManyWithoutVendorsNestedInput
    quotes?: quotesUncheckedUpdateManyWithoutVendorsNestedInput
    tokenPairs?: tokenPairsUncheckedUpdateManyWithoutVendorsNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutVendorsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedUpdateManyWithoutVendorsNestedInput
  }

  export type webhookRequestsCreateWithoutInstitutionalProductsInput = {
    id: string
    httpStatusCode: number
    requestPayload: JsonNullValueInput | InputJsonValue
    responsePayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyEngineEvents?: custodyEngineEventsCreateNestedOneWithoutWebhookRequestsInput
    webhooks: webhooksCreateNestedOneWithoutWebhookRequestsInput
  }

  export type webhookRequestsUncheckedCreateWithoutInstitutionalProductsInput = {
    id: string
    webhookId: string
    httpStatusCode: number
    requestPayload: JsonNullValueInput | InputJsonValue
    responsePayload?: NullableJsonNullValueInput | InputJsonValue
    custodyEngineEventId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type webhookRequestsCreateOrConnectWithoutInstitutionalProductsInput = {
    where: webhookRequestsWhereUniqueInput
    create: XOR<webhookRequestsCreateWithoutInstitutionalProductsInput, webhookRequestsUncheckedCreateWithoutInstitutionalProductsInput>
  }

  export type webhookRequestsCreateManyInstitutionalProductsInputEnvelope = {
    data: Enumerable<webhookRequestsCreateManyInstitutionalProductsInput>
    skipDuplicates?: boolean
  }

  export type webhookRequestsUpsertWithWhereUniqueWithoutInstitutionalProductsInput = {
    where: webhookRequestsWhereUniqueInput
    update: XOR<webhookRequestsUpdateWithoutInstitutionalProductsInput, webhookRequestsUncheckedUpdateWithoutInstitutionalProductsInput>
    create: XOR<webhookRequestsCreateWithoutInstitutionalProductsInput, webhookRequestsUncheckedCreateWithoutInstitutionalProductsInput>
  }

  export type webhookRequestsUpdateWithWhereUniqueWithoutInstitutionalProductsInput = {
    where: webhookRequestsWhereUniqueInput
    data: XOR<webhookRequestsUpdateWithoutInstitutionalProductsInput, webhookRequestsUncheckedUpdateWithoutInstitutionalProductsInput>
  }

  export type webhookRequestsUpdateManyWithWhereWithoutInstitutionalProductsInput = {
    where: webhookRequestsScalarWhereInput
    data: XOR<webhookRequestsUpdateManyMutationInput, webhookRequestsUncheckedUpdateManyWithoutWebhookRequestsInput>
  }

  export type quotesCreateWithoutOrdersInput = {
    id: string
    side: enum_quotes_side
    userId: string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    buyPrice?: string
    sellPrice?: string
    quantity?: string
    tokenPairsInfo?: tokenPairsInfoCreateNestedOneWithoutQuotesInput
    quoteStatuses: quoteStatusesCreateNestedOneWithoutQuotesInput
    assets_quotes_sourceAssetIdToassets: assetsCreateNestedOneWithoutQuotes_quotes_sourceAssetIdToassetsInput
    assets_quotes_targetAssetIdToassets: assetsCreateNestedOneWithoutQuotes_quotes_targetAssetIdToassetsInput
    vendors?: vendorsCreateNestedOneWithoutQuotesInput
  }

  export type quotesUncheckedCreateWithoutOrdersInput = {
    id: string
    quoteStatusId: number
    sourceAssetId: number
    targetAssetId: number
    side: enum_quotes_side
    userId: string
    vendorId?: number | null
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    fxRequestID?: string | null
    buyPrice?: string
    sellPrice?: string
    quantity?: string
  }

  export type quotesCreateOrConnectWithoutOrdersInput = {
    where: quotesWhereUniqueInput
    create: XOR<quotesCreateWithoutOrdersInput, quotesUncheckedCreateWithoutOrdersInput>
  }

  export type quotesUpsertWithoutOrdersInput = {
    update: XOR<quotesUpdateWithoutOrdersInput, quotesUncheckedUpdateWithoutOrdersInput>
    create: XOR<quotesCreateWithoutOrdersInput, quotesUncheckedCreateWithoutOrdersInput>
  }

  export type quotesUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: Enumenum_quotes_sideFieldUpdateOperationsInput | enum_quotes_side
    userId?: StringFieldUpdateOperationsInput | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buyPrice?: StringFieldUpdateOperationsInput | string
    sellPrice?: StringFieldUpdateOperationsInput | string
    quantity?: StringFieldUpdateOperationsInput | string
    tokenPairsInfo?: tokenPairsInfoUpdateOneWithoutQuotesNestedInput
    quoteStatuses?: quoteStatusesUpdateOneRequiredWithoutQuotesNestedInput
    assets_quotes_sourceAssetIdToassets?: assetsUpdateOneRequiredWithoutQuotes_quotes_sourceAssetIdToassetsNestedInput
    assets_quotes_targetAssetIdToassets?: assetsUpdateOneRequiredWithoutQuotes_quotes_targetAssetIdToassetsNestedInput
    vendors?: vendorsUpdateOneWithoutQuotesNestedInput
  }

  export type quotesUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteStatusId?: IntFieldUpdateOperationsInput | number
    sourceAssetId?: IntFieldUpdateOperationsInput | number
    targetAssetId?: IntFieldUpdateOperationsInput | number
    side?: Enumenum_quotes_sideFieldUpdateOperationsInput | enum_quotes_side
    userId?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fxRequestID?: NullableStringFieldUpdateOperationsInput | string | null
    buyPrice?: StringFieldUpdateOperationsInput | string
    sellPrice?: StringFieldUpdateOperationsInput | string
    quantity?: StringFieldUpdateOperationsInput | string
  }

  export type organizationsCreateWithoutOrganizationStatusTypesInput = {
    name: string
    primaryEmail: string
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyEngineEvents?: custodyEngineEventsCreateNestedManyWithoutOrganizationsInput
    pricingPlans?: pricingPlansCreateNestedOneWithoutOrganizationsInput
    users?: usersCreateNestedManyWithoutOrganizationsInput
    webhooks?: webhooksCreateNestedManyWithoutOrganizationsInput
    withdrawalAddresses?: withdrawalAddressesCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateWithoutOrganizationStatusTypesInput = {
    id?: number
    name: string
    primaryEmail: string
    pricingPlanId?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyEngineEvents?: custodyEngineEventsUncheckedCreateNestedManyWithoutOrganizationsInput
    users?: usersUncheckedCreateNestedManyWithoutOrganizationsInput
    webhooks?: webhooksUncheckedCreateNestedManyWithoutOrganizationsInput
    withdrawalAddresses?: withdrawalAddressesUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsCreateOrConnectWithoutOrganizationStatusTypesInput = {
    where: organizationsWhereUniqueInput
    create: XOR<organizationsCreateWithoutOrganizationStatusTypesInput, organizationsUncheckedCreateWithoutOrganizationStatusTypesInput>
  }

  export type organizationsCreateManyOrganizationStatusTypesInputEnvelope = {
    data: Enumerable<organizationsCreateManyOrganizationStatusTypesInput>
    skipDuplicates?: boolean
  }

  export type organizationsUpsertWithWhereUniqueWithoutOrganizationStatusTypesInput = {
    where: organizationsWhereUniqueInput
    update: XOR<organizationsUpdateWithoutOrganizationStatusTypesInput, organizationsUncheckedUpdateWithoutOrganizationStatusTypesInput>
    create: XOR<organizationsCreateWithoutOrganizationStatusTypesInput, organizationsUncheckedCreateWithoutOrganizationStatusTypesInput>
  }

  export type organizationsUpdateWithWhereUniqueWithoutOrganizationStatusTypesInput = {
    where: organizationsWhereUniqueInput
    data: XOR<organizationsUpdateWithoutOrganizationStatusTypesInput, organizationsUncheckedUpdateWithoutOrganizationStatusTypesInput>
  }

  export type organizationsUpdateManyWithWhereWithoutOrganizationStatusTypesInput = {
    where: organizationsScalarWhereInput
    data: XOR<organizationsUpdateManyMutationInput, organizationsUncheckedUpdateManyWithoutOrganizationsInput>
  }

  export type organizationsScalarWhereInput = {
    AND?: Enumerable<organizationsScalarWhereInput>
    OR?: Enumerable<organizationsScalarWhereInput>
    NOT?: Enumerable<organizationsScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    primaryEmail?: StringFilter | string
    pricingPlanId?: IntFilter | number
    statusId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type custodyEngineEventsCreateWithoutOrganizationsInput = {
    id: string
    event: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyEngineEventTypes: custodyEngineEventTypesCreateNestedOneWithoutCustodyEngineEventsInput
    webhookRequests?: webhookRequestsCreateNestedManyWithoutCustodyEngineEventsInput
  }

  export type custodyEngineEventsUncheckedCreateWithoutOrganizationsInput = {
    id: string
    custodyEngineEventTypeId: number
    event: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    webhookRequests?: webhookRequestsUncheckedCreateNestedManyWithoutCustodyEngineEventsInput
  }

  export type custodyEngineEventsCreateOrConnectWithoutOrganizationsInput = {
    where: custodyEngineEventsWhereUniqueInput
    create: XOR<custodyEngineEventsCreateWithoutOrganizationsInput, custodyEngineEventsUncheckedCreateWithoutOrganizationsInput>
  }

  export type custodyEngineEventsCreateManyOrganizationsInputEnvelope = {
    data: Enumerable<custodyEngineEventsCreateManyOrganizationsInput>
    skipDuplicates?: boolean
  }

  export type pricingPlansCreateWithoutOrganizationsInput = {
    price: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pricingPlanSupportsAssets?: pricingPlanSupportsAssetsCreateNestedManyWithoutPricingPlansInput
    pricingPlanProfiles: pricingPlanProfilesCreateNestedOneWithoutPricingPlansInput
  }

  export type pricingPlansUncheckedCreateWithoutOrganizationsInput = {
    id?: number
    price: number
    active?: boolean
    pricingPlanProfileId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pricingPlanSupportsAssets?: pricingPlanSupportsAssetsUncheckedCreateNestedManyWithoutPricingPlansInput
  }

  export type pricingPlansCreateOrConnectWithoutOrganizationsInput = {
    where: pricingPlansWhereUniqueInput
    create: XOR<pricingPlansCreateWithoutOrganizationsInput, pricingPlansUncheckedCreateWithoutOrganizationsInput>
  }

  export type organizationStatusTypesCreateWithoutOrganizationsInput = {
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type organizationStatusTypesUncheckedCreateWithoutOrganizationsInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type organizationStatusTypesCreateOrConnectWithoutOrganizationsInput = {
    where: organizationStatusTypesWhereUniqueInput
    create: XOR<organizationStatusTypesCreateWithoutOrganizationsInput, organizationStatusTypesUncheckedCreateWithoutOrganizationsInput>
  }

  export type usersCreateWithoutOrganizationsInput = {
    id: string
    primaryEmail: string
    firstName: string
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publicKey?: string | null
    apiKey?: string | null
    transactionPolicies?: transactionPoliciesCreateNestedManyWithoutUsersInput
    transactions?: transactionsCreateNestedManyWithoutUsersInput
    userTypes: userTypesCreateNestedOneWithoutUsersInput
    vaults?: vaultsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutOrganizationsInput = {
    id: string
    userTypeId: number
    primaryEmail: string
    firstName: string
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publicKey?: string | null
    apiKey?: string | null
    transactionPolicies?: transactionPoliciesUncheckedCreateNestedManyWithoutUsersInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutUsersInput
    vaults?: vaultsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutOrganizationsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutOrganizationsInput, usersUncheckedCreateWithoutOrganizationsInput>
  }

  export type usersCreateManyOrganizationsInputEnvelope = {
    data: Enumerable<usersCreateManyOrganizationsInput>
    skipDuplicates?: boolean
  }

  export type webhooksCreateWithoutOrganizationsInput = {
    id: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    webhookRequests?: webhookRequestsCreateNestedManyWithoutWebhooksInput
    webhookStatusTypes: webhookStatusTypesCreateNestedOneWithoutWebhooksInput
  }

  export type webhooksUncheckedCreateWithoutOrganizationsInput = {
    id: string
    webhookStatusTypeId: number
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    webhookRequests?: webhookRequestsUncheckedCreateNestedManyWithoutWebhooksInput
  }

  export type webhooksCreateOrConnectWithoutOrganizationsInput = {
    where: webhooksWhereUniqueInput
    create: XOR<webhooksCreateWithoutOrganizationsInput, webhooksUncheckedCreateWithoutOrganizationsInput>
  }

  export type webhooksCreateManyOrganizationsInputEnvelope = {
    data: Enumerable<webhooksCreateManyOrganizationsInput>
    skipDuplicates?: boolean
  }

  export type withdrawalAddressesCreateWithoutOrganizationsInput = {
    id: string
    nickname?: string | null
    address: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionPolicies?: transactionPoliciesCreateNestedManyWithoutWithdrawalAddressesInput
    transactions?: transactionsCreateNestedManyWithoutWithdrawalAddressesInput
    assets: assetsCreateNestedOneWithoutWithdrawalAddressesInput
  }

  export type withdrawalAddressesUncheckedCreateWithoutOrganizationsInput = {
    id: string
    assetId: number
    nickname?: string | null
    address: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionPolicies?: transactionPoliciesUncheckedCreateNestedManyWithoutWithdrawalAddressesInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutWithdrawalAddressesInput
  }

  export type withdrawalAddressesCreateOrConnectWithoutOrganizationsInput = {
    where: withdrawalAddressesWhereUniqueInput
    create: XOR<withdrawalAddressesCreateWithoutOrganizationsInput, withdrawalAddressesUncheckedCreateWithoutOrganizationsInput>
  }

  export type withdrawalAddressesCreateManyOrganizationsInputEnvelope = {
    data: Enumerable<withdrawalAddressesCreateManyOrganizationsInput>
    skipDuplicates?: boolean
  }

  export type custodyEngineEventsUpsertWithWhereUniqueWithoutOrganizationsInput = {
    where: custodyEngineEventsWhereUniqueInput
    update: XOR<custodyEngineEventsUpdateWithoutOrganizationsInput, custodyEngineEventsUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<custodyEngineEventsCreateWithoutOrganizationsInput, custodyEngineEventsUncheckedCreateWithoutOrganizationsInput>
  }

  export type custodyEngineEventsUpdateWithWhereUniqueWithoutOrganizationsInput = {
    where: custodyEngineEventsWhereUniqueInput
    data: XOR<custodyEngineEventsUpdateWithoutOrganizationsInput, custodyEngineEventsUncheckedUpdateWithoutOrganizationsInput>
  }

  export type custodyEngineEventsUpdateManyWithWhereWithoutOrganizationsInput = {
    where: custodyEngineEventsScalarWhereInput
    data: XOR<custodyEngineEventsUpdateManyMutationInput, custodyEngineEventsUncheckedUpdateManyWithoutCustodyEngineEventsInput>
  }

  export type pricingPlansUpsertWithoutOrganizationsInput = {
    update: XOR<pricingPlansUpdateWithoutOrganizationsInput, pricingPlansUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<pricingPlansCreateWithoutOrganizationsInput, pricingPlansUncheckedCreateWithoutOrganizationsInput>
  }

  export type pricingPlansUpdateWithoutOrganizationsInput = {
    price?: FloatFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingPlanSupportsAssets?: pricingPlanSupportsAssetsUpdateManyWithoutPricingPlansNestedInput
    pricingPlanProfiles?: pricingPlanProfilesUpdateOneRequiredWithoutPricingPlansNestedInput
  }

  export type pricingPlansUncheckedUpdateWithoutOrganizationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    pricingPlanProfileId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingPlanSupportsAssets?: pricingPlanSupportsAssetsUncheckedUpdateManyWithoutPricingPlansNestedInput
  }

  export type organizationStatusTypesUpsertWithoutOrganizationsInput = {
    update: XOR<organizationStatusTypesUpdateWithoutOrganizationsInput, organizationStatusTypesUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<organizationStatusTypesCreateWithoutOrganizationsInput, organizationStatusTypesUncheckedCreateWithoutOrganizationsInput>
  }

  export type organizationStatusTypesUpdateWithoutOrganizationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type organizationStatusTypesUncheckedUpdateWithoutOrganizationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUpsertWithWhereUniqueWithoutOrganizationsInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutOrganizationsInput, usersUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<usersCreateWithoutOrganizationsInput, usersUncheckedCreateWithoutOrganizationsInput>
  }

  export type usersUpdateWithWhereUniqueWithoutOrganizationsInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutOrganizationsInput, usersUncheckedUpdateWithoutOrganizationsInput>
  }

  export type usersUpdateManyWithWhereWithoutOrganizationsInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutUsersInput>
  }

  export type usersScalarWhereInput = {
    AND?: Enumerable<usersScalarWhereInput>
    OR?: Enumerable<usersScalarWhereInput>
    NOT?: Enumerable<usersScalarWhereInput>
    id?: UuidFilter | string
    organizationId?: IntFilter | number
    userTypeId?: IntFilter | number
    primaryEmail?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    publicKey?: StringNullableFilter | string | null
    apiKey?: StringNullableFilter | string | null
  }

  export type webhooksUpsertWithWhereUniqueWithoutOrganizationsInput = {
    where: webhooksWhereUniqueInput
    update: XOR<webhooksUpdateWithoutOrganizationsInput, webhooksUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<webhooksCreateWithoutOrganizationsInput, webhooksUncheckedCreateWithoutOrganizationsInput>
  }

  export type webhooksUpdateWithWhereUniqueWithoutOrganizationsInput = {
    where: webhooksWhereUniqueInput
    data: XOR<webhooksUpdateWithoutOrganizationsInput, webhooksUncheckedUpdateWithoutOrganizationsInput>
  }

  export type webhooksUpdateManyWithWhereWithoutOrganizationsInput = {
    where: webhooksScalarWhereInput
    data: XOR<webhooksUpdateManyMutationInput, webhooksUncheckedUpdateManyWithoutWebhooksInput>
  }

  export type webhooksScalarWhereInput = {
    AND?: Enumerable<webhooksScalarWhereInput>
    OR?: Enumerable<webhooksScalarWhereInput>
    NOT?: Enumerable<webhooksScalarWhereInput>
    id?: UuidFilter | string
    organizationId?: IntFilter | number
    webhookStatusTypeId?: IntFilter | number
    url?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type withdrawalAddressesUpsertWithWhereUniqueWithoutOrganizationsInput = {
    where: withdrawalAddressesWhereUniqueInput
    update: XOR<withdrawalAddressesUpdateWithoutOrganizationsInput, withdrawalAddressesUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<withdrawalAddressesCreateWithoutOrganizationsInput, withdrawalAddressesUncheckedCreateWithoutOrganizationsInput>
  }

  export type withdrawalAddressesUpdateWithWhereUniqueWithoutOrganizationsInput = {
    where: withdrawalAddressesWhereUniqueInput
    data: XOR<withdrawalAddressesUpdateWithoutOrganizationsInput, withdrawalAddressesUncheckedUpdateWithoutOrganizationsInput>
  }

  export type withdrawalAddressesUpdateManyWithWhereWithoutOrganizationsInput = {
    where: withdrawalAddressesScalarWhereInput
    data: XOR<withdrawalAddressesUpdateManyMutationInput, withdrawalAddressesUncheckedUpdateManyWithoutWithdrawalAddressesInput>
  }

  export type pricingPlansCreateWithoutPricingPlanProfilesInput = {
    price: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organizations?: organizationsCreateNestedManyWithoutPricingPlansInput
    pricingPlanSupportsAssets?: pricingPlanSupportsAssetsCreateNestedManyWithoutPricingPlansInput
  }

  export type pricingPlansUncheckedCreateWithoutPricingPlanProfilesInput = {
    id?: number
    price: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organizations?: organizationsUncheckedCreateNestedManyWithoutPricingPlansInput
    pricingPlanSupportsAssets?: pricingPlanSupportsAssetsUncheckedCreateNestedManyWithoutPricingPlansInput
  }

  export type pricingPlansCreateOrConnectWithoutPricingPlanProfilesInput = {
    where: pricingPlansWhereUniqueInput
    create: XOR<pricingPlansCreateWithoutPricingPlanProfilesInput, pricingPlansUncheckedCreateWithoutPricingPlanProfilesInput>
  }

  export type pricingPlansCreateManyPricingPlanProfilesInputEnvelope = {
    data: Enumerable<pricingPlansCreateManyPricingPlanProfilesInput>
    skipDuplicates?: boolean
  }

  export type pricingPlansUpsertWithWhereUniqueWithoutPricingPlanProfilesInput = {
    where: pricingPlansWhereUniqueInput
    update: XOR<pricingPlansUpdateWithoutPricingPlanProfilesInput, pricingPlansUncheckedUpdateWithoutPricingPlanProfilesInput>
    create: XOR<pricingPlansCreateWithoutPricingPlanProfilesInput, pricingPlansUncheckedCreateWithoutPricingPlanProfilesInput>
  }

  export type pricingPlansUpdateWithWhereUniqueWithoutPricingPlanProfilesInput = {
    where: pricingPlansWhereUniqueInput
    data: XOR<pricingPlansUpdateWithoutPricingPlanProfilesInput, pricingPlansUncheckedUpdateWithoutPricingPlanProfilesInput>
  }

  export type pricingPlansUpdateManyWithWhereWithoutPricingPlanProfilesInput = {
    where: pricingPlansScalarWhereInput
    data: XOR<pricingPlansUpdateManyMutationInput, pricingPlansUncheckedUpdateManyWithoutPricingPlansInput>
  }

  export type pricingPlansScalarWhereInput = {
    AND?: Enumerable<pricingPlansScalarWhereInput>
    OR?: Enumerable<pricingPlansScalarWhereInput>
    NOT?: Enumerable<pricingPlansScalarWhereInput>
    id?: IntFilter | number
    price?: FloatFilter | number
    active?: BoolFilter | boolean
    pricingPlanProfileId?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type pricingPlansCreateWithoutPricingPlanSupportsAssetsInput = {
    price: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organizations?: organizationsCreateNestedManyWithoutPricingPlansInput
    pricingPlanProfiles: pricingPlanProfilesCreateNestedOneWithoutPricingPlansInput
  }

  export type pricingPlansUncheckedCreateWithoutPricingPlanSupportsAssetsInput = {
    id?: number
    price: number
    active?: boolean
    pricingPlanProfileId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    organizations?: organizationsUncheckedCreateNestedManyWithoutPricingPlansInput
  }

  export type pricingPlansCreateOrConnectWithoutPricingPlanSupportsAssetsInput = {
    where: pricingPlansWhereUniqueInput
    create: XOR<pricingPlansCreateWithoutPricingPlanSupportsAssetsInput, pricingPlansUncheckedCreateWithoutPricingPlanSupportsAssetsInput>
  }

  export type vendorSupportsAssetsCreateWithoutPricingPlanSupportsAssetsInput = {
    enabled?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    theirId?: string | null
    assets: assetsCreateNestedOneWithoutVendorSupportsAssetsInput
    vendors: vendorsCreateNestedOneWithoutVendorSupportsAssetsInput
  }

  export type vendorSupportsAssetsUncheckedCreateWithoutPricingPlanSupportsAssetsInput = {
    id?: number
    assetId: number
    vendorId: number
    enabled?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    theirId?: string | null
  }

  export type vendorSupportsAssetsCreateOrConnectWithoutPricingPlanSupportsAssetsInput = {
    where: vendorSupportsAssetsWhereUniqueInput
    create: XOR<vendorSupportsAssetsCreateWithoutPricingPlanSupportsAssetsInput, vendorSupportsAssetsUncheckedCreateWithoutPricingPlanSupportsAssetsInput>
  }

  export type pricingPlansUpsertWithoutPricingPlanSupportsAssetsInput = {
    update: XOR<pricingPlansUpdateWithoutPricingPlanSupportsAssetsInput, pricingPlansUncheckedUpdateWithoutPricingPlanSupportsAssetsInput>
    create: XOR<pricingPlansCreateWithoutPricingPlanSupportsAssetsInput, pricingPlansUncheckedCreateWithoutPricingPlanSupportsAssetsInput>
  }

  export type pricingPlansUpdateWithoutPricingPlanSupportsAssetsInput = {
    price?: FloatFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizations?: organizationsUpdateManyWithoutPricingPlansNestedInput
    pricingPlanProfiles?: pricingPlanProfilesUpdateOneRequiredWithoutPricingPlansNestedInput
  }

  export type pricingPlansUncheckedUpdateWithoutPricingPlanSupportsAssetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    pricingPlanProfileId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizations?: organizationsUncheckedUpdateManyWithoutPricingPlansNestedInput
  }

  export type vendorSupportsAssetsUpsertWithoutPricingPlanSupportsAssetsInput = {
    update: XOR<vendorSupportsAssetsUpdateWithoutPricingPlanSupportsAssetsInput, vendorSupportsAssetsUncheckedUpdateWithoutPricingPlanSupportsAssetsInput>
    create: XOR<vendorSupportsAssetsCreateWithoutPricingPlanSupportsAssetsInput, vendorSupportsAssetsUncheckedCreateWithoutPricingPlanSupportsAssetsInput>
  }

  export type vendorSupportsAssetsUpdateWithoutPricingPlanSupportsAssetsInput = {
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    theirId?: NullableStringFieldUpdateOperationsInput | string | null
    assets?: assetsUpdateOneRequiredWithoutVendorSupportsAssetsNestedInput
    vendors?: vendorsUpdateOneRequiredWithoutVendorSupportsAssetsNestedInput
  }

  export type vendorSupportsAssetsUncheckedUpdateWithoutPricingPlanSupportsAssetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    theirId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type organizationsCreateWithoutPricingPlansInput = {
    name: string
    primaryEmail: string
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyEngineEvents?: custodyEngineEventsCreateNestedManyWithoutOrganizationsInput
    organizationStatusTypes: organizationStatusTypesCreateNestedOneWithoutOrganizationsInput
    users?: usersCreateNestedManyWithoutOrganizationsInput
    webhooks?: webhooksCreateNestedManyWithoutOrganizationsInput
    withdrawalAddresses?: withdrawalAddressesCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateWithoutPricingPlansInput = {
    id?: number
    name: string
    primaryEmail: string
    statusId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyEngineEvents?: custodyEngineEventsUncheckedCreateNestedManyWithoutOrganizationsInput
    users?: usersUncheckedCreateNestedManyWithoutOrganizationsInput
    webhooks?: webhooksUncheckedCreateNestedManyWithoutOrganizationsInput
    withdrawalAddresses?: withdrawalAddressesUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsCreateOrConnectWithoutPricingPlansInput = {
    where: organizationsWhereUniqueInput
    create: XOR<organizationsCreateWithoutPricingPlansInput, organizationsUncheckedCreateWithoutPricingPlansInput>
  }

  export type organizationsCreateManyPricingPlansInputEnvelope = {
    data: Enumerable<organizationsCreateManyPricingPlansInput>
    skipDuplicates?: boolean
  }

  export type pricingPlanSupportsAssetsCreateWithoutPricingPlansInput = {
    enabled?: boolean
    buyBps: number
    sellBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorSupportsAssets: vendorSupportsAssetsCreateNestedOneWithoutPricingPlanSupportsAssetsInput
  }

  export type pricingPlanSupportsAssetsUncheckedCreateWithoutPricingPlansInput = {
    id?: number
    vendorSupportsAssetId: number
    enabled?: boolean
    buyBps: number
    sellBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pricingPlanSupportsAssetsCreateOrConnectWithoutPricingPlansInput = {
    where: pricingPlanSupportsAssetsWhereUniqueInput
    create: XOR<pricingPlanSupportsAssetsCreateWithoutPricingPlansInput, pricingPlanSupportsAssetsUncheckedCreateWithoutPricingPlansInput>
  }

  export type pricingPlanSupportsAssetsCreateManyPricingPlansInputEnvelope = {
    data: Enumerable<pricingPlanSupportsAssetsCreateManyPricingPlansInput>
    skipDuplicates?: boolean
  }

  export type pricingPlanProfilesCreateWithoutPricingPlansInput = {
    name: string
    quoteEngineRps: number
    custodyEngineRps: number
    numberOfUsers: number
    sla: number
    rbac: boolean
    quoteEngineClaims: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pricingPlanProfilesUncheckedCreateWithoutPricingPlansInput = {
    id?: number
    name: string
    quoteEngineRps: number
    custodyEngineRps: number
    numberOfUsers: number
    sla: number
    rbac: boolean
    quoteEngineClaims: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pricingPlanProfilesCreateOrConnectWithoutPricingPlansInput = {
    where: pricingPlanProfilesWhereUniqueInput
    create: XOR<pricingPlanProfilesCreateWithoutPricingPlansInput, pricingPlanProfilesUncheckedCreateWithoutPricingPlansInput>
  }

  export type organizationsUpsertWithWhereUniqueWithoutPricingPlansInput = {
    where: organizationsWhereUniqueInput
    update: XOR<organizationsUpdateWithoutPricingPlansInput, organizationsUncheckedUpdateWithoutPricingPlansInput>
    create: XOR<organizationsCreateWithoutPricingPlansInput, organizationsUncheckedCreateWithoutPricingPlansInput>
  }

  export type organizationsUpdateWithWhereUniqueWithoutPricingPlansInput = {
    where: organizationsWhereUniqueInput
    data: XOR<organizationsUpdateWithoutPricingPlansInput, organizationsUncheckedUpdateWithoutPricingPlansInput>
  }

  export type organizationsUpdateManyWithWhereWithoutPricingPlansInput = {
    where: organizationsScalarWhereInput
    data: XOR<organizationsUpdateManyMutationInput, organizationsUncheckedUpdateManyWithoutOrganizationsInput>
  }

  export type pricingPlanSupportsAssetsUpsertWithWhereUniqueWithoutPricingPlansInput = {
    where: pricingPlanSupportsAssetsWhereUniqueInput
    update: XOR<pricingPlanSupportsAssetsUpdateWithoutPricingPlansInput, pricingPlanSupportsAssetsUncheckedUpdateWithoutPricingPlansInput>
    create: XOR<pricingPlanSupportsAssetsCreateWithoutPricingPlansInput, pricingPlanSupportsAssetsUncheckedCreateWithoutPricingPlansInput>
  }

  export type pricingPlanSupportsAssetsUpdateWithWhereUniqueWithoutPricingPlansInput = {
    where: pricingPlanSupportsAssetsWhereUniqueInput
    data: XOR<pricingPlanSupportsAssetsUpdateWithoutPricingPlansInput, pricingPlanSupportsAssetsUncheckedUpdateWithoutPricingPlansInput>
  }

  export type pricingPlanSupportsAssetsUpdateManyWithWhereWithoutPricingPlansInput = {
    where: pricingPlanSupportsAssetsScalarWhereInput
    data: XOR<pricingPlanSupportsAssetsUpdateManyMutationInput, pricingPlanSupportsAssetsUncheckedUpdateManyWithoutPricingPlanSupportsAssetsInput>
  }

  export type pricingPlanSupportsAssetsScalarWhereInput = {
    AND?: Enumerable<pricingPlanSupportsAssetsScalarWhereInput>
    OR?: Enumerable<pricingPlanSupportsAssetsScalarWhereInput>
    NOT?: Enumerable<pricingPlanSupportsAssetsScalarWhereInput>
    id?: IntFilter | number
    vendorSupportsAssetId?: IntFilter | number
    pricingPlanId?: IntFilter | number
    enabled?: BoolFilter | boolean
    buyBps?: FloatFilter | number
    sellBps?: FloatFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type pricingPlanProfilesUpsertWithoutPricingPlansInput = {
    update: XOR<pricingPlanProfilesUpdateWithoutPricingPlansInput, pricingPlanProfilesUncheckedUpdateWithoutPricingPlansInput>
    create: XOR<pricingPlanProfilesCreateWithoutPricingPlansInput, pricingPlanProfilesUncheckedCreateWithoutPricingPlansInput>
  }

  export type pricingPlanProfilesUpdateWithoutPricingPlansInput = {
    name?: StringFieldUpdateOperationsInput | string
    quoteEngineRps?: IntFieldUpdateOperationsInput | number
    custodyEngineRps?: IntFieldUpdateOperationsInput | number
    numberOfUsers?: IntFieldUpdateOperationsInput | number
    sla?: FloatFieldUpdateOperationsInput | number
    rbac?: BoolFieldUpdateOperationsInput | boolean
    quoteEngineClaims?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pricingPlanProfilesUncheckedUpdateWithoutPricingPlansInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    quoteEngineRps?: IntFieldUpdateOperationsInput | number
    custodyEngineRps?: IntFieldUpdateOperationsInput | number
    numberOfUsers?: IntFieldUpdateOperationsInput | number
    sla?: FloatFieldUpdateOperationsInput | number
    rbac?: BoolFieldUpdateOperationsInput | boolean
    quoteEngineClaims?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quotesCreateWithoutQuoteStatusesInput = {
    id: string
    side: enum_quotes_side
    userId: string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    buyPrice?: string
    sellPrice?: string
    quantity?: string
    orders?: ordersCreateNestedManyWithoutQuotesInput
    tokenPairsInfo?: tokenPairsInfoCreateNestedOneWithoutQuotesInput
    assets_quotes_sourceAssetIdToassets: assetsCreateNestedOneWithoutQuotes_quotes_sourceAssetIdToassetsInput
    assets_quotes_targetAssetIdToassets: assetsCreateNestedOneWithoutQuotes_quotes_targetAssetIdToassetsInput
    vendors?: vendorsCreateNestedOneWithoutQuotesInput
  }

  export type quotesUncheckedCreateWithoutQuoteStatusesInput = {
    id: string
    sourceAssetId: number
    targetAssetId: number
    side: enum_quotes_side
    userId: string
    vendorId?: number | null
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    fxRequestID?: string | null
    buyPrice?: string
    sellPrice?: string
    quantity?: string
    orders?: ordersUncheckedCreateNestedManyWithoutQuotesInput
  }

  export type quotesCreateOrConnectWithoutQuoteStatusesInput = {
    where: quotesWhereUniqueInput
    create: XOR<quotesCreateWithoutQuoteStatusesInput, quotesUncheckedCreateWithoutQuoteStatusesInput>
  }

  export type quotesCreateManyQuoteStatusesInputEnvelope = {
    data: Enumerable<quotesCreateManyQuoteStatusesInput>
    skipDuplicates?: boolean
  }

  export type quotesUpsertWithWhereUniqueWithoutQuoteStatusesInput = {
    where: quotesWhereUniqueInput
    update: XOR<quotesUpdateWithoutQuoteStatusesInput, quotesUncheckedUpdateWithoutQuoteStatusesInput>
    create: XOR<quotesCreateWithoutQuoteStatusesInput, quotesUncheckedCreateWithoutQuoteStatusesInput>
  }

  export type quotesUpdateWithWhereUniqueWithoutQuoteStatusesInput = {
    where: quotesWhereUniqueInput
    data: XOR<quotesUpdateWithoutQuoteStatusesInput, quotesUncheckedUpdateWithoutQuoteStatusesInput>
  }

  export type quotesUpdateManyWithWhereWithoutQuoteStatusesInput = {
    where: quotesScalarWhereInput
    data: XOR<quotesUpdateManyMutationInput, quotesUncheckedUpdateManyWithoutQuotesInput>
  }

  export type vendorsCreateWithoutTokenPairsInput = {
    name: string
    identifier: string
    quoteEngineBaseBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsCreateNestedManyWithoutVendorsInput
    depositAddresses?: depositAddressesCreateNestedManyWithoutVendorsInput
    quotes?: quotesCreateNestedManyWithoutVendorsInput
    transactions?: transactionsCreateNestedManyWithoutVendorsInput
    vendorSupportsAssets?: vendorSupportsAssetsCreateNestedManyWithoutVendorsInput
    vendorTypes: vendorTypesCreateNestedOneWithoutVendorsInput
  }

  export type vendorsUncheckedCreateWithoutTokenPairsInput = {
    id?: number
    name: string
    identifier: string
    vendorTypeId: number
    quoteEngineBaseBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUncheckedCreateNestedManyWithoutVendorsInput
    depositAddresses?: depositAddressesUncheckedCreateNestedManyWithoutVendorsInput
    quotes?: quotesUncheckedCreateNestedManyWithoutVendorsInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutVendorsInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedCreateNestedManyWithoutVendorsInput
  }

  export type vendorsCreateOrConnectWithoutTokenPairsInput = {
    where: vendorsWhereUniqueInput
    create: XOR<vendorsCreateWithoutTokenPairsInput, vendorsUncheckedCreateWithoutTokenPairsInput>
  }

  export type tokenPairsInfoCreateWithoutTokenPairsInput = {
    fxRequestID: string
    quantity: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes?: quotesCreateNestedManyWithoutTokenPairsInfoInput
  }

  export type tokenPairsInfoUncheckedCreateWithoutTokenPairsInput = {
    id?: number
    fxRequestID: string
    quantity: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes?: quotesUncheckedCreateNestedManyWithoutTokenPairsInfoInput
  }

  export type tokenPairsInfoCreateOrConnectWithoutTokenPairsInput = {
    where: tokenPairsInfoWhereUniqueInput
    create: XOR<tokenPairsInfoCreateWithoutTokenPairsInput, tokenPairsInfoUncheckedCreateWithoutTokenPairsInput>
  }

  export type tokenPairsInfoCreateManyTokenPairsInputEnvelope = {
    data: Enumerable<tokenPairsInfoCreateManyTokenPairsInput>
    skipDuplicates?: boolean
  }

  export type vendorsUpsertWithoutTokenPairsInput = {
    update: XOR<vendorsUpdateWithoutTokenPairsInput, vendorsUncheckedUpdateWithoutTokenPairsInput>
    create: XOR<vendorsCreateWithoutTokenPairsInput, vendorsUncheckedCreateWithoutTokenPairsInput>
  }

  export type vendorsUpdateWithoutTokenPairsInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    quoteEngineBaseBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUpdateManyWithoutVendorsNestedInput
    depositAddresses?: depositAddressesUpdateManyWithoutVendorsNestedInput
    quotes?: quotesUpdateManyWithoutVendorsNestedInput
    transactions?: transactionsUpdateManyWithoutVendorsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUpdateManyWithoutVendorsNestedInput
    vendorTypes?: vendorTypesUpdateOneRequiredWithoutVendorsNestedInput
  }

  export type vendorsUncheckedUpdateWithoutTokenPairsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    vendorTypeId?: IntFieldUpdateOperationsInput | number
    quoteEngineBaseBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUncheckedUpdateManyWithoutVendorsNestedInput
    depositAddresses?: depositAddressesUncheckedUpdateManyWithoutVendorsNestedInput
    quotes?: quotesUncheckedUpdateManyWithoutVendorsNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutVendorsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedUpdateManyWithoutVendorsNestedInput
  }

  export type tokenPairsInfoUpsertWithWhereUniqueWithoutTokenPairsInput = {
    where: tokenPairsInfoWhereUniqueInput
    update: XOR<tokenPairsInfoUpdateWithoutTokenPairsInput, tokenPairsInfoUncheckedUpdateWithoutTokenPairsInput>
    create: XOR<tokenPairsInfoCreateWithoutTokenPairsInput, tokenPairsInfoUncheckedCreateWithoutTokenPairsInput>
  }

  export type tokenPairsInfoUpdateWithWhereUniqueWithoutTokenPairsInput = {
    where: tokenPairsInfoWhereUniqueInput
    data: XOR<tokenPairsInfoUpdateWithoutTokenPairsInput, tokenPairsInfoUncheckedUpdateWithoutTokenPairsInput>
  }

  export type tokenPairsInfoUpdateManyWithWhereWithoutTokenPairsInput = {
    where: tokenPairsInfoScalarWhereInput
    data: XOR<tokenPairsInfoUpdateManyMutationInput, tokenPairsInfoUncheckedUpdateManyWithoutTokenPairsInfoInput>
  }

  export type tokenPairsInfoScalarWhereInput = {
    AND?: Enumerable<tokenPairsInfoScalarWhereInput>
    OR?: Enumerable<tokenPairsInfoScalarWhereInput>
    NOT?: Enumerable<tokenPairsInfoScalarWhereInput>
    id?: IntFilter | number
    tokenPairId?: IntFilter | number
    fxRequestID?: UuidFilter | string
    quantity?: JsonFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type quotesCreateWithoutTokenPairsInfoInput = {
    id: string
    side: enum_quotes_side
    userId: string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    buyPrice?: string
    sellPrice?: string
    quantity?: string
    orders?: ordersCreateNestedManyWithoutQuotesInput
    quoteStatuses: quoteStatusesCreateNestedOneWithoutQuotesInput
    assets_quotes_sourceAssetIdToassets: assetsCreateNestedOneWithoutQuotes_quotes_sourceAssetIdToassetsInput
    assets_quotes_targetAssetIdToassets: assetsCreateNestedOneWithoutQuotes_quotes_targetAssetIdToassetsInput
    vendors?: vendorsCreateNestedOneWithoutQuotesInput
  }

  export type quotesUncheckedCreateWithoutTokenPairsInfoInput = {
    id: string
    quoteStatusId: number
    sourceAssetId: number
    targetAssetId: number
    side: enum_quotes_side
    userId: string
    vendorId?: number | null
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    buyPrice?: string
    sellPrice?: string
    quantity?: string
    orders?: ordersUncheckedCreateNestedManyWithoutQuotesInput
  }

  export type quotesCreateOrConnectWithoutTokenPairsInfoInput = {
    where: quotesWhereUniqueInput
    create: XOR<quotesCreateWithoutTokenPairsInfoInput, quotesUncheckedCreateWithoutTokenPairsInfoInput>
  }

  export type quotesCreateManyTokenPairsInfoInputEnvelope = {
    data: Enumerable<quotesCreateManyTokenPairsInfoInput>
    skipDuplicates?: boolean
  }

  export type tokenPairsCreateWithoutTokenPairsInfoInput = {
    baseToken: string
    quoteToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vendors: vendorsCreateNestedOneWithoutTokenPairsInput
  }

  export type tokenPairsUncheckedCreateWithoutTokenPairsInfoInput = {
    id?: number
    baseToken: string
    quoteToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorId: number
  }

  export type tokenPairsCreateOrConnectWithoutTokenPairsInfoInput = {
    where: tokenPairsWhereUniqueInput
    create: XOR<tokenPairsCreateWithoutTokenPairsInfoInput, tokenPairsUncheckedCreateWithoutTokenPairsInfoInput>
  }

  export type quotesUpsertWithWhereUniqueWithoutTokenPairsInfoInput = {
    where: quotesWhereUniqueInput
    update: XOR<quotesUpdateWithoutTokenPairsInfoInput, quotesUncheckedUpdateWithoutTokenPairsInfoInput>
    create: XOR<quotesCreateWithoutTokenPairsInfoInput, quotesUncheckedCreateWithoutTokenPairsInfoInput>
  }

  export type quotesUpdateWithWhereUniqueWithoutTokenPairsInfoInput = {
    where: quotesWhereUniqueInput
    data: XOR<quotesUpdateWithoutTokenPairsInfoInput, quotesUncheckedUpdateWithoutTokenPairsInfoInput>
  }

  export type quotesUpdateManyWithWhereWithoutTokenPairsInfoInput = {
    where: quotesScalarWhereInput
    data: XOR<quotesUpdateManyMutationInput, quotesUncheckedUpdateManyWithoutQuotesInput>
  }

  export type tokenPairsUpsertWithoutTokenPairsInfoInput = {
    update: XOR<tokenPairsUpdateWithoutTokenPairsInfoInput, tokenPairsUncheckedUpdateWithoutTokenPairsInfoInput>
    create: XOR<tokenPairsCreateWithoutTokenPairsInfoInput, tokenPairsUncheckedCreateWithoutTokenPairsInfoInput>
  }

  export type tokenPairsUpdateWithoutTokenPairsInfoInput = {
    baseToken?: StringFieldUpdateOperationsInput | string
    quoteToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendors?: vendorsUpdateOneRequiredWithoutTokenPairsNestedInput
  }

  export type tokenPairsUncheckedUpdateWithoutTokenPairsInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    baseToken?: StringFieldUpdateOperationsInput | string
    quoteToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorId?: IntFieldUpdateOperationsInput | number
  }

  export type assetsCreateWithoutTransactionPoliciesInput = {
    name: string
    description: string
    type: enum_assets_type
    ticker: string
    fireblocksTicker?: string | null
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    baseNetworks?: baseNetworksCreateNestedOneWithoutAssetsInput
    quotes_quotes_sourceAssetIdToassets?: quotesCreateNestedManyWithoutAssets_quotes_sourceAssetIdToassetsInput
    quotes_quotes_targetAssetIdToassets?: quotesCreateNestedManyWithoutAssets_quotes_targetAssetIdToassetsInput
    transactions?: transactionsCreateNestedManyWithoutAssetsInput
    vaultAssets?: vaultAssetsCreateNestedManyWithoutAssetsInput
    vendorSupportsAssets?: vendorSupportsAssetsCreateNestedManyWithoutAssetsInput
    withdrawalAddresses?: withdrawalAddressesCreateNestedManyWithoutAssetsInput
  }

  export type assetsUncheckedCreateWithoutTransactionPoliciesInput = {
    id?: number
    name: string
    description: string
    baseNetworkId?: number | null
    type: enum_assets_type
    ticker: string
    fireblocksTicker?: string | null
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes_quotes_sourceAssetIdToassets?: quotesUncheckedCreateNestedManyWithoutAssets_quotes_sourceAssetIdToassetsInput
    quotes_quotes_targetAssetIdToassets?: quotesUncheckedCreateNestedManyWithoutAssets_quotes_targetAssetIdToassetsInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutAssetsInput
    vaultAssets?: vaultAssetsUncheckedCreateNestedManyWithoutAssetsInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedCreateNestedManyWithoutAssetsInput
    withdrawalAddresses?: withdrawalAddressesUncheckedCreateNestedManyWithoutAssetsInput
  }

  export type assetsCreateOrConnectWithoutTransactionPoliciesInput = {
    where: assetsWhereUniqueInput
    create: XOR<assetsCreateWithoutTransactionPoliciesInput, assetsUncheckedCreateWithoutTransactionPoliciesInput>
  }

  export type vaultsCreateWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput = {
    id: string
    vaultName?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesCreateNestedManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsCreateNestedManyWithoutVaults_transactions_sourceVaultIdTovaultsInput
    transactions_transactions_targetVaultIdTovaults?: transactionsCreateNestedManyWithoutVaults_transactions_targetVaultIdTovaultsInput
    vaultAssets?: vaultAssetsCreateNestedManyWithoutVaultsInput
    users: usersCreateNestedOneWithoutVaultsInput
    vaultStatusTypes?: vaultStatusTypesCreateNestedOneWithoutVaultsInput
  }

  export type vaultsUncheckedCreateWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput = {
    id: string
    createdByUserId: string
    vaultStatusId?: number | null
    vaultName?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesUncheckedCreateNestedManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsUncheckedCreateNestedManyWithoutVaults_transactions_sourceVaultIdTovaultsInput
    transactions_transactions_targetVaultIdTovaults?: transactionsUncheckedCreateNestedManyWithoutVaults_transactions_targetVaultIdTovaultsInput
    vaultAssets?: vaultAssetsUncheckedCreateNestedManyWithoutVaultsInput
  }

  export type vaultsCreateOrConnectWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput = {
    where: vaultsWhereUniqueInput
    create: XOR<vaultsCreateWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput, vaultsUncheckedCreateWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput>
  }

  export type vaultsCreateWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput = {
    id: string
    vaultName?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesCreateNestedManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsCreateNestedManyWithoutVaults_transactions_sourceVaultIdTovaultsInput
    transactions_transactions_targetVaultIdTovaults?: transactionsCreateNestedManyWithoutVaults_transactions_targetVaultIdTovaultsInput
    vaultAssets?: vaultAssetsCreateNestedManyWithoutVaultsInput
    users: usersCreateNestedOneWithoutVaultsInput
    vaultStatusTypes?: vaultStatusTypesCreateNestedOneWithoutVaultsInput
  }

  export type vaultsUncheckedCreateWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput = {
    id: string
    createdByUserId: string
    vaultStatusId?: number | null
    vaultName?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesUncheckedCreateNestedManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsUncheckedCreateNestedManyWithoutVaults_transactions_sourceVaultIdTovaultsInput
    transactions_transactions_targetVaultIdTovaults?: transactionsUncheckedCreateNestedManyWithoutVaults_transactions_targetVaultIdTovaultsInput
    vaultAssets?: vaultAssetsUncheckedCreateNestedManyWithoutVaultsInput
  }

  export type vaultsCreateOrConnectWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput = {
    where: vaultsWhereUniqueInput
    create: XOR<vaultsCreateWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput, vaultsUncheckedCreateWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput>
  }

  export type withdrawalAddressesCreateWithoutTransactionPoliciesInput = {
    id: string
    nickname?: string | null
    address: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: transactionsCreateNestedManyWithoutWithdrawalAddressesInput
    assets: assetsCreateNestedOneWithoutWithdrawalAddressesInput
    organizations: organizationsCreateNestedOneWithoutWithdrawalAddressesInput
  }

  export type withdrawalAddressesUncheckedCreateWithoutTransactionPoliciesInput = {
    id: string
    organizationId: number
    assetId: number
    nickname?: string | null
    address: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: transactionsUncheckedCreateNestedManyWithoutWithdrawalAddressesInput
  }

  export type withdrawalAddressesCreateOrConnectWithoutTransactionPoliciesInput = {
    where: withdrawalAddressesWhereUniqueInput
    create: XOR<withdrawalAddressesCreateWithoutTransactionPoliciesInput, withdrawalAddressesUncheckedCreateWithoutTransactionPoliciesInput>
  }

  export type transactionTypesCreateWithoutTransactionPoliciesInput = {
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: transactionsCreateNestedManyWithoutTransactionTypesInput
  }

  export type transactionTypesUncheckedCreateWithoutTransactionPoliciesInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: transactionsUncheckedCreateNestedManyWithoutTransactionTypesInput
  }

  export type transactionTypesCreateOrConnectWithoutTransactionPoliciesInput = {
    where: transactionTypesWhereUniqueInput
    create: XOR<transactionTypesCreateWithoutTransactionPoliciesInput, transactionTypesUncheckedCreateWithoutTransactionPoliciesInput>
  }

  export type usersCreateWithoutTransactionPoliciesInput = {
    id: string
    primaryEmail: string
    firstName: string
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publicKey?: string | null
    apiKey?: string | null
    transactions?: transactionsCreateNestedManyWithoutUsersInput
    organizations: organizationsCreateNestedOneWithoutUsersInput
    userTypes: userTypesCreateNestedOneWithoutUsersInput
    vaults?: vaultsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutTransactionPoliciesInput = {
    id: string
    organizationId: number
    userTypeId: number
    primaryEmail: string
    firstName: string
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publicKey?: string | null
    apiKey?: string | null
    transactions?: transactionsUncheckedCreateNestedManyWithoutUsersInput
    vaults?: vaultsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutTransactionPoliciesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTransactionPoliciesInput, usersUncheckedCreateWithoutTransactionPoliciesInput>
  }

  export type assetsUpsertWithoutTransactionPoliciesInput = {
    update: XOR<assetsUpdateWithoutTransactionPoliciesInput, assetsUncheckedUpdateWithoutTransactionPoliciesInput>
    create: XOR<assetsCreateWithoutTransactionPoliciesInput, assetsUncheckedCreateWithoutTransactionPoliciesInput>
  }

  export type assetsUpdateWithoutTransactionPoliciesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: Enumenum_assets_typeFieldUpdateOperationsInput | enum_assets_type
    ticker?: StringFieldUpdateOperationsInput | string
    fireblocksTicker?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseNetworks?: baseNetworksUpdateOneWithoutAssetsNestedInput
    quotes_quotes_sourceAssetIdToassets?: quotesUpdateManyWithoutAssets_quotes_sourceAssetIdToassetsNestedInput
    quotes_quotes_targetAssetIdToassets?: quotesUpdateManyWithoutAssets_quotes_targetAssetIdToassetsNestedInput
    transactions?: transactionsUpdateManyWithoutAssetsNestedInput
    vaultAssets?: vaultAssetsUpdateManyWithoutAssetsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUpdateManyWithoutAssetsNestedInput
    withdrawalAddresses?: withdrawalAddressesUpdateManyWithoutAssetsNestedInput
  }

  export type assetsUncheckedUpdateWithoutTransactionPoliciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    baseNetworkId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: Enumenum_assets_typeFieldUpdateOperationsInput | enum_assets_type
    ticker?: StringFieldUpdateOperationsInput | string
    fireblocksTicker?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes_quotes_sourceAssetIdToassets?: quotesUncheckedUpdateManyWithoutAssets_quotes_sourceAssetIdToassetsNestedInput
    quotes_quotes_targetAssetIdToassets?: quotesUncheckedUpdateManyWithoutAssets_quotes_targetAssetIdToassetsNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutAssetsNestedInput
    vaultAssets?: vaultAssetsUncheckedUpdateManyWithoutAssetsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedUpdateManyWithoutAssetsNestedInput
    withdrawalAddresses?: withdrawalAddressesUncheckedUpdateManyWithoutAssetsNestedInput
  }

  export type vaultsUpsertWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput = {
    update: XOR<vaultsUpdateWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput, vaultsUncheckedUpdateWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput>
    create: XOR<vaultsCreateWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput, vaultsUncheckedCreateWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput>
  }

  export type vaultsUpdateWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaultName?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesUpdateManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsNestedInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsUpdateManyWithoutVaults_transactions_sourceVaultIdTovaultsNestedInput
    transactions_transactions_targetVaultIdTovaults?: transactionsUpdateManyWithoutVaults_transactions_targetVaultIdTovaultsNestedInput
    vaultAssets?: vaultAssetsUpdateManyWithoutVaultsNestedInput
    users?: usersUpdateOneRequiredWithoutVaultsNestedInput
    vaultStatusTypes?: vaultStatusTypesUpdateOneWithoutVaultsNestedInput
  }

  export type vaultsUncheckedUpdateWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    vaultStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    vaultName?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesUncheckedUpdateManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsNestedInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsUncheckedUpdateManyWithoutVaults_transactions_sourceVaultIdTovaultsNestedInput
    transactions_transactions_targetVaultIdTovaults?: transactionsUncheckedUpdateManyWithoutVaults_transactions_targetVaultIdTovaultsNestedInput
    vaultAssets?: vaultAssetsUncheckedUpdateManyWithoutVaultsNestedInput
  }

  export type vaultsUpsertWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput = {
    update: XOR<vaultsUpdateWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput, vaultsUncheckedUpdateWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput>
    create: XOR<vaultsCreateWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput, vaultsUncheckedCreateWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput>
  }

  export type vaultsUpdateWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaultName?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesUpdateManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsNestedInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsUpdateManyWithoutVaults_transactions_sourceVaultIdTovaultsNestedInput
    transactions_transactions_targetVaultIdTovaults?: transactionsUpdateManyWithoutVaults_transactions_targetVaultIdTovaultsNestedInput
    vaultAssets?: vaultAssetsUpdateManyWithoutVaultsNestedInput
    users?: usersUpdateOneRequiredWithoutVaultsNestedInput
    vaultStatusTypes?: vaultStatusTypesUpdateOneWithoutVaultsNestedInput
  }

  export type vaultsUncheckedUpdateWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    vaultStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    vaultName?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesUncheckedUpdateManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsNestedInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsUncheckedUpdateManyWithoutVaults_transactions_sourceVaultIdTovaultsNestedInput
    transactions_transactions_targetVaultIdTovaults?: transactionsUncheckedUpdateManyWithoutVaults_transactions_targetVaultIdTovaultsNestedInput
    vaultAssets?: vaultAssetsUncheckedUpdateManyWithoutVaultsNestedInput
  }

  export type withdrawalAddressesUpsertWithoutTransactionPoliciesInput = {
    update: XOR<withdrawalAddressesUpdateWithoutTransactionPoliciesInput, withdrawalAddressesUncheckedUpdateWithoutTransactionPoliciesInput>
    create: XOR<withdrawalAddressesCreateWithoutTransactionPoliciesInput, withdrawalAddressesUncheckedCreateWithoutTransactionPoliciesInput>
  }

  export type withdrawalAddressesUpdateWithoutTransactionPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: transactionsUpdateManyWithoutWithdrawalAddressesNestedInput
    assets?: assetsUpdateOneRequiredWithoutWithdrawalAddressesNestedInput
    organizations?: organizationsUpdateOneRequiredWithoutWithdrawalAddressesNestedInput
  }

  export type withdrawalAddressesUncheckedUpdateWithoutTransactionPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: transactionsUncheckedUpdateManyWithoutWithdrawalAddressesNestedInput
  }

  export type transactionTypesUpsertWithoutTransactionPoliciesInput = {
    update: XOR<transactionTypesUpdateWithoutTransactionPoliciesInput, transactionTypesUncheckedUpdateWithoutTransactionPoliciesInput>
    create: XOR<transactionTypesCreateWithoutTransactionPoliciesInput, transactionTypesUncheckedCreateWithoutTransactionPoliciesInput>
  }

  export type transactionTypesUpdateWithoutTransactionPoliciesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: transactionsUpdateManyWithoutTransactionTypesNestedInput
  }

  export type transactionTypesUncheckedUpdateWithoutTransactionPoliciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: transactionsUncheckedUpdateManyWithoutTransactionTypesNestedInput
  }

  export type usersUpsertWithoutTransactionPoliciesInput = {
    update: XOR<usersUpdateWithoutTransactionPoliciesInput, usersUncheckedUpdateWithoutTransactionPoliciesInput>
    create: XOR<usersCreateWithoutTransactionPoliciesInput, usersUncheckedCreateWithoutTransactionPoliciesInput>
  }

  export type usersUpdateWithoutTransactionPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    primaryEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicKey?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: transactionsUpdateManyWithoutUsersNestedInput
    organizations?: organizationsUpdateOneRequiredWithoutUsersNestedInput
    userTypes?: userTypesUpdateOneRequiredWithoutUsersNestedInput
    vaults?: vaultsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutTransactionPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    userTypeId?: IntFieldUpdateOperationsInput | number
    primaryEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicKey?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: transactionsUncheckedUpdateManyWithoutUsersNestedInput
    vaults?: vaultsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutUserTypesInput = {
    id: string
    primaryEmail: string
    firstName: string
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publicKey?: string | null
    apiKey?: string | null
    transactionPolicies?: transactionPoliciesCreateNestedManyWithoutUsersInput
    transactions?: transactionsCreateNestedManyWithoutUsersInput
    organizations: organizationsCreateNestedOneWithoutUsersInput
    vaults?: vaultsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUserTypesInput = {
    id: string
    organizationId: number
    primaryEmail: string
    firstName: string
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publicKey?: string | null
    apiKey?: string | null
    transactionPolicies?: transactionPoliciesUncheckedCreateNestedManyWithoutUsersInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutUsersInput
    vaults?: vaultsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUserTypesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUserTypesInput, usersUncheckedCreateWithoutUserTypesInput>
  }

  export type usersCreateManyUserTypesInputEnvelope = {
    data: Enumerable<usersCreateManyUserTypesInput>
    skipDuplicates?: boolean
  }

  export type usersUpsertWithWhereUniqueWithoutUserTypesInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutUserTypesInput, usersUncheckedUpdateWithoutUserTypesInput>
    create: XOR<usersCreateWithoutUserTypesInput, usersUncheckedCreateWithoutUserTypesInput>
  }

  export type usersUpdateWithWhereUniqueWithoutUserTypesInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutUserTypesInput, usersUncheckedUpdateWithoutUserTypesInput>
  }

  export type usersUpdateManyWithWhereWithoutUserTypesInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutUsersInput>
  }

  export type custodyVendorVaultAssetsCreateWithoutVaultAssetsInput = {
    vendorRef: string
    balance: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vendors: vendorsCreateNestedOneWithoutCustodyVendorVaultAssetsInput
  }

  export type custodyVendorVaultAssetsUncheckedCreateWithoutVaultAssetsInput = {
    id?: number
    vendorId: number
    vendorRef: string
    balance: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type custodyVendorVaultAssetsCreateOrConnectWithoutVaultAssetsInput = {
    where: custodyVendorVaultAssetsWhereUniqueInput
    create: XOR<custodyVendorVaultAssetsCreateWithoutVaultAssetsInput, custodyVendorVaultAssetsUncheckedCreateWithoutVaultAssetsInput>
  }

  export type custodyVendorVaultAssetsCreateManyVaultAssetsInputEnvelope = {
    data: Enumerable<custodyVendorVaultAssetsCreateManyVaultAssetsInput>
    skipDuplicates?: boolean
  }

  export type depositAddressesCreateWithoutVaultAssetsInput = {
    id: string
    address: string
    depositAddressStatusId?: number | null
    vendorRef: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vendors?: vendorsCreateNestedOneWithoutDepositAddressesInput
  }

  export type depositAddressesUncheckedCreateWithoutVaultAssetsInput = {
    id: string
    address: string
    depositAddressStatusId?: number | null
    vendorId?: number | null
    vendorRef: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type depositAddressesCreateOrConnectWithoutVaultAssetsInput = {
    where: depositAddressesWhereUniqueInput
    create: XOR<depositAddressesCreateWithoutVaultAssetsInput, depositAddressesUncheckedCreateWithoutVaultAssetsInput>
  }

  export type depositAddressesCreateManyVaultAssetsInputEnvelope = {
    data: Enumerable<depositAddressesCreateManyVaultAssetsInput>
    skipDuplicates?: boolean
  }

  export type assetsCreateWithoutVaultAssetsInput = {
    name: string
    description: string
    type: enum_assets_type
    ticker: string
    fireblocksTicker?: string | null
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    baseNetworks?: baseNetworksCreateNestedOneWithoutAssetsInput
    quotes_quotes_sourceAssetIdToassets?: quotesCreateNestedManyWithoutAssets_quotes_sourceAssetIdToassetsInput
    quotes_quotes_targetAssetIdToassets?: quotesCreateNestedManyWithoutAssets_quotes_targetAssetIdToassetsInput
    transactionPolicies?: transactionPoliciesCreateNestedManyWithoutAssetsInput
    transactions?: transactionsCreateNestedManyWithoutAssetsInput
    vendorSupportsAssets?: vendorSupportsAssetsCreateNestedManyWithoutAssetsInput
    withdrawalAddresses?: withdrawalAddressesCreateNestedManyWithoutAssetsInput
  }

  export type assetsUncheckedCreateWithoutVaultAssetsInput = {
    id?: number
    name: string
    description: string
    baseNetworkId?: number | null
    type: enum_assets_type
    ticker: string
    fireblocksTicker?: string | null
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes_quotes_sourceAssetIdToassets?: quotesUncheckedCreateNestedManyWithoutAssets_quotes_sourceAssetIdToassetsInput
    quotes_quotes_targetAssetIdToassets?: quotesUncheckedCreateNestedManyWithoutAssets_quotes_targetAssetIdToassetsInput
    transactionPolicies?: transactionPoliciesUncheckedCreateNestedManyWithoutAssetsInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutAssetsInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedCreateNestedManyWithoutAssetsInput
    withdrawalAddresses?: withdrawalAddressesUncheckedCreateNestedManyWithoutAssetsInput
  }

  export type assetsCreateOrConnectWithoutVaultAssetsInput = {
    where: assetsWhereUniqueInput
    create: XOR<assetsCreateWithoutVaultAssetsInput, assetsUncheckedCreateWithoutVaultAssetsInput>
  }

  export type vaultsCreateWithoutVaultAssetsInput = {
    id: string
    vaultName?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesCreateNestedManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesCreateNestedManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsCreateNestedManyWithoutVaults_transactions_sourceVaultIdTovaultsInput
    transactions_transactions_targetVaultIdTovaults?: transactionsCreateNestedManyWithoutVaults_transactions_targetVaultIdTovaultsInput
    users: usersCreateNestedOneWithoutVaultsInput
    vaultStatusTypes?: vaultStatusTypesCreateNestedOneWithoutVaultsInput
  }

  export type vaultsUncheckedCreateWithoutVaultAssetsInput = {
    id: string
    createdByUserId: string
    vaultStatusId?: number | null
    vaultName?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesUncheckedCreateNestedManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesUncheckedCreateNestedManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsUncheckedCreateNestedManyWithoutVaults_transactions_sourceVaultIdTovaultsInput
    transactions_transactions_targetVaultIdTovaults?: transactionsUncheckedCreateNestedManyWithoutVaults_transactions_targetVaultIdTovaultsInput
  }

  export type vaultsCreateOrConnectWithoutVaultAssetsInput = {
    where: vaultsWhereUniqueInput
    create: XOR<vaultsCreateWithoutVaultAssetsInput, vaultsUncheckedCreateWithoutVaultAssetsInput>
  }

  export type custodyVendorVaultAssetsUpsertWithWhereUniqueWithoutVaultAssetsInput = {
    where: custodyVendorVaultAssetsWhereUniqueInput
    update: XOR<custodyVendorVaultAssetsUpdateWithoutVaultAssetsInput, custodyVendorVaultAssetsUncheckedUpdateWithoutVaultAssetsInput>
    create: XOR<custodyVendorVaultAssetsCreateWithoutVaultAssetsInput, custodyVendorVaultAssetsUncheckedCreateWithoutVaultAssetsInput>
  }

  export type custodyVendorVaultAssetsUpdateWithWhereUniqueWithoutVaultAssetsInput = {
    where: custodyVendorVaultAssetsWhereUniqueInput
    data: XOR<custodyVendorVaultAssetsUpdateWithoutVaultAssetsInput, custodyVendorVaultAssetsUncheckedUpdateWithoutVaultAssetsInput>
  }

  export type custodyVendorVaultAssetsUpdateManyWithWhereWithoutVaultAssetsInput = {
    where: custodyVendorVaultAssetsScalarWhereInput
    data: XOR<custodyVendorVaultAssetsUpdateManyMutationInput, custodyVendorVaultAssetsUncheckedUpdateManyWithoutCustodyVendorVaultAssetsInput>
  }

  export type depositAddressesUpsertWithWhereUniqueWithoutVaultAssetsInput = {
    where: depositAddressesWhereUniqueInput
    update: XOR<depositAddressesUpdateWithoutVaultAssetsInput, depositAddressesUncheckedUpdateWithoutVaultAssetsInput>
    create: XOR<depositAddressesCreateWithoutVaultAssetsInput, depositAddressesUncheckedCreateWithoutVaultAssetsInput>
  }

  export type depositAddressesUpdateWithWhereUniqueWithoutVaultAssetsInput = {
    where: depositAddressesWhereUniqueInput
    data: XOR<depositAddressesUpdateWithoutVaultAssetsInput, depositAddressesUncheckedUpdateWithoutVaultAssetsInput>
  }

  export type depositAddressesUpdateManyWithWhereWithoutVaultAssetsInput = {
    where: depositAddressesScalarWhereInput
    data: XOR<depositAddressesUpdateManyMutationInput, depositAddressesUncheckedUpdateManyWithoutDepositAddressesInput>
  }

  export type assetsUpsertWithoutVaultAssetsInput = {
    update: XOR<assetsUpdateWithoutVaultAssetsInput, assetsUncheckedUpdateWithoutVaultAssetsInput>
    create: XOR<assetsCreateWithoutVaultAssetsInput, assetsUncheckedCreateWithoutVaultAssetsInput>
  }

  export type assetsUpdateWithoutVaultAssetsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: Enumenum_assets_typeFieldUpdateOperationsInput | enum_assets_type
    ticker?: StringFieldUpdateOperationsInput | string
    fireblocksTicker?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseNetworks?: baseNetworksUpdateOneWithoutAssetsNestedInput
    quotes_quotes_sourceAssetIdToassets?: quotesUpdateManyWithoutAssets_quotes_sourceAssetIdToassetsNestedInput
    quotes_quotes_targetAssetIdToassets?: quotesUpdateManyWithoutAssets_quotes_targetAssetIdToassetsNestedInput
    transactionPolicies?: transactionPoliciesUpdateManyWithoutAssetsNestedInput
    transactions?: transactionsUpdateManyWithoutAssetsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUpdateManyWithoutAssetsNestedInput
    withdrawalAddresses?: withdrawalAddressesUpdateManyWithoutAssetsNestedInput
  }

  export type assetsUncheckedUpdateWithoutVaultAssetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    baseNetworkId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: Enumenum_assets_typeFieldUpdateOperationsInput | enum_assets_type
    ticker?: StringFieldUpdateOperationsInput | string
    fireblocksTicker?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes_quotes_sourceAssetIdToassets?: quotesUncheckedUpdateManyWithoutAssets_quotes_sourceAssetIdToassetsNestedInput
    quotes_quotes_targetAssetIdToassets?: quotesUncheckedUpdateManyWithoutAssets_quotes_targetAssetIdToassetsNestedInput
    transactionPolicies?: transactionPoliciesUncheckedUpdateManyWithoutAssetsNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutAssetsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedUpdateManyWithoutAssetsNestedInput
    withdrawalAddresses?: withdrawalAddressesUncheckedUpdateManyWithoutAssetsNestedInput
  }

  export type vaultsUpsertWithoutVaultAssetsInput = {
    update: XOR<vaultsUpdateWithoutVaultAssetsInput, vaultsUncheckedUpdateWithoutVaultAssetsInput>
    create: XOR<vaultsCreateWithoutVaultAssetsInput, vaultsUncheckedCreateWithoutVaultAssetsInput>
  }

  export type vaultsUpdateWithoutVaultAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaultName?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesUpdateManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsNestedInput
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesUpdateManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsNestedInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsUpdateManyWithoutVaults_transactions_sourceVaultIdTovaultsNestedInput
    transactions_transactions_targetVaultIdTovaults?: transactionsUpdateManyWithoutVaults_transactions_targetVaultIdTovaultsNestedInput
    users?: usersUpdateOneRequiredWithoutVaultsNestedInput
    vaultStatusTypes?: vaultStatusTypesUpdateOneWithoutVaultsNestedInput
  }

  export type vaultsUncheckedUpdateWithoutVaultAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    vaultStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    vaultName?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesUncheckedUpdateManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsNestedInput
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesUncheckedUpdateManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsNestedInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsUncheckedUpdateManyWithoutVaults_transactions_sourceVaultIdTovaultsNestedInput
    transactions_transactions_targetVaultIdTovaults?: transactionsUncheckedUpdateManyWithoutVaults_transactions_targetVaultIdTovaultsNestedInput
  }

  export type vaultsCreateWithoutVaultStatusTypesInput = {
    id: string
    vaultName?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesCreateNestedManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesCreateNestedManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsCreateNestedManyWithoutVaults_transactions_sourceVaultIdTovaultsInput
    transactions_transactions_targetVaultIdTovaults?: transactionsCreateNestedManyWithoutVaults_transactions_targetVaultIdTovaultsInput
    vaultAssets?: vaultAssetsCreateNestedManyWithoutVaultsInput
    users: usersCreateNestedOneWithoutVaultsInput
  }

  export type vaultsUncheckedCreateWithoutVaultStatusTypesInput = {
    id: string
    createdByUserId: string
    vaultName?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesUncheckedCreateNestedManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesUncheckedCreateNestedManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsUncheckedCreateNestedManyWithoutVaults_transactions_sourceVaultIdTovaultsInput
    transactions_transactions_targetVaultIdTovaults?: transactionsUncheckedCreateNestedManyWithoutVaults_transactions_targetVaultIdTovaultsInput
    vaultAssets?: vaultAssetsUncheckedCreateNestedManyWithoutVaultsInput
  }

  export type vaultsCreateOrConnectWithoutVaultStatusTypesInput = {
    where: vaultsWhereUniqueInput
    create: XOR<vaultsCreateWithoutVaultStatusTypesInput, vaultsUncheckedCreateWithoutVaultStatusTypesInput>
  }

  export type vaultsCreateManyVaultStatusTypesInputEnvelope = {
    data: Enumerable<vaultsCreateManyVaultStatusTypesInput>
    skipDuplicates?: boolean
  }

  export type vaultsUpsertWithWhereUniqueWithoutVaultStatusTypesInput = {
    where: vaultsWhereUniqueInput
    update: XOR<vaultsUpdateWithoutVaultStatusTypesInput, vaultsUncheckedUpdateWithoutVaultStatusTypesInput>
    create: XOR<vaultsCreateWithoutVaultStatusTypesInput, vaultsUncheckedCreateWithoutVaultStatusTypesInput>
  }

  export type vaultsUpdateWithWhereUniqueWithoutVaultStatusTypesInput = {
    where: vaultsWhereUniqueInput
    data: XOR<vaultsUpdateWithoutVaultStatusTypesInput, vaultsUncheckedUpdateWithoutVaultStatusTypesInput>
  }

  export type vaultsUpdateManyWithWhereWithoutVaultStatusTypesInput = {
    where: vaultsScalarWhereInput
    data: XOR<vaultsUpdateManyMutationInput, vaultsUncheckedUpdateManyWithoutVaultsInput>
  }

  export type transactionPoliciesCreateWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput = {
    id: string
    toOneTimeAddresses?: boolean | null
    greaterThanUSD: string
    action: enum_transactionPolicies_action
    createdAt?: Date | string
    updatedAt?: Date | string
    assets: assetsCreateNestedOneWithoutTransactionPoliciesInput
    vaults_transactionPolicies_targetVaultIdTovaults?: vaultsCreateNestedOneWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput
    withdrawalAddresses?: withdrawalAddressesCreateNestedOneWithoutTransactionPoliciesInput
    transactionTypes: transactionTypesCreateNestedOneWithoutTransactionPoliciesInput
    users: usersCreateNestedOneWithoutTransactionPoliciesInput
  }

  export type transactionPoliciesUncheckedCreateWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput = {
    id: string
    userId: string
    transactionTypeId: number
    targetVaultId?: string | null
    targetWithdrawalAddressId?: string | null
    toOneTimeAddresses?: boolean | null
    greaterThanUSD: string
    assetId: number
    action: enum_transactionPolicies_action
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionPoliciesCreateOrConnectWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput = {
    where: transactionPoliciesWhereUniqueInput
    create: XOR<transactionPoliciesCreateWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput, transactionPoliciesUncheckedCreateWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput>
  }

  export type transactionPoliciesCreateManyVaults_transactionPolicies_sourceVaultIdTovaultsInputEnvelope = {
    data: Enumerable<transactionPoliciesCreateManyVaults_transactionPolicies_sourceVaultIdTovaultsInput>
    skipDuplicates?: boolean
  }

  export type transactionPoliciesCreateWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput = {
    id: string
    toOneTimeAddresses?: boolean | null
    greaterThanUSD: string
    action: enum_transactionPolicies_action
    createdAt?: Date | string
    updatedAt?: Date | string
    assets: assetsCreateNestedOneWithoutTransactionPoliciesInput
    vaults_transactionPolicies_sourceVaultIdTovaults: vaultsCreateNestedOneWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput
    withdrawalAddresses?: withdrawalAddressesCreateNestedOneWithoutTransactionPoliciesInput
    transactionTypes: transactionTypesCreateNestedOneWithoutTransactionPoliciesInput
    users: usersCreateNestedOneWithoutTransactionPoliciesInput
  }

  export type transactionPoliciesUncheckedCreateWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput = {
    id: string
    userId: string
    transactionTypeId: number
    sourceVaultId: string
    targetWithdrawalAddressId?: string | null
    toOneTimeAddresses?: boolean | null
    greaterThanUSD: string
    assetId: number
    action: enum_transactionPolicies_action
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionPoliciesCreateOrConnectWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput = {
    where: transactionPoliciesWhereUniqueInput
    create: XOR<transactionPoliciesCreateWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput, transactionPoliciesUncheckedCreateWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput>
  }

  export type transactionPoliciesCreateManyVaults_transactionPolicies_targetVaultIdTovaultsInputEnvelope = {
    data: Enumerable<transactionPoliciesCreateManyVaults_transactionPolicies_targetVaultIdTovaultsInput>
    skipDuplicates?: boolean
  }

  export type transactionsCreateWithoutVaults_transactions_sourceVaultIdTovaultsInput = {
    id: string
    custodyVendorRef: string
    amountAsset: string
    amountUSD: string
    onChainTxId?: string | null
    sourceExternalAddress?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assets: assetsCreateNestedOneWithoutTransactionsInput
    users?: usersCreateNestedOneWithoutTransactionsInput
    vendors: vendorsCreateNestedOneWithoutTransactionsInput
    vaults_transactions_targetVaultIdTovaults?: vaultsCreateNestedOneWithoutTransactions_transactions_targetVaultIdTovaultsInput
    withdrawalAddresses?: withdrawalAddressesCreateNestedOneWithoutTransactionsInput
    transactionStatusTypes: transactionStatusTypesCreateNestedOneWithoutTransactionsInput
    transactionTypes: transactionTypesCreateNestedOneWithoutTransactionsInput
  }

  export type transactionsUncheckedCreateWithoutVaults_transactions_sourceVaultIdTovaultsInput = {
    id: string
    custodyVendorId: number
    custodyVendorRef: string
    transactionTypeId: number
    amountAsset: string
    amountUSD: string
    assetId: number
    transactionStatusTypeId: number
    onChainTxId?: string | null
    targetVaultId?: string | null
    targetWithdrawalAddressId?: string | null
    sourceExternalAddress?: string | null
    createdByUserId?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionsCreateOrConnectWithoutVaults_transactions_sourceVaultIdTovaultsInput = {
    where: transactionsWhereUniqueInput
    create: XOR<transactionsCreateWithoutVaults_transactions_sourceVaultIdTovaultsInput, transactionsUncheckedCreateWithoutVaults_transactions_sourceVaultIdTovaultsInput>
  }

  export type transactionsCreateManyVaults_transactions_sourceVaultIdTovaultsInputEnvelope = {
    data: Enumerable<transactionsCreateManyVaults_transactions_sourceVaultIdTovaultsInput>
    skipDuplicates?: boolean
  }

  export type transactionsCreateWithoutVaults_transactions_targetVaultIdTovaultsInput = {
    id: string
    custodyVendorRef: string
    amountAsset: string
    amountUSD: string
    onChainTxId?: string | null
    sourceExternalAddress?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assets: assetsCreateNestedOneWithoutTransactionsInput
    users?: usersCreateNestedOneWithoutTransactionsInput
    vendors: vendorsCreateNestedOneWithoutTransactionsInput
    vaults_transactions_sourceVaultIdTovaults?: vaultsCreateNestedOneWithoutTransactions_transactions_sourceVaultIdTovaultsInput
    withdrawalAddresses?: withdrawalAddressesCreateNestedOneWithoutTransactionsInput
    transactionStatusTypes: transactionStatusTypesCreateNestedOneWithoutTransactionsInput
    transactionTypes: transactionTypesCreateNestedOneWithoutTransactionsInput
  }

  export type transactionsUncheckedCreateWithoutVaults_transactions_targetVaultIdTovaultsInput = {
    id: string
    custodyVendorId: number
    custodyVendorRef: string
    transactionTypeId: number
    amountAsset: string
    amountUSD: string
    assetId: number
    transactionStatusTypeId: number
    onChainTxId?: string | null
    sourceVaultId?: string | null
    targetWithdrawalAddressId?: string | null
    sourceExternalAddress?: string | null
    createdByUserId?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionsCreateOrConnectWithoutVaults_transactions_targetVaultIdTovaultsInput = {
    where: transactionsWhereUniqueInput
    create: XOR<transactionsCreateWithoutVaults_transactions_targetVaultIdTovaultsInput, transactionsUncheckedCreateWithoutVaults_transactions_targetVaultIdTovaultsInput>
  }

  export type transactionsCreateManyVaults_transactions_targetVaultIdTovaultsInputEnvelope = {
    data: Enumerable<transactionsCreateManyVaults_transactions_targetVaultIdTovaultsInput>
    skipDuplicates?: boolean
  }

  export type vaultAssetsCreateWithoutVaultsInput = {
    balance: string
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsCreateNestedManyWithoutVaultAssetsInput
    depositAddresses?: depositAddressesCreateNestedManyWithoutVaultAssetsInput
    assets: assetsCreateNestedOneWithoutVaultAssetsInput
  }

  export type vaultAssetsUncheckedCreateWithoutVaultsInput = {
    id?: number
    assetId: number
    balance: string
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUncheckedCreateNestedManyWithoutVaultAssetsInput
    depositAddresses?: depositAddressesUncheckedCreateNestedManyWithoutVaultAssetsInput
  }

  export type vaultAssetsCreateOrConnectWithoutVaultsInput = {
    where: vaultAssetsWhereUniqueInput
    create: XOR<vaultAssetsCreateWithoutVaultsInput, vaultAssetsUncheckedCreateWithoutVaultsInput>
  }

  export type vaultAssetsCreateManyVaultsInputEnvelope = {
    data: Enumerable<vaultAssetsCreateManyVaultsInput>
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutVaultsInput = {
    id: string
    primaryEmail: string
    firstName: string
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publicKey?: string | null
    apiKey?: string | null
    transactionPolicies?: transactionPoliciesCreateNestedManyWithoutUsersInput
    transactions?: transactionsCreateNestedManyWithoutUsersInput
    organizations: organizationsCreateNestedOneWithoutUsersInput
    userTypes: userTypesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutVaultsInput = {
    id: string
    organizationId: number
    userTypeId: number
    primaryEmail: string
    firstName: string
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publicKey?: string | null
    apiKey?: string | null
    transactionPolicies?: transactionPoliciesUncheckedCreateNestedManyWithoutUsersInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutVaultsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutVaultsInput, usersUncheckedCreateWithoutVaultsInput>
  }

  export type vaultStatusTypesCreateWithoutVaultsInput = {
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vaultStatusTypesUncheckedCreateWithoutVaultsInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vaultStatusTypesCreateOrConnectWithoutVaultsInput = {
    where: vaultStatusTypesWhereUniqueInput
    create: XOR<vaultStatusTypesCreateWithoutVaultsInput, vaultStatusTypesUncheckedCreateWithoutVaultsInput>
  }

  export type transactionPoliciesUpsertWithWhereUniqueWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput = {
    where: transactionPoliciesWhereUniqueInput
    update: XOR<transactionPoliciesUpdateWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput, transactionPoliciesUncheckedUpdateWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput>
    create: XOR<transactionPoliciesCreateWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput, transactionPoliciesUncheckedCreateWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput>
  }

  export type transactionPoliciesUpdateWithWhereUniqueWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput = {
    where: transactionPoliciesWhereUniqueInput
    data: XOR<transactionPoliciesUpdateWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput, transactionPoliciesUncheckedUpdateWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput>
  }

  export type transactionPoliciesUpdateManyWithWhereWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput = {
    where: transactionPoliciesScalarWhereInput
    data: XOR<transactionPoliciesUpdateManyMutationInput, transactionPoliciesUncheckedUpdateManyWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput>
  }

  export type transactionPoliciesUpsertWithWhereUniqueWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput = {
    where: transactionPoliciesWhereUniqueInput
    update: XOR<transactionPoliciesUpdateWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput, transactionPoliciesUncheckedUpdateWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput>
    create: XOR<transactionPoliciesCreateWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput, transactionPoliciesUncheckedCreateWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput>
  }

  export type transactionPoliciesUpdateWithWhereUniqueWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput = {
    where: transactionPoliciesWhereUniqueInput
    data: XOR<transactionPoliciesUpdateWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput, transactionPoliciesUncheckedUpdateWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput>
  }

  export type transactionPoliciesUpdateManyWithWhereWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput = {
    where: transactionPoliciesScalarWhereInput
    data: XOR<transactionPoliciesUpdateManyMutationInput, transactionPoliciesUncheckedUpdateManyWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput>
  }

  export type transactionsUpsertWithWhereUniqueWithoutVaults_transactions_sourceVaultIdTovaultsInput = {
    where: transactionsWhereUniqueInput
    update: XOR<transactionsUpdateWithoutVaults_transactions_sourceVaultIdTovaultsInput, transactionsUncheckedUpdateWithoutVaults_transactions_sourceVaultIdTovaultsInput>
    create: XOR<transactionsCreateWithoutVaults_transactions_sourceVaultIdTovaultsInput, transactionsUncheckedCreateWithoutVaults_transactions_sourceVaultIdTovaultsInput>
  }

  export type transactionsUpdateWithWhereUniqueWithoutVaults_transactions_sourceVaultIdTovaultsInput = {
    where: transactionsWhereUniqueInput
    data: XOR<transactionsUpdateWithoutVaults_transactions_sourceVaultIdTovaultsInput, transactionsUncheckedUpdateWithoutVaults_transactions_sourceVaultIdTovaultsInput>
  }

  export type transactionsUpdateManyWithWhereWithoutVaults_transactions_sourceVaultIdTovaultsInput = {
    where: transactionsScalarWhereInput
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyWithoutTransactions_transactions_sourceVaultIdTovaultsInput>
  }

  export type transactionsUpsertWithWhereUniqueWithoutVaults_transactions_targetVaultIdTovaultsInput = {
    where: transactionsWhereUniqueInput
    update: XOR<transactionsUpdateWithoutVaults_transactions_targetVaultIdTovaultsInput, transactionsUncheckedUpdateWithoutVaults_transactions_targetVaultIdTovaultsInput>
    create: XOR<transactionsCreateWithoutVaults_transactions_targetVaultIdTovaultsInput, transactionsUncheckedCreateWithoutVaults_transactions_targetVaultIdTovaultsInput>
  }

  export type transactionsUpdateWithWhereUniqueWithoutVaults_transactions_targetVaultIdTovaultsInput = {
    where: transactionsWhereUniqueInput
    data: XOR<transactionsUpdateWithoutVaults_transactions_targetVaultIdTovaultsInput, transactionsUncheckedUpdateWithoutVaults_transactions_targetVaultIdTovaultsInput>
  }

  export type transactionsUpdateManyWithWhereWithoutVaults_transactions_targetVaultIdTovaultsInput = {
    where: transactionsScalarWhereInput
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyWithoutTransactions_transactions_targetVaultIdTovaultsInput>
  }

  export type vaultAssetsUpsertWithWhereUniqueWithoutVaultsInput = {
    where: vaultAssetsWhereUniqueInput
    update: XOR<vaultAssetsUpdateWithoutVaultsInput, vaultAssetsUncheckedUpdateWithoutVaultsInput>
    create: XOR<vaultAssetsCreateWithoutVaultsInput, vaultAssetsUncheckedCreateWithoutVaultsInput>
  }

  export type vaultAssetsUpdateWithWhereUniqueWithoutVaultsInput = {
    where: vaultAssetsWhereUniqueInput
    data: XOR<vaultAssetsUpdateWithoutVaultsInput, vaultAssetsUncheckedUpdateWithoutVaultsInput>
  }

  export type vaultAssetsUpdateManyWithWhereWithoutVaultsInput = {
    where: vaultAssetsScalarWhereInput
    data: XOR<vaultAssetsUpdateManyMutationInput, vaultAssetsUncheckedUpdateManyWithoutVaultAssetsInput>
  }

  export type usersUpsertWithoutVaultsInput = {
    update: XOR<usersUpdateWithoutVaultsInput, usersUncheckedUpdateWithoutVaultsInput>
    create: XOR<usersCreateWithoutVaultsInput, usersUncheckedCreateWithoutVaultsInput>
  }

  export type usersUpdateWithoutVaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    primaryEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicKey?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    transactionPolicies?: transactionPoliciesUpdateManyWithoutUsersNestedInput
    transactions?: transactionsUpdateManyWithoutUsersNestedInput
    organizations?: organizationsUpdateOneRequiredWithoutUsersNestedInput
    userTypes?: userTypesUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutVaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    userTypeId?: IntFieldUpdateOperationsInput | number
    primaryEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicKey?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    transactionPolicies?: transactionPoliciesUncheckedUpdateManyWithoutUsersNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type vaultStatusTypesUpsertWithoutVaultsInput = {
    update: XOR<vaultStatusTypesUpdateWithoutVaultsInput, vaultStatusTypesUncheckedUpdateWithoutVaultsInput>
    create: XOR<vaultStatusTypesCreateWithoutVaultsInput, vaultStatusTypesUncheckedCreateWithoutVaultsInput>
  }

  export type vaultStatusTypesUpdateWithoutVaultsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vaultStatusTypesUncheckedUpdateWithoutVaultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pricingPlanSupportsAssetsCreateWithoutVendorSupportsAssetsInput = {
    enabled?: boolean
    buyBps: number
    sellBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pricingPlans: pricingPlansCreateNestedOneWithoutPricingPlanSupportsAssetsInput
  }

  export type pricingPlanSupportsAssetsUncheckedCreateWithoutVendorSupportsAssetsInput = {
    id?: number
    pricingPlanId: number
    enabled?: boolean
    buyBps: number
    sellBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pricingPlanSupportsAssetsCreateOrConnectWithoutVendorSupportsAssetsInput = {
    where: pricingPlanSupportsAssetsWhereUniqueInput
    create: XOR<pricingPlanSupportsAssetsCreateWithoutVendorSupportsAssetsInput, pricingPlanSupportsAssetsUncheckedCreateWithoutVendorSupportsAssetsInput>
  }

  export type pricingPlanSupportsAssetsCreateManyVendorSupportsAssetsInputEnvelope = {
    data: Enumerable<pricingPlanSupportsAssetsCreateManyVendorSupportsAssetsInput>
    skipDuplicates?: boolean
  }

  export type assetsCreateWithoutVendorSupportsAssetsInput = {
    name: string
    description: string
    type: enum_assets_type
    ticker: string
    fireblocksTicker?: string | null
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    baseNetworks?: baseNetworksCreateNestedOneWithoutAssetsInput
    quotes_quotes_sourceAssetIdToassets?: quotesCreateNestedManyWithoutAssets_quotes_sourceAssetIdToassetsInput
    quotes_quotes_targetAssetIdToassets?: quotesCreateNestedManyWithoutAssets_quotes_targetAssetIdToassetsInput
    transactionPolicies?: transactionPoliciesCreateNestedManyWithoutAssetsInput
    transactions?: transactionsCreateNestedManyWithoutAssetsInput
    vaultAssets?: vaultAssetsCreateNestedManyWithoutAssetsInput
    withdrawalAddresses?: withdrawalAddressesCreateNestedManyWithoutAssetsInput
  }

  export type assetsUncheckedCreateWithoutVendorSupportsAssetsInput = {
    id?: number
    name: string
    description: string
    baseNetworkId?: number | null
    type: enum_assets_type
    ticker: string
    fireblocksTicker?: string | null
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes_quotes_sourceAssetIdToassets?: quotesUncheckedCreateNestedManyWithoutAssets_quotes_sourceAssetIdToassetsInput
    quotes_quotes_targetAssetIdToassets?: quotesUncheckedCreateNestedManyWithoutAssets_quotes_targetAssetIdToassetsInput
    transactionPolicies?: transactionPoliciesUncheckedCreateNestedManyWithoutAssetsInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutAssetsInput
    vaultAssets?: vaultAssetsUncheckedCreateNestedManyWithoutAssetsInput
    withdrawalAddresses?: withdrawalAddressesUncheckedCreateNestedManyWithoutAssetsInput
  }

  export type assetsCreateOrConnectWithoutVendorSupportsAssetsInput = {
    where: assetsWhereUniqueInput
    create: XOR<assetsCreateWithoutVendorSupportsAssetsInput, assetsUncheckedCreateWithoutVendorSupportsAssetsInput>
  }

  export type vendorsCreateWithoutVendorSupportsAssetsInput = {
    name: string
    identifier: string
    quoteEngineBaseBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsCreateNestedManyWithoutVendorsInput
    depositAddresses?: depositAddressesCreateNestedManyWithoutVendorsInput
    quotes?: quotesCreateNestedManyWithoutVendorsInput
    tokenPairs?: tokenPairsCreateNestedManyWithoutVendorsInput
    transactions?: transactionsCreateNestedManyWithoutVendorsInput
    vendorTypes: vendorTypesCreateNestedOneWithoutVendorsInput
  }

  export type vendorsUncheckedCreateWithoutVendorSupportsAssetsInput = {
    id?: number
    name: string
    identifier: string
    vendorTypeId: number
    quoteEngineBaseBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUncheckedCreateNestedManyWithoutVendorsInput
    depositAddresses?: depositAddressesUncheckedCreateNestedManyWithoutVendorsInput
    quotes?: quotesUncheckedCreateNestedManyWithoutVendorsInput
    tokenPairs?: tokenPairsUncheckedCreateNestedManyWithoutVendorsInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutVendorsInput
  }

  export type vendorsCreateOrConnectWithoutVendorSupportsAssetsInput = {
    where: vendorsWhereUniqueInput
    create: XOR<vendorsCreateWithoutVendorSupportsAssetsInput, vendorsUncheckedCreateWithoutVendorSupportsAssetsInput>
  }

  export type pricingPlanSupportsAssetsUpsertWithWhereUniqueWithoutVendorSupportsAssetsInput = {
    where: pricingPlanSupportsAssetsWhereUniqueInput
    update: XOR<pricingPlanSupportsAssetsUpdateWithoutVendorSupportsAssetsInput, pricingPlanSupportsAssetsUncheckedUpdateWithoutVendorSupportsAssetsInput>
    create: XOR<pricingPlanSupportsAssetsCreateWithoutVendorSupportsAssetsInput, pricingPlanSupportsAssetsUncheckedCreateWithoutVendorSupportsAssetsInput>
  }

  export type pricingPlanSupportsAssetsUpdateWithWhereUniqueWithoutVendorSupportsAssetsInput = {
    where: pricingPlanSupportsAssetsWhereUniqueInput
    data: XOR<pricingPlanSupportsAssetsUpdateWithoutVendorSupportsAssetsInput, pricingPlanSupportsAssetsUncheckedUpdateWithoutVendorSupportsAssetsInput>
  }

  export type pricingPlanSupportsAssetsUpdateManyWithWhereWithoutVendorSupportsAssetsInput = {
    where: pricingPlanSupportsAssetsScalarWhereInput
    data: XOR<pricingPlanSupportsAssetsUpdateManyMutationInput, pricingPlanSupportsAssetsUncheckedUpdateManyWithoutPricingPlanSupportsAssetsInput>
  }

  export type assetsUpsertWithoutVendorSupportsAssetsInput = {
    update: XOR<assetsUpdateWithoutVendorSupportsAssetsInput, assetsUncheckedUpdateWithoutVendorSupportsAssetsInput>
    create: XOR<assetsCreateWithoutVendorSupportsAssetsInput, assetsUncheckedCreateWithoutVendorSupportsAssetsInput>
  }

  export type assetsUpdateWithoutVendorSupportsAssetsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: Enumenum_assets_typeFieldUpdateOperationsInput | enum_assets_type
    ticker?: StringFieldUpdateOperationsInput | string
    fireblocksTicker?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseNetworks?: baseNetworksUpdateOneWithoutAssetsNestedInput
    quotes_quotes_sourceAssetIdToassets?: quotesUpdateManyWithoutAssets_quotes_sourceAssetIdToassetsNestedInput
    quotes_quotes_targetAssetIdToassets?: quotesUpdateManyWithoutAssets_quotes_targetAssetIdToassetsNestedInput
    transactionPolicies?: transactionPoliciesUpdateManyWithoutAssetsNestedInput
    transactions?: transactionsUpdateManyWithoutAssetsNestedInput
    vaultAssets?: vaultAssetsUpdateManyWithoutAssetsNestedInput
    withdrawalAddresses?: withdrawalAddressesUpdateManyWithoutAssetsNestedInput
  }

  export type assetsUncheckedUpdateWithoutVendorSupportsAssetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    baseNetworkId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: Enumenum_assets_typeFieldUpdateOperationsInput | enum_assets_type
    ticker?: StringFieldUpdateOperationsInput | string
    fireblocksTicker?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes_quotes_sourceAssetIdToassets?: quotesUncheckedUpdateManyWithoutAssets_quotes_sourceAssetIdToassetsNestedInput
    quotes_quotes_targetAssetIdToassets?: quotesUncheckedUpdateManyWithoutAssets_quotes_targetAssetIdToassetsNestedInput
    transactionPolicies?: transactionPoliciesUncheckedUpdateManyWithoutAssetsNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutAssetsNestedInput
    vaultAssets?: vaultAssetsUncheckedUpdateManyWithoutAssetsNestedInput
    withdrawalAddresses?: withdrawalAddressesUncheckedUpdateManyWithoutAssetsNestedInput
  }

  export type vendorsUpsertWithoutVendorSupportsAssetsInput = {
    update: XOR<vendorsUpdateWithoutVendorSupportsAssetsInput, vendorsUncheckedUpdateWithoutVendorSupportsAssetsInput>
    create: XOR<vendorsCreateWithoutVendorSupportsAssetsInput, vendorsUncheckedCreateWithoutVendorSupportsAssetsInput>
  }

  export type vendorsUpdateWithoutVendorSupportsAssetsInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    quoteEngineBaseBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUpdateManyWithoutVendorsNestedInput
    depositAddresses?: depositAddressesUpdateManyWithoutVendorsNestedInput
    quotes?: quotesUpdateManyWithoutVendorsNestedInput
    tokenPairs?: tokenPairsUpdateManyWithoutVendorsNestedInput
    transactions?: transactionsUpdateManyWithoutVendorsNestedInput
    vendorTypes?: vendorTypesUpdateOneRequiredWithoutVendorsNestedInput
  }

  export type vendorsUncheckedUpdateWithoutVendorSupportsAssetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    vendorTypeId?: IntFieldUpdateOperationsInput | number
    quoteEngineBaseBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUncheckedUpdateManyWithoutVendorsNestedInput
    depositAddresses?: depositAddressesUncheckedUpdateManyWithoutVendorsNestedInput
    quotes?: quotesUncheckedUpdateManyWithoutVendorsNestedInput
    tokenPairs?: tokenPairsUncheckedUpdateManyWithoutVendorsNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutVendorsNestedInput
  }

  export type custodyEngineEventsCreateWithoutWebhookRequestsInput = {
    id: string
    event: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyEngineEventTypes: custodyEngineEventTypesCreateNestedOneWithoutCustodyEngineEventsInput
    organizations: organizationsCreateNestedOneWithoutCustodyEngineEventsInput
  }

  export type custodyEngineEventsUncheckedCreateWithoutWebhookRequestsInput = {
    id: string
    organizationId: number
    custodyEngineEventTypeId: number
    event: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type custodyEngineEventsCreateOrConnectWithoutWebhookRequestsInput = {
    where: custodyEngineEventsWhereUniqueInput
    create: XOR<custodyEngineEventsCreateWithoutWebhookRequestsInput, custodyEngineEventsUncheckedCreateWithoutWebhookRequestsInput>
  }

  export type institutionalProductsCreateWithoutWebhookRequestsInput = {
    id: string
    name: string
    enabled: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type institutionalProductsUncheckedCreateWithoutWebhookRequestsInput = {
    id: string
    name: string
    enabled: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type institutionalProductsCreateOrConnectWithoutWebhookRequestsInput = {
    where: institutionalProductsWhereUniqueInput
    create: XOR<institutionalProductsCreateWithoutWebhookRequestsInput, institutionalProductsUncheckedCreateWithoutWebhookRequestsInput>
  }

  export type webhooksCreateWithoutWebhookRequestsInput = {
    id: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    organizations: organizationsCreateNestedOneWithoutWebhooksInput
    webhookStatusTypes: webhookStatusTypesCreateNestedOneWithoutWebhooksInput
  }

  export type webhooksUncheckedCreateWithoutWebhookRequestsInput = {
    id: string
    organizationId: number
    webhookStatusTypeId: number
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type webhooksCreateOrConnectWithoutWebhookRequestsInput = {
    where: webhooksWhereUniqueInput
    create: XOR<webhooksCreateWithoutWebhookRequestsInput, webhooksUncheckedCreateWithoutWebhookRequestsInput>
  }

  export type custodyEngineEventsUpsertWithoutWebhookRequestsInput = {
    update: XOR<custodyEngineEventsUpdateWithoutWebhookRequestsInput, custodyEngineEventsUncheckedUpdateWithoutWebhookRequestsInput>
    create: XOR<custodyEngineEventsCreateWithoutWebhookRequestsInput, custodyEngineEventsUncheckedCreateWithoutWebhookRequestsInput>
  }

  export type custodyEngineEventsUpdateWithoutWebhookRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyEngineEventTypes?: custodyEngineEventTypesUpdateOneRequiredWithoutCustodyEngineEventsNestedInput
    organizations?: organizationsUpdateOneRequiredWithoutCustodyEngineEventsNestedInput
  }

  export type custodyEngineEventsUncheckedUpdateWithoutWebhookRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    custodyEngineEventTypeId?: IntFieldUpdateOperationsInput | number
    event?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type institutionalProductsUpsertWithoutWebhookRequestsInput = {
    update: XOR<institutionalProductsUpdateWithoutWebhookRequestsInput, institutionalProductsUncheckedUpdateWithoutWebhookRequestsInput>
    create: XOR<institutionalProductsCreateWithoutWebhookRequestsInput, institutionalProductsUncheckedCreateWithoutWebhookRequestsInput>
  }

  export type institutionalProductsUpdateWithoutWebhookRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type institutionalProductsUncheckedUpdateWithoutWebhookRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type webhooksUpsertWithoutWebhookRequestsInput = {
    update: XOR<webhooksUpdateWithoutWebhookRequestsInput, webhooksUncheckedUpdateWithoutWebhookRequestsInput>
    create: XOR<webhooksCreateWithoutWebhookRequestsInput, webhooksUncheckedCreateWithoutWebhookRequestsInput>
  }

  export type webhooksUpdateWithoutWebhookRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizations?: organizationsUpdateOneRequiredWithoutWebhooksNestedInput
    webhookStatusTypes?: webhookStatusTypesUpdateOneRequiredWithoutWebhooksNestedInput
  }

  export type webhooksUncheckedUpdateWithoutWebhookRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    webhookStatusTypeId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type webhooksCreateWithoutWebhookStatusTypesInput = {
    id: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    webhookRequests?: webhookRequestsCreateNestedManyWithoutWebhooksInput
    organizations: organizationsCreateNestedOneWithoutWebhooksInput
  }

  export type webhooksUncheckedCreateWithoutWebhookStatusTypesInput = {
    id: string
    organizationId: number
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    webhookRequests?: webhookRequestsUncheckedCreateNestedManyWithoutWebhooksInput
  }

  export type webhooksCreateOrConnectWithoutWebhookStatusTypesInput = {
    where: webhooksWhereUniqueInput
    create: XOR<webhooksCreateWithoutWebhookStatusTypesInput, webhooksUncheckedCreateWithoutWebhookStatusTypesInput>
  }

  export type webhooksCreateManyWebhookStatusTypesInputEnvelope = {
    data: Enumerable<webhooksCreateManyWebhookStatusTypesInput>
    skipDuplicates?: boolean
  }

  export type webhooksUpsertWithWhereUniqueWithoutWebhookStatusTypesInput = {
    where: webhooksWhereUniqueInput
    update: XOR<webhooksUpdateWithoutWebhookStatusTypesInput, webhooksUncheckedUpdateWithoutWebhookStatusTypesInput>
    create: XOR<webhooksCreateWithoutWebhookStatusTypesInput, webhooksUncheckedCreateWithoutWebhookStatusTypesInput>
  }

  export type webhooksUpdateWithWhereUniqueWithoutWebhookStatusTypesInput = {
    where: webhooksWhereUniqueInput
    data: XOR<webhooksUpdateWithoutWebhookStatusTypesInput, webhooksUncheckedUpdateWithoutWebhookStatusTypesInput>
  }

  export type webhooksUpdateManyWithWhereWithoutWebhookStatusTypesInput = {
    where: webhooksScalarWhereInput
    data: XOR<webhooksUpdateManyMutationInput, webhooksUncheckedUpdateManyWithoutWebhooksInput>
  }

  export type webhookRequestsCreateWithoutWebhooksInput = {
    id: string
    httpStatusCode: number
    requestPayload: JsonNullValueInput | InputJsonValue
    responsePayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyEngineEvents?: custodyEngineEventsCreateNestedOneWithoutWebhookRequestsInput
    institutionalProducts?: institutionalProductsCreateNestedOneWithoutWebhookRequestsInput
  }

  export type webhookRequestsUncheckedCreateWithoutWebhooksInput = {
    id: string
    institutionalProductId?: string | null
    httpStatusCode: number
    requestPayload: JsonNullValueInput | InputJsonValue
    responsePayload?: NullableJsonNullValueInput | InputJsonValue
    custodyEngineEventId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type webhookRequestsCreateOrConnectWithoutWebhooksInput = {
    where: webhookRequestsWhereUniqueInput
    create: XOR<webhookRequestsCreateWithoutWebhooksInput, webhookRequestsUncheckedCreateWithoutWebhooksInput>
  }

  export type webhookRequestsCreateManyWebhooksInputEnvelope = {
    data: Enumerable<webhookRequestsCreateManyWebhooksInput>
    skipDuplicates?: boolean
  }

  export type organizationsCreateWithoutWebhooksInput = {
    name: string
    primaryEmail: string
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyEngineEvents?: custodyEngineEventsCreateNestedManyWithoutOrganizationsInput
    pricingPlans?: pricingPlansCreateNestedOneWithoutOrganizationsInput
    organizationStatusTypes: organizationStatusTypesCreateNestedOneWithoutOrganizationsInput
    users?: usersCreateNestedManyWithoutOrganizationsInput
    withdrawalAddresses?: withdrawalAddressesCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateWithoutWebhooksInput = {
    id?: number
    name: string
    primaryEmail: string
    pricingPlanId?: number
    statusId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyEngineEvents?: custodyEngineEventsUncheckedCreateNestedManyWithoutOrganizationsInput
    users?: usersUncheckedCreateNestedManyWithoutOrganizationsInput
    withdrawalAddresses?: withdrawalAddressesUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsCreateOrConnectWithoutWebhooksInput = {
    where: organizationsWhereUniqueInput
    create: XOR<organizationsCreateWithoutWebhooksInput, organizationsUncheckedCreateWithoutWebhooksInput>
  }

  export type webhookStatusTypesCreateWithoutWebhooksInput = {
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type webhookStatusTypesUncheckedCreateWithoutWebhooksInput = {
    id?: number
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type webhookStatusTypesCreateOrConnectWithoutWebhooksInput = {
    where: webhookStatusTypesWhereUniqueInput
    create: XOR<webhookStatusTypesCreateWithoutWebhooksInput, webhookStatusTypesUncheckedCreateWithoutWebhooksInput>
  }

  export type webhookRequestsUpsertWithWhereUniqueWithoutWebhooksInput = {
    where: webhookRequestsWhereUniqueInput
    update: XOR<webhookRequestsUpdateWithoutWebhooksInput, webhookRequestsUncheckedUpdateWithoutWebhooksInput>
    create: XOR<webhookRequestsCreateWithoutWebhooksInput, webhookRequestsUncheckedCreateWithoutWebhooksInput>
  }

  export type webhookRequestsUpdateWithWhereUniqueWithoutWebhooksInput = {
    where: webhookRequestsWhereUniqueInput
    data: XOR<webhookRequestsUpdateWithoutWebhooksInput, webhookRequestsUncheckedUpdateWithoutWebhooksInput>
  }

  export type webhookRequestsUpdateManyWithWhereWithoutWebhooksInput = {
    where: webhookRequestsScalarWhereInput
    data: XOR<webhookRequestsUpdateManyMutationInput, webhookRequestsUncheckedUpdateManyWithoutWebhookRequestsInput>
  }

  export type organizationsUpsertWithoutWebhooksInput = {
    update: XOR<organizationsUpdateWithoutWebhooksInput, organizationsUncheckedUpdateWithoutWebhooksInput>
    create: XOR<organizationsCreateWithoutWebhooksInput, organizationsUncheckedCreateWithoutWebhooksInput>
  }

  export type organizationsUpdateWithoutWebhooksInput = {
    name?: StringFieldUpdateOperationsInput | string
    primaryEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyEngineEvents?: custodyEngineEventsUpdateManyWithoutOrganizationsNestedInput
    pricingPlans?: pricingPlansUpdateOneRequiredWithoutOrganizationsNestedInput
    organizationStatusTypes?: organizationStatusTypesUpdateOneRequiredWithoutOrganizationsNestedInput
    users?: usersUpdateManyWithoutOrganizationsNestedInput
    withdrawalAddresses?: withdrawalAddressesUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateWithoutWebhooksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    primaryEmail?: StringFieldUpdateOperationsInput | string
    pricingPlanId?: IntFieldUpdateOperationsInput | number
    statusId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyEngineEvents?: custodyEngineEventsUncheckedUpdateManyWithoutOrganizationsNestedInput
    users?: usersUncheckedUpdateManyWithoutOrganizationsNestedInput
    withdrawalAddresses?: withdrawalAddressesUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type webhookStatusTypesUpsertWithoutWebhooksInput = {
    update: XOR<webhookStatusTypesUpdateWithoutWebhooksInput, webhookStatusTypesUncheckedUpdateWithoutWebhooksInput>
    create: XOR<webhookStatusTypesCreateWithoutWebhooksInput, webhookStatusTypesUncheckedCreateWithoutWebhooksInput>
  }

  export type webhookStatusTypesUpdateWithoutWebhooksInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type webhookStatusTypesUncheckedUpdateWithoutWebhooksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionPoliciesCreateWithoutWithdrawalAddressesInput = {
    id: string
    toOneTimeAddresses?: boolean | null
    greaterThanUSD: string
    action: enum_transactionPolicies_action
    createdAt?: Date | string
    updatedAt?: Date | string
    assets: assetsCreateNestedOneWithoutTransactionPoliciesInput
    vaults_transactionPolicies_sourceVaultIdTovaults: vaultsCreateNestedOneWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput
    vaults_transactionPolicies_targetVaultIdTovaults?: vaultsCreateNestedOneWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput
    transactionTypes: transactionTypesCreateNestedOneWithoutTransactionPoliciesInput
    users: usersCreateNestedOneWithoutTransactionPoliciesInput
  }

  export type transactionPoliciesUncheckedCreateWithoutWithdrawalAddressesInput = {
    id: string
    userId: string
    transactionTypeId: number
    sourceVaultId: string
    targetVaultId?: string | null
    toOneTimeAddresses?: boolean | null
    greaterThanUSD: string
    assetId: number
    action: enum_transactionPolicies_action
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionPoliciesCreateOrConnectWithoutWithdrawalAddressesInput = {
    where: transactionPoliciesWhereUniqueInput
    create: XOR<transactionPoliciesCreateWithoutWithdrawalAddressesInput, transactionPoliciesUncheckedCreateWithoutWithdrawalAddressesInput>
  }

  export type transactionPoliciesCreateManyWithdrawalAddressesInputEnvelope = {
    data: Enumerable<transactionPoliciesCreateManyWithdrawalAddressesInput>
    skipDuplicates?: boolean
  }

  export type transactionsCreateWithoutWithdrawalAddressesInput = {
    id: string
    custodyVendorRef: string
    amountAsset: string
    amountUSD: string
    onChainTxId?: string | null
    sourceExternalAddress?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assets: assetsCreateNestedOneWithoutTransactionsInput
    users?: usersCreateNestedOneWithoutTransactionsInput
    vendors: vendorsCreateNestedOneWithoutTransactionsInput
    vaults_transactions_sourceVaultIdTovaults?: vaultsCreateNestedOneWithoutTransactions_transactions_sourceVaultIdTovaultsInput
    vaults_transactions_targetVaultIdTovaults?: vaultsCreateNestedOneWithoutTransactions_transactions_targetVaultIdTovaultsInput
    transactionStatusTypes: transactionStatusTypesCreateNestedOneWithoutTransactionsInput
    transactionTypes: transactionTypesCreateNestedOneWithoutTransactionsInput
  }

  export type transactionsUncheckedCreateWithoutWithdrawalAddressesInput = {
    id: string
    custodyVendorId: number
    custodyVendorRef: string
    transactionTypeId: number
    amountAsset: string
    amountUSD: string
    assetId: number
    transactionStatusTypeId: number
    onChainTxId?: string | null
    sourceVaultId?: string | null
    targetVaultId?: string | null
    sourceExternalAddress?: string | null
    createdByUserId?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionsCreateOrConnectWithoutWithdrawalAddressesInput = {
    where: transactionsWhereUniqueInput
    create: XOR<transactionsCreateWithoutWithdrawalAddressesInput, transactionsUncheckedCreateWithoutWithdrawalAddressesInput>
  }

  export type transactionsCreateManyWithdrawalAddressesInputEnvelope = {
    data: Enumerable<transactionsCreateManyWithdrawalAddressesInput>
    skipDuplicates?: boolean
  }

  export type assetsCreateWithoutWithdrawalAddressesInput = {
    name: string
    description: string
    type: enum_assets_type
    ticker: string
    fireblocksTicker?: string | null
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    baseNetworks?: baseNetworksCreateNestedOneWithoutAssetsInput
    quotes_quotes_sourceAssetIdToassets?: quotesCreateNestedManyWithoutAssets_quotes_sourceAssetIdToassetsInput
    quotes_quotes_targetAssetIdToassets?: quotesCreateNestedManyWithoutAssets_quotes_targetAssetIdToassetsInput
    transactionPolicies?: transactionPoliciesCreateNestedManyWithoutAssetsInput
    transactions?: transactionsCreateNestedManyWithoutAssetsInput
    vaultAssets?: vaultAssetsCreateNestedManyWithoutAssetsInput
    vendorSupportsAssets?: vendorSupportsAssetsCreateNestedManyWithoutAssetsInput
  }

  export type assetsUncheckedCreateWithoutWithdrawalAddressesInput = {
    id?: number
    name: string
    description: string
    baseNetworkId?: number | null
    type: enum_assets_type
    ticker: string
    fireblocksTicker?: string | null
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes_quotes_sourceAssetIdToassets?: quotesUncheckedCreateNestedManyWithoutAssets_quotes_sourceAssetIdToassetsInput
    quotes_quotes_targetAssetIdToassets?: quotesUncheckedCreateNestedManyWithoutAssets_quotes_targetAssetIdToassetsInput
    transactionPolicies?: transactionPoliciesUncheckedCreateNestedManyWithoutAssetsInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutAssetsInput
    vaultAssets?: vaultAssetsUncheckedCreateNestedManyWithoutAssetsInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedCreateNestedManyWithoutAssetsInput
  }

  export type assetsCreateOrConnectWithoutWithdrawalAddressesInput = {
    where: assetsWhereUniqueInput
    create: XOR<assetsCreateWithoutWithdrawalAddressesInput, assetsUncheckedCreateWithoutWithdrawalAddressesInput>
  }

  export type organizationsCreateWithoutWithdrawalAddressesInput = {
    name: string
    primaryEmail: string
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyEngineEvents?: custodyEngineEventsCreateNestedManyWithoutOrganizationsInput
    pricingPlans?: pricingPlansCreateNestedOneWithoutOrganizationsInput
    organizationStatusTypes: organizationStatusTypesCreateNestedOneWithoutOrganizationsInput
    users?: usersCreateNestedManyWithoutOrganizationsInput
    webhooks?: webhooksCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsUncheckedCreateWithoutWithdrawalAddressesInput = {
    id?: number
    name: string
    primaryEmail: string
    pricingPlanId?: number
    statusId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    custodyEngineEvents?: custodyEngineEventsUncheckedCreateNestedManyWithoutOrganizationsInput
    users?: usersUncheckedCreateNestedManyWithoutOrganizationsInput
    webhooks?: webhooksUncheckedCreateNestedManyWithoutOrganizationsInput
  }

  export type organizationsCreateOrConnectWithoutWithdrawalAddressesInput = {
    where: organizationsWhereUniqueInput
    create: XOR<organizationsCreateWithoutWithdrawalAddressesInput, organizationsUncheckedCreateWithoutWithdrawalAddressesInput>
  }

  export type transactionPoliciesUpsertWithWhereUniqueWithoutWithdrawalAddressesInput = {
    where: transactionPoliciesWhereUniqueInput
    update: XOR<transactionPoliciesUpdateWithoutWithdrawalAddressesInput, transactionPoliciesUncheckedUpdateWithoutWithdrawalAddressesInput>
    create: XOR<transactionPoliciesCreateWithoutWithdrawalAddressesInput, transactionPoliciesUncheckedCreateWithoutWithdrawalAddressesInput>
  }

  export type transactionPoliciesUpdateWithWhereUniqueWithoutWithdrawalAddressesInput = {
    where: transactionPoliciesWhereUniqueInput
    data: XOR<transactionPoliciesUpdateWithoutWithdrawalAddressesInput, transactionPoliciesUncheckedUpdateWithoutWithdrawalAddressesInput>
  }

  export type transactionPoliciesUpdateManyWithWhereWithoutWithdrawalAddressesInput = {
    where: transactionPoliciesScalarWhereInput
    data: XOR<transactionPoliciesUpdateManyMutationInput, transactionPoliciesUncheckedUpdateManyWithoutTransactionPoliciesInput>
  }

  export type transactionsUpsertWithWhereUniqueWithoutWithdrawalAddressesInput = {
    where: transactionsWhereUniqueInput
    update: XOR<transactionsUpdateWithoutWithdrawalAddressesInput, transactionsUncheckedUpdateWithoutWithdrawalAddressesInput>
    create: XOR<transactionsCreateWithoutWithdrawalAddressesInput, transactionsUncheckedCreateWithoutWithdrawalAddressesInput>
  }

  export type transactionsUpdateWithWhereUniqueWithoutWithdrawalAddressesInput = {
    where: transactionsWhereUniqueInput
    data: XOR<transactionsUpdateWithoutWithdrawalAddressesInput, transactionsUncheckedUpdateWithoutWithdrawalAddressesInput>
  }

  export type transactionsUpdateManyWithWhereWithoutWithdrawalAddressesInput = {
    where: transactionsScalarWhereInput
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyWithoutTransactionsInput>
  }

  export type assetsUpsertWithoutWithdrawalAddressesInput = {
    update: XOR<assetsUpdateWithoutWithdrawalAddressesInput, assetsUncheckedUpdateWithoutWithdrawalAddressesInput>
    create: XOR<assetsCreateWithoutWithdrawalAddressesInput, assetsUncheckedCreateWithoutWithdrawalAddressesInput>
  }

  export type assetsUpdateWithoutWithdrawalAddressesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: Enumenum_assets_typeFieldUpdateOperationsInput | enum_assets_type
    ticker?: StringFieldUpdateOperationsInput | string
    fireblocksTicker?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseNetworks?: baseNetworksUpdateOneWithoutAssetsNestedInput
    quotes_quotes_sourceAssetIdToassets?: quotesUpdateManyWithoutAssets_quotes_sourceAssetIdToassetsNestedInput
    quotes_quotes_targetAssetIdToassets?: quotesUpdateManyWithoutAssets_quotes_targetAssetIdToassetsNestedInput
    transactionPolicies?: transactionPoliciesUpdateManyWithoutAssetsNestedInput
    transactions?: transactionsUpdateManyWithoutAssetsNestedInput
    vaultAssets?: vaultAssetsUpdateManyWithoutAssetsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUpdateManyWithoutAssetsNestedInput
  }

  export type assetsUncheckedUpdateWithoutWithdrawalAddressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    baseNetworkId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: Enumenum_assets_typeFieldUpdateOperationsInput | enum_assets_type
    ticker?: StringFieldUpdateOperationsInput | string
    fireblocksTicker?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes_quotes_sourceAssetIdToassets?: quotesUncheckedUpdateManyWithoutAssets_quotes_sourceAssetIdToassetsNestedInput
    quotes_quotes_targetAssetIdToassets?: quotesUncheckedUpdateManyWithoutAssets_quotes_targetAssetIdToassetsNestedInput
    transactionPolicies?: transactionPoliciesUncheckedUpdateManyWithoutAssetsNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutAssetsNestedInput
    vaultAssets?: vaultAssetsUncheckedUpdateManyWithoutAssetsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedUpdateManyWithoutAssetsNestedInput
  }

  export type organizationsUpsertWithoutWithdrawalAddressesInput = {
    update: XOR<organizationsUpdateWithoutWithdrawalAddressesInput, organizationsUncheckedUpdateWithoutWithdrawalAddressesInput>
    create: XOR<organizationsCreateWithoutWithdrawalAddressesInput, organizationsUncheckedCreateWithoutWithdrawalAddressesInput>
  }

  export type organizationsUpdateWithoutWithdrawalAddressesInput = {
    name?: StringFieldUpdateOperationsInput | string
    primaryEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyEngineEvents?: custodyEngineEventsUpdateManyWithoutOrganizationsNestedInput
    pricingPlans?: pricingPlansUpdateOneRequiredWithoutOrganizationsNestedInput
    organizationStatusTypes?: organizationStatusTypesUpdateOneRequiredWithoutOrganizationsNestedInput
    users?: usersUpdateManyWithoutOrganizationsNestedInput
    webhooks?: webhooksUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateWithoutWithdrawalAddressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    primaryEmail?: StringFieldUpdateOperationsInput | string
    pricingPlanId?: IntFieldUpdateOperationsInput | number
    statusId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyEngineEvents?: custodyEngineEventsUncheckedUpdateManyWithoutOrganizationsNestedInput
    users?: usersUncheckedUpdateManyWithoutOrganizationsNestedInput
    webhooks?: webhooksUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type quotesCreateManyAssets_quotes_sourceAssetIdToassetsInput = {
    id: string
    quoteStatusId: number
    targetAssetId: number
    side: enum_quotes_side
    userId: string
    vendorId?: number | null
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    fxRequestID?: string | null
    buyPrice?: string
    sellPrice?: string
    quantity?: string
  }

  export type quotesCreateManyAssets_quotes_targetAssetIdToassetsInput = {
    id: string
    quoteStatusId: number
    sourceAssetId: number
    side: enum_quotes_side
    userId: string
    vendorId?: number | null
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    fxRequestID?: string | null
    buyPrice?: string
    sellPrice?: string
    quantity?: string
  }

  export type transactionPoliciesCreateManyAssetsInput = {
    id: string
    userId: string
    transactionTypeId: number
    sourceVaultId: string
    targetVaultId?: string | null
    targetWithdrawalAddressId?: string | null
    toOneTimeAddresses?: boolean | null
    greaterThanUSD: string
    action: enum_transactionPolicies_action
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionsCreateManyAssetsInput = {
    id: string
    custodyVendorId: number
    custodyVendorRef: string
    transactionTypeId: number
    amountAsset: string
    amountUSD: string
    transactionStatusTypeId: number
    onChainTxId?: string | null
    sourceVaultId?: string | null
    targetVaultId?: string | null
    targetWithdrawalAddressId?: string | null
    sourceExternalAddress?: string | null
    createdByUserId?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vaultAssetsCreateManyAssetsInput = {
    id?: number
    vaultId: string
    balance: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vendorSupportsAssetsCreateManyAssetsInput = {
    id?: number
    vendorId: number
    enabled?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    theirId?: string | null
  }

  export type withdrawalAddressesCreateManyAssetsInput = {
    id: string
    organizationId: number
    nickname?: string | null
    address: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type quotesUpdateWithoutAssets_quotes_sourceAssetIdToassetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: Enumenum_quotes_sideFieldUpdateOperationsInput | enum_quotes_side
    userId?: StringFieldUpdateOperationsInput | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buyPrice?: StringFieldUpdateOperationsInput | string
    sellPrice?: StringFieldUpdateOperationsInput | string
    quantity?: StringFieldUpdateOperationsInput | string
    orders?: ordersUpdateManyWithoutQuotesNestedInput
    tokenPairsInfo?: tokenPairsInfoUpdateOneWithoutQuotesNestedInput
    quoteStatuses?: quoteStatusesUpdateOneRequiredWithoutQuotesNestedInput
    assets_quotes_targetAssetIdToassets?: assetsUpdateOneRequiredWithoutQuotes_quotes_targetAssetIdToassetsNestedInput
    vendors?: vendorsUpdateOneWithoutQuotesNestedInput
  }

  export type quotesUncheckedUpdateWithoutAssets_quotes_sourceAssetIdToassetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteStatusId?: IntFieldUpdateOperationsInput | number
    targetAssetId?: IntFieldUpdateOperationsInput | number
    side?: Enumenum_quotes_sideFieldUpdateOperationsInput | enum_quotes_side
    userId?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fxRequestID?: NullableStringFieldUpdateOperationsInput | string | null
    buyPrice?: StringFieldUpdateOperationsInput | string
    sellPrice?: StringFieldUpdateOperationsInput | string
    quantity?: StringFieldUpdateOperationsInput | string
    orders?: ordersUncheckedUpdateManyWithoutQuotesNestedInput
  }

  export type quotesUncheckedUpdateManyWithoutQuotes_quotes_sourceAssetIdToassetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteStatusId?: IntFieldUpdateOperationsInput | number
    targetAssetId?: IntFieldUpdateOperationsInput | number
    side?: Enumenum_quotes_sideFieldUpdateOperationsInput | enum_quotes_side
    userId?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fxRequestID?: NullableStringFieldUpdateOperationsInput | string | null
    buyPrice?: StringFieldUpdateOperationsInput | string
    sellPrice?: StringFieldUpdateOperationsInput | string
    quantity?: StringFieldUpdateOperationsInput | string
  }

  export type quotesUpdateWithoutAssets_quotes_targetAssetIdToassetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: Enumenum_quotes_sideFieldUpdateOperationsInput | enum_quotes_side
    userId?: StringFieldUpdateOperationsInput | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buyPrice?: StringFieldUpdateOperationsInput | string
    sellPrice?: StringFieldUpdateOperationsInput | string
    quantity?: StringFieldUpdateOperationsInput | string
    orders?: ordersUpdateManyWithoutQuotesNestedInput
    tokenPairsInfo?: tokenPairsInfoUpdateOneWithoutQuotesNestedInput
    quoteStatuses?: quoteStatusesUpdateOneRequiredWithoutQuotesNestedInput
    assets_quotes_sourceAssetIdToassets?: assetsUpdateOneRequiredWithoutQuotes_quotes_sourceAssetIdToassetsNestedInput
    vendors?: vendorsUpdateOneWithoutQuotesNestedInput
  }

  export type quotesUncheckedUpdateWithoutAssets_quotes_targetAssetIdToassetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteStatusId?: IntFieldUpdateOperationsInput | number
    sourceAssetId?: IntFieldUpdateOperationsInput | number
    side?: Enumenum_quotes_sideFieldUpdateOperationsInput | enum_quotes_side
    userId?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fxRequestID?: NullableStringFieldUpdateOperationsInput | string | null
    buyPrice?: StringFieldUpdateOperationsInput | string
    sellPrice?: StringFieldUpdateOperationsInput | string
    quantity?: StringFieldUpdateOperationsInput | string
    orders?: ordersUncheckedUpdateManyWithoutQuotesNestedInput
  }

  export type quotesUncheckedUpdateManyWithoutQuotes_quotes_targetAssetIdToassetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteStatusId?: IntFieldUpdateOperationsInput | number
    sourceAssetId?: IntFieldUpdateOperationsInput | number
    side?: Enumenum_quotes_sideFieldUpdateOperationsInput | enum_quotes_side
    userId?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fxRequestID?: NullableStringFieldUpdateOperationsInput | string | null
    buyPrice?: StringFieldUpdateOperationsInput | string
    sellPrice?: StringFieldUpdateOperationsInput | string
    quantity?: StringFieldUpdateOperationsInput | string
  }

  export type transactionPoliciesUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    toOneTimeAddresses?: NullableBoolFieldUpdateOperationsInput | boolean | null
    greaterThanUSD?: StringFieldUpdateOperationsInput | string
    action?: Enumenum_transactionPolicies_actionFieldUpdateOperationsInput | enum_transactionPolicies_action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaults_transactionPolicies_sourceVaultIdTovaults?: vaultsUpdateOneRequiredWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsNestedInput
    vaults_transactionPolicies_targetVaultIdTovaults?: vaultsUpdateOneWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsNestedInput
    withdrawalAddresses?: withdrawalAddressesUpdateOneWithoutTransactionPoliciesNestedInput
    transactionTypes?: transactionTypesUpdateOneRequiredWithoutTransactionPoliciesNestedInput
    users?: usersUpdateOneRequiredWithoutTransactionPoliciesNestedInput
  }

  export type transactionPoliciesUncheckedUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionTypeId?: IntFieldUpdateOperationsInput | number
    sourceVaultId?: StringFieldUpdateOperationsInput | string
    targetVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetWithdrawalAddressId?: NullableStringFieldUpdateOperationsInput | string | null
    toOneTimeAddresses?: NullableBoolFieldUpdateOperationsInput | boolean | null
    greaterThanUSD?: StringFieldUpdateOperationsInput | string
    action?: Enumenum_transactionPolicies_actionFieldUpdateOperationsInput | enum_transactionPolicies_action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionPoliciesUncheckedUpdateManyWithoutTransactionPoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionTypeId?: IntFieldUpdateOperationsInput | number
    sourceVaultId?: StringFieldUpdateOperationsInput | string
    targetVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetWithdrawalAddressId?: NullableStringFieldUpdateOperationsInput | string | null
    toOneTimeAddresses?: NullableBoolFieldUpdateOperationsInput | boolean | null
    greaterThanUSD?: StringFieldUpdateOperationsInput | string
    action?: Enumenum_transactionPolicies_actionFieldUpdateOperationsInput | enum_transactionPolicies_action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionsUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    custodyVendorRef?: StringFieldUpdateOperationsInput | string
    amountAsset?: StringFieldUpdateOperationsInput | string
    amountUSD?: StringFieldUpdateOperationsInput | string
    onChainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceExternalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneWithoutTransactionsNestedInput
    vendors?: vendorsUpdateOneRequiredWithoutTransactionsNestedInput
    vaults_transactions_sourceVaultIdTovaults?: vaultsUpdateOneWithoutTransactions_transactions_sourceVaultIdTovaultsNestedInput
    vaults_transactions_targetVaultIdTovaults?: vaultsUpdateOneWithoutTransactions_transactions_targetVaultIdTovaultsNestedInput
    withdrawalAddresses?: withdrawalAddressesUpdateOneWithoutTransactionsNestedInput
    transactionStatusTypes?: transactionStatusTypesUpdateOneRequiredWithoutTransactionsNestedInput
    transactionTypes?: transactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    custodyVendorId?: IntFieldUpdateOperationsInput | number
    custodyVendorRef?: StringFieldUpdateOperationsInput | string
    transactionTypeId?: IntFieldUpdateOperationsInput | number
    amountAsset?: StringFieldUpdateOperationsInput | string
    amountUSD?: StringFieldUpdateOperationsInput | string
    transactionStatusTypeId?: IntFieldUpdateOperationsInput | number
    onChainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetWithdrawalAddressId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceExternalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionsUncheckedUpdateManyWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    custodyVendorId?: IntFieldUpdateOperationsInput | number
    custodyVendorRef?: StringFieldUpdateOperationsInput | string
    transactionTypeId?: IntFieldUpdateOperationsInput | number
    amountAsset?: StringFieldUpdateOperationsInput | string
    amountUSD?: StringFieldUpdateOperationsInput | string
    transactionStatusTypeId?: IntFieldUpdateOperationsInput | number
    onChainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetWithdrawalAddressId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceExternalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vaultAssetsUpdateWithoutAssetsInput = {
    balance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUpdateManyWithoutVaultAssetsNestedInput
    depositAddresses?: depositAddressesUpdateManyWithoutVaultAssetsNestedInput
    vaults?: vaultsUpdateOneRequiredWithoutVaultAssetsNestedInput
  }

  export type vaultAssetsUncheckedUpdateWithoutAssetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    vaultId?: StringFieldUpdateOperationsInput | string
    balance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUncheckedUpdateManyWithoutVaultAssetsNestedInput
    depositAddresses?: depositAddressesUncheckedUpdateManyWithoutVaultAssetsNestedInput
  }

  export type vaultAssetsUncheckedUpdateManyWithoutVaultAssetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    vaultId?: StringFieldUpdateOperationsInput | string
    balance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vendorSupportsAssetsUpdateWithoutAssetsInput = {
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    theirId?: NullableStringFieldUpdateOperationsInput | string | null
    pricingPlanSupportsAssets?: pricingPlanSupportsAssetsUpdateManyWithoutVendorSupportsAssetsNestedInput
    vendors?: vendorsUpdateOneRequiredWithoutVendorSupportsAssetsNestedInput
  }

  export type vendorSupportsAssetsUncheckedUpdateWithoutAssetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    theirId?: NullableStringFieldUpdateOperationsInput | string | null
    pricingPlanSupportsAssets?: pricingPlanSupportsAssetsUncheckedUpdateManyWithoutVendorSupportsAssetsNestedInput
  }

  export type vendorSupportsAssetsUncheckedUpdateManyWithoutVendorSupportsAssetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    theirId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type withdrawalAddressesUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionPolicies?: transactionPoliciesUpdateManyWithoutWithdrawalAddressesNestedInput
    transactions?: transactionsUpdateManyWithoutWithdrawalAddressesNestedInput
    organizations?: organizationsUpdateOneRequiredWithoutWithdrawalAddressesNestedInput
  }

  export type withdrawalAddressesUncheckedUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionPolicies?: transactionPoliciesUncheckedUpdateManyWithoutWithdrawalAddressesNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutWithdrawalAddressesNestedInput
  }

  export type withdrawalAddressesUncheckedUpdateManyWithoutWithdrawalAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type assetsCreateManyBaseNetworksInput = {
    id?: number
    name: string
    description: string
    type: enum_assets_type
    ticker: string
    fireblocksTicker?: string | null
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type assetsUpdateWithoutBaseNetworksInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: Enumenum_assets_typeFieldUpdateOperationsInput | enum_assets_type
    ticker?: StringFieldUpdateOperationsInput | string
    fireblocksTicker?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes_quotes_sourceAssetIdToassets?: quotesUpdateManyWithoutAssets_quotes_sourceAssetIdToassetsNestedInput
    quotes_quotes_targetAssetIdToassets?: quotesUpdateManyWithoutAssets_quotes_targetAssetIdToassetsNestedInput
    transactionPolicies?: transactionPoliciesUpdateManyWithoutAssetsNestedInput
    transactions?: transactionsUpdateManyWithoutAssetsNestedInput
    vaultAssets?: vaultAssetsUpdateManyWithoutAssetsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUpdateManyWithoutAssetsNestedInput
    withdrawalAddresses?: withdrawalAddressesUpdateManyWithoutAssetsNestedInput
  }

  export type assetsUncheckedUpdateWithoutBaseNetworksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: Enumenum_assets_typeFieldUpdateOperationsInput | enum_assets_type
    ticker?: StringFieldUpdateOperationsInput | string
    fireblocksTicker?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes_quotes_sourceAssetIdToassets?: quotesUncheckedUpdateManyWithoutAssets_quotes_sourceAssetIdToassetsNestedInput
    quotes_quotes_targetAssetIdToassets?: quotesUncheckedUpdateManyWithoutAssets_quotes_targetAssetIdToassetsNestedInput
    transactionPolicies?: transactionPoliciesUncheckedUpdateManyWithoutAssetsNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutAssetsNestedInput
    vaultAssets?: vaultAssetsUncheckedUpdateManyWithoutAssetsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedUpdateManyWithoutAssetsNestedInput
    withdrawalAddresses?: withdrawalAddressesUncheckedUpdateManyWithoutAssetsNestedInput
  }

  export type assetsUncheckedUpdateManyWithoutAssetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: Enumenum_assets_typeFieldUpdateOperationsInput | enum_assets_type
    ticker?: StringFieldUpdateOperationsInput | string
    fireblocksTicker?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ordersCreateManyQuotesInput = {
    id: string
    orderStatus?: string | null
    userAcceptedPrice: string
    userAcceptedQuantity: string
    userAcceptedSide: enum_orders_userAcceptedSide
    userAcceptedTradePair: JsonNullValueInput | InputJsonValue
    userAcceptedTimestamp: Date | string
    orderType?: enum_orders_orderType | null
    orderTimeInForce?: string | null
    vendorQuoteId?: string | null
    vendorQuantityRequested?: string | null
    vendorPriceRequested?: string | null
    orderQuantityExecuted?: string | null
    orderPriceExecuted?: string | null
    orderTimestampExecuted?: Date | string | null
    orderVendorStatus?: string | null
    allowedSlippage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ordersUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderStatus?: NullableStringFieldUpdateOperationsInput | string | null
    userAcceptedPrice?: StringFieldUpdateOperationsInput | string
    userAcceptedQuantity?: StringFieldUpdateOperationsInput | string
    userAcceptedSide?: Enumenum_orders_userAcceptedSideFieldUpdateOperationsInput | enum_orders_userAcceptedSide
    userAcceptedTradePair?: JsonNullValueInput | InputJsonValue
    userAcceptedTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    orderType?: NullableEnumenum_orders_orderTypeFieldUpdateOperationsInput | enum_orders_orderType | null
    orderTimeInForce?: NullableStringFieldUpdateOperationsInput | string | null
    vendorQuoteId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorQuantityRequested?: NullableStringFieldUpdateOperationsInput | string | null
    vendorPriceRequested?: NullableStringFieldUpdateOperationsInput | string | null
    orderQuantityExecuted?: NullableStringFieldUpdateOperationsInput | string | null
    orderPriceExecuted?: NullableStringFieldUpdateOperationsInput | string | null
    orderTimestampExecuted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderVendorStatus?: NullableStringFieldUpdateOperationsInput | string | null
    allowedSlippage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ordersUncheckedUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderStatus?: NullableStringFieldUpdateOperationsInput | string | null
    userAcceptedPrice?: StringFieldUpdateOperationsInput | string
    userAcceptedQuantity?: StringFieldUpdateOperationsInput | string
    userAcceptedSide?: Enumenum_orders_userAcceptedSideFieldUpdateOperationsInput | enum_orders_userAcceptedSide
    userAcceptedTradePair?: JsonNullValueInput | InputJsonValue
    userAcceptedTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    orderType?: NullableEnumenum_orders_orderTypeFieldUpdateOperationsInput | enum_orders_orderType | null
    orderTimeInForce?: NullableStringFieldUpdateOperationsInput | string | null
    vendorQuoteId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorQuantityRequested?: NullableStringFieldUpdateOperationsInput | string | null
    vendorPriceRequested?: NullableStringFieldUpdateOperationsInput | string | null
    orderQuantityExecuted?: NullableStringFieldUpdateOperationsInput | string | null
    orderPriceExecuted?: NullableStringFieldUpdateOperationsInput | string | null
    orderTimestampExecuted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderVendorStatus?: NullableStringFieldUpdateOperationsInput | string | null
    allowedSlippage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ordersUncheckedUpdateManyWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderStatus?: NullableStringFieldUpdateOperationsInput | string | null
    userAcceptedPrice?: StringFieldUpdateOperationsInput | string
    userAcceptedQuantity?: StringFieldUpdateOperationsInput | string
    userAcceptedSide?: Enumenum_orders_userAcceptedSideFieldUpdateOperationsInput | enum_orders_userAcceptedSide
    userAcceptedTradePair?: JsonNullValueInput | InputJsonValue
    userAcceptedTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    orderType?: NullableEnumenum_orders_orderTypeFieldUpdateOperationsInput | enum_orders_orderType | null
    orderTimeInForce?: NullableStringFieldUpdateOperationsInput | string | null
    vendorQuoteId?: NullableStringFieldUpdateOperationsInput | string | null
    vendorQuantityRequested?: NullableStringFieldUpdateOperationsInput | string | null
    vendorPriceRequested?: NullableStringFieldUpdateOperationsInput | string | null
    orderQuantityExecuted?: NullableStringFieldUpdateOperationsInput | string | null
    orderPriceExecuted?: NullableStringFieldUpdateOperationsInput | string | null
    orderTimestampExecuted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderVendorStatus?: NullableStringFieldUpdateOperationsInput | string | null
    allowedSlippage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionsCreateManyTransactionStatusTypesInput = {
    id: string
    custodyVendorId: number
    custodyVendorRef: string
    transactionTypeId: number
    amountAsset: string
    amountUSD: string
    assetId: number
    onChainTxId?: string | null
    sourceVaultId?: string | null
    targetVaultId?: string | null
    targetWithdrawalAddressId?: string | null
    sourceExternalAddress?: string | null
    createdByUserId?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionsUpdateWithoutTransactionStatusTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    custodyVendorRef?: StringFieldUpdateOperationsInput | string
    amountAsset?: StringFieldUpdateOperationsInput | string
    amountUSD?: StringFieldUpdateOperationsInput | string
    onChainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceExternalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: assetsUpdateOneRequiredWithoutTransactionsNestedInput
    users?: usersUpdateOneWithoutTransactionsNestedInput
    vendors?: vendorsUpdateOneRequiredWithoutTransactionsNestedInput
    vaults_transactions_sourceVaultIdTovaults?: vaultsUpdateOneWithoutTransactions_transactions_sourceVaultIdTovaultsNestedInput
    vaults_transactions_targetVaultIdTovaults?: vaultsUpdateOneWithoutTransactions_transactions_targetVaultIdTovaultsNestedInput
    withdrawalAddresses?: withdrawalAddressesUpdateOneWithoutTransactionsNestedInput
    transactionTypes?: transactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateWithoutTransactionStatusTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    custodyVendorId?: IntFieldUpdateOperationsInput | number
    custodyVendorRef?: StringFieldUpdateOperationsInput | string
    transactionTypeId?: IntFieldUpdateOperationsInput | number
    amountAsset?: StringFieldUpdateOperationsInput | string
    amountUSD?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    onChainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetWithdrawalAddressId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceExternalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionPoliciesCreateManyTransactionTypesInput = {
    id: string
    userId: string
    sourceVaultId: string
    targetVaultId?: string | null
    targetWithdrawalAddressId?: string | null
    toOneTimeAddresses?: boolean | null
    greaterThanUSD: string
    assetId: number
    action: enum_transactionPolicies_action
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionsCreateManyTransactionTypesInput = {
    id: string
    custodyVendorId: number
    custodyVendorRef: string
    amountAsset: string
    amountUSD: string
    assetId: number
    transactionStatusTypeId: number
    onChainTxId?: string | null
    sourceVaultId?: string | null
    targetVaultId?: string | null
    targetWithdrawalAddressId?: string | null
    sourceExternalAddress?: string | null
    createdByUserId?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionPoliciesUpdateWithoutTransactionTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    toOneTimeAddresses?: NullableBoolFieldUpdateOperationsInput | boolean | null
    greaterThanUSD?: StringFieldUpdateOperationsInput | string
    action?: Enumenum_transactionPolicies_actionFieldUpdateOperationsInput | enum_transactionPolicies_action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: assetsUpdateOneRequiredWithoutTransactionPoliciesNestedInput
    vaults_transactionPolicies_sourceVaultIdTovaults?: vaultsUpdateOneRequiredWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsNestedInput
    vaults_transactionPolicies_targetVaultIdTovaults?: vaultsUpdateOneWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsNestedInput
    withdrawalAddresses?: withdrawalAddressesUpdateOneWithoutTransactionPoliciesNestedInput
    users?: usersUpdateOneRequiredWithoutTransactionPoliciesNestedInput
  }

  export type transactionPoliciesUncheckedUpdateWithoutTransactionTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sourceVaultId?: StringFieldUpdateOperationsInput | string
    targetVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetWithdrawalAddressId?: NullableStringFieldUpdateOperationsInput | string | null
    toOneTimeAddresses?: NullableBoolFieldUpdateOperationsInput | boolean | null
    greaterThanUSD?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    action?: Enumenum_transactionPolicies_actionFieldUpdateOperationsInput | enum_transactionPolicies_action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionsUpdateWithoutTransactionTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    custodyVendorRef?: StringFieldUpdateOperationsInput | string
    amountAsset?: StringFieldUpdateOperationsInput | string
    amountUSD?: StringFieldUpdateOperationsInput | string
    onChainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceExternalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: assetsUpdateOneRequiredWithoutTransactionsNestedInput
    users?: usersUpdateOneWithoutTransactionsNestedInput
    vendors?: vendorsUpdateOneRequiredWithoutTransactionsNestedInput
    vaults_transactions_sourceVaultIdTovaults?: vaultsUpdateOneWithoutTransactions_transactions_sourceVaultIdTovaultsNestedInput
    vaults_transactions_targetVaultIdTovaults?: vaultsUpdateOneWithoutTransactions_transactions_targetVaultIdTovaultsNestedInput
    withdrawalAddresses?: withdrawalAddressesUpdateOneWithoutTransactionsNestedInput
    transactionStatusTypes?: transactionStatusTypesUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateWithoutTransactionTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    custodyVendorId?: IntFieldUpdateOperationsInput | number
    custodyVendorRef?: StringFieldUpdateOperationsInput | string
    amountAsset?: StringFieldUpdateOperationsInput | string
    amountUSD?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    transactionStatusTypeId?: IntFieldUpdateOperationsInput | number
    onChainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetWithdrawalAddressId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceExternalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionPoliciesCreateManyUsersInput = {
    id: string
    transactionTypeId: number
    sourceVaultId: string
    targetVaultId?: string | null
    targetWithdrawalAddressId?: string | null
    toOneTimeAddresses?: boolean | null
    greaterThanUSD: string
    assetId: number
    action: enum_transactionPolicies_action
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionsCreateManyUsersInput = {
    id: string
    custodyVendorId: number
    custodyVendorRef: string
    transactionTypeId: number
    amountAsset: string
    amountUSD: string
    assetId: number
    transactionStatusTypeId: number
    onChainTxId?: string | null
    sourceVaultId?: string | null
    targetVaultId?: string | null
    targetWithdrawalAddressId?: string | null
    sourceExternalAddress?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vaultsCreateManyUsersInput = {
    id: string
    vaultStatusId?: number | null
    vaultName?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionPoliciesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    toOneTimeAddresses?: NullableBoolFieldUpdateOperationsInput | boolean | null
    greaterThanUSD?: StringFieldUpdateOperationsInput | string
    action?: Enumenum_transactionPolicies_actionFieldUpdateOperationsInput | enum_transactionPolicies_action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: assetsUpdateOneRequiredWithoutTransactionPoliciesNestedInput
    vaults_transactionPolicies_sourceVaultIdTovaults?: vaultsUpdateOneRequiredWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsNestedInput
    vaults_transactionPolicies_targetVaultIdTovaults?: vaultsUpdateOneWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsNestedInput
    withdrawalAddresses?: withdrawalAddressesUpdateOneWithoutTransactionPoliciesNestedInput
    transactionTypes?: transactionTypesUpdateOneRequiredWithoutTransactionPoliciesNestedInput
  }

  export type transactionPoliciesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionTypeId?: IntFieldUpdateOperationsInput | number
    sourceVaultId?: StringFieldUpdateOperationsInput | string
    targetVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetWithdrawalAddressId?: NullableStringFieldUpdateOperationsInput | string | null
    toOneTimeAddresses?: NullableBoolFieldUpdateOperationsInput | boolean | null
    greaterThanUSD?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    action?: Enumenum_transactionPolicies_actionFieldUpdateOperationsInput | enum_transactionPolicies_action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    custodyVendorRef?: StringFieldUpdateOperationsInput | string
    amountAsset?: StringFieldUpdateOperationsInput | string
    amountUSD?: StringFieldUpdateOperationsInput | string
    onChainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceExternalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: assetsUpdateOneRequiredWithoutTransactionsNestedInput
    vendors?: vendorsUpdateOneRequiredWithoutTransactionsNestedInput
    vaults_transactions_sourceVaultIdTovaults?: vaultsUpdateOneWithoutTransactions_transactions_sourceVaultIdTovaultsNestedInput
    vaults_transactions_targetVaultIdTovaults?: vaultsUpdateOneWithoutTransactions_transactions_targetVaultIdTovaultsNestedInput
    withdrawalAddresses?: withdrawalAddressesUpdateOneWithoutTransactionsNestedInput
    transactionStatusTypes?: transactionStatusTypesUpdateOneRequiredWithoutTransactionsNestedInput
    transactionTypes?: transactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    custodyVendorId?: IntFieldUpdateOperationsInput | number
    custodyVendorRef?: StringFieldUpdateOperationsInput | string
    transactionTypeId?: IntFieldUpdateOperationsInput | number
    amountAsset?: StringFieldUpdateOperationsInput | string
    amountUSD?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    transactionStatusTypeId?: IntFieldUpdateOperationsInput | number
    onChainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetWithdrawalAddressId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceExternalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vaultsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaultName?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesUpdateManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsNestedInput
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesUpdateManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsNestedInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsUpdateManyWithoutVaults_transactions_sourceVaultIdTovaultsNestedInput
    transactions_transactions_targetVaultIdTovaults?: transactionsUpdateManyWithoutVaults_transactions_targetVaultIdTovaultsNestedInput
    vaultAssets?: vaultAssetsUpdateManyWithoutVaultsNestedInput
    vaultStatusTypes?: vaultStatusTypesUpdateOneWithoutVaultsNestedInput
  }

  export type vaultsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaultStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    vaultName?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesUncheckedUpdateManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsNestedInput
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesUncheckedUpdateManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsNestedInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsUncheckedUpdateManyWithoutVaults_transactions_sourceVaultIdTovaultsNestedInput
    transactions_transactions_targetVaultIdTovaults?: transactionsUncheckedUpdateManyWithoutVaults_transactions_targetVaultIdTovaultsNestedInput
    vaultAssets?: vaultAssetsUncheckedUpdateManyWithoutVaultsNestedInput
  }

  export type vaultsUncheckedUpdateManyWithoutVaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaultStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    vaultName?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vendorsCreateManyVendorTypesInput = {
    id?: number
    name: string
    identifier: string
    quoteEngineBaseBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vendorsUpdateWithoutVendorTypesInput = {
    name?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    quoteEngineBaseBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUpdateManyWithoutVendorsNestedInput
    depositAddresses?: depositAddressesUpdateManyWithoutVendorsNestedInput
    quotes?: quotesUpdateManyWithoutVendorsNestedInput
    tokenPairs?: tokenPairsUpdateManyWithoutVendorsNestedInput
    transactions?: transactionsUpdateManyWithoutVendorsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUpdateManyWithoutVendorsNestedInput
  }

  export type vendorsUncheckedUpdateWithoutVendorTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    quoteEngineBaseBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUncheckedUpdateManyWithoutVendorsNestedInput
    depositAddresses?: depositAddressesUncheckedUpdateManyWithoutVendorsNestedInput
    quotes?: quotesUncheckedUpdateManyWithoutVendorsNestedInput
    tokenPairs?: tokenPairsUncheckedUpdateManyWithoutVendorsNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutVendorsNestedInput
    vendorSupportsAssets?: vendorSupportsAssetsUncheckedUpdateManyWithoutVendorsNestedInput
  }

  export type vendorsUncheckedUpdateManyWithoutVendorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    quoteEngineBaseBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type custodyVendorVaultAssetsCreateManyVendorsInput = {
    id?: number
    vendorRef: string
    balance: string
    vaultAssetId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type depositAddressesCreateManyVendorsInput = {
    id: string
    vaultAssetId: number
    address: string
    depositAddressStatusId?: number | null
    vendorRef: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type quotesCreateManyVendorsInput = {
    id: string
    quoteStatusId: number
    sourceAssetId: number
    targetAssetId: number
    side: enum_quotes_side
    userId: string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    fxRequestID?: string | null
    buyPrice?: string
    sellPrice?: string
    quantity?: string
  }

  export type tokenPairsCreateManyVendorsInput = {
    id?: number
    baseToken: string
    quoteToken: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionsCreateManyVendorsInput = {
    id: string
    custodyVendorRef: string
    transactionTypeId: number
    amountAsset: string
    amountUSD: string
    assetId: number
    transactionStatusTypeId: number
    onChainTxId?: string | null
    sourceVaultId?: string | null
    targetVaultId?: string | null
    targetWithdrawalAddressId?: string | null
    sourceExternalAddress?: string | null
    createdByUserId?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vendorSupportsAssetsCreateManyVendorsInput = {
    id?: number
    assetId: number
    enabled?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    theirId?: string | null
  }

  export type custodyVendorVaultAssetsUpdateWithoutVendorsInput = {
    vendorRef?: StringFieldUpdateOperationsInput | string
    balance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaultAssets?: vaultAssetsUpdateOneRequiredWithoutCustodyVendorVaultAssetsNestedInput
  }

  export type custodyVendorVaultAssetsUncheckedUpdateWithoutVendorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorRef?: StringFieldUpdateOperationsInput | string
    balance?: StringFieldUpdateOperationsInput | string
    vaultAssetId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type custodyVendorVaultAssetsUncheckedUpdateManyWithoutCustodyVendorVaultAssetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorRef?: StringFieldUpdateOperationsInput | string
    balance?: StringFieldUpdateOperationsInput | string
    vaultAssetId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type depositAddressesUpdateWithoutVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    depositAddressStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    vendorRef?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaultAssets?: vaultAssetsUpdateOneRequiredWithoutDepositAddressesNestedInput
  }

  export type depositAddressesUncheckedUpdateWithoutVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaultAssetId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    depositAddressStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    vendorRef?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type depositAddressesUncheckedUpdateManyWithoutDepositAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaultAssetId?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    depositAddressStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    vendorRef?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quotesUpdateWithoutVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: Enumenum_quotes_sideFieldUpdateOperationsInput | enum_quotes_side
    userId?: StringFieldUpdateOperationsInput | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buyPrice?: StringFieldUpdateOperationsInput | string
    sellPrice?: StringFieldUpdateOperationsInput | string
    quantity?: StringFieldUpdateOperationsInput | string
    orders?: ordersUpdateManyWithoutQuotesNestedInput
    tokenPairsInfo?: tokenPairsInfoUpdateOneWithoutQuotesNestedInput
    quoteStatuses?: quoteStatusesUpdateOneRequiredWithoutQuotesNestedInput
    assets_quotes_sourceAssetIdToassets?: assetsUpdateOneRequiredWithoutQuotes_quotes_sourceAssetIdToassetsNestedInput
    assets_quotes_targetAssetIdToassets?: assetsUpdateOneRequiredWithoutQuotes_quotes_targetAssetIdToassetsNestedInput
  }

  export type quotesUncheckedUpdateWithoutVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteStatusId?: IntFieldUpdateOperationsInput | number
    sourceAssetId?: IntFieldUpdateOperationsInput | number
    targetAssetId?: IntFieldUpdateOperationsInput | number
    side?: Enumenum_quotes_sideFieldUpdateOperationsInput | enum_quotes_side
    userId?: StringFieldUpdateOperationsInput | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fxRequestID?: NullableStringFieldUpdateOperationsInput | string | null
    buyPrice?: StringFieldUpdateOperationsInput | string
    sellPrice?: StringFieldUpdateOperationsInput | string
    quantity?: StringFieldUpdateOperationsInput | string
    orders?: ordersUncheckedUpdateManyWithoutQuotesNestedInput
  }

  export type quotesUncheckedUpdateManyWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteStatusId?: IntFieldUpdateOperationsInput | number
    sourceAssetId?: IntFieldUpdateOperationsInput | number
    targetAssetId?: IntFieldUpdateOperationsInput | number
    side?: Enumenum_quotes_sideFieldUpdateOperationsInput | enum_quotes_side
    userId?: StringFieldUpdateOperationsInput | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fxRequestID?: NullableStringFieldUpdateOperationsInput | string | null
    buyPrice?: StringFieldUpdateOperationsInput | string
    sellPrice?: StringFieldUpdateOperationsInput | string
    quantity?: StringFieldUpdateOperationsInput | string
  }

  export type tokenPairsUpdateWithoutVendorsInput = {
    baseToken?: StringFieldUpdateOperationsInput | string
    quoteToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenPairsInfo?: tokenPairsInfoUpdateManyWithoutTokenPairsNestedInput
  }

  export type tokenPairsUncheckedUpdateWithoutVendorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    baseToken?: StringFieldUpdateOperationsInput | string
    quoteToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenPairsInfo?: tokenPairsInfoUncheckedUpdateManyWithoutTokenPairsNestedInput
  }

  export type tokenPairsUncheckedUpdateManyWithoutTokenPairsInput = {
    id?: IntFieldUpdateOperationsInput | number
    baseToken?: StringFieldUpdateOperationsInput | string
    quoteToken?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionsUpdateWithoutVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    custodyVendorRef?: StringFieldUpdateOperationsInput | string
    amountAsset?: StringFieldUpdateOperationsInput | string
    amountUSD?: StringFieldUpdateOperationsInput | string
    onChainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceExternalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: assetsUpdateOneRequiredWithoutTransactionsNestedInput
    users?: usersUpdateOneWithoutTransactionsNestedInput
    vaults_transactions_sourceVaultIdTovaults?: vaultsUpdateOneWithoutTransactions_transactions_sourceVaultIdTovaultsNestedInput
    vaults_transactions_targetVaultIdTovaults?: vaultsUpdateOneWithoutTransactions_transactions_targetVaultIdTovaultsNestedInput
    withdrawalAddresses?: withdrawalAddressesUpdateOneWithoutTransactionsNestedInput
    transactionStatusTypes?: transactionStatusTypesUpdateOneRequiredWithoutTransactionsNestedInput
    transactionTypes?: transactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateWithoutVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    custodyVendorRef?: StringFieldUpdateOperationsInput | string
    transactionTypeId?: IntFieldUpdateOperationsInput | number
    amountAsset?: StringFieldUpdateOperationsInput | string
    amountUSD?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    transactionStatusTypeId?: IntFieldUpdateOperationsInput | number
    onChainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetWithdrawalAddressId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceExternalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vendorSupportsAssetsUpdateWithoutVendorsInput = {
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    theirId?: NullableStringFieldUpdateOperationsInput | string | null
    pricingPlanSupportsAssets?: pricingPlanSupportsAssetsUpdateManyWithoutVendorSupportsAssetsNestedInput
    assets?: assetsUpdateOneRequiredWithoutVendorSupportsAssetsNestedInput
  }

  export type vendorSupportsAssetsUncheckedUpdateWithoutVendorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    theirId?: NullableStringFieldUpdateOperationsInput | string | null
    pricingPlanSupportsAssets?: pricingPlanSupportsAssetsUncheckedUpdateManyWithoutVendorSupportsAssetsNestedInput
  }

  export type custodyEngineEventsCreateManyCustodyEngineEventTypesInput = {
    id: string
    organizationId: number
    event: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type custodyEngineEventsUpdateWithoutCustodyEngineEventTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizations?: organizationsUpdateOneRequiredWithoutCustodyEngineEventsNestedInput
    webhookRequests?: webhookRequestsUpdateManyWithoutCustodyEngineEventsNestedInput
  }

  export type custodyEngineEventsUncheckedUpdateWithoutCustodyEngineEventTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    event?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    webhookRequests?: webhookRequestsUncheckedUpdateManyWithoutCustodyEngineEventsNestedInput
  }

  export type custodyEngineEventsUncheckedUpdateManyWithoutCustodyEngineEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    event?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type webhookRequestsCreateManyCustodyEngineEventsInput = {
    id: string
    webhookId: string
    institutionalProductId?: string | null
    httpStatusCode: number
    requestPayload: JsonNullValueInput | InputJsonValue
    responsePayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type webhookRequestsUpdateWithoutCustodyEngineEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    httpStatusCode?: IntFieldUpdateOperationsInput | number
    requestPayload?: JsonNullValueInput | InputJsonValue
    responsePayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institutionalProducts?: institutionalProductsUpdateOneWithoutWebhookRequestsNestedInput
    webhooks?: webhooksUpdateOneRequiredWithoutWebhookRequestsNestedInput
  }

  export type webhookRequestsUncheckedUpdateWithoutCustodyEngineEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    webhookId?: StringFieldUpdateOperationsInput | string
    institutionalProductId?: NullableStringFieldUpdateOperationsInput | string | null
    httpStatusCode?: IntFieldUpdateOperationsInput | number
    requestPayload?: JsonNullValueInput | InputJsonValue
    responsePayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type webhookRequestsUncheckedUpdateManyWithoutWebhookRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    webhookId?: StringFieldUpdateOperationsInput | string
    institutionalProductId?: NullableStringFieldUpdateOperationsInput | string | null
    httpStatusCode?: IntFieldUpdateOperationsInput | number
    requestPayload?: JsonNullValueInput | InputJsonValue
    responsePayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type webhookRequestsCreateManyInstitutionalProductsInput = {
    id: string
    webhookId: string
    httpStatusCode: number
    requestPayload: JsonNullValueInput | InputJsonValue
    responsePayload?: NullableJsonNullValueInput | InputJsonValue
    custodyEngineEventId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type webhookRequestsUpdateWithoutInstitutionalProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    httpStatusCode?: IntFieldUpdateOperationsInput | number
    requestPayload?: JsonNullValueInput | InputJsonValue
    responsePayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyEngineEvents?: custodyEngineEventsUpdateOneWithoutWebhookRequestsNestedInput
    webhooks?: webhooksUpdateOneRequiredWithoutWebhookRequestsNestedInput
  }

  export type webhookRequestsUncheckedUpdateWithoutInstitutionalProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    webhookId?: StringFieldUpdateOperationsInput | string
    httpStatusCode?: IntFieldUpdateOperationsInput | number
    requestPayload?: JsonNullValueInput | InputJsonValue
    responsePayload?: NullableJsonNullValueInput | InputJsonValue
    custodyEngineEventId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type organizationsCreateManyOrganizationStatusTypesInput = {
    id?: number
    name: string
    primaryEmail: string
    pricingPlanId?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type organizationsUpdateWithoutOrganizationStatusTypesInput = {
    name?: StringFieldUpdateOperationsInput | string
    primaryEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyEngineEvents?: custodyEngineEventsUpdateManyWithoutOrganizationsNestedInput
    pricingPlans?: pricingPlansUpdateOneRequiredWithoutOrganizationsNestedInput
    users?: usersUpdateManyWithoutOrganizationsNestedInput
    webhooks?: webhooksUpdateManyWithoutOrganizationsNestedInput
    withdrawalAddresses?: withdrawalAddressesUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateWithoutOrganizationStatusTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    primaryEmail?: StringFieldUpdateOperationsInput | string
    pricingPlanId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyEngineEvents?: custodyEngineEventsUncheckedUpdateManyWithoutOrganizationsNestedInput
    users?: usersUncheckedUpdateManyWithoutOrganizationsNestedInput
    webhooks?: webhooksUncheckedUpdateManyWithoutOrganizationsNestedInput
    withdrawalAddresses?: withdrawalAddressesUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateManyWithoutOrganizationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    primaryEmail?: StringFieldUpdateOperationsInput | string
    pricingPlanId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type custodyEngineEventsCreateManyOrganizationsInput = {
    id: string
    custodyEngineEventTypeId: number
    event: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type usersCreateManyOrganizationsInput = {
    id: string
    userTypeId: number
    primaryEmail: string
    firstName: string
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publicKey?: string | null
    apiKey?: string | null
  }

  export type webhooksCreateManyOrganizationsInput = {
    id: string
    webhookStatusTypeId: number
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type withdrawalAddressesCreateManyOrganizationsInput = {
    id: string
    assetId: number
    nickname?: string | null
    address: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type custodyEngineEventsUpdateWithoutOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    event?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyEngineEventTypes?: custodyEngineEventTypesUpdateOneRequiredWithoutCustodyEngineEventsNestedInput
    webhookRequests?: webhookRequestsUpdateManyWithoutCustodyEngineEventsNestedInput
  }

  export type custodyEngineEventsUncheckedUpdateWithoutOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    custodyEngineEventTypeId?: IntFieldUpdateOperationsInput | number
    event?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    webhookRequests?: webhookRequestsUncheckedUpdateManyWithoutCustodyEngineEventsNestedInput
  }

  export type usersUpdateWithoutOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    primaryEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicKey?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    transactionPolicies?: transactionPoliciesUpdateManyWithoutUsersNestedInput
    transactions?: transactionsUpdateManyWithoutUsersNestedInput
    userTypes?: userTypesUpdateOneRequiredWithoutUsersNestedInput
    vaults?: vaultsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userTypeId?: IntFieldUpdateOperationsInput | number
    primaryEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicKey?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    transactionPolicies?: transactionPoliciesUncheckedUpdateManyWithoutUsersNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutUsersNestedInput
    vaults?: vaultsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userTypeId?: IntFieldUpdateOperationsInput | number
    primaryEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicKey?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type webhooksUpdateWithoutOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    webhookRequests?: webhookRequestsUpdateManyWithoutWebhooksNestedInput
    webhookStatusTypes?: webhookStatusTypesUpdateOneRequiredWithoutWebhooksNestedInput
  }

  export type webhooksUncheckedUpdateWithoutOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    webhookStatusTypeId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    webhookRequests?: webhookRequestsUncheckedUpdateManyWithoutWebhooksNestedInput
  }

  export type webhooksUncheckedUpdateManyWithoutWebhooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    webhookStatusTypeId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type withdrawalAddressesUpdateWithoutOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionPolicies?: transactionPoliciesUpdateManyWithoutWithdrawalAddressesNestedInput
    transactions?: transactionsUpdateManyWithoutWithdrawalAddressesNestedInput
    assets?: assetsUpdateOneRequiredWithoutWithdrawalAddressesNestedInput
  }

  export type withdrawalAddressesUncheckedUpdateWithoutOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionPolicies?: transactionPoliciesUncheckedUpdateManyWithoutWithdrawalAddressesNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutWithdrawalAddressesNestedInput
  }

  export type pricingPlansCreateManyPricingPlanProfilesInput = {
    id?: number
    price: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pricingPlansUpdateWithoutPricingPlanProfilesInput = {
    price?: FloatFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizations?: organizationsUpdateManyWithoutPricingPlansNestedInput
    pricingPlanSupportsAssets?: pricingPlanSupportsAssetsUpdateManyWithoutPricingPlansNestedInput
  }

  export type pricingPlansUncheckedUpdateWithoutPricingPlanProfilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizations?: organizationsUncheckedUpdateManyWithoutPricingPlansNestedInput
    pricingPlanSupportsAssets?: pricingPlanSupportsAssetsUncheckedUpdateManyWithoutPricingPlansNestedInput
  }

  export type pricingPlansUncheckedUpdateManyWithoutPricingPlansInput = {
    id?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type organizationsCreateManyPricingPlansInput = {
    id?: number
    name: string
    primaryEmail: string
    statusId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pricingPlanSupportsAssetsCreateManyPricingPlansInput = {
    id?: number
    vendorSupportsAssetId: number
    enabled?: boolean
    buyBps: number
    sellBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type organizationsUpdateWithoutPricingPlansInput = {
    name?: StringFieldUpdateOperationsInput | string
    primaryEmail?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyEngineEvents?: custodyEngineEventsUpdateManyWithoutOrganizationsNestedInput
    organizationStatusTypes?: organizationStatusTypesUpdateOneRequiredWithoutOrganizationsNestedInput
    users?: usersUpdateManyWithoutOrganizationsNestedInput
    webhooks?: webhooksUpdateManyWithoutOrganizationsNestedInput
    withdrawalAddresses?: withdrawalAddressesUpdateManyWithoutOrganizationsNestedInput
  }

  export type organizationsUncheckedUpdateWithoutPricingPlansInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    primaryEmail?: StringFieldUpdateOperationsInput | string
    statusId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyEngineEvents?: custodyEngineEventsUncheckedUpdateManyWithoutOrganizationsNestedInput
    users?: usersUncheckedUpdateManyWithoutOrganizationsNestedInput
    webhooks?: webhooksUncheckedUpdateManyWithoutOrganizationsNestedInput
    withdrawalAddresses?: withdrawalAddressesUncheckedUpdateManyWithoutOrganizationsNestedInput
  }

  export type pricingPlanSupportsAssetsUpdateWithoutPricingPlansInput = {
    enabled?: BoolFieldUpdateOperationsInput | boolean
    buyBps?: FloatFieldUpdateOperationsInput | number
    sellBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorSupportsAssets?: vendorSupportsAssetsUpdateOneRequiredWithoutPricingPlanSupportsAssetsNestedInput
  }

  export type pricingPlanSupportsAssetsUncheckedUpdateWithoutPricingPlansInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorSupportsAssetId?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    buyBps?: FloatFieldUpdateOperationsInput | number
    sellBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pricingPlanSupportsAssetsUncheckedUpdateManyWithoutPricingPlanSupportsAssetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorSupportsAssetId?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    buyBps?: FloatFieldUpdateOperationsInput | number
    sellBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quotesCreateManyQuoteStatusesInput = {
    id: string
    sourceAssetId: number
    targetAssetId: number
    side: enum_quotes_side
    userId: string
    vendorId?: number | null
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    fxRequestID?: string | null
    buyPrice?: string
    sellPrice?: string
    quantity?: string
  }

  export type quotesUpdateWithoutQuoteStatusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: Enumenum_quotes_sideFieldUpdateOperationsInput | enum_quotes_side
    userId?: StringFieldUpdateOperationsInput | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buyPrice?: StringFieldUpdateOperationsInput | string
    sellPrice?: StringFieldUpdateOperationsInput | string
    quantity?: StringFieldUpdateOperationsInput | string
    orders?: ordersUpdateManyWithoutQuotesNestedInput
    tokenPairsInfo?: tokenPairsInfoUpdateOneWithoutQuotesNestedInput
    assets_quotes_sourceAssetIdToassets?: assetsUpdateOneRequiredWithoutQuotes_quotes_sourceAssetIdToassetsNestedInput
    assets_quotes_targetAssetIdToassets?: assetsUpdateOneRequiredWithoutQuotes_quotes_targetAssetIdToassetsNestedInput
    vendors?: vendorsUpdateOneWithoutQuotesNestedInput
  }

  export type quotesUncheckedUpdateWithoutQuoteStatusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceAssetId?: IntFieldUpdateOperationsInput | number
    targetAssetId?: IntFieldUpdateOperationsInput | number
    side?: Enumenum_quotes_sideFieldUpdateOperationsInput | enum_quotes_side
    userId?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fxRequestID?: NullableStringFieldUpdateOperationsInput | string | null
    buyPrice?: StringFieldUpdateOperationsInput | string
    sellPrice?: StringFieldUpdateOperationsInput | string
    quantity?: StringFieldUpdateOperationsInput | string
    orders?: ordersUncheckedUpdateManyWithoutQuotesNestedInput
  }

  export type tokenPairsInfoCreateManyTokenPairsInput = {
    id?: number
    fxRequestID: string
    quantity: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type tokenPairsInfoUpdateWithoutTokenPairsInput = {
    fxRequestID?: StringFieldUpdateOperationsInput | string
    quantity?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes?: quotesUpdateManyWithoutTokenPairsInfoNestedInput
  }

  export type tokenPairsInfoUncheckedUpdateWithoutTokenPairsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fxRequestID?: StringFieldUpdateOperationsInput | string
    quantity?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes?: quotesUncheckedUpdateManyWithoutTokenPairsInfoNestedInput
  }

  export type tokenPairsInfoUncheckedUpdateManyWithoutTokenPairsInfoInput = {
    id?: IntFieldUpdateOperationsInput | number
    fxRequestID?: StringFieldUpdateOperationsInput | string
    quantity?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quotesCreateManyTokenPairsInfoInput = {
    id: string
    quoteStatusId: number
    sourceAssetId: number
    targetAssetId: number
    side: enum_quotes_side
    userId: string
    vendorId?: number | null
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    buyPrice?: string
    sellPrice?: string
    quantity?: string
  }

  export type quotesUpdateWithoutTokenPairsInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    side?: Enumenum_quotes_sideFieldUpdateOperationsInput | enum_quotes_side
    userId?: StringFieldUpdateOperationsInput | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buyPrice?: StringFieldUpdateOperationsInput | string
    sellPrice?: StringFieldUpdateOperationsInput | string
    quantity?: StringFieldUpdateOperationsInput | string
    orders?: ordersUpdateManyWithoutQuotesNestedInput
    quoteStatuses?: quoteStatusesUpdateOneRequiredWithoutQuotesNestedInput
    assets_quotes_sourceAssetIdToassets?: assetsUpdateOneRequiredWithoutQuotes_quotes_sourceAssetIdToassetsNestedInput
    assets_quotes_targetAssetIdToassets?: assetsUpdateOneRequiredWithoutQuotes_quotes_targetAssetIdToassetsNestedInput
    vendors?: vendorsUpdateOneWithoutQuotesNestedInput
  }

  export type quotesUncheckedUpdateWithoutTokenPairsInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteStatusId?: IntFieldUpdateOperationsInput | number
    sourceAssetId?: IntFieldUpdateOperationsInput | number
    targetAssetId?: IntFieldUpdateOperationsInput | number
    side?: Enumenum_quotes_sideFieldUpdateOperationsInput | enum_quotes_side
    userId?: StringFieldUpdateOperationsInput | string
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    extraData?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buyPrice?: StringFieldUpdateOperationsInput | string
    sellPrice?: StringFieldUpdateOperationsInput | string
    quantity?: StringFieldUpdateOperationsInput | string
    orders?: ordersUncheckedUpdateManyWithoutQuotesNestedInput
  }

  export type usersCreateManyUserTypesInput = {
    id: string
    organizationId: number
    primaryEmail: string
    firstName: string
    lastName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publicKey?: string | null
    apiKey?: string | null
  }

  export type usersUpdateWithoutUserTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    primaryEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicKey?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    transactionPolicies?: transactionPoliciesUpdateManyWithoutUsersNestedInput
    transactions?: transactionsUpdateManyWithoutUsersNestedInput
    organizations?: organizationsUpdateOneRequiredWithoutUsersNestedInput
    vaults?: vaultsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUserTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    primaryEmail?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicKey?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    transactionPolicies?: transactionPoliciesUncheckedUpdateManyWithoutUsersNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutUsersNestedInput
    vaults?: vaultsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type custodyVendorVaultAssetsCreateManyVaultAssetsInput = {
    id?: number
    vendorId: number
    vendorRef: string
    balance: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type depositAddressesCreateManyVaultAssetsInput = {
    id: string
    address: string
    depositAddressStatusId?: number | null
    vendorId?: number | null
    vendorRef: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type custodyVendorVaultAssetsUpdateWithoutVaultAssetsInput = {
    vendorRef?: StringFieldUpdateOperationsInput | string
    balance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendors?: vendorsUpdateOneRequiredWithoutCustodyVendorVaultAssetsNestedInput
  }

  export type custodyVendorVaultAssetsUncheckedUpdateWithoutVaultAssetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    vendorId?: IntFieldUpdateOperationsInput | number
    vendorRef?: StringFieldUpdateOperationsInput | string
    balance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type depositAddressesUpdateWithoutVaultAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    depositAddressStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    vendorRef?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendors?: vendorsUpdateOneWithoutDepositAddressesNestedInput
  }

  export type depositAddressesUncheckedUpdateWithoutVaultAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    depositAddressStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    vendorId?: NullableIntFieldUpdateOperationsInput | number | null
    vendorRef?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vaultsCreateManyVaultStatusTypesInput = {
    id: string
    createdByUserId: string
    vaultName?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vaultsUpdateWithoutVaultStatusTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaultName?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesUpdateManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsNestedInput
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesUpdateManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsNestedInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsUpdateManyWithoutVaults_transactions_sourceVaultIdTovaultsNestedInput
    transactions_transactions_targetVaultIdTovaults?: transactionsUpdateManyWithoutVaults_transactions_targetVaultIdTovaultsNestedInput
    vaultAssets?: vaultAssetsUpdateManyWithoutVaultsNestedInput
    users?: usersUpdateOneRequiredWithoutVaultsNestedInput
  }

  export type vaultsUncheckedUpdateWithoutVaultStatusTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdByUserId?: StringFieldUpdateOperationsInput | string
    vaultName?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionPolicies_transactionPolicies_sourceVaultIdTovaults?: transactionPoliciesUncheckedUpdateManyWithoutVaults_transactionPolicies_sourceVaultIdTovaultsNestedInput
    transactionPolicies_transactionPolicies_targetVaultIdTovaults?: transactionPoliciesUncheckedUpdateManyWithoutVaults_transactionPolicies_targetVaultIdTovaultsNestedInput
    transactions_transactions_sourceVaultIdTovaults?: transactionsUncheckedUpdateManyWithoutVaults_transactions_sourceVaultIdTovaultsNestedInput
    transactions_transactions_targetVaultIdTovaults?: transactionsUncheckedUpdateManyWithoutVaults_transactions_targetVaultIdTovaultsNestedInput
    vaultAssets?: vaultAssetsUncheckedUpdateManyWithoutVaultsNestedInput
  }

  export type transactionPoliciesCreateManyVaults_transactionPolicies_sourceVaultIdTovaultsInput = {
    id: string
    userId: string
    transactionTypeId: number
    targetVaultId?: string | null
    targetWithdrawalAddressId?: string | null
    toOneTimeAddresses?: boolean | null
    greaterThanUSD: string
    assetId: number
    action: enum_transactionPolicies_action
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionPoliciesCreateManyVaults_transactionPolicies_targetVaultIdTovaultsInput = {
    id: string
    userId: string
    transactionTypeId: number
    sourceVaultId: string
    targetWithdrawalAddressId?: string | null
    toOneTimeAddresses?: boolean | null
    greaterThanUSD: string
    assetId: number
    action: enum_transactionPolicies_action
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionsCreateManyVaults_transactions_sourceVaultIdTovaultsInput = {
    id: string
    custodyVendorId: number
    custodyVendorRef: string
    transactionTypeId: number
    amountAsset: string
    amountUSD: string
    assetId: number
    transactionStatusTypeId: number
    onChainTxId?: string | null
    targetVaultId?: string | null
    targetWithdrawalAddressId?: string | null
    sourceExternalAddress?: string | null
    createdByUserId?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionsCreateManyVaults_transactions_targetVaultIdTovaultsInput = {
    id: string
    custodyVendorId: number
    custodyVendorRef: string
    transactionTypeId: number
    amountAsset: string
    amountUSD: string
    assetId: number
    transactionStatusTypeId: number
    onChainTxId?: string | null
    sourceVaultId?: string | null
    targetWithdrawalAddressId?: string | null
    sourceExternalAddress?: string | null
    createdByUserId?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vaultAssetsCreateManyVaultsInput = {
    id?: number
    assetId: number
    balance: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionPoliciesUpdateWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    toOneTimeAddresses?: NullableBoolFieldUpdateOperationsInput | boolean | null
    greaterThanUSD?: StringFieldUpdateOperationsInput | string
    action?: Enumenum_transactionPolicies_actionFieldUpdateOperationsInput | enum_transactionPolicies_action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: assetsUpdateOneRequiredWithoutTransactionPoliciesNestedInput
    vaults_transactionPolicies_targetVaultIdTovaults?: vaultsUpdateOneWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsNestedInput
    withdrawalAddresses?: withdrawalAddressesUpdateOneWithoutTransactionPoliciesNestedInput
    transactionTypes?: transactionTypesUpdateOneRequiredWithoutTransactionPoliciesNestedInput
    users?: usersUpdateOneRequiredWithoutTransactionPoliciesNestedInput
  }

  export type transactionPoliciesUncheckedUpdateWithoutVaults_transactionPolicies_sourceVaultIdTovaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionTypeId?: IntFieldUpdateOperationsInput | number
    targetVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetWithdrawalAddressId?: NullableStringFieldUpdateOperationsInput | string | null
    toOneTimeAddresses?: NullableBoolFieldUpdateOperationsInput | boolean | null
    greaterThanUSD?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    action?: Enumenum_transactionPolicies_actionFieldUpdateOperationsInput | enum_transactionPolicies_action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionPoliciesUncheckedUpdateManyWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionTypeId?: IntFieldUpdateOperationsInput | number
    targetVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetWithdrawalAddressId?: NullableStringFieldUpdateOperationsInput | string | null
    toOneTimeAddresses?: NullableBoolFieldUpdateOperationsInput | boolean | null
    greaterThanUSD?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    action?: Enumenum_transactionPolicies_actionFieldUpdateOperationsInput | enum_transactionPolicies_action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionPoliciesUpdateWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    toOneTimeAddresses?: NullableBoolFieldUpdateOperationsInput | boolean | null
    greaterThanUSD?: StringFieldUpdateOperationsInput | string
    action?: Enumenum_transactionPolicies_actionFieldUpdateOperationsInput | enum_transactionPolicies_action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: assetsUpdateOneRequiredWithoutTransactionPoliciesNestedInput
    vaults_transactionPolicies_sourceVaultIdTovaults?: vaultsUpdateOneRequiredWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsNestedInput
    withdrawalAddresses?: withdrawalAddressesUpdateOneWithoutTransactionPoliciesNestedInput
    transactionTypes?: transactionTypesUpdateOneRequiredWithoutTransactionPoliciesNestedInput
    users?: usersUpdateOneRequiredWithoutTransactionPoliciesNestedInput
  }

  export type transactionPoliciesUncheckedUpdateWithoutVaults_transactionPolicies_targetVaultIdTovaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionTypeId?: IntFieldUpdateOperationsInput | number
    sourceVaultId?: StringFieldUpdateOperationsInput | string
    targetWithdrawalAddressId?: NullableStringFieldUpdateOperationsInput | string | null
    toOneTimeAddresses?: NullableBoolFieldUpdateOperationsInput | boolean | null
    greaterThanUSD?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    action?: Enumenum_transactionPolicies_actionFieldUpdateOperationsInput | enum_transactionPolicies_action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionPoliciesUncheckedUpdateManyWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionTypeId?: IntFieldUpdateOperationsInput | number
    sourceVaultId?: StringFieldUpdateOperationsInput | string
    targetWithdrawalAddressId?: NullableStringFieldUpdateOperationsInput | string | null
    toOneTimeAddresses?: NullableBoolFieldUpdateOperationsInput | boolean | null
    greaterThanUSD?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    action?: Enumenum_transactionPolicies_actionFieldUpdateOperationsInput | enum_transactionPolicies_action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionsUpdateWithoutVaults_transactions_sourceVaultIdTovaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    custodyVendorRef?: StringFieldUpdateOperationsInput | string
    amountAsset?: StringFieldUpdateOperationsInput | string
    amountUSD?: StringFieldUpdateOperationsInput | string
    onChainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceExternalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: assetsUpdateOneRequiredWithoutTransactionsNestedInput
    users?: usersUpdateOneWithoutTransactionsNestedInput
    vendors?: vendorsUpdateOneRequiredWithoutTransactionsNestedInput
    vaults_transactions_targetVaultIdTovaults?: vaultsUpdateOneWithoutTransactions_transactions_targetVaultIdTovaultsNestedInput
    withdrawalAddresses?: withdrawalAddressesUpdateOneWithoutTransactionsNestedInput
    transactionStatusTypes?: transactionStatusTypesUpdateOneRequiredWithoutTransactionsNestedInput
    transactionTypes?: transactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateWithoutVaults_transactions_sourceVaultIdTovaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    custodyVendorId?: IntFieldUpdateOperationsInput | number
    custodyVendorRef?: StringFieldUpdateOperationsInput | string
    transactionTypeId?: IntFieldUpdateOperationsInput | number
    amountAsset?: StringFieldUpdateOperationsInput | string
    amountUSD?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    transactionStatusTypeId?: IntFieldUpdateOperationsInput | number
    onChainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    targetVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetWithdrawalAddressId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceExternalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionsUncheckedUpdateManyWithoutTransactions_transactions_sourceVaultIdTovaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    custodyVendorId?: IntFieldUpdateOperationsInput | number
    custodyVendorRef?: StringFieldUpdateOperationsInput | string
    transactionTypeId?: IntFieldUpdateOperationsInput | number
    amountAsset?: StringFieldUpdateOperationsInput | string
    amountUSD?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    transactionStatusTypeId?: IntFieldUpdateOperationsInput | number
    onChainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    targetVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetWithdrawalAddressId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceExternalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionsUpdateWithoutVaults_transactions_targetVaultIdTovaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    custodyVendorRef?: StringFieldUpdateOperationsInput | string
    amountAsset?: StringFieldUpdateOperationsInput | string
    amountUSD?: StringFieldUpdateOperationsInput | string
    onChainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceExternalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: assetsUpdateOneRequiredWithoutTransactionsNestedInput
    users?: usersUpdateOneWithoutTransactionsNestedInput
    vendors?: vendorsUpdateOneRequiredWithoutTransactionsNestedInput
    vaults_transactions_sourceVaultIdTovaults?: vaultsUpdateOneWithoutTransactions_transactions_sourceVaultIdTovaultsNestedInput
    withdrawalAddresses?: withdrawalAddressesUpdateOneWithoutTransactionsNestedInput
    transactionStatusTypes?: transactionStatusTypesUpdateOneRequiredWithoutTransactionsNestedInput
    transactionTypes?: transactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateWithoutVaults_transactions_targetVaultIdTovaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    custodyVendorId?: IntFieldUpdateOperationsInput | number
    custodyVendorRef?: StringFieldUpdateOperationsInput | string
    transactionTypeId?: IntFieldUpdateOperationsInput | number
    amountAsset?: StringFieldUpdateOperationsInput | string
    amountUSD?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    transactionStatusTypeId?: IntFieldUpdateOperationsInput | number
    onChainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetWithdrawalAddressId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceExternalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionsUncheckedUpdateManyWithoutTransactions_transactions_targetVaultIdTovaultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    custodyVendorId?: IntFieldUpdateOperationsInput | number
    custodyVendorRef?: StringFieldUpdateOperationsInput | string
    transactionTypeId?: IntFieldUpdateOperationsInput | number
    amountAsset?: StringFieldUpdateOperationsInput | string
    amountUSD?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    transactionStatusTypeId?: IntFieldUpdateOperationsInput | number
    onChainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetWithdrawalAddressId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceExternalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vaultAssetsUpdateWithoutVaultsInput = {
    balance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUpdateManyWithoutVaultAssetsNestedInput
    depositAddresses?: depositAddressesUpdateManyWithoutVaultAssetsNestedInput
    assets?: assetsUpdateOneRequiredWithoutVaultAssetsNestedInput
  }

  export type vaultAssetsUncheckedUpdateWithoutVaultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    assetId?: IntFieldUpdateOperationsInput | number
    balance?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyVendorVaultAssets?: custodyVendorVaultAssetsUncheckedUpdateManyWithoutVaultAssetsNestedInput
    depositAddresses?: depositAddressesUncheckedUpdateManyWithoutVaultAssetsNestedInput
  }

  export type pricingPlanSupportsAssetsCreateManyVendorSupportsAssetsInput = {
    id?: number
    pricingPlanId: number
    enabled?: boolean
    buyBps: number
    sellBps: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type pricingPlanSupportsAssetsUpdateWithoutVendorSupportsAssetsInput = {
    enabled?: BoolFieldUpdateOperationsInput | boolean
    buyBps?: FloatFieldUpdateOperationsInput | number
    sellBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingPlans?: pricingPlansUpdateOneRequiredWithoutPricingPlanSupportsAssetsNestedInput
  }

  export type pricingPlanSupportsAssetsUncheckedUpdateWithoutVendorSupportsAssetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    pricingPlanId?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    buyBps?: FloatFieldUpdateOperationsInput | number
    sellBps?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type webhooksCreateManyWebhookStatusTypesInput = {
    id: string
    organizationId: number
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type webhooksUpdateWithoutWebhookStatusTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    webhookRequests?: webhookRequestsUpdateManyWithoutWebhooksNestedInput
    organizations?: organizationsUpdateOneRequiredWithoutWebhooksNestedInput
  }

  export type webhooksUncheckedUpdateWithoutWebhookStatusTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    webhookRequests?: webhookRequestsUncheckedUpdateManyWithoutWebhooksNestedInput
  }

  export type webhookRequestsCreateManyWebhooksInput = {
    id: string
    institutionalProductId?: string | null
    httpStatusCode: number
    requestPayload: JsonNullValueInput | InputJsonValue
    responsePayload?: NullableJsonNullValueInput | InputJsonValue
    custodyEngineEventId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type webhookRequestsUpdateWithoutWebhooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    httpStatusCode?: IntFieldUpdateOperationsInput | number
    requestPayload?: JsonNullValueInput | InputJsonValue
    responsePayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    custodyEngineEvents?: custodyEngineEventsUpdateOneWithoutWebhookRequestsNestedInput
    institutionalProducts?: institutionalProductsUpdateOneWithoutWebhookRequestsNestedInput
  }

  export type webhookRequestsUncheckedUpdateWithoutWebhooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    institutionalProductId?: NullableStringFieldUpdateOperationsInput | string | null
    httpStatusCode?: IntFieldUpdateOperationsInput | number
    requestPayload?: JsonNullValueInput | InputJsonValue
    responsePayload?: NullableJsonNullValueInput | InputJsonValue
    custodyEngineEventId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionPoliciesCreateManyWithdrawalAddressesInput = {
    id: string
    userId: string
    transactionTypeId: number
    sourceVaultId: string
    targetVaultId?: string | null
    toOneTimeAddresses?: boolean | null
    greaterThanUSD: string
    assetId: number
    action: enum_transactionPolicies_action
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionsCreateManyWithdrawalAddressesInput = {
    id: string
    custodyVendorId: number
    custodyVendorRef: string
    transactionTypeId: number
    amountAsset: string
    amountUSD: string
    assetId: number
    transactionStatusTypeId: number
    onChainTxId?: string | null
    sourceVaultId?: string | null
    targetVaultId?: string | null
    sourceExternalAddress?: string | null
    createdByUserId?: string | null
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type transactionPoliciesUpdateWithoutWithdrawalAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    toOneTimeAddresses?: NullableBoolFieldUpdateOperationsInput | boolean | null
    greaterThanUSD?: StringFieldUpdateOperationsInput | string
    action?: Enumenum_transactionPolicies_actionFieldUpdateOperationsInput | enum_transactionPolicies_action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: assetsUpdateOneRequiredWithoutTransactionPoliciesNestedInput
    vaults_transactionPolicies_sourceVaultIdTovaults?: vaultsUpdateOneRequiredWithoutTransactionPolicies_transactionPolicies_sourceVaultIdTovaultsNestedInput
    vaults_transactionPolicies_targetVaultIdTovaults?: vaultsUpdateOneWithoutTransactionPolicies_transactionPolicies_targetVaultIdTovaultsNestedInput
    transactionTypes?: transactionTypesUpdateOneRequiredWithoutTransactionPoliciesNestedInput
    users?: usersUpdateOneRequiredWithoutTransactionPoliciesNestedInput
  }

  export type transactionPoliciesUncheckedUpdateWithoutWithdrawalAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionTypeId?: IntFieldUpdateOperationsInput | number
    sourceVaultId?: StringFieldUpdateOperationsInput | string
    targetVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    toOneTimeAddresses?: NullableBoolFieldUpdateOperationsInput | boolean | null
    greaterThanUSD?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    action?: Enumenum_transactionPolicies_actionFieldUpdateOperationsInput | enum_transactionPolicies_action
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionsUpdateWithoutWithdrawalAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    custodyVendorRef?: StringFieldUpdateOperationsInput | string
    amountAsset?: StringFieldUpdateOperationsInput | string
    amountUSD?: StringFieldUpdateOperationsInput | string
    onChainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceExternalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: assetsUpdateOneRequiredWithoutTransactionsNestedInput
    users?: usersUpdateOneWithoutTransactionsNestedInput
    vendors?: vendorsUpdateOneRequiredWithoutTransactionsNestedInput
    vaults_transactions_sourceVaultIdTovaults?: vaultsUpdateOneWithoutTransactions_transactions_sourceVaultIdTovaultsNestedInput
    vaults_transactions_targetVaultIdTovaults?: vaultsUpdateOneWithoutTransactions_transactions_targetVaultIdTovaultsNestedInput
    transactionStatusTypes?: transactionStatusTypesUpdateOneRequiredWithoutTransactionsNestedInput
    transactionTypes?: transactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateWithoutWithdrawalAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    custodyVendorId?: IntFieldUpdateOperationsInput | number
    custodyVendorRef?: StringFieldUpdateOperationsInput | string
    transactionTypeId?: IntFieldUpdateOperationsInput | number
    amountAsset?: StringFieldUpdateOperationsInput | string
    amountUSD?: StringFieldUpdateOperationsInput | string
    assetId?: IntFieldUpdateOperationsInput | number
    transactionStatusTypeId?: IntFieldUpdateOperationsInput | number
    onChainTxId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    targetVaultId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceExternalAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}